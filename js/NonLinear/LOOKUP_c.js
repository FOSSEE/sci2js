/* autogenerated from "macros/NonLinear/LOOKUP_c.sci" */
function LOOKUP_c() {
    LOOKUP_c.prototype.define = function LOOKUP_c() {
        this.model = scicos_model();
        this.xx = [[-1],[0.5],[1],[1.5],[2.5]];
        this.yy = [[-6],[-1],[-3],[3],[-4]];
        N = length(this.xx);
        this.Method = 1;
        Graf = "n";
        this.model.sim = list(new ScilabString(["lookup_c"]), new ScilabDouble([4]));
        this.model.in1 = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.outtyp = new ScilabDouble([-1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-2]);
        this.model.outtyp = new ScilabDouble([-1]);
        this.model.rpar = new ScilabDouble([this.xx.slice()],[this.yy.slice()]);
        this.model.ipar = new ScilabDouble([N],[this.Method],[0],[0]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = [true,false];
        this.model.evtin = [];
        this.model.evtout = [];
        this.model.firing = new ScilabDouble([0]);
        exprs = [[sci2exp(this.Method)],[sci2exp(this.xx)],[sci2exp(this.yy)],[sci2exp(0)],[Graf]];
        gr_i = [];
        this.x = standard_define([2,2],this.model,exprs,gr_i);
        return new BasicBlock(this.x);
    }
    LOOKUP_c.prototype.details = function LOOKUP_c() {
        return this.x;
    }
    LOOKUP_c.prototype.get = function LOOKUP_c() {
        var options = {
            Method:["Spline Interpolation method (0..9)",this.Method],
            xx:["x",this.xx.toString().replace(/,/g," ")],
            yy:["y",this.yy.toString().replace(/,/g," ")],
            extrapo:["Extrapolate method (0,1)",this.extrapo],
            graf:["Launch graphic window(y/n)?",this.graf],
        }
        return options;
    }
    LOOKUP_c.prototype.set = function LOOKUP_c() {
        this.Method = parseFloat(arguments[0]["Method"])
        this.xx = inverse(arguments[0]["xx"])
        this.yy = inverse(arguments[0]["yy"])
        this.extrapo = parseFloat(arguments[0]["extrapo"])
        this.graf = arguments[0]["graf"]
        this.x = arg1;
        this.model = arg1.model;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        ok = false;
        SaveExit = false;
        while (true) {
            Ask_again = false;
            [ok,this.Method,this.xx,this.yy,this.extrapo,this.graf,exprs] = scicos_getvalue("Lookup table parameters",["Spline Interpolation method (0..9)","x","y","Extrapolate method (0,1)","Launch graphic window(y/n)?"],list("vec",1,"vec",-1,"vec",-1,"vec",1,"str",1),exprs);
            if (!ok) {
                break;
            }
            PeriodicOption = "n";
            if (PeriodicOption=="y"||PeriodicOption=="Y") {
                PO = 1;
            } else {
                PO = 0;
            }
            mtd = int(this.Method);
            if (mtd<0) {
                mtd = 0;
            }
            if (mtd>9) {
                mtd = 9;
            }
            METHOD = getmethod(mtd);
            this.extrapo = int(this.extrapo);
            if (this.extrapo<0) {
                this.extrapo = 0;
            }
            if (this.extrapo>1) {
                this.extrapo = 1;
            }
            if (!Ask_again) {
                this.xx = this.xx.slice();
                this.yy = this.yy.slice();
                [nx,mx] = size(this.xx);
                [ny,my] = size(this.yy);
                if (!((nx==ny)&&(mx==my))) {
                    x_message("incompatible size of x and y");
                    Ask_again = true;
                }
            }
            if (!Ask_again) {
                this.xy = [this.xx,this.yy];
                [this.xy] = cleandata(this.xy);
                N = size(this.xy,"r");
                exprs[5-1] = "n";
                if (this.graf=="y"||this.graf=="Y") {
                    ipar = [[N],[mtd],[PO],[this.extrapo]];
                    rpar = [];
                    if (!exists("curwin")) {
                        gh = gcf();
                        this.curwin = gh.figure_id;
                    }
                    save_curwin = this.curwin;
                    this.curwin = max(winsid())+1;
                    [orpar,oipar,ok] = poke_point(this.xy,ipar,rpar);
                    this.curwin = save_curwin;
                    if (!ok) {
                        break;
                    }
                    N2 = oipar[1-1];
                    xy2 = [orpar.slice(1-1,N2),orpar.slice(N2+1-1,2*N2)];
                    New_methhod = oipar[2-1];
                    DChange = false;
                    METHOD = getmethod(New_methhod);
                    if (or(this.xy.slice()[1-1]!=xy2.slice()[1-1])) {
                        DChange = true;
                    }
                    if (or(this.xy.slice(1-1,N-1)[2-1]!=xy2.slice(1-1,N2-1)[2-1])) {
                        DChange = true;
                    }
                    if ((this.xy[N-1][2-1]!=xy2[N2-1][2-1]&&(METHOD!="periodic"))) {
                        DChange = true;
                    }
                    if (DChange) {
                        exprs[2-1] = strcat(sci2exp(xy2.slice()[1-1]));
                        exprs[3-1] = strcat(sci2exp(xy2.slice()[2-1]));
                    }
                    exprs[1-1] = sci2exp(New_methhod);
                    exprs[4-1] = sci2exp(oipar[4-1]);
                    if (oipar[3-1]==1) {
                        perop = "y";
                    } else {
                        perop = "n";
                    }
                    SaveExit = true;
                } else {
                    [Xdummy,Ydummy,orpar] = Do_Spline(N,mtd,this.xy.slice()[1-1],this.xy.slice()[2-1],this.xy[$-1][1-1],this.xy[1-1][1-1],0);
                    if ((METHOD=="periodic")) {
                        this.xy[N-1][2-1] = this.xy[1-1][2-1];
                    }
                    if ((METHOD=="order 2"||METHOD=="not_a_knot"||METHOD=="periodic"||METHOD=="monotone"||METHOD=="fast"||METHOD=="clamped")) {
                        orpar = [[this.xy.slice()[1-1]],[this.xy.slice()[2-1]],[orpar]];
                    } else {
                        if ((METHOD=="zero order-below"||METHOD=="linear"||METHOD=="zero order-above"||METHOD=="zero order-nearest")) {
                            orpar = [[this.xy.slice()[1-1]],[this.xy.slice()[2-1]]];
                        }
                    }
                    exprs[1-1] = sci2exp(mtd);
                    oipar = [[N],[mtd],[PO],[this.extrapo]];
                    SaveExit = true;
                }
            }
            if ((SaveExit)) {
                xp = find(orpar.slice(1-1,oipar[1-1])>=0);
                if ((xp!=[])) {
                    this.model.firing = new ScilabDouble([orpar[xp[1-1]-1]]);
                } else {
                    this.model.firing = new ScilabDouble([-1]);
                }
                this.model.rpar = new ScilabDouble(orpar);
                this.model.ipar = new ScilabDouble(oipar);
                graphics.exprs = exprs;
                this.x.model = this.model;
                this.x.graphics = graphics;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
