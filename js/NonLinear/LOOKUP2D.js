/* autogenerated from "macros/NonLinear/LOOKUP2D.sci" */
function LOOKUP2D() {
    LOOKUP2D.prototype.define = function LOOKUP2D() {
        model = scicos_model();
        this.xx = [1:4];
        this.yy = [1:3];
        this.zz = [[4,5,6],[16,19,20],[10,18,23],[6,3,-1]];
        this.Method = 1;
        Graf = "n";
        Nx = length(this.xx);
        Ny = length(this.yy);
        model.sim = list("lookup2d",4);
        model.in1 = [[1],[1]];
        model.out = 1;
        model.rpar = [[this.xx.slice()],[this.yy.slice()],[this.zz.slice()]];
        model.ipar = [[Nx],[Ny],[this.Method]];
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = list(strcat(sci2exp(this.xx)),strcat(sci2exp(this.yy)),strcat(sci2exp(this.zz)),sci2exp(this.Method),Graf);
        gr_i = [];
        this.x = standard_define([2.5,2],model,exprs,gr_i);
        return new BasicBlock(this.x);
    }
    LOOKUP2D.prototype.details = function LOOKUP2D() {
        return this.x;
    }
    LOOKUP2D.prototype.get = function LOOKUP2D() {
    }
    LOOKUP2D.prototype.set = function LOOKUP2D() {
        this.x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        ok = false;
        SaveExit = false;
        while (true) {
            Ask_again = false;
            [ok,this.xx,this.yy,this.zz,this.Method,this.graf,exprs] = scicos_getvalue("2D Lookup table parameters",[["Row index input values"],["Column index input values"],["Table data"],["Lookup method(1..5)"],["Launch graphic window(y/n)?"]],list("vec",-1,"vec",-1,"mat",[-1,-1],"vec",1,"str",1),exprs);
            if (!ok) {
                break;
            }
            mtd = int(this.Method);
            if (mtd<1) {
                mtd = 1;
            }
            if (mtd>6) {
                mtd = 6;
            }
            if (this.graf!="y"&&this.graf!="Y") {
                this.graf = "n";
            }
            exprs[5-1] = "n";
            exprs[4-1] = sci2exp(mtd);
            METHOD = getmethod(mtd);
            if (!Ask_again) {
                this.xx = this.xx.slice();
                this.yy = this.yy.slice();
                [nx,mx] = size(this.xx);
                [ny,my] = size(this.yy);
                [nz,mz] = size(this.zz);
                if (((nx<=1)||(ny<=1))) {
                    x_message("input row/column data size should be greater than one");
                    Ask_again = true;
                }
                if (!((nx==nz)&&(ny==mz))) {
                    x_message("incompatible size of x and y");
                    Ask_again = true;
                }
                [ok] = test_increasing(this.xx);
                if ((!ok)) {
                    x_message("Row input values must be monotonically increasing");
                    Ask_again = true;
                }
                [ok] = test_increasing(this.yy);
                if ((!ok)) {
                    x_message("Column input values must be monotonically increasing");
                    Ask_again = true;
                }
            }
            if (!Ask_again) {
                if ((this.graf=="Y"||this.graf=="y")) {
                    gh = gcf();
                    curwin = gh.figure_id;
                    save_curwin = curwin;
                    gh2 = scf();
                    curwin = max(winsid())+1;
                    plot3d(this.xx,this.yy,this.zz,35,45,"X@Y@Z",[5,2,4]);
                    curwin = save_curwin;
                    gh.figure_id = curwin;
                }
                model.rpar = [[this.xx.slice()],[this.yy.slice()],[this.zz.slice()]];
                model.ipar = [[nx],[ny],[mtd]];
                graphics.exprs = exprs;
                this.x.model = model;
                this.x.graphics = graphics;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
