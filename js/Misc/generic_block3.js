/* autogenerated from "macros/Misc/generic_block3.sci" */
function generic_block3() {
    generic_block3.prototype.define = function generic_block3() {
        model = scicos_model();
        this.function_name = "sinblk";
        this.funtyp = 4;
        model.sim = list(this.function_name,this.funtyp);
        model.in1 = 1;
        model.in2 = 1;
        model.intyp = 1;
        model.out = 1;
        model.out2 = 1;
        model.outtyp = 1;
        model.dep_ut = [true,false];
        label = [[this.function_name],[sci2exp(this.funtyp)],[sci2exp([model.in1,model.in2])],[sci2exp(model.intyp)],[sci2exp([model.out,model.out2]),sci2exp(model.outtyp)],[sci2exp(model.evtin)],[sci2exp(model.evtout)],[sci2exp(model.state)],[sci2exp(model.dstate)],[sci2exp(model.odstate)],[sci2exp(model.rpar)],[sci2exp(model.ipar)],[sci2exp(model.opar)],[sci2exp(model.nmode)],[sci2exp(model.nzcross)],[sci2exp(model.firing)],["y"],["n"]];
        gr_i = [];
        this.x = standard_define([4,2],model,label,gr_i);
        return new BasicBlock(this.x);
    }
    generic_block3.prototype.details = function generic_block3() {
        return this.x;
    }
    generic_block3.prototype.get = function generic_block3() {
    }
    generic_block3.prototype.set = function generic_block3() {
        this.function_name = parseFloat((arguments[0]["function_name"]))
        this.funtyp = parseFloat((arguments[0]["funtyp"]))
        this.in1 = parseFloat((arguments[0]["in1"]))
        this.it = parseFloat((arguments[0]["it"]))
        this.out = parseFloat((arguments[0]["out"]))
        this.ot = parseFloat((arguments[0]["ot"]))
        this.ci = parseFloat((arguments[0]["ci"]))
        this.co = parseFloat((arguments[0]["co"]))
        this.xx = parseFloat((arguments[0]["xx"]))
        this.z = parseFloat((arguments[0]["z"]))
        this.oz = parseFloat((arguments[0]["oz"]))
        this.rpar = parseFloat((arguments[0]["rpar"]))
        this.ipar = parseFloat((arguments[0]["ipar"]))
        this.opar = parseFloat((arguments[0]["opar"]))
        this.nmode = parseFloat((arguments[0]["nmode"]))
        this.nzcr = parseFloat((arguments[0]["nzcr"]))
        this.auto0 = parseFloat((arguments[0]["auto0"]))
        this.depu = parseFloat((arguments[0]["depu"]))
        this.dept = parseFloat((arguments[0]["dept"]))
        this.lab = parseFloat((arguments[0]["lab"]))
        this.x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        label = graphics.exprs;
        if (size(label,"*")==14) {
            label[9-1] = [];
        }
        while (true) {
            [ok,this.function_name,this.funtyp,this.in1,this.it,this.out,this.ot,this.ci,this.co,this.xx,this.z,this.oz,this.rpar,this.ipar,this.opar,this.nmode,this.nzcr,this.auto0,this.depu,this.dept,this.lab] = scicos_getvalue("Set GENERIC block parameters",["Simulation function","Function type (0,1,2,..)","Input ports sizes","Input ports type","Output port sizes","Output ports type","Input event ports sizes","Output events ports sizes","Initial continuous state","Initial discrete state","Initial object state","Real parameters vector","Integer parameters vector","Object parameters list","Number of modes","Number of zero crossings","Initial firing vector (<0 for no firing)","Direct feedthrough (y or n)","Time dependence (y or n)"],list("str",1,"vec",1,"mat",[-1,2],"vec",-1,"mat",[-1,2],"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"lis",-1,"vec",-1,"vec",-1,"lis",-1,"vec",1,"vec",1,"vec","sum(%8)","str",1,"str",1),label);
            if (!ok) {
                break;
            }
            label = this.lab;
            this.function_name = stripblanks(this.function_name);
            this.xx = this.xx.slice();
            this.z = this.z.slice();
            this.rpar = this.rpar.slice();
            this.ipar = int(this.ipar.slice());
            this.ci = int(this.ci.slice());
            this.co = int(this.co.slice());
            this.funtyp = this.funtyp;
            if (this.funtyp<0) {
                message("function type cannot be negative");
                ok = false;
            }
            if ([[this.ci],[this.co]]!=[]) {
                if (max([[this.ci],[this.co]])>1) {
                    message("vector event links not supported");
                    ok = false;
                }
            }
            if (this.type[this.opar-1]!=15) {
                message("object parameter must be a list");
                ok = false;
            }
            if (this.type[this.oz-1]!=15) {
                message("discrete object state must be a list");
                ok = false;
            }
            this.depu = stripblanks(this.depu);
            if (part(this.depu,1)=="y") {
                this.depu = true;
            } else {
                this.depu = false;
            }
            this.dept = stripblanks(this.dept);
            if (part(this.dept,1)=="y") {
                this.dept = true;
            } else {
                this.dept = false;
            }
            dep_ut = [this.depu,this.dept];
            if (ok) {
                [model,graphics,ok] = set_io(model,graphics,list(this.in1,this.it),list(this.out,this.ot),this.ci,this.co);
            }
            if (ok) {
                if (this.funtyp==3) {
                    needcompile = 4;
                }
                model.sim = list(this.function_name,this.funtyp);
                model.state = this.xx;
                model.dstate = this.z;
                model.odstate = this.oz;
                model.rpar = this.rpar;
                model.ipar = this.ipar;
                model.opar = this.opar;
                model.firing = this.auto0;
                model.nzcross = this.nzcr;
                model.nmode = this.nmode;
                model.dep_ut = dep_ut;
                arg1.model = model;
                graphics.exprs = label;
                arg1.graphics = graphics;
                this.x = arg1;
                break;
            }
        }
        needcompile = resume(needcompile)
        return new BasicBlock(this.x);
    }
}
