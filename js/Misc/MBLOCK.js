/* autogenerated from "macros/Misc/MBLOCK.sci" */
function MBLOCK() {
    MBLOCK.prototype.define = function MBLOCK() {
in1=["u1"];
intype=["I"];
out=[["y1"],["y2"]];
outtype=[["I"],["E"]];
param=[["R"],["L"]];
paramv=list(0.1,.0001);
pprop=[[0],[0]];
nameF="generic";
exprs=tlist(["MBLOCK","in","intype","out","outtype","param","paramv","pprop","nameF","funtxt"],sci2exp(in1.slice()),sci2exp(intype.slice()),sci2exp(out.slice()),sci2exp(outtype.slice()),sci2exp(param.slice()),list(string(0.1),string(.0001)),sci2exp(pprop.slice()),nameF,[]);
model=scicos_model();
model.blocktype="c";
model.dep_ut=[false,true];
model.rpar=[];
for (i=1;i<=lstsize[paramv-1];i+=1) {
model.rpar=[[model.rpar],[paramv[i-1].slice()]];
}
mo=modelica();
mo.model=nameF;
mo.parameters=list(param,paramv);
model.sim=list(mo.model,30004);
mo.inputs=in1;
mo.outputs=out;
model.in1=ones(size(mo.inputs,"r"),1);
model.out=ones(size(mo.outputs,"r"),1);
model.equations=mo;
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
x.graphics.in_implicit=intype;
x.graphics.out_implicit=outtype;
    }
    MBLOCK.prototype.details = function MBLOCK() {
    }
    MBLOCK.prototype.get = function MBLOCK() {
    }
    MBLOCK.prototype.set = function MBLOCK() {
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
exprs=graphics.exprs;
if (type[exprs-1]==15) {
paramv=list();
pprop=[];
for (i=1;i<=size(model.rpar,"*");i+=1) {
paramv[$+1-1]=string(model.rpar[i-1]);
pprop[$+1-1]=0;
}
exprs=tlist(["MBLOCK","in","intype","out","outtype","param","paramv","pprop","nameF","funtxt"],exprs[1-1][1-1],exprs[1-1][2-1],exprs[1-1][3-1],exprs[1-1][4-1],exprs[1-1][5-1],paramv,sci2exp(pprop.slice()),exprs[1-1][7-1],exprs[2-1]);
}
lab_1=list(exprs.in1,exprs.intype,exprs.out,exprs.outtype,exprs.param,exprs.pprop,exprs.nameF);
lab_2=exprs.paramv;
while (true) {
[ok,Tin,Tintype,Tout,Touttype,Tparam,pprop,Tfunam,lab_1]=scicos_getvalue("Set Modelica generic block parameters",[["Input variables:       "],["Input variables types: "],["Output variables:      "],["Output variables types:"],["Parameters in Modelica:"],["Parameters properties: "],["Function name:         "]],list("str",-1,"str",-1,"str",-1,"str",-1,"str",-1,"vec",-1,"str",-1),lab_1);
if (!ok) {
break;
}
ierr=execstr("in=stripblanks(evstr(Tin));            intype=stripblanks(evstr(Tintype));            out=stripblanks(evstr(Tout));            outtype=stripblanks(evstr(Touttype));            param=stripblanks(evstr(Tparam));            funam=stripblanks(Tfunam)","errcatch");
if (ierr!=0) {
messagebox("Error in evaluation of variables.","modal","error");
ok=false;
}
if (ok) {
for (i=1;i<=size(in1,"*");i+=1) {
r=false;
ierr=execstr("r=validvar(in(i))","errcatch");
if (!r) {
ok=false;
break;
}
}
if (!ok) {
messagebox([["Invalid variable name for the input "+string(i)+"."],["\""+in1[i-1]+"\""],["Please choose another variable name."]],"modal","error");
}
}
if (ok) {
for (i=1;i<=size(out,"*");i+=1) {
r=false;
ierr=execstr("r=validvar(out(i))","errcatch");
if (!r) {
ok=false;
break;
}
}
if (!ok) {
messagebox([["Invalid variable name for the output "+string(i)+"."],["\""+out[i-1]+"\""],["Please choose another variable name."]],"modal","error");
}
}
if (ok) {
param=param.slice();
for (i=1;i<=size(param,"*");i+=1) {
r=false;
ierr=execstr("r=validvar(param(i))","errcatch");
if (!r) {
ok=false;
break;
}
}
if (!ok) {
messagebox([["Invalid variable name for the parameter "+string(i)+"."],["\""+param[i-1]+"\""],["Please choose another variable name."]],"modal","error");
}
}
if (ok) {
for (i=1;i<=size(intype,"*");i+=1) {
if (intype[i-1]!="E"&&intype[i-1]!="I") {
messagebox("Input type should be \'E\' or \'I\'!","modal","error");
ok=false;
break;
}
}
}
if (ok) {
for (i=1;i<=size(outtype,"*");i+=1) {
if (outtype[i-1]!="E"&&outtype[i-1]!="I") {
messagebox("Output type should be \'E\' or \'I\'!","modal","error");
ok=false;
break;
}
}
}
if (ok) {
if (or(size(intype)!=size(in1))) {
messagebox("Input variables are not well defined!","modal","error");
ok=false;
}
}
if (ok) {
if (or(size(outtype)!=size(out))) {
messagebox("Output variables are not well defined!","modal","error");
ok=false;
}
}
if (ok) {
pprop=pprop.slice();
if ((size(param,"*")!=size(pprop,"*"))) {
messagebox([["There is differences in"],["size of param and size "],["of param properties."]],"modal","error");
ok=false;
}
}
if (ok) {
if (max(pprop)>2||min(pprop)<0) {
messagebox([["Parameters properties must be :"],["0 : for simple paramater,"],["1 : for initial state value,"],["2 : for a fixed initial state value."]],"modal","error");
ok=false;
}
}
if (ok) {
if (funam=="") {
messagebox("The filename is not defined!","modal","error");
ok=false;
}
}
if (ok) {
[dirF,nameF,extF]=fileparts(funam);
if ((extF!=""&&extF!=".mo")||(dirF!=""&&extF!=".mo")) {
messagebox("Filename extention should be \'.mo \' !","modal","error");
ok=false;
}
}
if (ok) {
intypex=find(intype=="I");
outtypex=find(outtype=="I");
[model,graphics,ok]=set_io(model,graphics,list([ones(in1),ones(in1)],ones(in1)),list([ones(out),ones(out)],ones(out)),[],[],intypex,outtypex);
}
if (ok) {
Tparam_lab=evstr(Tparam);
Tparam_sz=size(Tparam_lab,"*");
if (Tparam_sz>lstsize[lab_2-1]) {
for (i=1;i<=(Tparam_sz-lstsize[lab_2-1]);i+=1) {
lab_2[$+1-1]="0";
}
} else if (Tparam_sz<lstsize[lab_2-1]) {
lab_2_tmp=list();
if (Tparam_sz!=0) {
for (i=1;i<=(lstsize[lab_2-1]-Tparam_sz);i+=1) {
lab_2_tmp[i-1]=lab_2[i-1];
}
}
lab_2=lab_2_tmp;
}
if (Tparam_sz!=0) {
lhs_txt="";
lab_txt="";
rhs_txt="";
for (i=1;i<=Tparam_sz;i+=1) {
lhs_txt=lhs_txt+"%v"+string(i)+",";
if (pprop[i-1]==0) {
lab_txt=lab_txt+"\'"+Tparam_lab[i-1]+"\';";
} else if (pprop[i-1]==1) {
lab_txt=lab_txt+"\'"+Tparam_lab[i-1]+" (state) \';";
} else if (pprop[i-1]==2) {
lab_txt=lab_txt+"\'"+Tparam_lab[i-1]+" (fixed state) \';";
}
rhs_txt=rhs_txt+"\'vec\',-1,";
}
lhs_txt=part(lhs_txt,1,length(lhs_txt)-1);
lab_txt=part(lab_txt,1,length(lab_txt)-1);
rhs_txt=part(rhs_txt,1,length(rhs_txt)-1);
getvalue_txt="[ok,"+lhs_txt+",lab_2]=scicos_getvalue(\'Set parameters values\',["+lab_txt+"],"+"list("+rhs_txt+"),lab_2)";
execstr(getvalue_txt);
if (!ok) {
lab_2=exprs.paramv;
}
}
}
if (ok) {
paramv=list();
for (i=1;i<=Tparam_sz;i+=1) {
execstr("paramv("+string(i)+")=%v"+string(i));
}
}
if (ok) {
if (extF==".mo"&&fileinfo(funam)!=[]) {
tt=mgetl(funam);
} else {
tt=exprs.funtxt;
mo=model.equations;
if (mo.model!=nameF) {
tt=[];
}
}
[ok,tt]=MODCOM(funam,tt,in1,out,param,paramv,pprop);
if (!ok) {
break;
}
}
if (ok) {
mo=modelica();
mo.model=nameF;
mo.inputs=in1;
mo.outputs=out;
if (max(pprop)>0) {
mo.parameters=list(transpose(param),paramv,transpose(pprop));
} else {
mo.parameters=list(transpose(param),paramv);
}
model.equations=mo;
model.rpar=[];
for (i=1;i<=lstsize[paramv-1];i+=1) {
model.rpar=[[model.rpar],[paramv[i-1].slice()]];
}
model.sim[1-1]=funam;
exprs.in1=lab_1[1-1];
exprs.intype=lab_1[2-1];
exprs.out=lab_1[3-1];
exprs.outtype=lab_1[4-1];
exprs.param=lab_1[5-1];
exprs.paramv=list();
if (Tparam_sz!=0) {
if (type[lab_2-1]==15) {
for (i=1;i<=lstsize[lab_2-1];i+=1) {
exprs.paramv[i-1]=lab_2[i-1];
}
} else {
for (i=1;i<=size(lab_2,"*");i+=1) {
exprs.paramv[i-1]=lab_2[i-1];
}
}
}
exprs.pprop=lab_1[6-1];
exprs.nameF=lab_1[7-1];
exprs.funtxt=tt;
x.model=model;
graphics.gr_i[1-1][1-1]="txt=[\'Modelica\';\' "+nameF+" \'];";
graphics.in_implicit=intype;
graphics.out_implicit=outtype;
graphics.exprs=exprs;
x.graphics=graphics;
break;
}
}
    }
}
