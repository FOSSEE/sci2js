/* autogenerated from "macros/Misc/BOUNCE.sci" */
function BOUNCE() {
    BOUNCE.prototype.define = function BOUNCE() {
        n = 2;
        k = 1;
        ipar = [];
        for (i=1;i<=n;i+=1) {
            for (j=i+1;j<=n;j+=1) {
                ipar[k-1] = i;
                k = k+1;
                ipar[k-1] = j;
                k = k+1;
            }
        }
        this.walls = [[0],[5],[0],[5]];
        this.x = [[2],[2.5]];
        this.xd = [[0],[0]];
        this.y = [[3],[5]];
        this.yd = [[0],[0]];
        this.g = 9.81;
        this.C = 0;
        this.rpar1 = ones(n,1);
        this.rpar2 = this.rpar1;
        state = [this.x,this.xd,this.y,this.yd];
        state = transpose(state);
        this.model = scicos_model();
        this.model.sim = list(new ScilabString("bounce_ball"),new ScilabDouble(4));
        this.model.in1 = [];
        this.model.out = [[n],[n]];
        this.model.state = state.slice();
        this.model.rpar = [[this.rpar1],[this.rpar2],[this.walls],[this.g],[this.C]];
        this.model.ipar = ipar;
        this.model.nzcross = new ScilabDouble(n*(n-1)/2+4*n);
        this.model.blocktype = new ScilabString("c");
        this.model.dep_ut = [false,true];
        exprs = [[strcat(sci2exp(this.rpar1))],[strcat(sci2exp(this.rpar2))],[strcat(sci2exp(this.walls))],[strcat(sci2exp(this.x))],[strcat(sci2exp(this.xd))],[strcat(sci2exp(this.y))],[strcat(sci2exp(this.yd))]];
        gr_i = [];
        this.x = standard_define([3,2],this.model,exprs,gr_i);
        return new BasicBlock(this.x);
    }
    BOUNCE.prototype.details = function BOUNCE() {
        return this.x;
    }
    BOUNCE.prototype.get = function BOUNCE() {
        var options = {
            rpar1:["Mass",this.rpar1],
            rpar2:["Radius",this.rpar2],
            walls:["[xmin,xmax,ymin,ymax]",this.walls.toString().replace(/,/g," ")],
            xt:["xpos",this.xt],
            xd:["xdpos",this.xd.toString().replace(/,/g," ")],
            y:["ypos",this.y],
            yd:["ydpos",this.yd.toString().replace(/,/g," ")],
            g:["g (gravity)",this.g],
            C:["C (aerodynamic coeff",this.C],
        }
        return options;
    }
    BOUNCE.prototype.set = function BOUNCE() {
        this.rpar1 = parseFloat(arguments[0]["rpar1"])
        this.rpar2 = parseFloat(arguments[0]["rpar2"])
        this.walls = inverse(arguments[0]["walls"])
        this.xt = inverse(arguments[0]["xt"])
        this.xd = inverse(arguments[0]["xd"])
        this.y = inverse(arguments[0]["y"])
        this.yd = inverse(arguments[0]["yd"])
        this.g = parseFloat(arguments[0]["g"])
        this.C = parseFloat(arguments[0]["C"])
        this.x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        this.model = arg1.model;
        if (size(exprs,"*")<9) {
            exprs[8-1] = "9.81";
            exprs[9-1] = "0";
        }
        while (true) {
            [ok,this.rpar1,this.rpar2,this.walls,this.xt,this.xd,this.y,this.yd,this.g,this.C,exprs] = scicos_getvalue(["Set Bounce Block"],["Mass","Radius","[xmin,xmax,ymin,ymax]","xpos","xdpos","ypos","ydpos","g (gravity)","C (aerodynamic coeff"],list("vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",1,"vec",1),exprs);
            if (!ok) {
                break;
            }
            this.xt = this.xt.slice();
            this.y = this.y.slice();
            this.xd = this.xd.slice();
            this.yd = this.yd.slice();
            this.rpar1 = this.rpar1.slice();
            this.rpar2 = this.rpar2.slice();
            n = size(this.xt,"*");
            this.walls = this.walls.slice();
            if (this.walls[1-1]>this.walls[2-1]) {
                this.walls = this.walls[[2,1]-1];
            }
            if (this.walls[3-1]>this.walls[3-1]) {
                this.walls = this.walls[[3,4]-1];
            }
            if (n!=size(this.y,"*")||n!=size(this.rpar1,"*")||n!=size(this.rpar2,"*")||n!=size(this.xd,"*")||n!=size(this.yd,"*")) {
                message("All vectors must have equal size");
                ok = false;
            } else if (!(min([[this.rpar1],[this.rpar2]])>0)) {
                message("Mass and radius must be >0");
                ok = false;
            }
            if (!ok) {
                break;
            }
            [model,graphics,ok] = check_io(this.model,graphics,[],[n,n],[],[]);
            if (ok) {
                k = 1;
                ipar = [];
                for (i=1;i<=n;i+=1) {
                    for (j=i+1;j<=n;j+=1) {
                        ipar[k-1] = i;
                        k = k+1;
                        ipar[k-1] = j;
                        k = k+1;
                    }
                }
                this.model.rpar = [[this.rpar1],[this.rpar2],[this.walls],[this.g],[this.C]];
                this.model.ipar = ipar;
                state = [this.xt,this.xd,this.y,this.yd];
                state = transpose(state);
                this.model.state = state.slice();
                this.model.nzcross = new ScilabDouble(n*(n-1)/2+4*n);
                graphics.exprs = exprs;
                this.x.graphics = graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
