/* autogenerated from "macros/Misc/CBLOCK.sci" */
function CBLOCK() {
    CBLOCK.prototype.define = function CBLOCK() {
        in1 = 1;
        out = 1;
        clkin = [];
        clkout = [];
        x0 = [];
        z0 = [];
        typ = "c";
        auto = [];
        this.rpar = [];
        this.ipar = [];
        funam = "toto";
        this.ng = 0;
        model = scicos_model();
        model.sim = list(" ",2004);
        model.in1 = in1;
        model.out = out;
        model.evtin = clkin;
        model.evtout = clkout;
        model.state = x0;
        model.dstate = z0;
        model.rpar = this.rpar;
        model.ipar = this.ipar;
        model.blocktype = typ;
        model.firing = auto;
        model.dep_ut = [true,false];
        model.nzcross = this.ng;
        label = list(transpose([funam,"n",sci2exp(in1),sci2exp(out),sci2exp(clkin),sci2exp(clkout),sci2exp(x0),sci2exp(0),sci2exp(z0),sci2exp(this.rpar),sci2exp(this.ipar),sci2exp(auto),"y","n"]),[]);
        gr_i = [];
        this.x = standard_define([4,2],model,label,gr_i);
        return new BasicBlock(this.x);
    }
    CBLOCK.prototype.details = function CBLOCK() {
        return this.x;
    }
    CBLOCK.prototype.get = function CBLOCK() {
        var options = {
            function_name:["simulation function",this.function_name],
            impli:["is block implicit? (y,n)",this.impli],
            i:["input ports sizes",this.i],
            o:["output ports sizes",this.o],
            ci:["input event ports sizes",this.ci],
            co:["output events ports sizes",this.co],
            xx:["initial continuous state",this.xx],
            ng:["number of zero crossing surfaces",this.ng],
            z:["initial discrete state",this.z],
            rpar:["Real parameters vector",this.rpar],
            ipar:["Integer parameters vector",this.ipar],
            auto0:["initial firing vector (<0 for no firing)",this.auto0],
            depu:["direct feedthrough (y or n)",this.depu],
            dept:["time dependence (y or n)",this.dept],
        }
        return options;
    }
    CBLOCK.prototype.set = function CBLOCK() {
        this.function_name = parseFloat((arguments[0]["function_name"]))
        this.impli = parseFloat((arguments[0]["impli"]))
        this.i = parseFloat((arguments[0]["i"]))
        this.o = parseFloat((arguments[0]["o"]))
        this.ci = parseFloat((arguments[0]["ci"]))
        this.co = parseFloat((arguments[0]["co"]))
        this.xx = parseFloat((arguments[0]["xx"]))
        this.ng = parseFloat((arguments[0]["ng"]))
        this.z = parseFloat((arguments[0]["z"]))
        this.rpar = parseFloat((arguments[0]["rpar"]))
        this.ipar = parseFloat((arguments[0]["ipar"]))
        this.auto0 = parseFloat((arguments[0]["auto0"]))
        this.depu = parseFloat((arguments[0]["depu"]))
        this.dept = parseFloat((arguments[0]["dept"]))
        this.lab = parseFloat((arguments[0]["lab"]))
        this.x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        label = graphics.exprs;
        while (true) {
            [ok,this.function_name,this.impli,this.i,this.o,this.ci,this.co,this.xx,this.ng,this.z,this.rpar,this.ipar,this.auto0,this.depu,this.dept,this.lab] = scicos_getvalue("Set C-Block2 block parameters",["simulation function","is block implicit? (y,n)","input ports sizes","output ports sizes","input event ports sizes","output events ports sizes","initial continuous state","number of zero crossing surfaces","initial discrete state","Real parameters vector","Integer parameters vector","initial firing vector (<0 for no firing)","direct feedthrough (y or n)","time dependence (y or n)"],list("str",1,"str",1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",1,"vec",-1,"vec",-1,"vec",-1,"vec","sum(%6)","str",1,"str",1),label[1-1]);
            if (!ok) {
                break;
            }
            label[1-1] = this.lab;
            funam = stripblanks(this.function_name);
            this.xx = this.xx.slice();
            this.z = this.z.slice();
            this.rpar = this.rpar.slice();
            this.ipar = int(this.ipar.slice());
            nx = size(this.xx,1);
            nz = size(this.z,1);
            this.i = int(this.i.slice());
            this.o = int(this.o.slice());
            nout = size(this.o,1);
            this.ci = int(this.ci.slice());
            nevin = size(this.ci,1);
            this.co = int(this.co.slice());
            nevout = size(this.co,1);
            if (part(this.impli,1)=="y") {
                funtyp = 12004;
            } else {
                funtyp = 2004;
            }
            if ([[this.ci],[this.co]]!=[]) {
                if (max([[this.ci],[this.co]])>1) {
                    message("vector event links not supported");
                    ok = false;
                }
            }
            this.depu = stripblanks(this.depu);
            if (part(this.depu,1)=="y") {
                this.depu = true;
            } else {
                this.depu = false;
            }
            this.dept = stripblanks(this.dept);
            if (part(this.dept,1)=="y") {
                this.dept = true;
            } else {
                this.dept = false;
            }
            dep_ut = [this.depu,this.dept];
            if (funam==" ") {
                break;
            }
            if (model.sim[1-1]!=funam||sign(size(model.state,"*"))!=sign(nx)||sign(size(model.dstate,"*"))!=sign(nz)||model.nzcross!=this.ng||sign(size(model.evtout,"*"))!=sign(nevout)) {
                tt = [];
            }
            tt = label[2-1];
            while (true) {
                [ok,tt,cancel] = CFORTR2(funam,tt);
                if (!ok) {
                    if (cancel) {
                        break;
                    }
                } else {
                    [model,graphics,ok] = check_io(model,graphics,this.i,this.o,this.ci,this.co);
                    if (ok) {
                        model.sim = list(funam,funtyp);
                        model.in1 = this.i;
                        model.out = this.o;
                        model.evtin = this.ci;
                        model.evtout = this.co;
                        model.state = this.xx;
                        model.dstate = this.z;
                        model.rpar = this.rpar;
                        model.ipar = this.ipar;
                        model.firing = this.auto0;
                        model.dep_ut = dep_ut;
                        model.nzcross = this.ng;
                        label[2-1] = tt;
                        this.x.model = model;
                        graphics.exprs = label;
                        this.x.graphics = graphics;
                        break;
                    }
                }
            }
            if (ok||cancel) {
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
