/* autogenerated from "macros/Sources/RAND_m.sci" */
function RAND_m() {
    RAND_m.prototype.define = function RAND_m() {
        a = 0;
        b = 1;
        dt = 0;
        flag = 0;
        function_name = "rndblk_m";
        funtyp = 4;
        model = scicos_model();
        model.sim = list(function_name,funtyp);
        model.in1 = [];
        model.in2 = [];
        model.intyp = [];
        model.out = 1;
        model.out2 = 1;
        model.outtyp = 1;
        model.evtin = 1;
        model.evtout = [];
        model.state = [];
        model.dstate = [[int(rand()*(10^7-1))],[0*a.slice()]];
        model.rpar = [a.slice(),b.slice()];
        model.ipar = flag;
        model.blocktype = "d";
        model.firing = [];
        model.dep_ut = [false,false];
        exprs = [[sci2exp(1)],[string(flag)],[sci2exp([a])],[sci2exp([b])],[sci2exp([model.dstate[1-1],int(rand()*(10^7-1))])]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    RAND_m.prototype.details = function RAND_m() {
    }
    RAND_m.prototype.get = function RAND_m() {
    }
    RAND_m.prototype.set = function RAND_m() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        if (size(exprs,"*")==14) {
        exprs[9-1] = [];
}
        while (true) {
        [ok,typ,flag,a,b,seed_c,exprs] = scicos_getvalue([["Set Random generator block parameters"],["flag = 0 : Uniform distribution A is min and A+B max"],["flag = 1 : Normal distribution A is mean and B deviation"],[" "],["A and B must be matrix with equal sizes"]],[["Datatype(1=real double  2=complex)"],["flag"],["A"],["B"],["SEED"]],list("vec",1,"vec",1,"mat",[-1,-2],"mat","[-1 -2]","mat",[1,2]),exprs);
        if (!ok) {
break;
}
        if (flag!=0&&flag!=1) {
message("flag must be equal to 1 or 0");
        } else {
        out = size(a);
        if (typ==1) {
        function_name = "rndblk_m";
        model.rpar = [[real(a.slice())],[real(b.slice())]];
        model.dstate = [[seed_c[1-1]],[0*real(a.slice())]];
        ot = 1;
        } else if (typ==2) {
        function_name = "rndblkz_m";
        ot = 2;
        model.rpar = [[real(a.slice())],[imag(a.slice())],[real(b.slice())],[imag(b.slice())]];
        model.dstate = [[seed_c.slice()],[0*[[real(a.slice())],[imag(a.slice())]]]];
        } else {
message("Datatype is not supported");
        ok = false;
}
        if (ok) {
        [model,graphics,ok] = set_io(model,graphics,list([],[]),list(out,ot),1,[]);
        if (ok) {
        model.sim = list(function_name,4);
        graphics.exprs = exprs;
        model.ipar = flag;
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
}
    }
}
