/* autogenerated from "macros/Branching/CLKFROM.sci" */
function CLKFROM() {
    CLKFROM.prototype.define = function CLKFROM() {
        this.model = scicos_model();
        this.model.sim = new ScilabString(["clkfrom"]);
        this.model.evtout = new ScilabDouble([1]);
        this.model.opar = list(new ScilabString(["A"]));
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([-1]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = "A";
        this.x = new standard_define(new ScilabDouble([2,1]),this.model,new ScilabString([this.exprs])," ");
        this.x.graphics.id = "From";
        return new BasicBlock(this.x);
    }
    CLKFROM.prototype.details = function CLKFROM() {
        return this.x;
    }
    CLKFROM.prototype.get = function CLKFROM() {
        var options = {
            tag:["Tag",this.tag],
        }
        return options;
    }
    CLKFROM.prototype.set = function CLKFROM() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.tag = arguments[0]["tag"];
            if (!ok) {
                break;
            }
            if (this.model.opar!=list(this.tag)) {
                var needcompile = 4;
                var y = needcompile;
            }
            this.model.opar = list(new ScilabDouble([this.tag]));
            this.model.evtout = new ScilabDouble([1]);
            this.model.firing = new ScilabDouble([-1]);
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        needcompile = resume(needcompile)
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/CLKGOTO.sci" */
function CLKGOTO() {
    CLKGOTO.prototype.define = function CLKGOTO() {
        this.model = scicos_model();
        this.model.sim = new ScilabString(["clkgoto"]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.opar = list(new ScilabString(["A"]));
        this.model.ipar = new ScilabDouble([int(1)]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([-1]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [["A"],[sci2exp(1)]];
        this.x = new standard_define(new ScilabDouble([2,1]),this.model,new ScilabDouble(this.exprs)," ");
        this.x.graphics.id = "Goto";
        return new BasicBlock(this.x);
    }
    CLKGOTO.prototype.details = function CLKGOTO() {
        return this.x;
    }
    CLKGOTO.prototype.get = function CLKGOTO() {
        var options = {
            tag:["Tag",this.tag],
            tagvis:["Tag Visibility (1=Local 2=Scoped 3=Global)",this.tagvis],
        }
        return options;
    }
    CLKGOTO.prototype.set = function CLKGOTO() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.tag = arguments[0]["tag"];
            this.tagvis = parseFloat(arguments[0]["tagvis"]);
            if (!ok) {
                break;
            }
            if (((this.tagvis<1)||(this.tagvis>3))) {
                message("Tag Visibility must be between 1 and 3");
                throw "user error";
                var ok = false;
            }
            this.tagvis = int(this.tagvis);
            if (ok) {
                if (((this.model.opar!=list(this.tag))||(this.model.ipar!=this.tagvis))) {
                    var needcompile = 4;
                    var y = needcompile;
                }
                this.model.opar = list(new ScilabDouble([this.tag]));
                this.model.ipar = new ScilabDouble([this.tagvis]);
                this.model.evtin = new ScilabDouble([1]);
                this.model.firing = new ScilabDouble([-1]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        needcompile = resume(needcompile)
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/CLKGotoTagVisibility.sci" */
function CLKGotoTagVisibility() {
    CLKGotoTagVisibility.prototype.define = function CLKGotoTagVisibility() {
        this.model = scicos_model();
        this.model.sim = new ScilabString(["clkgototagvisibility"]);
        this.model.in = new ScilabDouble([]);
        this.model.in2 = new ScilabDouble([]);
        this.model.out = new ScilabDouble([]);
        this.model.out2 = new ScilabDouble([]);
        this.model.evtin = new ScilabDouble([]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.opar = list(new ScilabString(["A"]));
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabBoolean([false]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = "A";
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CLKGotoTagVisibility\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    CLKGotoTagVisibility.prototype.details = function CLKGotoTagVisibility() {
        return this.x;
    }
    CLKGotoTagVisibility.prototype.get = function CLKGotoTagVisibility() {
        var options = {
            tag:["GotoTag",this.tag],
        }
        return options;
    }
    CLKGotoTagVisibility.prototype.set = function CLKGotoTagVisibility() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.tag = arguments[0]["tag"];
            if (!ok) {
                break;
            }
            if (ok) {
                if (this.model.opar!=list(this.tag)) {
                    var needcompile = 4;
                    var y = needcompile;
                }
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.opar = list(new ScilabDouble([this.tag]));
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        needcompile = resume(needcompile)
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/DEMUX.sci" */
function DEMUX() {
    DEMUX.prototype.define = function DEMUX() {
        this.out = 2;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["multiplex"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([0]);
        this.model.out = new ScilabDouble(-transpose([1:this.out]));
        this.model.ipar = new ScilabDouble([this.out]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = string(this.out);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"DEMUX\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([.5,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    DEMUX.prototype.details = function DEMUX() {
        return this.x;
    }
    DEMUX.prototype.get = function DEMUX() {
        var options = {
            out:["number of output ports or vector of sizes",this.out],
        }
        return options;
    }
    DEMUX.prototype.set = function DEMUX() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.out = parseFloat(arguments[0]["out"]);
            if (!ok) {
                break;
            }
            if (size(this.out,"*")==1) {
                if (this.out<2||this.out>31) {
                    message("Block must have at least 2 and at most 31 output ports");
                    throw "user error";
                    var ok = false;
                } else {
                    var tmpvar0 = check_io(this.model,this.graphics,0,-transpose([1:this.out]),[],[]);
                    this.model = tmpvar0[0];
                    this.graphics = tmpvar0[1];
                    var ok = tmpvar0[2];
                }
            } else {
                if (size(this.out,"*")<2||or(this.out==0)||size(this.out,"*")>31) {
                    message([["Block must have at least 2 and at most 31 output ports"],["size 0 is not allowed"]]);
                    throw "user error";
                    var ok = false;
                } else {
                    if (min(this.out)<0) {
                        var nin = 0;
                    } else {
                        var nin = sum(this.out);
                    }
                    var tmpvar1 = check_io(this.model,this.graphics,nin,this.out.slice(),[],[]);
                    this.model = tmpvar1[0];
                    this.graphics = tmpvar1[1];
                    var ok = tmpvar1[2];
                    if (ok) {
                        this.out = size(this.out,"*");
                    }
                }
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.ipar = new ScilabDouble([this.out]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/DEMUX_f.sci" */
function DEMUX_f() {
    DEMUX_f.prototype.define = function DEMUX_f() {
        this.out = 2;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["demux"]), new ScilabDouble([1]));
        this.model.in = new ScilabDouble([0]);
        this.model.out = new ScilabDouble(-transpose([1:this.out]));
        this.model.ipar = new ScilabDouble([this.out]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = string(this.out);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"DEMUX_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([.5,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    DEMUX_f.prototype.details = function DEMUX_f() {
        return this.x;
    }
    DEMUX_f.prototype.get = function DEMUX_f() {
        var options = {
            out:["number of output ports or vector of sizes",this.out],
        }
        return options;
    }
    DEMUX_f.prototype.set = function DEMUX_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.out = parseFloat(arguments[0]["out"]);
            if (!ok) {
                break;
            }
            if (size(this.out,"*")==1) {
                if (this.out<2||this.out>8) {
                    message("Block must have at least 2 and at most 8 output ports");
                    throw "user error";
                    var ok = false;
                } else {
                    var tmpvar0 = check_io(this.model,this.graphics,0,-transpose([1:this.out]),[],[]);
                    this.model = tmpvar0[0];
                    this.graphics = tmpvar0[1];
                    var ok = tmpvar0[2];
                }
            } else {
                if (size(this.out,"*")<2||size(this.out,"*")>8||or(this.out==0)) {
                    message([["Block must have at least 2 and at most 8 output ports"],["and size 0 is not allowed"]]);
                    throw "user error";
                    var ok = false;
                } else {
                    if (min(this.out)<0) {
                        var nin = 0;
                    } else {
                        var nin = sum(this.out);
                    }
                    var tmpvar1 = check_io(this.model,this.graphics,nin,this.out.slice(),[],[]);
                    this.model = tmpvar1[0];
                    this.graphics = tmpvar1[1];
                    var ok = tmpvar1[2];
                    if (ok) {
                        this.out = size(this.out,"*");
                    }
                }
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.ipar = new ScilabDouble([this.out]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/ESELECT_f.sci" */
function ESELECT_f() {
    ESELECT_f.prototype.define = function ESELECT_f() {
        this.out = 2;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["eselect"]), new ScilabDouble([-2]));
        this.model.in = new ScilabDouble([1]);
        this.model.in2 = new ScilabDouble([1]);
        this.model.intyp = new ScilabDouble([-1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.evtout = new ScilabDouble([ones(this.out,1)]);
        this.model.blocktype = new ScilabString(["l"]);
        this.model.firing = new ScilabDouble([-ones(this.out,1)]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.model.nmode = new ScilabDouble([0]);
        this.model.nzcross = new ScilabDouble([0]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"ESELECT_f\",sz(1),sz(2));"]);
        this.exprs = [[string(this.out)],[string(1)],[string(this.model.nmode)]];
        this.x = new standard_define(new ScilabDouble([4,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    ESELECT_f.prototype.details = function ESELECT_f() {
        return this.x;
    }
    ESELECT_f.prototype.get = function ESELECT_f() {
        var options = {
            out:["number of output event ports",this.out],
            inh:["Inherit (1: no, 0: yes)",this.inh],
            nmod:["zero-crossing (0: no, 1: yes)",this.nmod],
        }
        return options;
    }
    ESELECT_f.prototype.set = function ESELECT_f() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")==1) {
            this.exprs[2-1] = string(1);
        }
        if (size(this.exprs,"*")==2) {
            this.exprs[3-1] = string(0);
        }
        while (true) {
            var ok = true;
            this.out = parseFloat(arguments[0]["out"]);
            this.inh = parseFloat(arguments[0]["inh"]);
            this.nmod = parseFloat(arguments[0]["nmod"]);
            if (!ok) {
                break;
            }
            if (this.nmod!=0) {
                this.nmod = 1;
            }
            if (this.inh==0) {
                this.inh = [];
            } else {
                this.inh = 1;
            }
            this.out = int(this.out);
            if (this.out<2) {
                message("Block must have at least two output ports");
                throw "user error";
            } else {
                var tmpvar0 = check_io(this.model,this.graphics,1,[],this.inh,[ones(this.out,1)]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                if (ok) {
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    this.model.evtout = new ScilabDouble([ones(this.out,1)]);
                    this.model.firing = new ScilabDouble([-ones(this.out,1)]);
                    this.x.graphics = this.graphics;
                    this.model.nmode = new ScilabDouble([this.nmod]);
                    this.model.nzcross = new ScilabDouble([this.nmod]);
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/EXTRACTOR.sci" */
function EXTRACTOR() {
    EXTRACTOR.prototype.define = function EXTRACTOR() {
        this.ind = 1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["extractor"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([-1]);
        this.model.out = new ScilabDouble([1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.model.ipar = new ScilabDouble([this.ind]);
        this.exprs = [sci2exp(this.ind)];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"EXTRACTOR\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabString(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    EXTRACTOR.prototype.details = function EXTRACTOR() {
        return this.x;
    }
    EXTRACTOR.prototype.get = function EXTRACTOR() {
        var options = {
            ind:["indices to extract",this.ind],
        }
        return options;
    }
    EXTRACTOR.prototype.set = function EXTRACTOR() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.ind = parseFloat(arguments[0]["ind"]);
            if (!ok) {
                break;
            }
            this.ind = int(this.ind);
            this.ind = this.ind.slice();
            var tmpvar0 = check_io(this.model,this.graphics,[-1],size(this.ind,1),[],[]);
            this.model = tmpvar0[0];
            this.graphics = tmpvar0[1];
            var ok = tmpvar0[2];
            if (ok) {
                this.model.ipar = new ScilabDouble(this.ind);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/FROM.sci" */
function FROM() {
    FROM.prototype.define = function FROM() {
        this.model = scicos_model();
        this.model.sim = new ScilabString(["from"]);
        this.model.in = new ScilabDouble([]);
        this.model.in2 = new ScilabDouble([]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-2]);
        this.model.outtyp = new ScilabDouble([-1]);
        this.model.ipar = new ScilabDouble([]);
        this.model.opar = list(new ScilabString(["A"]));
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = ["A"];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"FROM\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,1]),this.model,new ScilabString(this.exprs),this.gr_i);
        this.x.graphics.id = "From";
        return new BasicBlock(this.x);
    }
    FROM.prototype.details = function FROM() {
        return this.x;
    }
    FROM.prototype.get = function FROM() {
        var options = {
            tag:["Tag",this.tag],
        }
        return options;
    }
    FROM.prototype.set = function FROM() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.tag = arguments[0]["tag"];
            if (!ok) {
                break;
            }
            if (ok) {
                if (this.model.opar!=list(this.tag)) {
                    var needcompile = 4;
                    var y = needcompile;
                }
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.opar = list(new ScilabDouble([this.tag]));
                this.x.model = this.model;
                this.x.graphics = this.graphics;
                break;
            }
        }
        needcompile = resume(needcompile)
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/FROMMO.sci" */
function FROMMO() {
    FROMMO.prototype.define = function FROMMO() {
        this.model = scicos_model();
        this.model.sim = new ScilabString(["frommo"]);
        this.model.in = new ScilabDouble([]);
        this.model.in2 = new ScilabDouble([]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-2]);
        this.model.outtyp = new ScilabDouble([-1]);
        this.model.ipar = new ScilabDouble([]);
        this.model.opar = list(new ScilabString(["A"]));
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        var mo = modelica();
        mo.model = "frommo";
        mo.outputs = "n";
        this.exprs = ["A"];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"FROMMO\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,1]),this.model,new ScilabString(this.exprs),this.gr_i);
        this.x.graphics.out_implicit = ["I"];
        return new BasicBlock(this.x);
    }
    FROMMO.prototype.details = function FROMMO() {
        return this.x;
    }
    FROMMO.prototype.get = function FROMMO() {
        var options = {
            tag:["Tag",this.tag],
        }
        return options;
    }
    FROMMO.prototype.set = function FROMMO() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.tag = arguments[0]["tag"];
            if (!ok) {
                break;
            }
            if (ok) {
                if (this.model.opar!=list(this.tag)) {
                    var needcompile = 4;
                    var y = needcompile;
                }
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.opar = list(new ScilabDouble([this.tag]));
                this.x.model = this.model;
                this.x.graphics = this.graphics;
                break;
            }
        }
        needcompile = resume(needcompile)
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/GOTO.sci" */
function GOTO() {
    GOTO.prototype.define = function GOTO() {
        this.model = scicos_model();
        this.model.sim = new ScilabString(["goto"]);
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([-1]);
        this.model.out = new ScilabDouble([]);
        this.model.out2 = new ScilabDouble([]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.ipar = new ScilabDouble([int(1)]);
        this.model.opar = list(new ScilabString(["A"]));
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [["A"],[sci2exp(1)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"GOTO\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,1]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        this.x.graphics.id = "Goto";
        return new BasicBlock(this.x);
    }
    GOTO.prototype.details = function GOTO() {
        return this.x;
    }
    GOTO.prototype.get = function GOTO() {
        var options = {
            tag:["Tag",this.tag],
            tagvis:["Tag Visibility(1=Local 2=scoped 3= global)",this.tagvis],
        }
        return options;
    }
    GOTO.prototype.set = function GOTO() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.tag = arguments[0]["tag"];
            this.tagvis = parseFloat(arguments[0]["tagvis"]);
            if (!ok) {
                break;
            }
            this.tagvis = int(this.tagvis);
            if (((this.tagvis<1)||(this.tagvis>3))) {
                message("Tag Visibility must be between 1 and 3");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                if (((this.model.ipar!=this.tagvis)||(this.model.opar!=list(this.tag)))) {
                    var needcompile = 4;
                    var y = needcompile;
                }
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.opar = list(new ScilabDouble([this.tag]));
                this.model.ipar = new ScilabDouble([this.tagvis]);
                this.x.model = this.model;
                this.x.graphics = this.graphics;
                break;
            }
        }
        needcompile = resume(needcompile)
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/GOTOMO.sci" */
function GOTOMO() {
    GOTOMO.prototype.define = function GOTOMO() {
        this.model = scicos_model();
        this.model.sim = new ScilabString(["gotomo"]);
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([]);
        this.model.out = new ScilabDouble([]);
        this.model.out2 = new ScilabDouble([]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.ipar = new ScilabDouble([int(1)]);
        this.model.opar = list(new ScilabString(["A"]));
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        var mo = modelica();
        mo.model = "gotomo";
        mo.inputs = "p";
        this.exprs = [["A"],[sci2exp(1)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"GOTOMO\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,1]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        this.x.graphics.in_implicit = ["I"];
        return new BasicBlock(this.x);
    }
    GOTOMO.prototype.details = function GOTOMO() {
        return this.x;
    }
    GOTOMO.prototype.get = function GOTOMO() {
        var options = {
            tag:["Tag",this.tag],
            tagvis:["Tag Visibility(1=Local 2=scoped 3= global)",this.tagvis],
        }
        return options;
    }
    GOTOMO.prototype.set = function GOTOMO() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.tag = arguments[0]["tag"];
            this.tagvis = parseFloat(arguments[0]["tagvis"]);
            if (!ok) {
                break;
            }
            this.tagvis = int(this.tagvis);
            if (((this.tagvis<1)||(this.tagvis>3))) {
                message("Tag Visibility must be between 1 and 3");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                if (((this.model.ipar!=this.tagvis)||(this.model.opar!=list(this.tag)))) {
                    var needcompile = 4;
                    var y = needcompile;
                }
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.opar = list(new ScilabDouble([this.tag]));
                this.model.ipar = new ScilabDouble([this.tagvis]);
                this.x.model = this.model;
                this.x.graphics = this.graphics;
                break;
            }
        }
        needcompile = resume(needcompile)
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/GotoTagVisibility.sci" */
function GotoTagVisibility() {
    GotoTagVisibility.prototype.define = function GotoTagVisibility() {
        this.model = scicos_model();
        this.model.sim = new ScilabString(["gototagvisibility"]);
        this.model.in = new ScilabDouble([]);
        this.model.in2 = new ScilabDouble([]);
        this.model.out = new ScilabDouble([]);
        this.model.out2 = new ScilabDouble([]);
        this.model.evtin = new ScilabDouble([]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.opar = list(new ScilabString(["A"]));
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabBoolean([false]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = "A";
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"GotoTagVisibility\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    GotoTagVisibility.prototype.details = function GotoTagVisibility() {
        return this.x;
    }
    GotoTagVisibility.prototype.get = function GotoTagVisibility() {
        var options = {
            tag:["GotoTag",this.tag],
        }
        return options;
    }
    GotoTagVisibility.prototype.set = function GotoTagVisibility() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.tag = arguments[0]["tag"];
            if (!ok) {
                break;
            }
            if (ok) {
                if (this.model.opar!=list(this.tag)) {
                    var needcompile = 4;
                    var y = needcompile;
                }
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.opar = list(new ScilabDouble([this.tag]));
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        needcompile = resume(needcompile)
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/GotoTagVisibilityMO.sci" */
function GotoTagVisibilityMO() {
    GotoTagVisibilityMO.prototype.define = function GotoTagVisibilityMO() {
        this.model = scicos_model();
        this.model.sim = new ScilabString(["gototagvisibilitymo"]);
        this.model.in = new ScilabDouble([]);
        this.model.in2 = new ScilabDouble([]);
        this.model.out = new ScilabDouble([]);
        this.model.out2 = new ScilabDouble([]);
        this.model.evtin = new ScilabDouble([]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.opar = list(new ScilabString(["A"]));
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabBoolean([false]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = "A";
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"GotoTagVisibilityMO\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    GotoTagVisibilityMO.prototype.details = function GotoTagVisibilityMO() {
        return this.x;
    }
    GotoTagVisibilityMO.prototype.get = function GotoTagVisibilityMO() {
        var options = {
            tag:["GotoTag",this.tag],
        }
        return options;
    }
    GotoTagVisibilityMO.prototype.set = function GotoTagVisibilityMO() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.tag = arguments[0]["tag"];
            if (!ok) {
                break;
            }
            if (ok) {
                if (this.model.opar!=list(this.tag)) {
                    var needcompile = 4;
                    var y = needcompile;
                }
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.opar = list(new ScilabDouble([this.tag]));
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        needcompile = resume(needcompile)
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/ISELECT_f.sci" */
function ISELECT_f() {
    ISELECT_f.prototype.define = function ISELECT_f() {
        this.z0 = 0;
        var out = [[-1],[-1]];
        this.nout = 2;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["selector"]), new ScilabDouble([2]));
        this.model.in = new ScilabDouble([-1]);
        this.model.out = new ScilabDouble(out);
        this.model.evtin = new ScilabDouble([ones(out)]);
        this.model.dstate = new ScilabDouble([this.z0]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[string(this.nout)],[string(this.z0+1)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"ISELECT_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    ISELECT_f.prototype.details = function ISELECT_f() {
        return this.x;
    }
    ISELECT_f.prototype.get = function ISELECT_f() {
        var options = {
            nout:["number of outputs",this.nout],
            z0:["initial connected output",this.z0],
        }
        return options;
    }
    ISELECT_f.prototype.set = function ISELECT_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.nout = parseFloat(arguments[0]["nout"]);
            this.z0 = parseFloat(arguments[0]["z0"]);
            if (!ok) {
                break;
            }
            if (this.z0>this.nout||this.z0<=0) {
                message("initial connected input is not a valid input port number");
                throw "user error";
            } else {
                var tmpvar0 = check_io(this.model,this.graphics,-1,-ones(this.nout,1),ones(this.nout,1),[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                if (ok) {
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    this.model.dstate = new ScilabDouble([this.z0-1]);
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/ISELECT_m.sci" */
function ISELECT_m() {
    ISELECT_m.prototype.define = function ISELECT_m() {
        this.z0 = 1;
        this.nout = 2;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["selector_m"]), new ScilabDouble([4]));
        this.model.out = new ScilabDouble([-1],[-1]);
        this.model.out2 = new ScilabDouble([-2],[-2]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.firing = new ScilabDouble([]);
        this.model.evtin = new ScilabDouble([ones(this.nout,1)]);
        this.model.dstate = new ScilabDouble([this.z0]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[sci2exp(1)],[sci2exp(this.nout)],[sci2exp(this.z0)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"ISELECT_m\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    ISELECT_m.prototype.details = function ISELECT_m() {
        return this.x;
    }
    ISELECT_m.prototype.get = function ISELECT_m() {
        var options = {
            typ:["Datatype(1= real double  2=Complex 3=int32 ...)",this.typ],
            nout:["number of outputs",this.nout],
            z0:["initial connected output",this.z0],
        }
        return options;
    }
    ISELECT_m.prototype.set = function ISELECT_m() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.typ = inverse(arguments[0]["typ"]);
            this.nout = parseFloat(arguments[0]["nout"]);
            this.z0 = parseFloat(arguments[0]["z0"]);
            if (!ok) {
                break;
            }
            if (this.z0>this.nout||this.z0<=0) {
                message("initial connected input is not a valid input port number");
                throw "user error";
            } else if (((this.typ<1)||(this.typ>8))) {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            } else {
                var it = this.typ;
                var ot = this.typ*ones(1,this.nout);
                if (ok) {
                    var out = [-ones(this.nout,1),-2*ones(this.nout,1)];
                    var in1 = [-1,-2];
                    var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),ones(this.nout,1),[]);
                    this.model = tmpvar0[0];
                    this.graphics = tmpvar0[1];
                    var ok = tmpvar0[2];
                    if (ok) {
                        this.graphics.exprs = new ScilabDouble([this.exprs]);
                        this.model.dstate = new ScilabDouble([this.z0]);
                        this.x.graphics = this.graphics;
                        this.x.model = this.model;
                        break;
                    }
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/MUX.sci" */
function MUX() {
    MUX.prototype.define = function MUX() {
        this.in1 = 2;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["multiplex"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble(-transpose([1:this.in1]));
        this.model.out = new ScilabDouble([0]);
        this.model.ipar = new ScilabDouble([this.in1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = string(this.in1);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MUX\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([.5,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    MUX.prototype.details = function MUX() {
        return this.x;
    }
    MUX.prototype.get = function MUX() {
        var options = {
            in1:["number of input ports or vector of sizes",this.in1],
        }
        return options;
    }
    MUX.prototype.set = function MUX() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.in1 = parseFloat(arguments[0]["in1"]);
            if (!ok) {
                break;
            }
            if (size(this.in1,"*")==1) {
                if (this.in1<2||this.in1>31) {
                    message("Block must have at least two input ports and at most 31");
                    throw "user error";
                    var ok = false;
                } else {
                    var tmpvar0 = check_io(this.model,this.graphics,-transpose([1:this.in1]),0,[],[]);
                    this.model = tmpvar0[0];
                    this.graphics = tmpvar0[1];
                    var ok = tmpvar0[2];
                }
            } else {
                if (size(this.in1,"*")<2||or(this.in1==0)||size(this.in1,"*")>31) {
                    message([["Block must have at least two input ports"],["and at most 31. Size 0 is not allowed. "]]);
                    throw "user error";
                    var ok = false;
                } else {
                    if (min(this.in1)<0) {
                        var nout = 0;
                    } else {
                        var nout = sum(this.in1);
                    }
                    var tmpvar1 = check_io(this.model,this.graphics,this.in1.slice(),nout,[],[]);
                    this.model = tmpvar1[0];
                    this.graphics = tmpvar1[1];
                    var ok = tmpvar1[2];
                    if (ok) {
                        this.in1 = size(this.in1,"*");
                    }
                }
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.ipar = new ScilabDouble([this.in1]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/MUX_f.sci" */
function MUX_f() {
    MUX_f.prototype.define = function MUX_f() {
        this.in1 = 2;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["mux"]), new ScilabDouble([1]));
        this.model.in = new ScilabDouble(-transpose([1:this.in1]));
        this.model.out = new ScilabDouble([0]);
        this.model.ipar = new ScilabDouble([this.in1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = string(this.in1);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MUX_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([0.5,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    MUX_f.prototype.details = function MUX_f() {
        return this.x;
    }
    MUX_f.prototype.get = function MUX_f() {
        var options = {
            in1:["number of input ports or vector of sizes",this.in1],
        }
        return options;
    }
    MUX_f.prototype.set = function MUX_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.in1 = parseFloat(arguments[0]["in1"]);
            if (!ok) {
                break;
            }
            if (size(this.in1,"*")==1) {
                if (this.in1<2||this.in1>8) {
                    message("Block must have at least two input ports and at most eight");
                    throw "user error";
                    var ok = false;
                } else {
                    var tmpvar0 = check_io(this.model,this.graphics,-transpose([1:this.in1]),0,[],[]);
                    this.model = tmpvar0[0];
                    this.graphics = tmpvar0[1];
                    var ok = tmpvar0[2];
                }
            } else {
                if (size(this.in1,"*")<2||size(this.in1,"*")>8||or(this.in1==0)) {
                    message([["Block must have at least two input ports"],["and at most eight, and size 0 is not allowed. "]]);
                    throw "user error";
                    var ok = false;
                } else {
                    if (min(this.in1)<0) {
                        var nout = 0;
                    } else {
                        var nout = sum(this.in1);
                    }
                    var tmpvar1 = check_io(this.model,this.graphics,this.in1.slice(),nout,[],[]);
                    this.model = tmpvar1[0];
                    this.graphics = tmpvar1[1];
                    var ok = tmpvar1[2];
                    if (ok) {
                        this.in1 = size(this.in1,"*");
                    }
                }
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.ipar = new ScilabDouble([this.in1]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/M_SWITCH.sci" */
function M_SWITCH() {
    M_SWITCH.prototype.define = function M_SWITCH() {
        var in1 = [[1],[-1],[-1]];
        var ipar = [[1],[3]];
        this.nin = 2;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["mswitch"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble(in1);
        this.model.out = new ScilabDouble([-1]);
        this.model.ipar = new ScilabDouble(ipar);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[string(this.nin)],[string(ipar)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"M_SWITCH\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2.5,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    M_SWITCH.prototype.details = function M_SWITCH() {
        return this.x;
    }
    M_SWITCH.prototype.get = function M_SWITCH() {
        var options = {
            nin:["number of inputs",this.nin],
            base:["zero base indexing (0), otherwise 1",this.base],
            rule:["rounding rule: int (0), round (1), ceil (2), floor (3)",this.rule],
        }
        return options;
    }
    M_SWITCH.prototype.set = function M_SWITCH() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.nin = parseFloat(arguments[0]["nin"]);
            this.base = parseFloat(arguments[0]["base"]);
            this.rule = arguments[0]["rule"];
            if (!ok) {
                break;
            }
            this.nin = int(this.nin);
            this.base = int(this.base);
            if (this.nin<1) {
                message("Number of inputs must be >=1 ");
                throw "user error";
            } else if (!((this.base==1)||(this.base==0))) {
                message("base indexing must be 1 or 0");
                throw "user error";
            } else if (!((this.rule==1)||(this.rule==0)||(this.rule==2)||(this.rule==3))) {
                message("incorrect rounding rule");
                throw "user error";
            } else {
                if (this.nin==1) {
                    var in1 = [[1,1],[-1,1]];
                    var out = [1,1];
                } else {
                    var in1 = [[1],[-ones(this.nin,1)]];
                    var in2 = [[1],[-2*ones(this.nin,1)]];
                    var in1 = [in1,in2];
                    var out = [-1,-2];
                }
                var it = [[-1],[-2*ones(this.nin,1)]];
                var ot = -2;
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                if (ok) {
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    this.model.ipar = new ScilabDouble([this.base],[this.rule]);
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/NRMSOM_f.sci" */
function NRMSOM_f() {
    NRMSOM_f.prototype.define = function NRMSOM_f() {
        var in1 = [[-1],[-1]];
        this.nin = 2;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["junk"]);
        this.model.in = new ScilabDouble(in1);
        this.model.out = new ScilabDouble([-1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [string(this.nin)];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"NRMSOM_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([.2,2]),this.model,new ScilabString(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    NRMSOM_f.prototype.details = function NRMSOM_f() {
        return this.x;
    }
    NRMSOM_f.prototype.get = function NRMSOM_f() {
        var options = {
            nin:["number of inputs",this.nin],
        }
        return options;
    }
    NRMSOM_f.prototype.set = function NRMSOM_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.nin = parseFloat(arguments[0]["nin"]);
            if (!ok) {
                break;
            }
            var tmpvar0 = check_io(this.model,this.graphics,-ones(this.nin,1),-1,[],[]);
            this.model = tmpvar0[0];
            this.graphics = tmpvar0[1];
            var ok = tmpvar0[2];
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/RELAY_f.sci" */
function RELAY_f() {
    RELAY_f.prototype.define = function RELAY_f() {
        var i0 = 0;
        var in1 = [[-1],[-1]];
        this.nin = 2;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["relay"]), new ScilabDouble([2]));
        this.model.in = new ScilabDouble(in1);
        this.model.out = new ScilabDouble([-1]);
        this.model.evtin = new ScilabDouble([ones(in1)]);
        this.model.dstate = new ScilabDouble([i0]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,true]);
        this.exprs = [[string(this.nin)],[string(i0+1)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"RELAY_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    RELAY_f.prototype.details = function RELAY_f() {
        return this.x;
    }
    RELAY_f.prototype.get = function RELAY_f() {
        var options = {
            nin:["number of inputs",this.nin],
            z0:["initial connected input",this.z0],
        }
        return options;
    }
    RELAY_f.prototype.set = function RELAY_f() {
        this.exprs = this.graphics.exprs;
        var ipar = this.model.ipar;
        while (true) {
            var ok = true;
            this.nin = parseFloat(arguments[0]["nin"]);
            this.z0 = arguments[0]["z0"];
            if (!ok) {
                break;
            }
            if (this.z0>this.nin||this.z0<=0) {
                message("initial connected input is not a valid input port number");
                throw "user error";
            } else {
                var tmpvar0 = check_io(this.model,this.graphics,-ones(this.nin,1),-1,ones(this.nin,1),[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                if (ok) {
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    this.model.dstate = new ScilabString([this.z0-1]);
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/SCALAR2VECTOR.sci" */
function SCALAR2VECTOR() {
    SCALAR2VECTOR.prototype.define = function SCALAR2VECTOR() {
        this.nout = -1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["scalar2vector"]), new ScilabDouble([4]));
        this.model.out = new ScilabDouble([this.nout]);
        this.model.in = new ScilabDouble([1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [string([this.nout])];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SCALAR2VECTOR\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabString(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    SCALAR2VECTOR.prototype.details = function SCALAR2VECTOR() {
        return this.x;
    }
    SCALAR2VECTOR.prototype.get = function SCALAR2VECTOR() {
        var options = {
            nout:["size of output (-1: if don\'t know)",this.nout],
        }
        return options;
    }
    SCALAR2VECTOR.prototype.set = function SCALAR2VECTOR() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.nout = parseFloat(arguments[0]["nout"]);
            if (!ok) {
                break;
            }
            this.nout = int(this.nout);
            if ((this.nout!=-1&&(this.nout<=0))) {
                message("size of output must be -1 or >0");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                var tmpvar0 = check_io(this.model,this.graphics,[1],this.nout,[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/SELECT_f.sci" */
function SELECT_f() {
    SELECT_f.prototype.define = function SELECT_f() {
        this.z0 = 0;
        var in1 = [[-1],[-1]];
        this.nin = 2;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["selector"]), new ScilabDouble([2]));
        this.model.in = new ScilabDouble(in1);
        this.model.out = new ScilabDouble([-1]);
        this.model.evtin = new ScilabDouble([ones(in1)]);
        this.model.dstate = new ScilabDouble([this.z0]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[string(this.nin)],[string(this.z0+1)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SELECT_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    SELECT_f.prototype.details = function SELECT_f() {
        return this.x;
    }
    SELECT_f.prototype.get = function SELECT_f() {
        var options = {
            nin:["number of inputs",this.nin],
            z0:["initial connected input",this.z0],
        }
        return options;
    }
    SELECT_f.prototype.set = function SELECT_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.nin = parseFloat(arguments[0]["nin"]);
            this.z0 = parseFloat(arguments[0]["z0"]);
            if (!ok) {
                break;
            }
            if (this.z0>this.nin||this.z0<=0) {
                message("initial connected input is not a valid input port number");
                throw "user error";
            } else {
                var tmpvar0 = check_io(this.model,this.graphics,-ones(this.nin,1),-1,ones(this.nin,1),[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                if (ok) {
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    this.model.dstate = new ScilabDouble([this.z0-1]);
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/SELECT_m.sci" */
function SELECT_m() {
    SELECT_m.prototype.define = function SELECT_m() {
        this.z0 = 1;
        this.nin = 2;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["selector_m"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([-1],[-1]);
        this.model.in2 = new ScilabDouble([-2],[-2]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-2]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.firing = new ScilabDouble([]);
        this.model.evtin = new ScilabDouble([ones(this.nin,1)]);
        this.model.dstate = new ScilabDouble([this.z0]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[sci2exp(1)],[sci2exp(this.nin)],[sci2exp(this.z0)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SELECT_m\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    SELECT_m.prototype.details = function SELECT_m() {
        return this.x;
    }
    SELECT_m.prototype.get = function SELECT_m() {
        var options = {
            typ:["Datatype(1= real double  2=Complex 3=int32 ..)",this.typ],
            nin:["number of inputs",this.nin],
            z0:["initial connected input",this.z0],
        }
        return options;
    }
    SELECT_m.prototype.set = function SELECT_m() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.typ = inverse(arguments[0]["typ"]);
            this.nin = parseFloat(arguments[0]["nin"]);
            this.z0 = parseFloat(arguments[0]["z0"]);
            if (!ok) {
                break;
            }
            if (this.z0>this.nin||this.z0<=0) {
                message("initial connected input is not a valid input port number");
                throw "user error";
            } else if (((this.typ<1)||(this.typ>8))&&(this.typ!=-1)) {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            } else {
                var it = this.typ*ones(1,this.nin);
                var ot = this.typ;
                if (ok) {
                    var in1 = [-ones(this.nin,1),-2*ones(this.nin,1)];
                    var out = [-1,-2];
                    var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),ones(this.nin,1),[]);
                    this.model = tmpvar0[0];
                    this.graphics = tmpvar0[1];
                    var ok = tmpvar0[2];
                    if (ok) {
                        this.graphics.exprs = new ScilabDouble([this.exprs]);
                        this.model.dstate = new ScilabDouble([this.z0]);
                        this.x.graphics = this.graphics;
                        this.x.model = this.model;
                        break;
                    }
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/SELF_SWITCH.sci" */
function SELF_SWITCH() {
    SELF_SWITCH.prototype.define = function SELF_SWITCH() {
        this.stateOpen = true;
        this.x = scicos_block();
        this.x.gui = "SELF_SWITCH";
        this.x.graphics.sz = [2,2];
        this.x.graphics.gr_i = [];
        this.x.graphics.pin = 0;
        this.x.graphics.pout = 0;
        this.x.model.sim = "csuper";
        this.x.model.in = 1;
        this.x.model.out = 1;
        this.x.model.blocktype = "h";
        this.x.model.dep_ut = [false,false];
        this.x.model.rpar = genSwitchInnerDiagram(this.stateOpen);
        this.x.model.opar = list(this.stateOpen);
        this.x.graphics.in_implicit = ["E"];
        this.x.graphics.in_style = "";
        this.x.graphics.out_implicit = ["E"];
        this.x.graphics.out_style = "";
        this.x.graphics.style = "SELF_SWITCH_OFF";
        return new BasicBlock(this.x);
    }
    SELF_SWITCH.prototype.details = function SELF_SWITCH() {
        return this.x;
    }
    SELF_SWITCH.prototype.get = function SELF_SWITCH() {
        alert("parameters cannot be modified");
    }
    SELF_SWITCH.prototype.set = function SELF_SWITCH() {
        this.stateOpen = this.x.model.opar[1-1];
        this.x.model.rpar = genSwitchInnerDiagram(!this.stateOpen);
        this.x.model.opar = list(!this.stateOpen);
        var y = 0;
        var typ = list();
        if (this.stateOpen==false) {
            this.x.graphics.style = "SELF_SWITCH_OFF";
        } else {
            this.x.graphics.style = "SELF_SWITCH_ON";
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/SWITCH2.sci" */
function SWITCH2() {
    SWITCH2.prototype.define = function SWITCH2() {
        var in1 = [[-1],[1],[-1]];
        var ipar = [0];
        this.nzz = 1;
        var rpar = 0;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["switch2"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble(in1);
        this.model.out = new ScilabDouble([-1]);
        this.model.ipar = new ScilabDouble(ipar);
        this.model.rpar = new ScilabDouble([rpar]);
        this.model.nzcross = new ScilabDouble([this.nzz]);
        this.model.nmode = new ScilabDouble([1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[string(ipar)],[string(rpar)],[string(this.nzz)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SWITCH2\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    SWITCH2.prototype.details = function SWITCH2() {
        return this.x;
    }
    SWITCH2.prototype.get = function SWITCH2() {
        var options = {
            rule:["pass first input if: u2>=a (0), u2>a (1), u2~=a (2)",this.rule],
            thra:["threshold a",this.thra],
            nzz:["use zero crossing: yes (1), no (0)",this.nzz],
        }
        return options;
    }
    SWITCH2.prototype.set = function SWITCH2() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.rule = parseFloat(arguments[0]["rule"]);
            this.thra = arguments[0]["thra"];
            this.nzz = parseFloat(arguments[0]["nzz"]);
            if (!ok) {
                break;
            }
            this.rule = int(this.rule);
            if ((this.rule<0)) {
                this.rule = 0;
            }
            if ((this.rule>2)) {
                this.rule = 2;
            }
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.model.ipar = new ScilabDouble([this.rule]);
            this.model.rpar = new ScilabDouble([this.thra]);
            if (this.nzz!=0) {
                this.model.nmode = new ScilabDouble([1]);
                this.model.nzcross = new ScilabDouble([1]);
            } else {
                this.model.nmode = new ScilabDouble([0]);
                this.model.nzcross = new ScilabDouble([0]);
            }
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/SWITCH2_m.sci" */
function SWITCH2_m() {
    SWITCH2_m.prototype.define = function SWITCH2_m() {
        var ipar = [0];
        this.nzz = 1;
        var rpar = 0;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["switch2_m"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([-1],[1],[-1]);
        this.model.in2 = new ScilabDouble([-2],[1],[-2]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-2]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.ipar = new ScilabDouble(ipar);
        this.model.rpar = new ScilabDouble([rpar]);
        this.model.nzcross = new ScilabDouble([this.nzz]);
        this.model.nmode = new ScilabDouble([1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[sci2exp(1)],[string(ipar)],[string(rpar)],[string(this.nzz)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SWITCH2_m\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    SWITCH2_m.prototype.details = function SWITCH2_m() {
        return this.x;
    }
    SWITCH2_m.prototype.get = function SWITCH2_m() {
        var options = {
            ot:["Datatype (1=real double  2=complex 3=int32 ...)",this.ot],
            rule:["pass first input if: u2>=a (0), u2>a (1), u2~=a (2)",this.rule],
            thra:["threshold a",this.thra],
            nzz:["use zero crossing: yes (1), no (0)",this.nzz],
        }
        return options;
    }
    SWITCH2_m.prototype.set = function SWITCH2_m() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.ot = arguments[0]["ot"];
            this.rule = parseFloat(arguments[0]["rule"]);
            this.thra = arguments[0]["thra"];
            this.nzz = parseFloat(arguments[0]["nzz"]);
            if (!ok) {
                break;
            }
            this.rule = int(this.rule);
            if ((this.rule<0)) {
                this.rule = 0;
            }
            if ((this.rule>2)) {
                this.rule = 2;
            }
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.model.ipar = new ScilabDouble([this.rule]);
            this.model.rpar = new ScilabDouble([this.thra]);
            if (this.nzz!=0) {
                this.model.nmode = new ScilabDouble([1]);
                this.model.nzcross = new ScilabDouble([1]);
            } else {
                this.model.nmode = new ScilabDouble([0]);
                this.model.nzcross = new ScilabDouble([0]);
            }
            if (((this.ot<1)||(this.ot>8))&&(this.ot!=-1)) {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                it[1-1] = this.ot;
                it[2-1] = 1;
                it[3-1] = this.ot;
                var in1 = [this.model.in,this.model.in2];
                var out = [this.model.out,this.model.out2];
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,this.ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Branching/SWITCH_f.sci" */
function SWITCH_f() {
    SWITCH_f.prototype.define = function SWITCH_f() {
        var i0 = 0;
        var in1 = [[-1],[-1]];
        this.nin = 2;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["switchn"]), new ScilabDouble([2]));
        this.model.in = new ScilabDouble(in1);
        this.model.out = new ScilabDouble([-1]);
        this.model.ipar = new ScilabDouble([i0]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,true]);
        this.exprs = [[string(this.nin)],[string(i0+1)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SWITCH_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    SWITCH_f.prototype.details = function SWITCH_f() {
        return this.x;
    }
    SWITCH_f.prototype.get = function SWITCH_f() {
        var options = {
            nin:["number of inputs",this.nin],
            z0:["connected input",this.z0],
        }
        return options;
    }
    SWITCH_f.prototype.set = function SWITCH_f() {
        this.exprs = this.graphics.exprs;
        var ipar = this.model.ipar;
        while (true) {
            var ok = true;
            this.nin = parseFloat(arguments[0]["nin"]);
            this.z0 = arguments[0]["z0"];
            if (!ok) {
                break;
            }
            if (this.z0>this.nin||this.z0<=0) {
                message("initial connected input is not a valid input port number");
                throw "user error";
            } else {
                var tmpvar0 = check_io(this.model,this.graphics,-ones(this.nin,1),-1,[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                if (ok) {
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    this.model.ipar = new ScilabString([this.z0-1]);
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/CCS.sci" */
function CCS() {
    CCS.prototype.define = function CCS() {
        var ModelName = "CCS";
        var PrametersValue = [];
        var ParametersName = [];
        this.model = scicos_model();
        var Typein = [];
        var Typeout = [];
        var MI = [];
        var MO = [];
        var P = [[2,50,1,0],[70,98,2,0],[70,2,-2,0]];
        var PortName = [["Iin"],["p"],["n"]];
        for (i=1;i<=size(P,"r");i+=1) {
            if (P[i-1][3-1]==1) {
                var Typein = [[Typein],["E"]];
                var MI = [[MI],[PortName[i-1]]];
            }
            if (P[i-1][3-1]==2) {
                var Typein = [[Typein],["I"]];
                var MI = [[MI],[PortName[i-1]]];
            }
            if (P[i-1][3-1]==-1) {
                var Typeout = [[Typeout],["E"]];
                var MO = [[MO],[PortName[i-1]]];
            }
            if (P[i-1][3-1]==-2) {
                var Typeout = [[Typeout],["I"]];
                var MO = [[MO],[PortName[i-1]]];
            }
        }
        this.model = scicos_model();
        var mo = modelica();
        this.model.sim = new ScilabString([ModelName]);
        mo.inputs = MI;
        mo.outputs = MO;
        this.model.rpar = new ScilabDouble(PrametersValue);
        mo.parameters = list(ParametersName,PrametersValue,zeros(ParametersName));
        this.exprs = [];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CCS\",sz(1),sz(2));"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        mo.model = ModelName;
        this.model.equations = new ScilabDouble([mo]);
        this.model.in = new ScilabDouble([ones(size(MI,"*"),1)]);
        this.model.out = new ScilabDouble([ones(size(MO,"*"),1)]);
        this.x = new standard_define(new ScilabDouble([2.1,3]),this.model,new ScilabDouble(this.exprs),list(this.gr_i,0));
        this.x.graphics.in_implicit = Typein;
        this.x.graphics.out_implicit = Typeout;
        return new BasicBlock(this.x);
    }
    CCS.prototype.details = function CCS() {
        return this.x;
    }
    CCS.prototype.get = function CCS() {
        alert("parameters cannot be modified");
    }
    CCS.prototype.set = function CCS() {
        this.exprs = this.graphics.exprs;
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/CVS.sci" */
function CVS() {
    CVS.prototype.define = function CVS() {
        var ModelName = "CVS";
        var PrametersValue = [];
        var ParametersName = [];
        this.model = scicos_model();
        var Typein = [];
        var Typeout = [];
        var MI = [];
        var MO = [];
        var P = [[2,50,1,0],[70,98,2,0],[70,2,-2,0]];
        var PortName = [["vin"],["p"],["n"]];
        for (i=1;i<=size(P,"r");i+=1) {
            if (P[i-1][3-1]==1) {
                var Typein = [[Typein],["E"]];
                var MI = [[MI],[PortName[i-1]]];
            }
            if (P[i-1][3-1]==2) {
                var Typein = [[Typein],["I"]];
                var MI = [[MI],[PortName[i-1]]];
            }
            if (P[i-1][3-1]==-1) {
                var Typeout = [[Typeout],["E"]];
                var MO = [[MO],[PortName[i-1]]];
            }
            if (P[i-1][3-1]==-2) {
                var Typeout = [[Typeout],["I"]];
                var MO = [[MO],[PortName[i-1]]];
            }
        }
        this.model = scicos_model();
        var mo = modelica();
        this.model.sim = new ScilabString([ModelName]);
        mo.inputs = MI;
        mo.outputs = MO;
        this.model.rpar = new ScilabDouble(PrametersValue);
        mo.parameters = list(ParametersName,PrametersValue,zeros(ParametersName));
        this.exprs = [];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CVS\",sz(1),sz(2));"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        mo.model = ModelName;
        this.model.equations = new ScilabDouble([mo]);
        this.model.in = new ScilabDouble([ones(size(MI,"*"),1)]);
        this.model.out = new ScilabDouble([ones(size(MO,"*"),1)]);
        this.x = new standard_define(new ScilabDouble([2.1,3]),this.model,new ScilabDouble(this.exprs),list(this.gr_i,0));
        this.x.graphics.in_implicit = Typein;
        this.x.graphics.out_implicit = Typeout;
        return new BasicBlock(this.x);
    }
    CVS.prototype.details = function CVS() {
        return this.x;
    }
    CVS.prototype.get = function CVS() {
        alert("parameters cannot be modified");
    }
    CVS.prototype.set = function CVS() {
        this.exprs = this.graphics.exprs;
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/Capacitor.sci" */
function Capacitor() {
    Capacitor.prototype.define = function Capacitor() {
        this.model = scicos_model();
        this.C = 0.01;
        this.v = 0;
        this.model.rpar = new ScilabDouble([this.C],[this.v]);
        this.model.sim = new ScilabString(["Capacitor"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var mo = modelica();
        mo.model = "Capacitor";
        mo.inputs = "p";
        mo.outputs = "n";
        mo.parameters = list(["C","v"],list(this.C,this.v),[0,1]);
        this.model.equations = new ScilabDouble([mo]);
        this.model.in = new ScilabDouble([ones(size(mo.inputs,"*"),1)]);
        this.model.out = new ScilabDouble([ones(size(mo.outputs,"*"),1)]);
        this.exprs = string([[this.C],[this.v]]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"Capacitor\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,1.1]),this.model,new ScilabString([this.exprs]),list(this.gr_i,0));
        this.x.graphics.in_implicit = ["I"];
        this.x.graphics.out_implicit = ["I"];
        return new BasicBlock(this.x);
    }
    Capacitor.prototype.details = function Capacitor() {
        return this.x;
    }
    Capacitor.prototype.get = function Capacitor() {
        var options = {
            C:["C (F)",this.C],
            v:["Initial Voltage",this.v],
        }
        return options;
    }
    Capacitor.prototype.set = function Capacitor() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.C = parseFloat(arguments[0]["C"]);
            this.v = parseFloat(arguments[0]["v"]);
            if (!ok) {
                break;
            }
            this.model.rpar = new ScilabDouble([this.C]);
            this.model.equations.parameters[2-1] = list(new ScilabDouble([this.C]), new ScilabDouble([this.v]));
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/ConstantVoltage.sci" */
function ConstantVoltage() {
    ConstantVoltage.prototype.define = function ConstantVoltage() {
        this.V = 0.01;
        this.model = scicos_model();
        this.model.rpar = new ScilabDouble([this.V]);
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.sim = new ScilabString(["ConstantVoltage"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        var mo = modelica();
        mo.model = "ConstantVoltage";
        mo.inputs = "p";
        mo.outputs = "n";
        mo.parameters = list("V",list(this.V));
        this.model.equations = new ScilabDouble([mo]);
        this.exprs = string(this.V);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"ConstantVoltage\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([1.5,1.1]),this.model,new ScilabString([this.exprs]),list(this.gr_i,0));
        this.x.graphics.in_implicit = ["I"];
        this.x.graphics.out_implicit = ["I"];
        return new BasicBlock(this.x);
    }
    ConstantVoltage.prototype.details = function ConstantVoltage() {
        return this.x;
    }
    ConstantVoltage.prototype.get = function ConstantVoltage() {
        var options = {
            V:["V (volt)",this.V],
        }
        return options;
    }
    ConstantVoltage.prototype.set = function ConstantVoltage() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.V = parseFloat(arguments[0]["V"]);
            if (!ok) {
                break;
            }
            this.model.rpar = new ScilabDouble([this.V]);
            this.model.equations.parameters[2-1] = list(new ScilabDouble([this.V]));
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/CurrentSensor.sci" */
function CurrentSensor() {
    CurrentSensor.prototype.define = function CurrentSensor() {
        this.model = scicos_model();
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1],[1]);
        this.model.sim = new ScilabString(["CurrentSensor"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var mo = modelica();
        mo.model = "CurrentSensor";
        mo.inputs = "p";
        mo.outputs = [["n"],["i"]];
        this.model.equations = new ScilabDouble([mo]);
        this.exprs = [];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CurrentSensor\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),list(this.gr_i,0));
        this.x.graphics.in_implicit = ["I"];
        this.x.graphics.out_implicit = [["I"],["E"]];
        return new BasicBlock(this.x);
    }
    CurrentSensor.prototype.details = function CurrentSensor() {
        return this.x;
    }
    CurrentSensor.prototype.get = function CurrentSensor() {
        alert("parameters cannot be modified");
    }
    CurrentSensor.prototype.set = function CurrentSensor() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/Diode.sci" */
function Diode() {
    Diode.prototype.define = function Diode() {
        this.Ids = 1.e-6;
        this.Vt = 0.04;
        this.Maxexp = 15;
        this.R = 1.e8;
        this.model = scicos_model();
        this.model.rpar = new ScilabDouble([this.Ids],[this.Vt],[this.Maxexp],[this.R]);
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.sim = new ScilabString(["Diode"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var mo = modelica();
        mo.model = "Diode";
        mo.inputs = "p";
        mo.outputs = "n";
        mo.parameters = list(["Ids","Vt","Maxexp","R"],list(this.Ids,this.Vt,this.Maxexp,this.R));
        this.model.equations = new ScilabDouble([mo]);
        this.exprs = string([[this.Ids],[this.Vt],[this.Maxexp],[this.R]]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"Diode\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,1]),this.model,new ScilabString([this.exprs]),list(this.gr_i,0));
        this.x.graphics.in_implicit = ["I"];
        this.x.graphics.out_implicit = ["I"];
        return new BasicBlock(this.x);
    }
    Diode.prototype.details = function Diode() {
        return this.x;
    }
    Diode.prototype.get = function Diode() {
        var options = {
            Ids:["Saturation cuurent (A)",this.Ids],
            Vt:["Voltage equivalent to temperature (Volt)",this.Vt],
            Maxexp:["Max exponent for linear continuation",this.Maxexp],
            R:["R (ohm)",this.R],
        }
        return options;
    }
    Diode.prototype.set = function Diode() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.Ids = parseFloat(arguments[0]["Ids"]);
            this.Vt = parseFloat(arguments[0]["Vt"]);
            this.Maxexp = parseFloat(arguments[0]["Maxexp"]);
            this.R = parseFloat(arguments[0]["R"]);
            if (!ok) {
                break;
            }
            this.model.rpar = new ScilabDouble([this.Ids],[this.Vt],[this.Maxexp],[this.R]);
            this.model.equations.parameters = list(new ScilabDouble([["Ids","Vt","Maxexp","R"]]),list(this.Ids,this.Vt,this.Maxexp,this.R));
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/Ground.sci" */
function Ground() {
    Ground.prototype.define = function Ground() {
        this.model = scicos_model();
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([]);
        this.model.sim = new ScilabString(["Ground"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var mo = modelica();
        mo.model = "Ground";
        mo.inputs = "p";
        this.model.equations = new ScilabDouble([mo]);
        this.exprs = "";
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"Ground\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([1,1]),this.model,new ScilabString([this.exprs]),list(this.gr_i,0));
        this.x.graphics.in_implicit = ["I"];
        this.x.graphics.out_implicit = ["I"];
        return new GroundBlock(this.x);
    }
    Ground.prototype.details = function Ground() {
        return this.x;
    }
    Ground.prototype.get = function Ground() {
        alert("parameters cannot be modified");
    }
    Ground.prototype.set = function Ground() {
        return new GroundBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/Gyrator.sci" */
function Gyrator() {
    Gyrator.prototype.define = function Gyrator() {
        var ModelName = "Gyrator";
        var PrametersValue = [[1],[1]];
        var ParametersName = [["G1"],["G2"]];
        this.model = scicos_model();
        var Typein = [];
        var Typeout = [];
        var MI = [];
        var MO = [];
        var P = [[2.5,90,2,0],[2.5,10,2,0],[97.5,90,-2,0],[97.5,10,-2,0]];
        var PortName = [["p1"],["n1"],["p2"],["n2"]];
        for (i=1;i<=size(P,"r");i+=1) {
            if (P[i-1][3-1]==1) {
                var Typein = [[Typein],["E"]];
                var MI = [[MI],[PortName[i-1]]];
            }
            if (P[i-1][3-1]==2) {
                var Typein = [[Typein],["I"]];
                var MI = [[MI],[PortName[i-1]]];
            }
            if (P[i-1][3-1]==-1) {
                var Typeout = [[Typeout],["E"]];
                var MO = [[MO],[PortName[i-1]]];
            }
            if (P[i-1][3-1]==-2) {
                var Typeout = [[Typeout],["I"]];
                var MO = [[MO],[PortName[i-1]]];
            }
        }
        this.model = scicos_model();
        var mo = modelica();
        this.model.sim = new ScilabString([ModelName]);
        mo.inputs = MI;
        mo.outputs = MO;
        this.model.rpar = new ScilabDouble(PrametersValue);
        mo.parameters = list(ParametersName,PrametersValue,zeros(ParametersName));
        this.exprs = [["1"],["1"]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"Gyrator\",sz(1),sz(2));"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        mo.model = ModelName;
        this.model.equations = new ScilabDouble([mo]);
        this.model.in = new ScilabDouble([ones(size(MI,"*"),1)]);
        this.model.out = new ScilabDouble([ones(size(MO,"*"),1)]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),list(this.gr_i,0));
        this.x.graphics.in_implicit = Typein;
        this.x.graphics.out_implicit = Typeout;
        return new BasicBlock(this.x);
    }
    Gyrator.prototype.details = function Gyrator() {
        return this.x;
    }
    Gyrator.prototype.get = function Gyrator() {
        var options = {
            G1:["G1",this.G1],
            G2:["G2",this.G2],
        }
        return options;
    }
    Gyrator.prototype.set = function Gyrator() {
        this.exprs = this.graphics.exprs;
        this.exprs = this.x.graphics.exprs;
        while (true) {
            var ok = true;
            this.G1 = arguments[0]["G1"];
            this.G2 = arguments[0]["G2"];
            if (!ok) {
                break;
            }
            this.x.model.equations.parameters[2-1] = list(this.G1,this.G2);
            this.x.graphics.exprs = this.exprs;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/IdealTransformer.sci" */
function IdealTransformer() {
    IdealTransformer.prototype.define = function IdealTransformer() {
        var ModelName = "IdealTransformer";
        var PrametersValue = [1];
        var ParametersName = ["N"];
        this.model = scicos_model();
        var Typein = [];
        var Typeout = [];
        var MI = [];
        var MO = [];
        var P = [[2.5,90,2,0],[2.5,10,2,0],[97.5,90,-2,0],[97.5,10,-2,0]];
        var PortName = [["p1"],["n1"],["p2"],["n2"]];
        for (i=1;i<=size(P,"r");i+=1) {
            if (P[i-1][3-1]==1) {
                var Typein = [[Typein],["E"]];
                var MI = [[MI],[PortName[i-1]]];
            }
            if (P[i-1][3-1]==2) {
                var Typein = [[Typein],["I"]];
                var MI = [[MI],[PortName[i-1]]];
            }
            if (P[i-1][3-1]==-1) {
                var Typeout = [[Typeout],["E"]];
                var MO = [[MO],[PortName[i-1]]];
            }
            if (P[i-1][3-1]==-2) {
                var Typeout = [[Typeout],["I"]];
                var MO = [[MO],[PortName[i-1]]];
            }
        }
        this.model = scicos_model();
        var mo = modelica();
        this.model.sim = new ScilabString([ModelName]);
        mo.inputs = MI;
        mo.outputs = MO;
        this.model.rpar = new ScilabDouble(PrametersValue);
        mo.parameters = list(ParametersName,PrametersValue,zeros(ParametersName));
        this.exprs = ["1"];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"IdealTransformer\",sz(1),sz(2));"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        mo.model = ModelName;
        this.model.equations = new ScilabDouble([mo]);
        this.model.in = new ScilabDouble([ones(size(MI,"*"),1)]);
        this.model.out = new ScilabDouble([ones(size(MO,"*"),1)]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString(this.exprs),list(this.gr_i,0));
        this.x.graphics.in_implicit = Typein;
        this.x.graphics.out_implicit = Typeout;
        return new BasicBlock(this.x);
    }
    IdealTransformer.prototype.details = function IdealTransformer() {
        return this.x;
    }
    IdealTransformer.prototype.get = function IdealTransformer() {
        var options = {
            N:["N",this.N],
        }
        return options;
    }
    IdealTransformer.prototype.set = function IdealTransformer() {
        this.exprs = this.graphics.exprs;
        this.exprs = this.x.graphics.exprs;
        while (true) {
            var ok = true;
            this.N = arguments[0]["N"];
            if (!ok) {
                break;
            }
            this.x.model.equations.parameters[2-1] = list(this.N);
            this.x.graphics.exprs = this.exprs;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/Inductor.sci" */
function Inductor() {
    Inductor.prototype.define = function Inductor() {
        this.model = scicos_model();
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.L = 1.e-5;
        this.model.rpar = new ScilabDouble([this.L]);
        this.model.sim = new ScilabString(["Inductor"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var mo = modelica();
        mo.model = "Inductor";
        mo.inputs = "p";
        mo.outputs = "n";
        mo.parameters = list("L",list(this.L));
        this.model.equations = new ScilabDouble([mo]);
        this.exprs = string(this.L);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"Inductor\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,0.9]),this.model,new ScilabString([this.exprs]),list(this.gr_i,0));
        this.x.graphics.in_implicit = ["I"];
        this.x.graphics.out_implicit = ["I"];
        return new BasicBlock(this.x);
    }
    Inductor.prototype.details = function Inductor() {
        return this.x;
    }
    Inductor.prototype.get = function Inductor() {
        var options = {
            L:["L (H)",this.L],
        }
        return options;
    }
    Inductor.prototype.set = function Inductor() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.L = parseFloat(arguments[0]["L"]);
            if (!ok) {
                break;
            }
            this.model.rpar = new ScilabDouble([this.L]);
            this.model.equations.parameters[2-1] = list(new ScilabDouble([this.L]));
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/MOTOR.sci" */
function MOTOR() {
    MOTOR.prototype.define = function MOTOR() {
        this.model = scicos_model();
        this.model.out = new ScilabDouble([1],[1]);
        this.model.in = new ScilabDouble([1]);
        this.model.sim = new ScilabString(["motor"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MOTOR\",sz(1),sz(2));"]);
        this.exprs = "";
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        this.x.graphics.out_implicit = [["I"],["I"]];
        this.x.graphics.in_implicit = ["I"];
        return new BasicBlock(this.x);
    }
    MOTOR.prototype.details = function MOTOR() {
        return this.x;
    }
    MOTOR.prototype.get = function MOTOR() {
        alert("parameters cannot be modified");
    }
    MOTOR.prototype.set = function MOTOR() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/NMOS.sci" */
function NMOS() {
    NMOS.prototype.define = function NMOS() {
        this.model = scicos_model();
        this.W = 20.e-6;
        this.L = 6.e-6;
        this.Beta = 0.041e-3;
        this.Vt = 0.8;
        this.K2 = 1.144;
        this.K5 = 0.7311;
        this.dW = -2.5e-6;
        this.dL = -1.5e-6;
        this.RDS = 1.e+7;
        this.model.sim = new ScilabString(["NMOS"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var mo = modelica();
        mo.model = "NMOS";
        mo.outputs = [["D"],["B"],["S"]];
        mo.inputs = "G";
        mo.parameters = list([["W"],["L"],["Beta"],["Vt"],["K2"],["K5"],["dW"],["dL"],["RDS"]],[[this.W],[this.L],[this.Beta],[this.Vt],[this.K2],[this.K5],[this.dW],[this.dL],[this.RDS]]);
        this.model.equations = new ScilabDouble([mo]);
        this.model.in = new ScilabDouble([ones(size(mo.inputs,"*"),1)]);
        this.model.out = new ScilabDouble([ones(size(mo.outputs,"*"),1)]);
        this.exprs = [[string(this.W)],[string(this.L)],[string(this.Beta)],[string(this.Vt)],[string(this.K2)],[string(this.K5)],[string(this.dW)],[string(this.dL)],[string(this.RDS)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"NMOS\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        this.x.graphics.in_implicit = ["I"];
        this.x.graphics.out_implicit = [["I"],["I"],["I"]];
        return new BasicBlock(this.x);
    }
    NMOS.prototype.details = function NMOS() {
        return this.x;
    }
    NMOS.prototype.get = function NMOS() {
        var options = {
            W:["Width [m]",this.W],
            L:["Length [m]",this.L],
            Beta:["Transconductance parameter [A/(V*V)]",this.Beta],
            Vt:["Zero bias threshold voltage [V]",this.Vt],
            K2:["Bulk threshold parameter",this.K2],
            K5:["Reduction of pinch-off region",this.K5],
            dW:["Narrowing of channel [m]",this.dW],
            dL:["Shortening of channel [m]",this.dL],
            RDS:["Drain-Source-Resistance [Ohm]",this.RDS],
        }
        return options;
    }
    NMOS.prototype.set = function NMOS() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.W = parseFloat(arguments[0]["W"]);
            this.L = parseFloat(arguments[0]["L"]);
            this.Beta = parseFloat(arguments[0]["Beta"]);
            this.Vt = parseFloat(arguments[0]["Vt"]);
            this.K2 = parseFloat(arguments[0]["K2"]);
            this.K5 = parseFloat(arguments[0]["K5"]);
            this.dW = parseFloat(arguments[0]["dW"]);
            this.dL = parseFloat(arguments[0]["dL"]);
            this.RDS = parseFloat(arguments[0]["RDS"]);
            if (!ok) {
                break;
            }
            this.model.equations.parameters[2-1] = list(new ScilabDouble([this.W]), new ScilabDouble([this.L]), new ScilabDouble([this.Beta]), new ScilabDouble([this.Vt]), new ScilabDouble([this.K2]), new ScilabDouble([this.K5]), new ScilabDouble([this.dW]), new ScilabDouble([this.dL]), new ScilabDouble([this.RDS]));
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/NPN.sci" */
function NPN() {
    NPN.prototype.define = function NPN() {
        var ModelName = "NPN";
        var PrametersValue = [[50],[0.1],[0],[0.02],[1.200e-10],[5.000e-09],[1.000e-12],[4.000e-13],[5.000e-13],[0.8],[0.4],[0.8],[0.333],[1.000e-15],[1.000e-15],[0.02585],[40]];
        var ParametersName = [["Bf"],["Br"],["Is"],["Vak"],["Tauf"],["Taur"],["Ccs"],["Cje"],["Cjc"],["Phie"],["Me"],["Phic"],["Mc"],["Gbc"],["Gbe"],["Vt"],["EMinMax"]];
        this.model = scicos_model();
        var Typein = [];
        var Typeout = [];
        var MI = [];
        var MO = [];
        var P = [[100,90,-2,0],[0,50,2,0],[100,10,-2,0]];
        var PortName = [["C"],["B"],["E"]];
        for (i=1;i<=size(P,"r");i+=1) {
            if (P[i-1][3-1]==1) {
                var Typein = [[Typein],["E"]];
                var MI = [[MI],[PortName[i-1]]];
            }
            if (P[i-1][3-1]==2) {
                var Typein = [[Typein],["I"]];
                var MI = [[MI],[PortName[i-1]]];
            }
            if (P[i-1][3-1]==-1) {
                var Typeout = [[Typeout],["E"]];
                var MO = [[MO],[PortName[i-1]]];
            }
            if (P[i-1][3-1]==-2) {
                var Typeout = [[Typeout],["I"]];
                var MO = [[MO],[PortName[i-1]]];
            }
        }
        this.model = scicos_model();
        var mo = modelica();
        this.model.sim = new ScilabString([ModelName]);
        mo.inputs = MI;
        mo.outputs = MO;
        this.model.rpar = new ScilabDouble(PrametersValue);
        mo.parameters = list(ParametersName,PrametersValue,zeros(ParametersName));
        this.exprs = [["50"],["0.1"],["1.e-16"],["0.02"],["0.12e-9"],["5e-9"],["1e-12"],["0.4e-12"],["0.5e-12"],["0.8"],["0.4"],["0.8"],["0.333"],["1e-15"],["1e-15"],["0.02585"],["40"]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"NPN\",sz(1),sz(2));"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        mo.model = ModelName;
        this.model.equations = new ScilabDouble([mo]);
        this.model.in = new ScilabDouble([ones(size(MI,"*"),1)]);
        this.model.out = new ScilabDouble([ones(size(MO,"*"),1)]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),list(this.gr_i,0));
        this.x.graphics.in_implicit = Typein;
        this.x.graphics.out_implicit = Typeout;
        return new BasicBlock(this.x);
    }
    NPN.prototype.details = function NPN() {
        return this.x;
    }
    NPN.prototype.get = function NPN() {
        var options = {
            Bf:["Bf  : Forward beta",this.Bf],
            Br:["Br  : Reverse beta",this.Br],
            Is:["Is  : Transport saturation current",this.Is],
            Vak:["Vak : Early voltage (inverse), 1/Volt",this.Vak],
            Tauf:["Tauf: Ideal forward transit time",this.Tauf],
            Taur:["Taur: Ideal reverse transit time",this.Taur],
            Ccs:["Ccs : Collector-substrat(ground) cap.",this.Ccs],
            Cje:["Cje : Base-emitter zero bias depletion cap.",this.Cje],
            Cjc:["Cjc : Base-coll. zero bias depletion cap.",this.Cjc],
            Phie:["Phie: Base-emitter diffusion voltage",this.Phie],
            Me:["Me  : Base-emitter gradation exponent",this.Me],
            Phic:["Phic: Base-collector diffusion voltage",this.Phic],
            Mc:["Mc  : Base-collector gradation exponent",this.Mc],
            Gbc:["Gbc : Base-collector conductance",this.Gbc],
            Gbe:["Gbe : Base-emitter conductance",this.Gbe],
            Vt:["Vt  : Voltage equivalent of temperature",this.Vt],
            EMinMax:["EMinmax: if x > EMinMax, the exp(x) is linearized",this.EMinMax],
        }
        return options;
    }
    NPN.prototype.set = function NPN() {
        this.exprs = this.graphics.exprs;
        this.exprs = this.x.graphics.exprs;
        while (true) {
            var ok = true;
            this.Bf = arguments[0]["Bf"];
            this.Br = arguments[0]["Br"];
            this.Is = arguments[0]["Is"];
            this.Vak = arguments[0]["Vak"];
            this.Tauf = arguments[0]["Tauf"];
            this.Taur = arguments[0]["Taur"];
            this.Ccs = arguments[0]["Ccs"];
            this.Cje = arguments[0]["Cje"];
            this.Cjc = arguments[0]["Cjc"];
            this.Phie = arguments[0]["Phie"];
            this.Me = arguments[0]["Me"];
            this.Phic = arguments[0]["Phic"];
            this.Mc = arguments[0]["Mc"];
            this.Gbc = arguments[0]["Gbc"];
            this.Gbe = arguments[0]["Gbe"];
            this.Vt = arguments[0]["Vt"];
            this.EMinMax = arguments[0]["EMinMax"];
            if (!ok) {
                break;
            }
            this.x.model.equations.parameters[2-1] = list(this.Bf,this.Br,this.Is,this.Vak,this.Tauf,this.Taur,this.Ccs,this.Cje,this.Cjc,this.Phie,this.Me,this.Phic,this.Mc,this.Gbc,this.Gbe,this.Vt,this.EMinMax);
            this.x.graphics.exprs = this.exprs;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/OpAmp.sci" */
function OpAmp() {
    OpAmp.prototype.define = function OpAmp() {
        var S = [];
        var Z = [];
        this.model = scicos_model();
        this.model.sim = new ScilabString(["OpAmp"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var mo = modelica();
        mo.model = this.model.sim;
        mo.inputs = [["in_p"],["in_n"]];
        mo.outputs = ["out"];
        mo.parameters = list(S,Z);
        this.model.equations = new ScilabDouble([mo]);
        this.model.in = new ScilabDouble([ones(size(mo.inputs,"*"),1)]);
        this.model.out = new ScilabDouble([ones(size(mo.outputs,"*"),1)]);
        this.model.rpar = new ScilabDouble(Z);
        this.exprs = string(Z);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"OpAmp\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,5]),this.model,new ScilabString([this.exprs]),this.gr_i);
        this.x.graphics.in_implicit = [["I"],["I"]];
        this.x.graphics.out_implicit = ["I"];
        return new BasicBlock(this.x);
    }
    OpAmp.prototype.details = function OpAmp() {
        return this.x;
    }
    OpAmp.prototype.get = function OpAmp() {
        var options = {
            OLGain:["Open Loop Gain",this.OLGain],
            SatH:["Positive saturation voltage",this.SatH],
            SatL:["Negative saturation voltage",this.SatL],
        }
        return options;
    }
    OpAmp.prototype.set = function OpAmp() {
        this.exprs = this.graphics.exprs;
        while (false) {
            var ok = true;
            this.OLGain = arguments[0]["OLGain"];
            this.SatH = arguments[0]["SatH"];
            this.SatL = arguments[0]["SatL"];
            if (!ok) {
                break;
            }
            this.model.equations.parameters[2-1] = list(new ScilabDouble([this.OLGain]), new ScilabDouble([this.SatH]), new ScilabDouble([this.SatL]));
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/PMOS.sci" */
function PMOS() {
    PMOS.prototype.define = function PMOS() {
        this.model = scicos_model();
        this.W = 50.0e-6;
        this.L = 6.0e-6;
        this.Beta = 0.0105e-3;
        this.Vt = -1;
        this.K2 = 0.41;
        this.K5 = 0.839;
        this.dW = -2.5e-6;
        this.dL = -2.1e-6;
        this.RDS = 1.e+7;
        this.model.sim = new ScilabString(["PMOS"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var mo = modelica();
        mo.model = "PMOS";
        mo.outputs = [["D"],["B"],["S"]];
        mo.inputs = "G";
        mo.parameters = list([["W"],["L"],["Beta"],["Vt"],["K2"],["K5"],["dW"],["dL"],["RDS"]],[[this.W],[this.L],[this.Beta],[this.Vt],[this.K2],[this.K5],[this.dW],[this.dL],[this.RDS]]);
        this.model.equations = new ScilabDouble([mo]);
        this.model.in = new ScilabDouble([ones(size(mo.inputs,"*"),1)]);
        this.model.out = new ScilabDouble([ones(size(mo.outputs,"*"),1)]);
        this.exprs = [[string(this.W)],[string(this.L)],[string(this.Beta)],[string(this.Vt)],[string(this.K2)],[string(this.K5)],[string(this.dW)],[string(this.dL)],[string(this.RDS)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"PMOS\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        this.x.graphics.in_implicit = ["I"];
        this.x.graphics.out_implicit = [["I"],["I"],["I"]];
        return new BasicBlock(this.x);
    }
    PMOS.prototype.details = function PMOS() {
        return this.x;
    }
    PMOS.prototype.get = function PMOS() {
        var options = {
            W:["Width [m]",this.W],
            L:["Length [m]",this.L],
            Beta:["Transconductance parameter [A/(V*V)]",this.Beta],
            Vt:["Zero bias threshold voltage [V]",this.Vt],
            K2:["Bulk threshold parameter",this.K2],
            K5:["Reduction of pinch-off region",this.K5],
            dW:["Narrowing of channel [m]",this.dW],
            dL:["Shortening of channel [m]",this.dL],
            RDS:["Drain-Source-Resistance [Ohm]",this.RDS],
        }
        return options;
    }
    PMOS.prototype.set = function PMOS() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.W = parseFloat(arguments[0]["W"]);
            this.L = parseFloat(arguments[0]["L"]);
            this.Beta = parseFloat(arguments[0]["Beta"]);
            this.Vt = parseFloat(arguments[0]["Vt"]);
            this.K2 = parseFloat(arguments[0]["K2"]);
            this.K5 = parseFloat(arguments[0]["K5"]);
            this.dW = parseFloat(arguments[0]["dW"]);
            this.dL = parseFloat(arguments[0]["dL"]);
            this.RDS = parseFloat(arguments[0]["RDS"]);
            if (!ok) {
                break;
            }
            this.model.equations.parameters[2-1] = list(new ScilabDouble([this.W]), new ScilabDouble([this.L]), new ScilabDouble([this.Beta]), new ScilabDouble([this.Vt]), new ScilabDouble([this.K2]), new ScilabDouble([this.K5]), new ScilabDouble([this.dW]), new ScilabDouble([this.dL]), new ScilabDouble([this.RDS]));
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/PNP.sci" */
function PNP() {
    PNP.prototype.define = function PNP() {
        var ModelName = "PNP";
        var PrametersValue = [[50],[0.1],[0],[0.02],[1.200e-10],[5.000e-09],[1.000e-12],[4.000e-13],[5.000e-13],[0.8],[0.4],[0.8],[0.333],[1.000e-15],[1.000e-15],[0.02585],[40]];
        var ParametersName = [["Bf"],["Br"],["Is"],["Vak"],["Tauf"],["Taur"],["Ccs"],["Cje"],["Cjc"],["Phie"],["Me"],["Phic"],["Mc"],["Gbc"],["Gbe"],["Vt"],["EMinMax"]];
        this.model = scicos_model();
        var Typein = [];
        var Typeout = [];
        var MI = [];
        var MO = [];
        var P = [[100,90,-2,0],[0,50,2,0],[100,10,-2,0]];
        var PortName = [["C"],["B"],["E"]];
        for (i=1;i<=size(P,"r");i+=1) {
            if (P[i-1][3-1]==1) {
                var Typein = [[Typein],["E"]];
                var MI = [[MI],[PortName[i-1]]];
            }
            if (P[i-1][3-1]==2) {
                var Typein = [[Typein],["I"]];
                var MI = [[MI],[PortName[i-1]]];
            }
            if (P[i-1][3-1]==-1) {
                var Typeout = [[Typeout],["E"]];
                var MO = [[MO],[PortName[i-1]]];
            }
            if (P[i-1][3-1]==-2) {
                var Typeout = [[Typeout],["I"]];
                var MO = [[MO],[PortName[i-1]]];
            }
        }
        this.model = scicos_model();
        var mo = modelica();
        this.model.sim = new ScilabString([ModelName]);
        mo.inputs = MI;
        mo.outputs = MO;
        this.model.rpar = new ScilabDouble(PrametersValue);
        mo.parameters = list(ParametersName,PrametersValue,zeros(ParametersName));
        this.exprs = [["50"],["0.1"],["1.e-16"],["0.02"],["0.12e-9"],["5e-9"],["1e-12"],["0.4e-12"],["0.5e-12"],["0.8"],["0.4"],["0.8"],["0.333"],["1e-15"],["1e-15"],["0.02585"],["40"]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"PNP\",sz(1),sz(2));"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        mo.model = ModelName;
        this.model.equations = new ScilabDouble([mo]);
        this.model.in = new ScilabDouble([ones(size(MI,"*"),1)]);
        this.model.out = new ScilabDouble([ones(size(MO,"*"),1)]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),list(this.gr_i,0));
        this.x.graphics.in_implicit = Typein;
        this.x.graphics.out_implicit = Typeout;
        return new BasicBlock(this.x);
    }
    PNP.prototype.details = function PNP() {
        return this.x;
    }
    PNP.prototype.get = function PNP() {
        var options = {
            Bf:["Bf  : Forward beta",this.Bf],
            Br:["Br  : Reverse beta",this.Br],
            Is:["Is  : Transport saturation current",this.Is],
            Vak:["Vak : Early voltage (inverse), 1/Volt",this.Vak],
            Tauf:["Tauf: Ideal forward transit time",this.Tauf],
            Taur:["Taur: Ideal reverse transit time",this.Taur],
            Ccs:["Ccs : Collector-substrat(ground) cap.",this.Ccs],
            Cje:["Cje : Base-emitter zero bias depletion cap.",this.Cje],
            Cjc:["Cjc : Base-coll. zero bias depletion cap.",this.Cjc],
            Phie:["Phie: Base-emitter diffusion voltage",this.Phie],
            Me:["Me  : Base-emitter gradation exponent",this.Me],
            Phic:["Phic: Base-collector diffusion voltage",this.Phic],
            Mc:["Mc  : Base-collector gradation exponent",this.Mc],
            Gbc:["Gbc : Base-collector conductance",this.Gbc],
            Gbe:["Gbe : Base-emitter conductance",this.Gbe],
            Vt:["Vt  : Voltage equivalent of temperature",this.Vt],
            EMinMax:["EMinMax: if x > EMinMax, the exp(x) function is linearized",this.EMinMax],
        }
        return options;
    }
    PNP.prototype.set = function PNP() {
        this.exprs = this.graphics.exprs;
        this.exprs = this.x.graphics.exprs;
        while (true) {
            var ok = true;
            this.Bf = arguments[0]["Bf"];
            this.Br = arguments[0]["Br"];
            this.Is = arguments[0]["Is"];
            this.Vak = arguments[0]["Vak"];
            this.Tauf = arguments[0]["Tauf"];
            this.Taur = arguments[0]["Taur"];
            this.Ccs = arguments[0]["Ccs"];
            this.Cje = arguments[0]["Cje"];
            this.Cjc = arguments[0]["Cjc"];
            this.Phie = arguments[0]["Phie"];
            this.Me = arguments[0]["Me"];
            this.Phic = arguments[0]["Phic"];
            this.Mc = arguments[0]["Mc"];
            this.Gbc = arguments[0]["Gbc"];
            this.Gbe = arguments[0]["Gbe"];
            this.Vt = arguments[0]["Vt"];
            this.EMinMax = arguments[0]["EMinMax"];
            if (!ok) {
                break;
            }
            this.x.model.equations.parameters[2-1] = list(this.Bf,this.Br,this.Is,this.Vak,this.Tauf,this.Taur,this.Ccs,this.Cje,this.Cjc,this.Phie,this.Me,this.Phic,this.Mc,this.Gbc,this.Gbe,this.Vt,this.EMinMax);
            this.x.graphics.exprs = this.exprs;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/PotentialSensor.sci" */
function PotentialSensor() {
    PotentialSensor.prototype.define = function PotentialSensor() {
        this.model = scicos_model();
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([]);
        this.model.sim = new ScilabString(["PotentialSensor"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var mo = modelica();
        mo.model = "PotentialSensor";
        mo.inputs = "p";
        mo.outputs = ["v"];
        this.model.equations = new ScilabDouble([mo]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"PotentialSensor\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([""]),list(this.gr_i,0));
        this.x.graphics.in_implicit = ["I"];
        this.x.graphics.out_implicit = ["E"];
        return new BasicBlock(this.x);
    }
    PotentialSensor.prototype.details = function PotentialSensor() {
        return this.x;
    }
    PotentialSensor.prototype.get = function PotentialSensor() {
        alert("parameters cannot be modified");
    }
    PotentialSensor.prototype.set = function PotentialSensor() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/Resistor.sci" */
function Resistor() {
    Resistor.prototype.define = function Resistor() {
        this.model = scicos_model();
        this.R = 0.01;
        this.model.rpar = new ScilabDouble([this.R]);
        this.model.sim = new ScilabString(["resistor"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var mo = modelica();
        mo.model = "Resistor";
        mo.inputs = "p";
        mo.outputs = "n";
        mo.parameters = list("R",list(this.R));
        this.model.equations = new ScilabDouble([mo]);
        this.model.in = new ScilabDouble([ones(size(mo.inputs,"*"),1)]);
        this.model.out = new ScilabDouble([ones(size(mo.outputs,"*"),1)]);
        this.exprs = string(this.R);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"Resistor\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,1]),this.model,new ScilabString([this.exprs]),list(this.gr_i,0));
        this.x.graphics.in_implicit = ["I"];
        this.x.graphics.out_implicit = ["I"];
        return new BasicBlock(this.x);
    }
    Resistor.prototype.details = function Resistor() {
        return this.x;
    }
    Resistor.prototype.get = function Resistor() {
        var options = {
            R:["R (ohm)",this.R],
        }
        return options;
    }
    Resistor.prototype.set = function Resistor() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.R = parseFloat(arguments[0]["R"]);
            if (!ok) {
                break;
            }
            this.model.rpar = new ScilabDouble([this.R]);
            this.model.equations.parameters[2-1] = list(new ScilabDouble([this.R]));
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/SineVoltage.sci" */
function SineVoltage() {
    SineVoltage.prototype.define = function SineVoltage() {
        this.model = scicos_model();
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.V = 1;
        this.ph = 0;
        this.frq = 1;
        this.offset = 0;
        this.start = 0;
        this.model.rpar = new ScilabDouble([this.V],[this.ph],[this.frq],[this.offset],[this.start]);
        this.model.sim = new ScilabString(["SineVoltage"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var mo = modelica();
        mo.model = "SineVoltage";
        mo.inputs = "p";
        mo.outputs = "n";
        mo.parameters = list([["V"],["phase"],["freqHz"],["offset"],["startTime"]],list(this.V,this.ph,this.frq,this.offset,this.start));
        this.model.equations = new ScilabDouble([mo]);
        this.exprs = [[string(this.V)],[string(this.ph)],[string(this.frq)],[string(this.offset)],[string(this.start)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SineVoltage\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        this.x.graphics.in_implicit = ["I"];
        this.x.graphics.out_implicit = ["I"];
        return new BasicBlock(this.x);
    }
    SineVoltage.prototype.details = function SineVoltage() {
        return this.x;
    }
    SineVoltage.prototype.get = function SineVoltage() {
        var options = {
            V:["Amplitude (Volt)",this.V],
            ph:["phase (rad)",this.ph],
            frq:["Frequency (Hz)",this.frq],
            offset:["Voltageoffset (V)",this.offset],
            start:["Timeoffset (s)",this.start],
        }
        return options;
    }
    SineVoltage.prototype.set = function SineVoltage() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.V = parseFloat(arguments[0]["V"]);
            this.ph = parseFloat(arguments[0]["ph"]);
            this.frq = parseFloat(arguments[0]["frq"]);
            this.offset = parseFloat(arguments[0]["offset"]);
            this.start = parseFloat(arguments[0]["start"]);
            if (!ok) {
                break;
            }
            this.model.rpar = new ScilabDouble([this.V],[this.ph],[this.frq],[this.offset],[this.start]);
            this.model.equations.parameters[2-1] = list(new ScilabDouble([this.V]), new ScilabDouble([this.ph]), new ScilabDouble([this.frq]), new ScilabDouble([this.offset]), new ScilabDouble([this.start]));
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/Switch.sci" */
function Switch() {
    Switch.prototype.define = function Switch() {
        this.model = scicos_model();
        this.Ron = 0.01;
        this.Roff = 1e5;
        var S = [["Ron"],["Roff"]];
        var Z = eval(S);
        this.model.sim = new ScilabString(["Switch"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var mo = modelica();
        mo.model = this.model.sim;
        mo.inputs = [["p"],["inp"]];
        mo.outputs = "n";
        mo.parameters = list(S,Z);
        this.model.equations = new ScilabDouble([mo]);
        this.model.in = new ScilabDouble([ones(size(mo.inputs,"*"),1)]);
        this.model.out = new ScilabDouble([ones(size(mo.outputs,"*"),1)]);
        this.model.rpar = new ScilabDouble([Z]);
        this.exprs = string(Z);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"Switch\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),list(this.gr_i,0));
        this.x.graphics.in_implicit = [["I"],["E"]];
        this.x.graphics.out_implicit = ["I"];
        return new BasicBlock(this.x);
    }
    Switch.prototype.details = function Switch() {
        return this.x;
    }
    Switch.prototype.get = function Switch() {
        var options = {
            Ron:["Resistance in On state (Ohm)",this.Ron],
            Roff:["Resistance in Off state (Ohm)",this.Roff],
        }
        return options;
    }
    Switch.prototype.set = function Switch() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.Ron = parseFloat(arguments[0]["Ron"]);
            this.Roff = parseFloat(arguments[0]["Roff"]);
            if (!ok) {
                break;
            }
            this.model.equations.parameters[2-1] = list(new ScilabDouble([this.Ron]), new ScilabDouble([this.Roff]));
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/VVsourceAC.sci" */
function VVsourceAC() {
    VVsourceAC.prototype.define = function VVsourceAC() {
        this.model = scicos_model();
        this.model.in = new ScilabDouble([1],[1]);
        this.model.out = new ScilabDouble([1]);
        var VA = 220;
        this.FR = 50;
        this.model.rpar = new ScilabDouble([this.FR]);
        this.model.sim = new ScilabString(["VVsourceAC"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var mo = modelica();
        mo.model = "VVsourceAC";
        mo.inputs = ["p","VA"];
        mo.outputs = "n";
        mo.parameters = list(["f"],list(this.FR));
        this.model.equations = new ScilabDouble([mo]);
        this.exprs = [string(this.FR)];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"VVsourceAC\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString(this.exprs),list(this.gr_i,0));
        this.x.graphics.in_implicit = ["I","E"];
        this.x.graphics.out_implicit = ["I"];
        return new BasicBlock(this.x);
    }
    VVsourceAC.prototype.details = function VVsourceAC() {
        return this.x;
    }
    VVsourceAC.prototype.get = function VVsourceAC() {
        var options = {
            FR:["Frequency (Hz)",this.FR],
        }
        return options;
    }
    VVsourceAC.prototype.set = function VVsourceAC() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.FR = parseFloat(arguments[0]["FR"]);
            if (!ok) {
                break;
            }
            this.model.rpar = new ScilabDouble([this.FR]);
            this.model.equations.parameters[2-1] = list(new ScilabDouble([this.FR]));
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/VariableResistor.sci" */
function VariableResistor() {
    VariableResistor.prototype.define = function VariableResistor() {
        this.model = scicos_model();
        this.model.sim = new ScilabString(["VariableResistor"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var mo = modelica();
        mo.model = "VariableResistor";
        mo.inputs = ["p","R"];
        mo.outputs = "n";
        this.model.equations = new ScilabDouble([mo]);
        this.model.in = new ScilabDouble([ones(size(mo.inputs,"*"),1)]);
        this.model.out = new ScilabDouble([ones(size(mo.outputs,"*"),1)]);
        this.exprs = [];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"VariableResistor\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),list(this.gr_i,0));
        this.x.graphics.in_implicit = ["I","E"];
        this.x.graphics.out_implicit = ["I"];
        return new BasicBlock(this.x);
    }
    VariableResistor.prototype.details = function VariableResistor() {
        return this.x;
    }
    VariableResistor.prototype.get = function VariableResistor() {
        alert("parameters cannot be modified");
    }
    VariableResistor.prototype.set = function VariableResistor() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/VoltageSensor.sci" */
function VoltageSensor() {
    VoltageSensor.prototype.define = function VoltageSensor() {
        this.model = scicos_model();
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1],[1]);
        this.model.sim = new ScilabString(["VoltageSensor"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var mo = modelica();
        mo.model = "VoltageSensor";
        mo.inputs = "p";
        mo.outputs = [["n"],["v"]];
        this.model.equations = new ScilabDouble([mo]);
        this.exprs = [];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"VoltageSensor\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),list(this.gr_i,0));
        this.x.graphics.in_implicit = ["I"];
        this.x.graphics.out_implicit = [["I"],["E"]];
        return new VoltageSensorBlock(this.x);
    }
    VoltageSensor.prototype.details = function VoltageSensor() {
        return this.x;
    }
    VoltageSensor.prototype.get = function VoltageSensor() {
        alert("parameters cannot be modified");
    }
    VoltageSensor.prototype.set = function VoltageSensor() {
        return new VoltageSensorBlock(this.x);
    }
}
/* autogenerated from "macros/Electrical/VsourceAC.sci" */
function VsourceAC() {
    VsourceAC.prototype.define = function VsourceAC() {
        this.model = scicos_model();
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.VA = 220;
        this.FR = 50;
        this.model.rpar = new ScilabDouble([this.VA],[this.FR]);
        this.model.sim = new ScilabString(["VsourceAC"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var mo = modelica();
        mo.model = "VsourceAC";
        mo.inputs = "p";
        mo.outputs = "n";
        mo.parameters = list([["VA"],["f"]],list(this.VA,this.FR));
        this.model.equations = new ScilabDouble([mo]);
        this.exprs = [[string(this.VA)],[string(this.FR)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"VsourceAC\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),list(this.gr_i,0));
        this.x.graphics.in_implicit = ["I"];
        this.x.graphics.out_implicit = ["I"];
        return new BasicBlock(this.x);
    }
    VsourceAC.prototype.details = function VsourceAC() {
        return this.x;
    }
    VsourceAC.prototype.get = function VsourceAC() {
        var options = {
            VA:["Amplitude (Volt)",this.VA],
            FR:["Frequency (Hz)",this.FR],
        }
        return options;
    }
    VsourceAC.prototype.set = function VsourceAC() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.VA = parseFloat(arguments[0]["VA"]);
            this.FR = parseFloat(arguments[0]["FR"]);
            if (!ok) {
                break;
            }
            this.model.rpar = new ScilabDouble([this.VA],[this.FR]);
            this.model.equations.parameters[2-1] = list(new ScilabDouble([this.VA]), new ScilabDouble([this.FR]));
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Events/ANDBLK.sci" */
function ANDBLK() {
    ANDBLK.prototype.define = function ANDBLK() {
        var andlog = ANDLOG_f("define");
        andlog.graphics.orig = [194,133];
        andlog.graphics.sz = [60,60];
        andlog.graphics.flip = true;
        andlog.graphics.pout = 9;
        andlog.graphics.pein = [[4],[11]];
        var input_port1 = CLKIN_f("define");
        input_port1.graphics.orig = [149,287];
        input_port1.graphics.sz = [20,20];
        input_port1.graphics.flip = true;
        input_port1.graphics.exprs = "1";
        input_port1.graphics.peout = 4;
        input_port1.model.ipar = 1;
        var output_port = CLKOUT_f("define");
        output_port.graphics.orig = [450,83];
        output_port.graphics.sz = [20,20];
        output_port.graphics.flip = true;
        output_port.graphics.exprs = "1";
        output_port.graphics.pein = 8;
        output_port.model.ipar = 1;
        var input_port2 = CLKIN_f("define");
        input_port2.graphics.orig = [141,330];
        input_port2.graphics.sz = [20,20];
        input_port2.graphics.flip = true;
        input_port2.graphics.exprs = "2";
        input_port2.graphics.peout = 6;
        input_port2.model.ipar = 2;
        var ifthel = IFTHEL_f("define");
        ifthel.graphics.orig = [331,137];
        ifthel.graphics.sz = [60,60];
        ifthel.graphics.flip = true;
        ifthel.graphics.pin = 9;
        ifthel.graphics.pein = 12;
        ifthel.graphics.peout = [[8],[0]];
        var split = CLKSPLIT_f("define");
        split.graphics.orig = [[234],[275.78348]];
        split.graphics.pein = 6;
        split.graphics.peout = [[11],[12]];
        var diagram = scicos_diagram();
        diagram.objs[1-1] = andlog;
        diagram.objs[2-1] = input_port1;
        diagram.objs[3-1] = output_port;
        diagram.objs[4-1] = scicos_link(xx=[[169],[214],[214]],yy=[[297],[297],[198.71]],ct=[5,-1],from=[2,1],to=[1,1]);
        diagram.objs[5-1] = input_port2;
        diagram.objs[6-1] = scicos_link(xx=[[161],[234],[234]],yy=[[340],[340],[275.78]],ct=[5,-1],from=[5,1],to=[10,1]);
        diagram.objs[7-1] = ifthel;
        diagram.objs[8-1] = scicos_link(xx=[[351],[351],[450]],yy=[[131.29],[93],[93]],ct=[5,-1],from=[7,1],to=[3,1]);
        diagram.objs[9-1] = scicos_link(xx=[[262.57],[322.43]],yy=[[163],[167]],ct=[1,1],from=[1,1],to=[7,1]);
        diagram.objs[10-1] = split;
        diagram.objs[11-1] = scicos_link(xx=[[234],[234]],yy=[[275.78],[198.71]],ct=[5,-1],from=[10,1],to=[1,2]);
        diagram.objs[12-1] = scicos_link(xx=[[234],[361],[361]],yy=[[275.78],[275.78],[202.71]],ct=[5,-1],from=[10,2],to=[7,1]);
        this.x = scicos_block();
        this.x.gui = "ANDBLK";
        this.x.graphics.sz = [2,2];
        this.x.graphics.gr_i = [];
        this.x.graphics.pein = [[0],[0]];
        this.x.graphics.peout = 0;
        this.x.model.sim = "csuper";
        this.x.model.evtin = [[1],[1]];
        this.x.model.evtout = 1;
        this.x.model.blocktype = "h";
        this.x.model.firing = false;
        this.x.model.dep_ut = [false,false];
        this.x.model.rpar = diagram;
        return new BasicBlock(this.x);
    }
    ANDBLK.prototype.details = function ANDBLK() {
        return this.x;
    }
    ANDBLK.prototype.get = function ANDBLK() {
        alert("parameters cannot be modified");
    }
    ANDBLK.prototype.set = function ANDBLK() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Events/ANDLOG_f.sci" */
function ANDLOG_f() {
    ANDLOG_f.prototype.define = function ANDLOG_f() {
        this.model = scicos_model();
        this.model.sim = new ScilabString(["andlog"]);
        this.model.out = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([1],[1]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"ANDLOG_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,3]),this.model,new ScilabDouble([]),this.gr_i);
        return new BasicBlock(this.x);
    }
    ANDLOG_f.prototype.details = function ANDLOG_f() {
        return this.x;
    }
    ANDLOG_f.prototype.get = function ANDLOG_f() {
        alert("parameters cannot be modified");
    }
    ANDLOG_f.prototype.set = function ANDLOG_f() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Events/CLKSOMV_f.sci" */
function CLKSOMV_f() {
    CLKSOMV_f.prototype.define = function CLKSOMV_f() {
        this.model = scicos_model();
        this.model.sim = new ScilabString(["sum"]);
        this.model.evtin = new ScilabDouble([1],[1],[1]);
        this.model.evtout = new ScilabDouble([1]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([-1]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CLKSOMV_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble([]),this.gr_i);
        return new BasicBlock(this.x);
    }
    CLKSOMV_f.prototype.details = function CLKSOMV_f() {
        return this.x;
    }
    CLKSOMV_f.prototype.get = function CLKSOMV_f() {
        alert("parameters cannot be modified");
    }
    CLKSOMV_f.prototype.set = function CLKSOMV_f() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Events/CLKSOM_f.sci" */
function CLKSOM_f() {
    CLKSOM_f.prototype.define = function CLKSOM_f() {
        this.model = scicos_model();
        this.model.sim = new ScilabString(["sum"]);
        this.model.evtin = new ScilabDouble([1],[1],[1]);
        this.model.evtout = new ScilabDouble([1]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([-1]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CLKSOM_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([1,1]),this.model,new ScilabDouble([]),this.gr_i);
        return new BasicBlock(this.x);
    }
    CLKSOM_f.prototype.details = function CLKSOM_f() {
        return this.x;
    }
    CLKSOM_f.prototype.get = function CLKSOM_f() {
        alert("parameters cannot be modified");
    }
    CLKSOM_f.prototype.set = function CLKSOM_f() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Events/CLKSPLIT_f.sci" */
function CLKSPLIT_f() {
    CLKSPLIT_f.prototype.define = function CLKSPLIT_f() {
        this.model = scicos_model();
        this.model.sim = new ScilabString(["split"]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.evtout = new ScilabDouble([1],[1]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabBoolean([false,false,false]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.x = new standard_define(new ScilabDouble([1,1]),this.model,new ScilabDouble([]),[]);
        return new BasicBlock(this.x);
    }
    CLKSPLIT_f.prototype.details = function CLKSPLIT_f() {
        return this.x;
    }
    CLKSPLIT_f.prototype.get = function CLKSPLIT_f() {
        alert("parameters cannot be modified");
    }
    CLKSPLIT_f.prototype.set = function CLKSPLIT_f() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Events/END_c.sci" */
function END_c() {
    END_c.prototype.define = function END_c() {
        this.tf = 100000000;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["scicosexit"]), new ScilabDouble([4]));
        this.model.evtin = new ScilabDouble([1]);
        this.model.evtout = new ScilabDouble([1]);
        this.model.firing = new ScilabDouble([this.tf]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = string(this.tf);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"END_c\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    END_c.prototype.details = function END_c() {
        return this.x;
    }
    END_c.prototype.get = function END_c() {
        var options = {
            tf:["Final simulation time",this.tf],
        }
        return options;
    }
    END_c.prototype.set = function END_c() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.tf = parseFloat(arguments[0]["tf"]);
            if (!ok) {
                break;
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.firing = new ScilabDouble([this.tf]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Events/EVTDLY_c.sci" */
function EVTDLY_c() {
    EVTDLY_c.prototype.define = function EVTDLY_c() {
        this.dt = 0.1;
        this.ff = 0.0;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["evtdly4"]), new ScilabDouble([4]));
        this.model.evtin = new ScilabDouble([1]);
        this.model.evtout = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([this.dt],[this.ff]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([this.ff]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [[string(this.dt)],[sci2exp(this.ff)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"EVTDLY_c\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    EVTDLY_c.prototype.details = function EVTDLY_c() {
        return this.x;
    }
    EVTDLY_c.prototype.get = function EVTDLY_c() {
        var options = {
            dt:["Delay",this.dt],
            ff:["Date of initial output event",this.ff],
        }
        return options;
    }
    EVTDLY_c.prototype.set = function EVTDLY_c() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.dt = parseFloat(arguments[0]["dt"]);
            this.ff = parseFloat(arguments[0]["ff"]);
            if (!ok) {
                break;
            }
            if (this.dt<=0) {
                message("Delay must be positive");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.rpar = new ScilabDouble([this.dt],[this.ff]);
                this.model.firing = new ScilabDouble([this.ff]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Events/EVTDLY_f.sci" */
function EVTDLY_f() {
    EVTDLY_f.prototype.define = function EVTDLY_f() {
        this.dt = 0.1;
        this.ff = this.dt;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["evtdly"]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.evtout = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([this.dt]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([this.ff]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [[string(this.dt)],[sci2exp(this.ff)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"EVTDLY_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    EVTDLY_f.prototype.details = function EVTDLY_f() {
        return this.x;
    }
    EVTDLY_f.prototype.get = function EVTDLY_f() {
        var options = {
            dt:["Delay",this.dt],
            ff:["Date of initial output event",this.ff],
        }
        return options;
    }
    EVTDLY_f.prototype.set = function EVTDLY_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.dt = parseFloat(arguments[0]["dt"]);
            this.ff = parseFloat(arguments[0]["ff"]);
            if (!ok) {
                break;
            }
            if (this.dt<=0) {
                message("Delay must be positive");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.rpar = new ScilabDouble([this.dt]);
                this.model.firing = new ScilabDouble([this.ff]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Events/EVTGEN_f.sci" */
function EVTGEN_f() {
    EVTGEN_f.prototype.define = function EVTGEN_f() {
        this.tt = 0;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["trash"]);
        this.model.evtout = new ScilabDouble([1]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([this.tt]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = string(this.tt);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"EVTGEN_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    EVTGEN_f.prototype.details = function EVTGEN_f() {
        return this.x;
    }
    EVTGEN_f.prototype.get = function EVTGEN_f() {
        var options = {
            tt:["Event Time",this.tt],
        }
        return options;
    }
    EVTGEN_f.prototype.set = function EVTGEN_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.tt = parseFloat(arguments[0]["tt"]);
            if (!ok) {
                break;
            }
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            if (this.model.firing!=this.tt) {
                this.model.firing = new ScilabDouble([this.tt]);
            }
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Events/EVTVARDLY.sci" */
function EVTVARDLY() {
    EVTVARDLY.prototype.define = function EVTVARDLY() {
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["evtvardly"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.evtout = new ScilabDouble([1]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([-1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = string(this.model.firing);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"EVTVARDLY\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    EVTVARDLY.prototype.details = function EVTVARDLY() {
        return this.x;
    }
    EVTVARDLY.prototype.get = function EVTVARDLY() {
        var options = {
            fir:["Initial event firing time (<0 if absent)",this.fir],
        }
        return options;
    }
    EVTVARDLY.prototype.set = function EVTVARDLY() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.fir = arguments[0]["fir"];
            if (!ok) {
                break;
            }
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.model.firing = new ScilabDouble([this.fir]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Events/HALT_f.sci" */
function HALT_f() {
    HALT_f.prototype.define = function HALT_f() {
        this.n = 0;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["hltblk"]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble([0]);
        this.model.ipar = new ScilabDouble([0]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = string(this.n);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"HALT_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    HALT_f.prototype.details = function HALT_f() {
        return this.x;
    }
    HALT_f.prototype.get = function HALT_f() {
        var options = {
            n:["State on halt",this.n],
        }
        return options;
    }
    HALT_f.prototype.set = function HALT_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.n = parseFloat(arguments[0]["n"]);
            if (!ok) {
                break;
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.ipar = new ScilabDouble([this.n]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Events/IFTHEL_f.sci" */
function IFTHEL_f() {
    IFTHEL_f.prototype.define = function IFTHEL_f() {
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["ifthel"]), new ScilabDouble([-1]));
        this.model.in = new ScilabDouble([1]);
        this.model.in2 = new ScilabDouble([1]);
        this.model.intyp = new ScilabDouble([-1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.evtout = new ScilabDouble([1],[1]);
        this.model.blocktype = new ScilabString(["l"]);
        this.model.firing = new ScilabDouble([-1,-1]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.model.nmode = new ScilabDouble([1]);
        this.model.nzcross = new ScilabDouble([1]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"IFTHEL_f\",sz(1),sz(2));"]);
        this.exprs = [[string(this.model.in)],[string(this.model.nmode)]];
        this.x = new standard_define(new ScilabDouble([3,3]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    IFTHEL_f.prototype.details = function IFTHEL_f() {
        return this.x;
    }
    IFTHEL_f.prototype.get = function IFTHEL_f() {
        var options = {
            inh:["Inherit (1: no, 0: yes)",this.inh],
            nmod:["zero-crossing (0: no, 1: yes)",this.nmod],
        }
        return options;
    }
    IFTHEL_f.prototype.set = function IFTHEL_f() {
        this.exprs = this.graphics.exprs;
        if (this.exprs.length==0) {
            this.exprs = string(1);
        }
        if (size(this.exprs,"*")==1) {
            this.exprs[2-1] = string(1);
        }
        while (true) {
            var ok = true;
            this.inh = inverse(arguments[0]["inh"]);
            this.nmod = parseFloat(arguments[0]["nmod"]);
            if (!ok) {
                break;
            }
            this.model.dep_ut = new ScilabBoolean([true,false]);
            if (this.nmod!=0) {
                this.nmod = 1;
            }
            if (this.inh!=1) {
                this.inh = [];
            }
            var tmpvar0 = check_io(this.model,this.graphics,1,[],this.inh,[[1],[1]]);
            this.model = tmpvar0[0];
            this.graphics = tmpvar0[1];
            var ok = tmpvar0[2];
            if (ok) {
                this.graphics.exprs = new ScilabString([this.exprs]);
                this.model.evtin = new ScilabDouble(this.inh);
                this.model.sim[2-1] = new ScilabDouble([-1]);
                this.model.nmode = new ScilabDouble([this.nmod]);
                this.model.nzcross = new ScilabDouble([this.nmod]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Events/MCLOCK_f.sci" */
function MCLOCK_f() {
    MCLOCK_f.prototype.define = function MCLOCK_f() {
        var nn = 2;
        var dt = 0.1;
        this.exprs = [[string(dt)],[string(nn)]];
        var mfclck = MFCLCK_f("define");
        mfclck.graphics.orig = [334,199];
        mfclck.graphics.sz = [40,40];
        mfclck.graphics.flip = true;
        mfclck.graphics.exprs = this.exprs;
        mfclck.graphics.pein = 12;
        mfclck.graphics.peout = [[4],[3]];
        mfclck.model.rpar = 0.1;
        mfclck.model.ipar = nn;
        mfclck.model.firing = [-1,0];
        var clksom = CLKSOM_f("define");
        clksom.graphics.orig = [457,161];
        clksom.graphics.sz = [16.666667,16.666667];
        clksom.graphics.flip = true;
        clksom.graphics.exprs = [["0.1"],["0.1"]];
        clksom.graphics.pein = [[4],[9],[0]];
        clksom.graphics.peout = 5;
        var output_port1 = CLKOUT_f("define");
        output_port1.graphics.orig = [509,261];
        output_port1.graphics.sz = [20,20];
        output_port1.graphics.flip = true;
        output_port1.graphics.exprs = "1";
        output_port1.graphics.pein = 10;
        output_port1.model.ipar = 1;
        var output_port2 = CLKOUT_f("define");
        output_port2.graphics.orig = [509,142];
        output_port2.graphics.sz = [20,20];
        output_port2.graphics.flip = true;
        output_port2.graphics.exprs = "2";
        output_port2.graphics.pein = 13;
        output_port2.model.ipar = 2;
        var split1 = CLKSPLIT_f("define");
        split1.graphics.orig = [[411.92504],[169.33333]];
        split1.graphics.pein = 3;
        split1.graphics.peout = [[9],[10]];
        var split2 = CLKSPLIT_f("define");
        split2.graphics.orig = [[482.45315],[169.33333]];
        split2.graphics.pein = 5;
        split2.graphics.peout = [[12],[13]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MCLOCK_f\",sz(1),sz(2));"]);
        var diagram = scicos_diagram();
        diagram.objs[1-1] = mfclck;
        diagram.objs[2-1] = clksom;
        diagram.objs[3-1] = scicos_link(xx=[[360.7],[360.7],[411.9]],yy=[[193.3],[169.3],[169.3]],ct=[10,-1],from=[1,2],to=[8,1]);
        diagram.objs[4-1] = scicos_link(xx=[[347.3],[347.3],[461.8],[461.8]],yy=[[193.3],[155.5],[155.5],[161]],ct=[10,-1],from=[1,1],to=[2,1]);
        diagram.objs[5-1] = scicos_link(xx=[[468.9],[482.5]],yy=[[169.3],[169.3]],ct=[10,-1],from=[2,1],to=[11,1]);
        diagram.objs[6-1] = output_port1;
        diagram.objs[7-1] = output_port2;
        diagram.objs[8-1] = split1;
        diagram.objs[9-1] = scicos_link(xx=[[411.9],[457]],yy=[[169.3],[169.3]],ct=[10,-1],from=[8,1],to=[2,2]);
        diagram.objs[10-1] = scicos_link(xx=[[411.9],[411.9],[509]],yy=[[169.3],[271],[271]],ct=[10,-1],from=[8,2],to=[6,1]);
        diagram.objs[11-1] = split2;
        diagram.objs[12-1] = scicos_link(xx=[[482.5],[489.6],[489.6],[354],[354]],yy=[[169.3],[169.3],[338.3],[338.3],[244.7]],ct=[10,-1],from=[11,1],to=[1,1]);
        diagram.objs[13-1] = scicos_link(xx=[[482.4],[482.4],[509]],yy=[[169.3],[152],[152]],ct=[10,-1],from=[11,2],to=[7,1]);
        this.x = scicos_block();
        this.x.gui = "MCLOCK_f";
        this.x.graphics.sz = [3,2];
        this.x.graphics.gr_i = this.gr_i;
        this.x.model.sim = "csuper";
        this.x.model.evtout = [[1],[1]];
        this.x.model.blocktype = "h";
        this.x.model.rpar = diagram;
        this.x.graphics.peout = [[0],[0]];
        return new BasicBlock(this.x);
    }
    MCLOCK_f.prototype.details = function MCLOCK_f() {
        return this.x;
    }
    MCLOCK_f.prototype.get = function MCLOCK_f() {
        alert("parameters cannot be modified");
    }
    MCLOCK_f.prototype.set = function MCLOCK_f() {
            if (typeof(o)=="Block"&&o.gui=="MFCLCK_f") {
                var path = i;
                break;
            }
        }
        var newpar = list();
        var spath = list("model","rpar","objs",path);
        execstr("xxn="+xx.gui+"(\'set\',xx)");
        if (or(this.xxn!=xx)) {
            newpar[size(newpar)+1-1] = path;
        }
        var y = 0;
        var typ = newpar;
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Events/MFCLCK_f.sci" */
function MFCLCK_f() {
    MFCLCK_f.prototype.define = function MFCLCK_f() {
        this.nn = 2;
        this.dt = 0.1;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["mfclck"]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.evtout = new ScilabDouble([1],[1]);
        this.model.dstate = new ScilabDouble([0]);
        this.model.rpar = new ScilabDouble([this.dt]);
        this.model.ipar = new ScilabDouble([this.nn]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([-1,0]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [[string(this.dt)],[string(this.nn)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MFCLCK_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    MFCLCK_f.prototype.details = function MFCLCK_f() {
        return this.x;
    }
    MFCLCK_f.prototype.get = function MFCLCK_f() {
        var options = {
        dt:["basic period (1/f)",this.dt],
        nn:["multiply by (n)",this.nn],
        }
        return options;
    }
    MFCLCK_f.prototype.set = function MFCLCK_f() {
        this.exprs = this.graphics.exprs;
        var ok = true;
        this.dt = parseFloat(arguments[0]["dt"]);
        this.nn = parseFloat(arguments[0]["nn"]);
        if (ok) {
            this.model.ipar = new ScilabDouble([this.nn]);
            this.model.rpar = new ScilabDouble([this.dt]);
            var hh = this.model.firing;
            hh[2-1] = 0;
            this.model.firing = new ScilabDouble(hh);
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Events/M_freq.sci" */
function M_freq() {
    M_freq.prototype.define = function M_freq() {
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["m_frequ"]), new ScilabDouble([4]));
        this.model.evtout = new ScilabDouble([1],[1],[1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([]);
        this.model.opar = list([[1,1,0],[1,1,1],[1,3,2]], new ScilabDouble([1]), new ScilabDouble([0]), new ScilabDouble([0]));
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([0,-1,-1]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [[sci2exp([[1],[2]])],[sci2exp([[0],[0]])]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"M_freq\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    M_freq.prototype.details = function M_freq() {
        return this.x;
    }
    M_freq.prototype.get = function M_freq() {
        var options = {
            frequ:["Sample time",this.frequ],
            offset:["Offset",this.offset],
        }
        return options;
    }
    M_freq.prototype.set = function M_freq() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.frequ = inverse(arguments[0]["frequ"]);
            this.offset = inverse(arguments[0]["offset"]);
            if (!ok) {
                break;
            }
            this.offset = this.offset.slice();
            this.frequ = this.frequ.slice();
            if ((size(this.frequ,"*"))!=(size(this.offset,"*"))) {
                message("offset and frequency must have the same size");
                throw "user error";
                var ok = false;
            } else if (or(this.frequ<0)) {
                message("Frequency must be a positif number");
                throw "user error";
                var ok = false;
            } else if (or(abs(this.offset)>this.frequ)) {
                message("The |Offset| must be less than the Frequency");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                var tmpvar0 = mfrequ_clk(this.frequ,this.offset);
                var m = tmpvar0[0];
                var den = tmpvar0[1];
                var off = tmpvar0[2];
                var count = tmpvar0[3];
                var m1 = tmpvar0[4];
                var fir = tmpvar0[5];
                this.frequ = tmpvar0[6];
                this.offset = tmpvar0[7];
                var ok = tmpvar0[8];
            }
            if (ok) {
                this.model.opar = list(m, new ScilabDouble([double(den)]), new ScilabDouble([off]), new ScilabDouble([count]));
                var mn = (2^size(m1,"*"))-1;
                var tmpvar1 = set_io(this.model,this.graphics,list(),list(),1,ones(mn,1));
                this.model = tmpvar1[0];
                this.graphics = tmpvar1[1];
                var ok = tmpvar1[2];
                if (mn>3) {
                    this.graphics.sz = new ScilabDouble([40+(mn-3)*10,40]);
                } else {
                    this.graphics.sz = new ScilabDouble([50,40]);
                }
                this.model.firing = new ScilabDouble([fir]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Events/VirtualCLK0.sci" */
function VirtualCLK0() {
    VirtualCLK0.prototype.define = function VirtualCLK0() {
        this.model = scicos_model();
        this.model.sim = new ScilabString(["vrtclk0"]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.opar = list();
        this.model.ipar = new ScilabDouble([]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([-1]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [];
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs)," ");
        return new BasicBlock(this.x);
    }
    VirtualCLK0.prototype.details = function VirtualCLK0() {
        return this.x;
    }
    VirtualCLK0.prototype.get = function VirtualCLK0() {
        alert("parameters cannot be modified");
    }
    VirtualCLK0.prototype.set = function VirtualCLK0() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Events/freq_div.sci" */
function freq_div() {
    freq_div.prototype.define = function freq_div() {
        var scs_m_1 = scicos_diagram();
        scs_m_1.objs[1-1] = Modulo_Count("define");
        scs_m_1.objs[2-1] = CLKINV_f("define");
        scs_m_1.objs[3-1] = CLKOUTV_f("define");
        scs_m_1.objs[4-1] = IFTHEL_f("define");
        scs_m_1.objs[5-1] = CLKSPLIT_f("define");
        scs_m_1.objs[6-1] = scicos_link();
        scs_m_1.objs[7-1] = scicos_link();
        scs_m_1.objs[8-1] = scicos_link();
        scs_m_1.objs[9-1] = scicos_link();
        scs_m_1.objs[10-1] = scicos_link();
        var blk = scs_m_1.objs[1-1];
        this.graphics = blk.graphics;
        this.model = blk.model;
        this.graphics.orig = new ScilabDouble([0,-100]);
        this.graphics.sz = new ScilabDouble([60,40]);
        this.graphics.exprs = new ScilabDouble(["0"],["3"]);
        this.model.dstate = new ScilabDouble([3]);
        this.model.ipar = new ScilabDouble([3]);
        this.graphics.pout = new ScilabDouble([7]);
        this.graphics.pein = new ScilabDouble([10]);
        blk.graphics = this.graphics;
        blk.model = this.model;
        scs_m_1.objs[1-1] = blk;
        var blk = scs_m_1.objs[2-1];
        this.graphics = blk.graphics;
        this.model = blk.model;
        this.graphics.orig = new ScilabDouble([120,0]);
        this.graphics.sz = new ScilabDouble([20,20]);
        this.graphics.exprs = new ScilabString(["1"]);
        this.model.ipar = new ScilabDouble([1]);
        this.graphics.peout = new ScilabDouble([6]);
        blk.graphics = this.graphics;
        blk.model = this.model;
        scs_m_1.objs[2-1] = blk;
        var blk = scs_m_1.objs[3-1];
        this.graphics = blk.graphics;
        this.model = blk.model;
        this.graphics.orig = new ScilabDouble([130,-160]);
        this.graphics.sz = new ScilabDouble([20,20]);
        this.graphics.exprs = new ScilabString(["1"]);
        this.model.ipar = new ScilabDouble([1]);
        this.graphics.pein = new ScilabDouble([8]);
        blk.graphics = this.graphics;
        blk.model = this.model;
        scs_m_1.objs[3-1] = blk;
        var blk = scs_m_1.objs[4-1];
        this.graphics = blk.graphics;
        this.model = blk.model;
        this.graphics.orig = new ScilabDouble([100,-100]);
        this.graphics.sz = new ScilabDouble([60,40]);
        this.graphics.exprs = new ScilabDouble(["1"],["0"]);
        this.model.ipar = new ScilabDouble([1]);
        this.graphics.pin = new ScilabDouble([7]);
        this.graphics.pein = new ScilabDouble([9]);
        this.graphics.peout = new ScilabDouble([0],[8]);
        blk.graphics = this.graphics;
        blk.model = this.model;
        scs_m_1.objs[4-1] = blk;
        var blk = scs_m_1.objs[5-1];
        this.graphics = blk.graphics;
        this.model = blk.model;
        this.graphics.orig = new ScilabDouble([127,-33]);
        this.graphics.sz = new ScilabDouble([7,7]);
        this.graphics.pein = new ScilabDouble([6]);
        this.graphics.peout = new ScilabDouble([9],[10]);
        blk.graphics = this.graphics;
        blk.model = this.model;
        scs_m_1.objs[5-1] = blk;
        var lnk = scs_m_1.objs[6-1];
        lnk.ct = [5,-1];
        lnk.from = [2,1,0];
        lnk.to = [5,1,1];
        scs_m_1.objs[6-1] = lnk;
        var lnk = scs_m_1.objs[7-1];
        lnk.from = [1,1,0];
        lnk.to = [4,1,1];
        scs_m_1.objs[7-1] = lnk;
        var lnk = scs_m_1.objs[8-1];
        lnk.ct = [5,-1];
        lnk.from = [4,2,0];
        lnk.to = [3,1,1];
        scs_m_1.objs[8-1] = lnk;
        var lnk = scs_m_1.objs[9-1];
        lnk.ct = [5,-1];
        lnk.from = [5,1,0];
        lnk.to = [4,1,1];
        scs_m_1.objs[9-1] = lnk;
        var lnk = scs_m_1.objs[10-1];
        lnk.xx = [0,30,1];
        lnk.yy = [0,-30,1];
        lnk.ct = [5,-1];
        lnk.from = [5,2,0];
        lnk.to = [1,1,1];
        scs_m_1.objs[10-1] = lnk;
        blk={};
        lnk={};
        this.model = scicos_model();
        this.model.sim = new ScilabString(["csuper"]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.evtout = new ScilabDouble([1]);
        this.model.rpar = scs_m_1;
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"freq_div\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble([]),this.gr_i);
        return new BasicBlock(this.x);
    }
    freq_div.prototype.details = function freq_div() {
        return this.x;
    }
    freq_div.prototype.get = function freq_div() {
        var options = {
            %ph:["Phase (0 to division factor -1)",this.%ph],
            %df:["Division factor",this.%df],
        }
        return options;
    }
    freq_div.prototype.set = function freq_div() {
            if (typeof(o)=="Block"&&o.gui=="Modulo_Count") {
                var path = i;
                break;
            }
        }
        var newpar = list();
        var y = 0;
        var spath = list();
        spath[$+1-1] = "model";
        spath[$+1-1] = "rpar";
        spath[$+1-1] = "objs";
        spath[$+1-1] = path;
        var xxn = xx;
        this.graphics = xx.graphics;
        this.exprs = this.graphics.exprs;
        this.model = xx.model;
        while (true) {
            var ok = true;
            this.%ph = parseFloat(arguments[0]["%ph"]);
            this.%df = parseFloat(arguments[0]["%df"]);
            if (!ok) {
                break;
            }
            if (ok) {
                if (%df<1) {
                    %df = 1;
                }
                %ph = abs(%ph);
                if (%ph>%df-1) {
                    %ph = %df-1;
                }
                this.graphics.exprs = new ScilabDouble(this.exprs);
                this.model.ipar = new ScilabDouble([%df]);
                this.model.dstate = new ScilabDouble([%ph]);
                xxn.graphics = this.graphics;
                xxn.model = this.model;
                break;
            }
        }
        if (diffobjs(xxn,xx)) {
            this.model = xx.model;
            var model_n = xxn.model;
            if (!is_modelica_block(xx)) {
                var modified = or(this.model.sim!=model_n.sim)||!isequal(this.model.state,model_n.state)||!isequal(this.model.dstate,model_n.dstate)||!isequal(this.model.rpar,model_n.rpar)||!isequal(this.model.ipar,model_n.ipar)||!isequal(this.model.label,model_n.label);
                if (or(this.model.in!=model_n.in)||or(this.model.out!=model_n.out)) {
                    var needcompile = 1;
                }
                if (or(this.model.firing!=model_n.firing)) {
                    var needcompile = 2;
                }
                if (this.model.sim=="input"||this.model.sim=="output") {
                    if (this.model.ipar!=model_n.ipar) {
                        var needcompile = 4;
                    }
                }
                if (or(this.model.blocktype!=model_n.blocktype)||or(this.model.dep_ut!=model_n.dep_ut)) {
                    var needcompile = 4;
                }
                if ((this.model.nzcross!=model_n.nzcross)||(this.model.nmode!=model_n.nmode)) {
                    var needcompile = 4;
                }
                if (prod(size(model_n.sim))>1) {
                    if (model_n.sim[2-1]>1000) {
                        if (this.model.sim[1-1]!=model_n.sim[1-1]) {
                            var needcompile = 4;
                        }
                    }
                }
            } else {
                var modified = or(model_n!=this.model);
                var eq = this.model.equations;
                var eqn = model_n.equations;
                if (or(eq.model!=eqn.model)||or(eq.inputs!=eqn.inputs)||or(eq.outputs!=eqn.outputs)) {
                    var needcompile = 4;
                }
            }
            newpar[size(newpar)+1-1] = 1;
            var y = max(y,needcompile);
        }
        var typ = newpar;
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Hydraulics/Bache.sci" */
function Bache() {
    Bache.prototype.define = function Bache() {
        var in1 = 2;
        var out = 3;
        this.model = scicos_model();
        this.model.in = new ScilabDouble([-transpose([1:in1])]);
        this.model.out = new ScilabDouble([-transpose([1:out])]);
        this.Patm = 1.013e5;
        this.A = 1;
        this.ze1 = 40;
        this.ze2 = 0;
        this.zs1 = 40;
        this.zs2 = 0;
        this.z0 = 30;
        this.T0 = 290;
        this.p_rho = 0;
        this.model.rpar = new ScilabDouble([this.Patm],[this.A],[this.ze1],[this.ze2],[this.zs1],[this.zs2],[this.z0],[this.T0],[this.p_rho]);
        this.model.sim = new ScilabString(["Bache"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var mo = modelica();
        mo.model = "Bache";
        mo.inputs = ["Ce1","Ce2"];
        mo.outputs = ["Cs1","Cs2","yNiveau"];
        mo.parameters = list([["Patm"],["A"],["ze1"],["ze2"],["zs1"],["zs2"],["z0"],["T0"],["p_rho"]],[[this.Patm],[this.A],[this.ze1],[this.ze2],[this.zs1],[this.zs2],[this.z0],[this.T0],[this.p_rho]]);
        this.model.equations = new ScilabDouble([mo]);
        this.model.in = new ScilabDouble([ones(size(mo.inputs,"*"),1)]);
        this.model.out = new ScilabDouble([ones(size(mo.outputs,"*"),1)]);
        this.exprs = [[string(this.Patm)],[string(this.A)],[string(this.ze1)],[string(this.ze2)],[string(this.zs1)],[string(this.zs2)],[string(this.z0)],[string(this.T0)],[string(this.p_rho)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"Bache\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),list(this.gr_i,0));
        this.x.graphics.in_implicit = [["I"],["I"]];
        this.x.graphics.out_implicit = [["I"],["I"],["E"]];
        return new BasicBlock(this.x);
    }
    Bache.prototype.details = function Bache() {
        return this.x;
    }
    Bache.prototype.get = function Bache() {
        var options = {
            Patm:["Pression dans le ciel de la bache : Patm (Pa)",this.Patm],
            A:["Section de la bache : A (m2)",this.A],
            ze1:["Altitude du piquage d entre 1: ze1 (m)",this.ze1],
            ze2:["Altitude du piquage d entre 2: ze2 (m)",this.ze2],
            zs1:["Altitude du piquage de sortie 1: zs1 (m)",this.zs1],
            zs2:["Altitude du piquage de sortie 2: zs2 (m)",this.zs2],
            z0:["Altitude initiale du fluide : z0 (m)",this.z0],
            T0:["Temprature initiale du fluide : T0 (K)",this.T0],
            p_rho:["Si >0, masse volumique impose du fluide : p_rho (kg/m3)",this.p_rho],
        }
        return options;
    }
    Bache.prototype.set = function Bache() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.Patm = parseFloat(arguments[0]["Patm"]);
            this.A = parseFloat(arguments[0]["A"]);
            this.ze1 = parseFloat(arguments[0]["ze1"]);
            this.ze2 = parseFloat(arguments[0]["ze2"]);
            this.zs1 = parseFloat(arguments[0]["zs1"]);
            this.zs2 = parseFloat(arguments[0]["zs2"]);
            this.z0 = parseFloat(arguments[0]["z0"]);
            this.T0 = parseFloat(arguments[0]["T0"]);
            this.p_rho = parseFloat(arguments[0]["p_rho"]);
            if (!ok) {
                break;
            }
            this.model.rpar = new ScilabDouble([this.Patm],[this.A],[this.ze1],[this.ze2],[this.zs1],[this.zs2],[this.z0],[this.T0],[this.p_rho]);
            this.model.equations.parameters[2-1] = list(new ScilabDouble([this.Patm]), new ScilabDouble([this.A]), new ScilabDouble([this.ze1]), new ScilabDouble([this.ze2]), new ScilabDouble([this.zs1]), new ScilabDouble([this.zs2]), new ScilabDouble([this.z0]), new ScilabDouble([this.T0]), new ScilabDouble([this.p_rho]));
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Hydraulics/Flowmeter.sci" */
function Flowmeter() {
    Flowmeter.prototype.define = function Flowmeter() {
        var ModelName = "Flowmeter";
        var PrametersValue = 1;
        var ParametersName = "Qini";
        this.model = scicos_model();
        var Typein = [];
        var Typeout = [];
        var MI = [];
        var MO = [];
        var P = [[50,105,-1,90],[0,10,2,0],[101,10,-2,0]];
        var PortName = [["Mesure"],["C1"],["C2"]];
        for (i=1;i<=size(P,"r");i+=1) {
            if (P[i-1][3-1]==1) {
                var Typein = [[Typein],["E"]];
                var MI = [[MI],[PortName[i-1]]];
            }
            if (P[i-1][3-1]==2) {
                var Typein = [[Typein],["I"]];
                var MI = [[MI],[PortName[i-1]]];
            }
            if (P[i-1][3-1]==-1) {
                var Typeout = [[Typeout],["E"]];
                var MO = [[MO],[PortName[i-1]]];
            }
            if (P[i-1][3-1]==-2) {
                var Typeout = [[Typeout],["I"]];
                var MO = [[MO],[PortName[i-1]]];
            }
        }
        this.model = scicos_model();
        var mo = modelica();
        this.model.sim = new ScilabString([ModelName]);
        mo.inputs = MI;
        mo.outputs = MO;
        this.model.rpar = new ScilabDouble([PrametersValue]);
        mo.parameters = list(ParametersName,PrametersValue,zeros(ParametersName));
        this.exprs = "1";
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"Flowmeter\",sz(1),sz(2));"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        mo.model = ModelName;
        this.model.equations = new ScilabDouble([mo]);
        this.model.in = new ScilabDouble([ones(size(MI,"*"),1)]);
        this.model.out = new ScilabDouble([ones(size(MO,"*"),1)]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),list(this.gr_i,0));
        this.x.graphics.in_implicit = Typein;
        this.x.graphics.out_implicit = Typeout;
        return new BasicBlock(this.x);
    }
    Flowmeter.prototype.details = function Flowmeter() {
        return this.x;
    }
    Flowmeter.prototype.get = function Flowmeter() {
        var options = {
            Qini:["Qini",this.Qini],
        }
        return options;
    }
    Flowmeter.prototype.set = function Flowmeter() {
        this.exprs = this.graphics.exprs;
        this.exprs = this.x.graphics.exprs;
        while (false) {
            var ok = true;
            this.Qini = arguments[0]["Qini"];
            if (!ok) {
                break;
            }
            this.x.model.equations.parameters[2-1] = list(this.Qini);
            this.x.graphics.exprs = this.exprs;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Hydraulics/PerteDP.sci" */
function PerteDP() {
    PerteDP.prototype.define = function PerteDP() {
        this.model = scicos_model();
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.L = 10;
        this.D = 0.2;
        this.lambda = 0.03;
        this.z1 = 0;
        this.z2 = 0;
        this.p_rho = 0;
        this.model.rpar = new ScilabDouble([this.L],[this.D],[this.lambda],[this.z1],[this.z2],[this.p_rho]);
        this.model.sim = new ScilabString(["PerteDP"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var mo = modelica();
        mo.model = "PerteDP";
        mo.inputs = "C1";
        mo.outputs = "C2";
        mo.parameters = list([["L"],["D"],["lambda"],["z1"],["z2"],["p_rho"]],[[this.L],[this.D],[this.lambda],[this.z1],[this.z2],[this.p_rho]]);
        this.model.equations = new ScilabDouble([mo]);
        this.model.in = new ScilabDouble([ones(size(mo.inputs,"*"),1)]);
        this.model.out = new ScilabDouble([ones(size(mo.outputs,"*"),1)]);
        this.exprs = [[string(this.L)],[string(this.D)],[string(this.lambda)],[string(this.z1)],[string(this.z2)],[string(this.p_rho)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"PerteDP\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,1]),this.model,new ScilabDouble(this.exprs),list(this.gr_i,0));
        this.x.graphics.in_implicit = ["I"];
        this.x.graphics.out_implicit = ["I"];
        return new BasicBlock(this.x);
    }
    PerteDP.prototype.details = function PerteDP() {
        return this.x;
    }
    PerteDP.prototype.get = function PerteDP() {
        var options = {
            L:["Longueur du tube : L (m)",this.L],
            D:["Diamtre interne du tube : D (m)",this.D],
            lambda:["Coefficient de perte de charge-frottement(S.U) : lambda",this.lambda],
            z1:["Altitude entre tuyauterie : z1 (m)",this.z1],
            z2:["Altitude sortie tuyauterie : z2 (m)",this.z2],
            p_rho:["Si >0, masse volumique impose fu fluide : p_rho (kg/m3)",this.p_rho],
        }
        return options;
    }
    PerteDP.prototype.set = function PerteDP() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.L = parseFloat(arguments[0]["L"]);
            this.D = parseFloat(arguments[0]["D"]);
            this.lambda = parseFloat(arguments[0]["lambda"]);
            this.z1 = parseFloat(arguments[0]["z1"]);
            this.z2 = parseFloat(arguments[0]["z2"]);
            this.p_rho = parseFloat(arguments[0]["p_rho"]);
            if (!ok) {
                break;
            }
            this.model.rpar = new ScilabDouble([this.L],[this.D],[this.lambda],[this.z1],[this.z2],[this.p_rho]);
            this.model.equations.parameters[2-1] = list(new ScilabDouble([this.L]), new ScilabDouble([this.D]), new ScilabDouble([this.lambda]), new ScilabDouble([this.z1]), new ScilabDouble([this.z2]), new ScilabDouble([this.p_rho]));
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Hydraulics/PuitsP.sci" */
function PuitsP() {
    PuitsP.prototype.define = function PuitsP() {
        this.model = scicos_model();
        this.P0 = 100000;
        this.T0 = 290;
        this.H0 = 100000;
        this.option_temperature = 1;
        this.model.rpar = new ScilabDouble([this.P0],[this.T0],[this.H0],[this.option_temperature]);
        this.model.sim = new ScilabString(["Puits"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var mo = modelica();
        mo.model = "Puits";
        mo.inputs = ["C"];
        mo.parameters = list([["P0"],["T0"],["H0"],["option_temperature"]],[[this.P0],[this.T0],[this.H0],[this.option_temperature]]);
        this.model.equations = new ScilabDouble([mo]);
        this.model.in = new ScilabDouble([ones(size(mo.inputs,"*"),1)]);
        this.exprs = [[string(this.P0)],[string(this.T0)],[string(this.H0)],[string(this.option_temperature)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"PuitsP\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2.5,2]),this.model,new ScilabDouble(this.exprs),list(this.gr_i,0));
        this.x.graphics.in_implicit = ["I"];
        return new BasicBlock(this.x);
    }
    PuitsP.prototype.details = function PuitsP() {
        return this.x;
    }
    PuitsP.prototype.get = function PuitsP() {
        var options = {
            P0:["Pression de la source : P0 (Pa)",this.P0],
            T0:["Temperature de la source : T0 (K)",this.T0],
            H0:["Enthalpie spcifique de la source : H0 (J/kg)",this.H0],
            option_temperature:["1:temprature fixe - 2:enthalpie fixe : option_temperature",this.option_temperature],
        }
        return options;
    }
    PuitsP.prototype.set = function PuitsP() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.P0 = parseFloat(arguments[0]["P0"]);
            this.T0 = parseFloat(arguments[0]["T0"]);
            this.H0 = parseFloat(arguments[0]["H0"]);
            this.option_temperature = parseFloat(arguments[0]["option_temperature"]);
            if (!ok) {
                break;
            }
            this.model.rpar = new ScilabDouble([this.P0],[this.T0],[this.H0],[this.option_temperature]);
            this.model.equations.parameters[2-1] = list(new ScilabDouble([this.P0]), new ScilabDouble([this.T0]), new ScilabDouble([this.H0]), new ScilabDouble([this.option_temperature]));
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Hydraulics/SourceP.sci" */
function SourceP() {
    SourceP.prototype.define = function SourceP() {
        this.model = scicos_model();
        this.P0 = 300000;
        this.T0 = 290;
        this.H0 = 100000;
        this.option_temperature = 1;
        this.model.rpar = new ScilabDouble([this.P0],[this.T0],[this.H0],[this.option_temperature]);
        this.model.sim = new ScilabString(["Source"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var mo = modelica();
        mo.model = "Source";
        mo.inputs = [];
        mo.outputs = ["C"];
        mo.parameters = list([["P0"],["T0"],["H0"],["option_temperature"]],[[this.P0],[this.T0],[this.H0],[this.option_temperature]]);
        this.model.equations = new ScilabDouble([mo]);
        this.model.in = new ScilabDouble([ones(size(mo.inputs,"*"),1)]);
        this.model.out = new ScilabDouble([ones(size(mo.outputs,"*"),1)]);
        this.exprs = [[string(this.P0)],[string(this.T0)],[string(this.H0)],[string(this.option_temperature)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SourceP\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2.5,2]),this.model,new ScilabDouble(this.exprs),list(this.gr_i,0));
        this.x.graphics.out_implicit = ["I"];
        return new BasicBlock(this.x);
    }
    SourceP.prototype.details = function SourceP() {
        return this.x;
    }
    SourceP.prototype.get = function SourceP() {
        var options = {
            P0:["Pression de la source : P0 (Pa)",this.P0],
            T0:["Temperature de la source : T0 (K)",this.T0],
            H0:["Enthalpie spcifique de la source : H0 (J/kg)",this.H0],
            option_temperature:["1:temprature fixe - 2:enthalpie fixe : option_temperature",this.option_temperature],
        }
        return options;
    }
    SourceP.prototype.set = function SourceP() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.P0 = parseFloat(arguments[0]["P0"]);
            this.T0 = parseFloat(arguments[0]["T0"]);
            this.H0 = parseFloat(arguments[0]["H0"]);
            this.option_temperature = parseFloat(arguments[0]["option_temperature"]);
            if (!ok) {
                break;
            }
            this.model.rpar = new ScilabDouble([this.P0],[this.T0],[this.H0],[this.option_temperature]);
            this.model.equations.parameters[2-1] = list(new ScilabDouble([this.P0]), new ScilabDouble([this.T0]), new ScilabDouble([this.H0]), new ScilabDouble([this.option_temperature]));
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Hydraulics/VanneReglante.sci" */
function VanneReglante() {
    VanneReglante.prototype.define = function VanneReglante() {
        this.model = scicos_model();
        this.model.in = new ScilabDouble([1],[1]);
        this.model.out = new ScilabDouble([1]);
        this.Cvmax = 8005.42;
        this.p_rho = 0;
        this.model.rpar = new ScilabDouble([this.Cvmax],[this.p_rho]);
        this.model.sim = new ScilabString(["VanneReglante"]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var mo = modelica();
        mo.model = "VanneReglante";
        mo.inputs = ["C1","Ouv"];
        mo.outputs = "C2";
        mo.parameters = list([["Cvmax"],["p_rho"]],[[this.Cvmax],[this.p_rho]]);
        this.model.equations = new ScilabDouble([mo]);
        this.model.in = new ScilabDouble([ones(size(mo.inputs,"*"),1)]);
        this.model.out = new ScilabDouble([ones(size(mo.outputs,"*"),1)]);
        this.exprs = [[string(this.Cvmax)],[string(this.p_rho)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"VanneReglante\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),list(this.gr_i,0));
        this.x.graphics.in_implicit = [["I"],["E"]];
        this.x.graphics.out_implicit = ["I"];
        return new BasicBlock(this.x);
    }
    VanneReglante.prototype.details = function VanneReglante() {
        return this.x;
    }
    VanneReglante.prototype.get = function VanneReglante() {
        var options = {
            Cvmax:["Cvmax",this.Cvmax],
            p_rho:["p_rho",this.p_rho],
        }
        return options;
    }
    VanneReglante.prototype.set = function VanneReglante() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.Cvmax = parseFloat(arguments[0]["Cvmax"]);
            this.p_rho = parseFloat(arguments[0]["p_rho"]);
            if (!ok) {
                break;
            }
            this.model.rpar = new ScilabDouble([this.Cvmax],[this.p_rho]);
            this.model.equations.parameters[2-1] = list(new ScilabDouble([this.Cvmax]), new ScilabDouble([this.p_rho]));
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/IntegerOp/BITCLEAR.sci" */
function BITCLEAR() {
    BITCLEAR.prototype.define = function BITCLEAR() {
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["bit_clear_32"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([1]);
        this.model.in2 = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.out2 = new ScilabDouble([1]);
        this.model.intyp = new ScilabDouble([3]);
        this.model.outtyp = new ScilabDouble([3]);
        this.model.opar = list(new ScilabDouble([int32(0)]));
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[sci2exp(3)],[sci2exp(0)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"BITCLEAR\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([4,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    BITCLEAR.prototype.details = function BITCLEAR() {
        return this.x;
    }
    BITCLEAR.prototype.get = function BITCLEAR() {
        var options = {
            Datatype:[msprintf("Data Type %s","(3:int32, 4:int16, 5:int8, ...)"),this.Datatype],
            bit:["Index of Bit (0 is least significant)",this.bit],
        }
        return options;
    }
    BITCLEAR.prototype.set = function BITCLEAR() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.Datatype = arguments[0]["Datatype"];
            this.bit = parseFloat(arguments[0]["bit"]);
            if (!ok) {
                break;
            }
            var in1 = [this.model.in,this.model.in2];
            if (floor(this.bit)!=this.bit) {
                block_parameter_error(msprintf("Wrong type for \'%s\' parameter: %5.1f.","Index of Bit",this.bit),"Must be integer.");
                var ok = false;
            } else if ((this.Datatype==3)||(this.Datatype==6)) {
                if (this.bit>31||this.bit<0) {
                    block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Index of Bit",this.bit),msprintf("Must be in the interval %s.","[0, 31]"));
                    var ok = false;
                } else {
                    this.bit = uint32(this.bit);
                    var n = (2^32-1)-2^this.bit;
                    var n = uint32(n);
                    this.model.sim = list(new ScilabString(["bit_clear_32"]), new ScilabDouble([4]));
                }
            } else if ((this.Datatype==4)||(this.Datatype==7)) {
                if (this.bit>15||this.bit<0) {
                    block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Index of Bit",this.bit),msprintf("Must be in the interval %s.","[0, 15]"));
                    var ok = false;
                } else {
                    this.bit = uint16(this.bit);
                    var n = (2^16-1)-2^this.bit;
                    var n = uint16(n);
                    this.model.sim = list(new ScilabString(["bit_clear_16"]), new ScilabDouble([4]));
                }
            } else if ((this.Datatype==5)||(this.Datatype==8)) {
                if (this.bit>7||this.bit<0) {
                    block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Index of Bit",this.bit),msprintf("Must be in the interval %s.","[0, 7]"));
                    var ok = false;
                } else {
                    this.bit = uint8(this.bit);
                    var n = (2^8-1)-2^this.bit;
                    var n = uint8(n);
                    this.model.sim = list(new ScilabString(["bit_clear_8"]), new ScilabDouble([4]));
                }
            } else {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Data Type",this.Datatype),msprintf("Must be in the interval %s.","[3, 8]"));
                var ok = false;
            }
            if (ok) {
                var it = this.Datatype;
                var ot = this.Datatype;
                var out = [1,1];
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.opar = list(new ScilabDouble([n]));
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/IntegerOp/BITSET.sci" */
function BITSET() {
    BITSET.prototype.define = function BITSET() {
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["bit_set_32"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([1]);
        this.model.in2 = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.out2 = new ScilabDouble([1]);
        this.model.intyp = new ScilabDouble([3]);
        this.model.outtyp = new ScilabDouble([3]);
        this.model.opar = list(new ScilabDouble([uint32(0)]));
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[sci2exp(3)],[sci2exp(0)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"BITSET\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([4,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    BITSET.prototype.details = function BITSET() {
        return this.x;
    }
    BITSET.prototype.get = function BITSET() {
        var options = {
            Datatype:[msprintf("Data Type %s","(3:int32, 4:int16, 5:int8, ...)"),this.Datatype],
            bit:["Index of Bit (0 is least significant)",this.bit],
        }
        return options;
    }
    BITSET.prototype.set = function BITSET() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.Datatype = arguments[0]["Datatype"];
            this.bit = parseFloat(arguments[0]["bit"]);
            if (!ok) {
                break;
            }
            var in1 = [this.model.in,this.model.in2];
            if (floor(this.bit)!=this.bit) {
                block_parameter_error(msprintf("Wrong type for \'%s\' parameter: %5.1f.","Index of Bit",this.bit),"Must be integer.");
                var ok = false;
            }
            if ((this.Datatype==3)||(this.Datatype==6)) {
                if (this.bit>31||this.bit<0) {
                    block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Index of Bit",this.bit),msprintf("Must be in the interval %s.","[0, 31]"));
                    var ok = false;
                }
                this.bit = uint32(this.bit);
                var n = 2^this.bit;
                var n = uint32(n);
                this.model.sim = list(new ScilabString(["bit_set_32"]), new ScilabDouble([4]));
            } else if ((this.Datatype==4)||(this.Datatype==7)) {
                if (this.bit>15||this.bit<0) {
                    block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Index of Bit",this.bit),msprintf("Must be in the interval %s.","[0, 15]"));
                    var ok = false;
                }
                this.bit = uint16(this.bit);
                var n = 2^this.bit;
                var n = uint16(n);
                this.model.sim = list(new ScilabString(["bit_set_16"]), new ScilabDouble([4]));
            } else if ((this.Datatype==5)||(this.Datatype==8)) {
                if (this.bit>7||this.bit<0) {
                    block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Index of Bit",this.bit),msprintf("Must be in the interval %s.","[0, 7]"));
                    var ok = false;
                }
                this.bit = uint8(this.bit);
                var n = 2^this.bit;
                var n = uint8(n);
                this.model.sim = list(new ScilabString(["bit_set_8"]), new ScilabDouble([4]));
            } else {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Data Type",this.Datatype),msprintf("Must be in the interval %s.","[3, 8]"));
                var ok = false;
            }
            if (ok) {
                var it = this.Datatype;
                var ot = this.Datatype;
                var out = [1,1];
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.opar = list(new ScilabDouble([n]));
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/IntegerOp/CONVERT.sci" */
function CONVERT() {
    CONVERT.prototype.define = function CONVERT() {
        var sgn = 2;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["convert"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([-1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.out2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.outtyp = new ScilabDouble([3]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([sgn]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[sci2exp(1)],[sci2exp(3)],[sci2exp(0)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CONVERT\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    CONVERT.prototype.details = function CONVERT() {
        return this.x;
    }
    CONVERT.prototype.get = function CONVERT() {
        var options = {
            it:["Input Type (1:double, 3:int32, 4:int16, 5:int8, ...)",this.it],
            ot:["Output Type (1:double, 3:int32, 4:int16, 5:int8, ...)",this.ot],
            np:["Do on Overflow (0:Nothing, 1:Saturate, 2:Error)",this.np],
        }
        return options;
    }
    CONVERT.prototype.set = function CONVERT() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.it = parseFloat(arguments[0]["it"]);
            this.ot = parseFloat(arguments[0]["ot"]);
            this.np = arguments[0]["np"];
            if (!ok) {
                break;
            }
            if (this.it==2) {
                this.it = 1;
            }
            if (this.ot==2) {
                this.ot = 1;
            }
            if ((this.np!=0&&this.np!=1&&this.np!=2)) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Do on Overflow",this.np),msprintf("Must be in the interval %s.","[0, 2]"));
                var ok = false;
            } else if ((this.it>8||this.it<1)) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Input Type",this.it),msprintf("Must be in the interval %s.","[1, 8]"));
                var ok = false;
            } else if ((this.ot>8||this.ot<1)) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Output Type",this.ot),msprintf("Must be in the interval %s.","[1, 8]"));
                var ok = false;
            }
            this.model.sim = list(new ScilabString(["convert"]), new ScilabDouble([4]));
            if ((this.it==this.ot)) {
                this.model.ipar = new ScilabDouble([1]);
            } else {
                if ((this.np==0)) {
                    if ((this.it==1)) {
                        if ((this.ot==3)) {
                            this.model.ipar = new ScilabDouble([2]);
                        } else if ((this.ot==4)) {
                            this.model.ipar = new ScilabDouble([3]);
                        } else if ((this.ot==5)) {
                            this.model.ipar = new ScilabDouble([4]);
                        } else if ((this.ot==6)) {
                            this.model.ipar = new ScilabDouble([5]);
                        } else if ((this.ot==7)) {
                            this.model.ipar = new ScilabDouble([6]);
                        } else if ((this.ot==8)) {
                            this.model.ipar = new ScilabDouble([7]);
                        }
                    } else if ((this.it==3)) {
                        if ((this.ot==1)) {
                            this.model.ipar = new ScilabDouble([8]);
                        } else if ((this.ot==4)) {
                            this.model.ipar = new ScilabDouble([9]);
                        } else if ((this.ot==5)) {
                            this.model.ipar = new ScilabDouble([10]);
                        } else if ((this.ot==6)) {
                            this.model.ipar = new ScilabDouble([1]);
                        } else if ((this.ot==7)) {
                            this.model.ipar = new ScilabDouble([11]);
                        } else if ((this.ot==8)) {
                            this.model.ipar = new ScilabDouble([12]);
                        }
                    } else if ((this.it==4)) {
                        if ((this.ot==1)) {
                            this.model.ipar = new ScilabDouble([13]);
                        } else if ((this.ot==3)) {
                            this.model.ipar = new ScilabDouble([14]);
                        } else if ((this.ot==5)) {
                            this.model.ipar = new ScilabDouble([15]);
                        } else if ((this.ot==6)) {
                            this.model.ipar = new ScilabDouble([16]);
                        } else if ((this.ot==7)) {
                            this.model.ipar = new ScilabDouble([1]);
                        } else if ((this.ot==8)) {
                            this.model.ipar = new ScilabDouble([17]);
                        }
                    } else if ((this.it==5)) {
                        if ((this.ot==1)) {
                            this.model.ipar = new ScilabDouble([18]);
                        } else if ((this.ot==3)) {
                            this.model.ipar = new ScilabDouble([19]);
                        } else if ((this.ot==4)) {
                            this.model.ipar = new ScilabDouble([20]);
                        } else if ((this.ot==6)) {
                            this.model.ipar = new ScilabDouble([21]);
                        } else if ((this.ot==7)) {
                            this.model.ipar = new ScilabDouble([22]);
                        } else if ((this.ot==8)) {
                            this.model.ipar = new ScilabDouble([1]);
                        }
                    } else if ((this.it==6)) {
                        if ((this.ot==1)) {
                            this.model.ipar = new ScilabDouble([23]);
                        } else if ((this.ot==3)) {
                            this.model.ipar = new ScilabDouble([1]);
                        } else if ((this.ot==4)) {
                            this.model.ipar = new ScilabDouble([24]);
                        } else if ((this.ot==5)) {
                            this.model.ipar = new ScilabDouble([25]);
                        } else if ((this.ot==7)) {
                            this.model.ipar = new ScilabDouble([26]);
                        } else if ((this.ot==8)) {
                            this.model.ipar = new ScilabDouble([27]);
                        }
                    } else if ((this.it==7)) {
                        if ((this.ot==1)) {
                            this.model.ipar = new ScilabDouble([28]);
                        } else if ((this.ot==3)) {
                            this.model.ipar = new ScilabDouble([29]);
                        } else if ((this.ot==4)) {
                            this.model.ipar = new ScilabDouble([1]);
                        } else if ((this.ot==5)) {
                            this.model.ipar = new ScilabDouble([30]);
                        } else if ((this.ot==6)) {
                            this.model.ipar = new ScilabDouble([31]);
                        } else if ((this.ot==8)) {
                            this.model.ipar = new ScilabDouble([32]);
                        }
                    } else if ((this.it==8)) {
                        if ((this.ot==1)) {
                            this.model.ipar = new ScilabDouble([33]);
                        } else if ((this.ot==3)) {
                            this.model.ipar = new ScilabDouble([34]);
                        } else if ((this.ot==4)) {
                            this.model.ipar = new ScilabDouble([35]);
                        } else if ((this.ot==5)) {
                            this.model.ipar = new ScilabDouble([1]);
                        } else if ((this.ot==6)) {
                            this.model.ipar = new ScilabDouble([36]);
                        } else if ((this.ot==7)) {
                            this.model.ipar = new ScilabDouble([37]);
                        }
                    }
                } else if ((this.np==1)) {
                    if ((this.it==1)) {
                        if ((this.ot==3)) {
                            this.model.ipar = new ScilabDouble([38]);
                        } else if ((this.ot==4)) {
                            this.model.ipar = new ScilabDouble([39]);
                        } else if ((this.ot==5)) {
                            this.model.ipar = new ScilabDouble([40]);
                        } else if ((this.ot==6)) {
                            this.model.ipar = new ScilabDouble([41]);
                        } else if ((this.ot==7)) {
                            this.model.ipar = new ScilabDouble([42]);
                        } else if ((this.ot==8)) {
                            this.model.ipar = new ScilabDouble([43]);
                        }
                    } else if ((this.it==3)) {
                        if ((this.ot==1)) {
                            this.model.ipar = new ScilabDouble([8]);
                        } else if ((this.ot==4)) {
                            this.model.ipar = new ScilabDouble([44]);
                        } else if ((this.ot==5)) {
                            this.model.ipar = new ScilabDouble([45]);
                        } else if ((this.ot==6)) {
                            this.model.ipar = new ScilabDouble([46]);
                        } else if ((this.ot==7)) {
                            this.model.ipar = new ScilabDouble([47]);
                        } else if ((this.ot==8)) {
                            this.model.ipar = new ScilabDouble([48]);
                        }
                    } else if ((this.it==4)) {
                        if ((this.ot==1)) {
                            this.model.ipar = new ScilabDouble([13]);
                        } else if ((this.ot==3)) {
                            this.model.ipar = new ScilabDouble([14]);
                        } else if ((this.ot==5)) {
                            this.model.ipar = new ScilabDouble([49]);
                        } else if ((this.ot==6)) {
                            this.model.ipar = new ScilabDouble([50]);
                        } else if ((this.ot==7)) {
                            this.model.ipar = new ScilabDouble([51]);
                        } else if ((this.ot==8)) {
                            this.model.ipar = new ScilabDouble([52]);
                        }
                    } else if ((this.it==5)) {
                        if ((this.ot==1)) {
                            this.model.ipar = new ScilabDouble([18]);
                        } else if ((this.ot==3)) {
                            this.model.ipar = new ScilabDouble([19]);
                        } else if ((this.ot==4)) {
                            this.model.ipar = new ScilabDouble([20]);
                        } else if ((this.ot==6)) {
                            this.model.ipar = new ScilabDouble([53]);
                        } else if ((this.ot==7)) {
                            this.model.ipar = new ScilabDouble([54]);
                        } else if ((this.ot==8)) {
                            this.model.ipar = new ScilabDouble([55]);
                        }
                    } else if ((this.it==6)) {
                        if ((this.ot==1)) {
                            this.model.ipar = new ScilabDouble([23]);
                        } else if ((this.ot==3)) {
                            this.model.ipar = new ScilabDouble([56]);
                        } else if ((this.ot==4)) {
                            this.model.ipar = new ScilabDouble([57]);
                        } else if ((this.ot==5)) {
                            this.model.ipar = new ScilabDouble([58]);
                        } else if ((this.ot==7)) {
                            this.model.ipar = new ScilabDouble([59]);
                        } else if ((this.ot==8)) {
                            this.model.ipar = new ScilabDouble([60]);
                        }
                    } else if ((this.it==7)) {
                        if ((this.ot==1)) {
                            this.model.ipar = new ScilabDouble([28]);
                        } else if ((this.ot==3)) {
                            this.model.ipar = new ScilabDouble([29]);
                        } else if ((this.ot==4)) {
                            this.model.ipar = new ScilabDouble([61]);
                        } else if ((this.ot==5)) {
                            this.model.ipar = new ScilabDouble([62]);
                        } else if ((this.ot==6)) {
                            this.model.ipar = new ScilabDouble([31]);
                        } else if ((this.ot==8)) {
                            this.model.ipar = new ScilabDouble([63]);
                        }
                    } else if ((this.it==8)) {
                        if ((this.ot==1)) {
                            this.model.ipar = new ScilabDouble([33]);
                        } else if ((this.ot==3)) {
                            this.model.ipar = new ScilabDouble([34]);
                        } else if ((this.ot==4)) {
                            this.model.ipar = new ScilabDouble([35]);
                        } else if ((this.ot==5)) {
                            this.model.ipar = new ScilabDouble([64]);
                        } else if ((this.ot==6)) {
                            this.model.ipar = new ScilabDouble([36]);
                        } else if ((this.ot==7)) {
                            this.model.ipar = new ScilabDouble([37]);
                        }
                    }
                } else if ((this.np==2)) {
                    if ((this.it==1)) {
                        if ((this.ot==3)) {
                            this.model.ipar = new ScilabDouble([65]);
                        } else if ((this.ot==4)) {
                            this.model.ipar = new ScilabDouble([66]);
                        } else if ((this.ot==5)) {
                            this.model.ipar = new ScilabDouble([67]);
                        } else if ((this.ot==6)) {
                            this.model.ipar = new ScilabDouble([68]);
                        } else if ((this.ot==7)) {
                            this.model.ipar = new ScilabDouble([69]);
                        } else if ((this.ot==8)) {
                            this.model.ipar = new ScilabDouble([70]);
                        }
                    } else if ((this.it==3)) {
                        if ((this.ot==1)) {
                            this.model.ipar = new ScilabDouble([8]);
                        } else if ((this.ot==4)) {
                            this.model.ipar = new ScilabDouble([71]);
                        } else if ((this.ot==5)) {
                            this.model.ipar = new ScilabDouble([72]);
                        } else if ((this.ot==6)) {
                            this.model.ipar = new ScilabDouble([73]);
                        } else if ((this.ot==7)) {
                            this.model.ipar = new ScilabDouble([74]);
                        } else if ((this.ot==8)) {
                            this.model.ipar = new ScilabDouble([75]);
                        }
                    } else if ((this.it==4)) {
                        if ((this.ot==1)) {
                            this.model.ipar = new ScilabDouble([13]);
                        } else if ((this.ot==3)) {
                            this.model.ipar = new ScilabDouble([14]);
                        } else if ((this.ot==5)) {
                            this.model.ipar = new ScilabDouble([76]);
                        } else if ((this.ot==6)) {
                            this.model.ipar = new ScilabDouble([77]);
                        } else if ((this.ot==7)) {
                            this.model.ipar = new ScilabDouble([78]);
                        } else if ((this.ot==8)) {
                            this.model.ipar = new ScilabDouble([79]);
                        }
                    } else if ((this.it==5)) {
                        if ((this.ot==1)) {
                            this.model.ipar = new ScilabDouble([18]);
                        } else if ((this.ot==3)) {
                            this.model.ipar = new ScilabDouble([19]);
                        } else if ((this.ot==4)) {
                            this.model.ipar = new ScilabDouble([20]);
                        } else if ((this.ot==6)) {
                            this.model.ipar = new ScilabDouble([80]);
                        } else if ((this.ot==7)) {
                            this.model.ipar = new ScilabDouble([81]);
                        } else if ((this.ot==8)) {
                            this.model.ipar = new ScilabDouble([82]);
                        }
                    } else if ((this.it==6)) {
                        if ((this.ot==1)) {
                            this.model.ipar = new ScilabDouble([23]);
                        } else if ((this.ot==3)) {
                            this.model.ipar = new ScilabDouble([83]);
                        } else if ((this.ot==4)) {
                            this.model.ipar = new ScilabDouble([84]);
                        } else if ((this.ot==5)) {
                            this.model.ipar = new ScilabDouble([85]);
                        } else if ((this.ot==7)) {
                            this.model.ipar = new ScilabDouble([86]);
                        } else if ((this.ot==8)) {
                            this.model.ipar = new ScilabDouble([87]);
                        }
                    } else if ((this.it==7)) {
                        if ((this.ot==1)) {
                            this.model.ipar = new ScilabDouble([28]);
                        } else if ((this.ot==3)) {
                            this.model.ipar = new ScilabDouble([29]);
                        } else if ((this.ot==4)) {
                            this.model.ipar = new ScilabDouble([88]);
                        } else if ((this.ot==5)) {
                            this.model.ipar = new ScilabDouble([89]);
                        } else if ((this.ot==6)) {
                            this.model.ipar = new ScilabDouble([31]);
                        } else if ((this.ot==8)) {
                            this.model.ipar = new ScilabDouble([90]);
                        }
                    } else if ((this.it==8)) {
                        if ((this.ot==1)) {
                            this.model.ipar = new ScilabDouble([33]);
                        } else if ((this.ot==3)) {
                            this.model.ipar = new ScilabDouble([34]);
                        } else if ((this.ot==4)) {
                            this.model.ipar = new ScilabDouble([35]);
                        } else if ((this.ot==5)) {
                            this.model.ipar = new ScilabDouble([91]);
                        } else if ((this.ot==6)) {
                            this.model.ipar = new ScilabDouble([36]);
                        } else if ((this.ot==7)) {
                            this.model.ipar = new ScilabDouble([37]);
                        }
                    }
                }
            }
            var in1 = [this.model.in,this.model.in2];
            var out = [this.model.out,this.model.out2];
            if (ok) {
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,this.it),list(out,this.ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/IntegerOp/DFLIPFLOP.sci" */
function DFLIPFLOP() {
    DFLIPFLOP.prototype.define = function DFLIPFLOP() {
        var scs_m = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["DFLIPFLOP"],tol=[0.0001,0.000001,1.000e-10,100001,0,0],tf=100000,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m.objs[1-1] = scicos_block(gui="CONST_m",graphics=scicos_graphics(orig=[109.62561,263.44465],sz=[[20],[20]],flip=true,theta=0,exprs="int8(0)",pin=[],pout=6,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim=list("cstblk4_m",4),in1=[],in2=[],intyp=1,out=1,out2=1,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(int8(0)),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[2-1] = scicos_block(gui="IFTHEL_f",graphics=scicos_graphics(orig=[239.98293,378.2166],sz=[60,60],flip=true,theta=0,exprs=[["1"],["1"]],pin=29,pout=[],pein=22,peout=[[16],[44]],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim=list("ifthel",-1),in1=1,in2=1,intyp=-1,out=[],out2=[],outtyp=1,evtin=1,evtout=[[1],[1]],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="l",firing=[-1,-1],dep_ut=[true,false],label="",nzcross=1,nmode=1,equations=list()),doc=list());
        scs_m.objs[3-1] = scicos_block(gui="LOGICAL_OP",graphics=scicos_graphics(orig=[152.88902,260.24498],sz=[60,40],flip=true,theta=0,exprs=[["2"],["1"],["5"],["0"]],pin=[[11],[39]],pout=5,pein=[],peout=[],gr_i=[],id="",in_implicit=[["E"],["E"]],out_implicit="E"),model=scicos_model(sim=list("logicalop_i8",4),in1=[[-1],[-1]],in2=[[-2],[-2]],intyp=[[5],[5]],out=-1,out2=-2,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[[1],[0]],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[4-1] = scicos_block(gui="SAMPHOLD_m",graphics=scicos_graphics(orig=[233.72156,260.24498],sz=[40,40],flip=true,theta=0,exprs="5",pin=5,pout=33,pein=42,peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("samphold4_m",4),in1=-1,in2=-2,intyp=5,out=-1,out2=-2,outtyp=5,evtin=1,evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="d",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[5-1] = scicos_link(xx=[[221.46044],[225.15013]],yy=[[280.24498],[280.24498]],id="drawlink",thick=[0,0],ct=[1,1],from=[3,1,0],to=[4,1,1]);
        scs_m.objs[6-1] = scicos_link(xx=[[138.19704],[140.34523]],yy=[[273.44465],[273.49157]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[38,1,1]);
        scs_m.objs[7-1] = scicos_block(gui="LOGICAL_OP",graphics=scicos_graphics(orig=[373.24106,309.46812],sz=[60,40],flip=true,theta=0,exprs=[["1"],["5"],["5"],["0"]],pin=36,pout=13,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("logicalop_i8",4),in1=-1,in2=-2,intyp=5,out=-1,out2=-2,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[[5],[0]],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[8-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[199.48466,398.2166],sz=[20,20],flip=true,theta=0,exprs="3",pin=[],pout=9,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=3,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[9-1] = scicos_link(xx=[[219.48466],[222.54128]],yy=[[408.2166],[408.2166]],id="drawlink",thick=[0,0],ct=[1,1],from=[8,1,0],to=[28,1,1]);
        scs_m.objs[10-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[104.31759,276.91165],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=11,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[11-1] = scicos_link(xx=[[124.31759],[144.31759]],yy=[[286.91165],[286.91165]],id="drawlink",thick=[0,0],ct=[1,1],from=[10,1,0],to=[3,1,1]);
        scs_m.objs[12-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[457.40928,320.20131],sz=[20,20],flip=true,theta=0,exprs="2",pin=13,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[13-1] = scicos_link(xx=[[441.81249],[457.40928]],yy=[[329.46812],[330.20131]],id="drawlink",thick=[0,0],ct=[1,1],from=[7,1,0],to=[12,1,1]);
        scs_m.objs[14-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[376.4669,270.83282],sz=[20,20],flip=true,theta=0,exprs="1",pin=37,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        var scs_m_1 = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title="Untitled",tol=[0.0001,0.000001,1.000e-10,100001,0,0],tf=100000,context=[],void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m_1.objs[1-1] = scicos_block(gui="ANDLOG_f",graphics=scicos_graphics(orig=[194,133],sz=[60,60],flip=true,theta=0,exprs=[],pin=[],pout=9,pein=[[4],[11]],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="andlog",in1=[],in2=[],intyp=1,out=1,out2=[],outtyp=1,evtin=[[1],[1]],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[2-1] = scicos_block(gui="CLKIN_f",graphics=scicos_graphics(orig=[149,287],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=[],pein=[],peout=4,gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=1,state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="d",firing=-1,dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[3-1] = scicos_block(gui="CLKOUT_f",graphics=scicos_graphics(orig=[450,83],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=[],pein=8,peout=[],gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="output",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[4-1] = scicos_link(xx=[[169],[214],[214]],yy=[[297],[297],[198.71]],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,1],to=[1,1]);
        scs_m_1.objs[5-1] = scicos_block(gui="CLKIN_f",graphics=scicos_graphics(orig=[141,330],sz=[20,20],flip=true,theta=0,exprs="2",pin=[],pout=[],pein=[],peout=6,gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=1,state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="d",firing=-1,dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[6-1] = scicos_link(xx=[[161],[234],[234]],yy=[[340],[340],[275.78]],id="drawlink",thick=[0,0],ct=[5,-1],from=[5,1],to=[10,1]);
        scs_m_1.objs[7-1] = scicos_block(gui="IFTHEL_f",graphics=scicos_graphics(orig=[331,137],sz=[60,60],flip=true,theta=0,exprs=[["1"],["1"]],pin=9,pout=[],pein=12,peout=[[8],[0]],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim=list("ifthel",-1),in1=1,in2=1,intyp=-1,out=[],out2=[],outtyp=1,evtin=1,evtout=[[1],[1]],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="l",firing=[-1,-1],dep_ut=[true,false],label="",nzcross=1,nmode=1,equations=list()),doc=list());
        scs_m_1.objs[8-1] = scicos_link(xx=[[351],[351],[450]],yy=[[131.29],[93],[93]],id="drawlink",thick=[0,0],ct=[5,-1],from=[7,1],to=[3,1]);
        scs_m_1.objs[9-1] = scicos_link(xx=[[262.57],[322.43]],yy=[[163],[167]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1],to=[7,1]);
        scs_m_1.objs[10-1] = scicos_block(gui="CLKSPLIT_f",graphics=scicos_graphics(orig=[[234],[275.78348]],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=[],pout=[],pein=6,peout=[[11],[12]],gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="split",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=[[1],[1]],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="d",firing=[false,false,false],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[11-1] = scicos_link(xx=[[234],[234]],yy=[[275.78],[198.71]],id="drawlink",thick=[0,0],ct=[5,-1],from=[10,1],to=[1,2]);
        scs_m_1.objs[12-1] = scicos_link(xx=[[234],[361],[361]],yy=[[275.78],[275.78],[202.71]],id="drawlink",thick=[0,0],ct=[5,-1],from=[10,2],to=[7,1]);
        scs_m.objs[15-1] = scicos_block(gui="ANDBLK",graphics=scicos_graphics(orig=[233.73039,318.74407],sz=[40,40],flip=true,theta=0,exprs=[],pin=[],pout=[],pein=[[19],[16]],peout=17,gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="csuper",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[[1],[1]],evtout=1,state=[],dstate=[],odstate=list(),rpar=scs_m_1,ipar=[],opar=list(),blocktype="h",firing=false,dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[16-1] = scicos_link(xx=[[259.98293],[260.39705]],yy=[[372.50232],[364.45835]],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,1,0],to=[15,2,1]);
        scs_m.objs[17-1] = scicos_link(xx=[[253.73039],[253.72572]],yy=[[313.02978],[309.29537]],id="drawlink",thick=[0,0],ct=[5,-1],from=[15,1,0],to=[41,1,1]);
        var scs_m_1 = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["EDGE_TRIGGER","./"],tol=[[0.0001],[0.000001],[1.000e-10],[100001],[0],[0],[0]],tf=30,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m_1.objs[1-1] = scicos_block(gui="EDGETRIGGER",graphics=scicos_graphics(orig=[288.58631,257.1131],sz=[60,40],flip=true,theta=0,exprs="1",pin=5,pout=3,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("edgetrig",4),in1=1,in2=[],intyp=1,out=1,out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=0,odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=1,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[2-1] = scicos_block(gui="IFTHEL_f",graphics=scicos_graphics(orig=[388.28869,247.1131],sz=[60,60],flip=true,theta=0,exprs=[["0"],["0"]],pin=3,pout=[],pein=[],peout=[[7],[0]],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim=list("ifthel",-1),in1=1,in2=[],intyp=1,out=[],out2=1,outtyp=[],evtin=[],evtout=[[1],[1]],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="l",firing=[-1,-1],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[3-1] = scicos_link(xx=[[357.15774],[362.99107],[379.71726]],yy=[[277.1131],[277.1131],[277.1131]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[2,1,1]);
        scs_m_1.objs[4-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[240.01488,267.1131],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=5,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=-1,out=-1,out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[5-1] = scicos_link(xx=[[260.01488],[280.01488]],yy=[[277.1131],[277.1131]],id="drawlink",thick=[0,0],ct=[1,1],from=[4,1,0],to=[1,1,1]);
        scs_m_1.objs[6-1] = scicos_block(gui="CLKOUTV_f",graphics=scicos_graphics(orig=[398.28869,181.39881],sz=[20,30],flip=true,theta=0,exprs="1",pin=[],pout=[],pein=7,peout=[],gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="output",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[7-1] = scicos_link(xx=[[408.28869],[408.28869]],yy=[[241.39881],[211.39881]],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,1,0],to=[6,1,1]);
        scs_m.objs[18-1] = scicos_block(gui="EDGE_TRIGGER",graphics=scicos_graphics(orig=[133.90637,385.342],sz=[60,40],flip=true,theta=0,exprs=[],pin=26,pout=[],pein=[],peout=19,gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="csuper",in1=-1,in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=1,state=[],dstate=[],odstate=list(),rpar=scs_m_1,ipar=[],opar=list(),blocktype="h",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[19-1] = scicos_link(xx=[[163.90637],[163.90637],[247.06372]],yy=[[379.62771],[364.45835],[364.45835]],id="drawlink",thick=[0,0],ct=[5,-1],from=[18,1,0],to=[15,1,1]);
        scs_m.objs[20-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[79.594811,395.47647],sz=[20,20],flip=true,theta=0,exprs="2",pin=[],pout=23,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        var scs_m_1 = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["Extract_Activation","./"],tol=[[0.0001],[0.000001],[1.000e-10],[100001],[0],[0],[0]],tf=30,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m_1.objs[1-1] = scicos_block(gui="IFTHEL_f",graphics=scicos_graphics(orig=[150.65045,143.82208],sz=[60,60],flip=true,theta=0,exprs=[["0"],["0"]],pin=6,pout=[],pein=[],peout=[[3],[4]],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim=list("ifthel",-1),in1=1,in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=[[1],[1]],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="l",firing=[-1,-1],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[2-1] = scicos_block(gui="CLKSOMV_f",graphics=scicos_graphics(orig=[169.82143,96.146231],sz=[16.666667,16.666667],flip=true,theta=0,exprs=[],pin=[],pout=[],pein=[[3],[4],[0]],peout=8,gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="sum",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[[1],[1],[1]],evtout=1,state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="d",firing=-1,dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[3-1] = scicos_link(xx=[[170.65045],[170.65045],[150.04302],[150.04302],[169.82143]],yy=[[138.10779],[128.235],[128.235],[104.47956],[104.47956]],id="drawlink",thick=[0,0],ct=[5,-1],from=[1,1,0],to=[2,1,1]);
        scs_m_1.objs[4-1] = scicos_link(xx=[[190.65045],[190.65045],[178.15476]],yy=[[138.10779],[111.55729],[112.8129]],id="drawlink",thick=[0,0],ct=[5,-1],from=[1,2,0],to=[2,2,1]);
        scs_m_1.objs[5-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[102.07902,163.82208],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=6,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=-1,out=-1,out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[6-1] = scicos_link(xx=[[122.07902],[142.07902]],yy=[[173.82208],[173.82208]],id="drawlink",thick=[0,0],ct=[1,1],from=[5,1,0],to=[1,1,1]);
        scs_m_1.objs[7-1] = scicos_block(gui="CLKOUTV_f",graphics=scicos_graphics(orig=[168.15476,38.527183],sz=[20,30],flip=true,theta=0,exprs="1",pin=[],pout=[],pein=8,peout=[],gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="output",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[8-1] = scicos_link(xx=[[178.15476],[178.15476]],yy=[[98.527183],[68.527183]],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,1,0],to=[7,1,1]);
        scs_m.objs[21-1] = scicos_block(gui="Extract_Activation",graphics=scicos_graphics(orig=[239.82193,456.57677],sz=[60,40],flip=true,theta=0,exprs=[],pin=31,pout=[],pein=[],peout=22,gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="csuper",in1=-1,in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=1,state=[],dstate=[],odstate=list(),rpar=scs_m_1,ipar=[],opar=list(),blocktype="h",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[22-1] = scicos_link(xx=[[269.82193],[269.98293]],yy=[[450.86248],[443.93089]],id="drawlink",thick=[0,0],ct=[5,-1],from=[21,1,0],to=[2,1,1]);
        scs_m.objs[23-1] = scicos_link(xx=[[99.594811],[110.25582]],yy=[[405.47647],[405.42077]],id="drawlink",thick=[0,0],ct=[1,1],from=[20,1,0],to=[25,1,1]);
        scs_m.objs[24-1] = scicos_block(gui="SUM_f",graphics=scicos_graphics(orig=[200.5252,469.13173],sz=[16.666667,16.666667],flip=true,theta=0,exprs=[],pin=[[27],[0],[30]],pout=31,pein=[],peout=[],gr_i=[],id="",in_implicit=[["E"],["E"],["E"]],out_implicit="E"),model=scicos_model(sim=list("plusblk",2),in1=[[-1],[-1],[-1]],in2=[],intyp=1,out=-1,out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[25-1] = scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[[110.25582],[405.42077]],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=23,pout=[[26],[27]],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[["E"],["E"],["E"]]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[[-1],[-1],[-1]],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[26-1] = scicos_link(xx=[[110.25582],[114.33667],[125.33494]],yy=[[405.42077],[405.39945],[405.342]],id="drawlink",thick=[0,0],ct=[1,1],from=[25,1,0],to=[18,1,1]);
        scs_m.objs[27-1] = scicos_link(xx=[[110.25582],[110.25582],[208.85853]],yy=[[405.42077],[469.13173],[469.13173]],id="drawlink",thick=[0,0],ct=[1,1],from=[25,2,0],to=[24,1,1]);
        scs_m.objs[28-1] = scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[[222.54128],[408.2166]],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=9,pout=[[29],[30]],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[["E"],["E"],["E"]]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[[-1],[-1],[-1]],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[29-1] = scicos_link(xx=[[222.54128],[231.4115]],yy=[[408.2166],[408.2166]],id="drawlink",thick=[0,0],ct=[1,1],from=[28,1,0],to=[2,1,1]);
        scs_m.objs[30-1] = scicos_link(xx=[[222.54128],[222.54128],[208.85853],[208.85853]],yy=[[408.2166],[453.0015],[453.0015],[485.7984]],id="drawlink",thick=[0,0],ct=[1,1],from=[28,2,0],to=[24,3,1]);
        scs_m.objs[31-1] = scicos_link(xx=[[219.57282],[231.2505]],yy=[[477.46506],[476.57677]],id="drawlink",thick=[0,0],ct=[1,1],from=[24,1,0],to=[21,1,1]);
        scs_m.objs[32-1] = scicos_block(gui="SELECT_m",graphics=scicos_graphics(orig=[298.86371,253.57321],sz=[40,40],flip=true,theta=0,exprs=[["5"],["2"],["1"]],pin=[[33],[40]],pout=34,pein=[[43],[44]],peout=[],gr_i=[],id="",in_implicit=[["E"],["E"]],out_implicit="E"),model=scicos_model(sim=list("selector_m",4),in1=[[-1],[-1]],in2=[[-2],[-2]],intyp=[[5],[5]],out=-1,out2=-2,outtyp=5,evtin=[[1],[1]],evtout=[],state=[],dstate=1,odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[33-1] = scicos_link(xx=[[282.29299],[290.29229]],yy=[[280.24498],[280.23987]],id="drawlink",thick=[0,0],ct=[1,1],from=[4,1,0],to=[32,1,1]);
        scs_m.objs[34-1] = scicos_link(xx=[[347.43514],[357.57328],[357.57328]],yy=[[273.57321],[273.57321],[280.83282]],id="drawlink",thick=[0,0],ct=[1,1],from=[32,1,0],to=[35,1,1]);
        scs_m.objs[35-1] = scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[357.57328,280.83282],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=34,pout=[[36],[37]],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[["E"],["E"],["E"]]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[[-1],[-1],[-1]],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[36-1] = scicos_link(xx=[[357.57328],[357.57328],[364.66964]],yy=[[280.83282],[329.46812],[329.46812]],id="drawlink",thick=[0,0],ct=[1,1],from=[35,1,0],to=[7,1,1]);
        scs_m.objs[37-1] = scicos_link(xx=[[357.57328],[376.4669]],yy=[[280.83282],[280.83282]],id="drawlink",thick=[0,0],ct=[1,1],from=[35,2,0],to=[14,1,1]);
        scs_m.objs[38-1] = scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[[140.34523],[273.49157]],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=6,pout=[[39],[40]],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[["E"],["E"],["E"]]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[[-1],[-1],[-1]],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[39-1] = scicos_link(xx=[[140.34523],[144.31759]],yy=[[273.49157],[273.57832]],id="drawlink",thick=[0,0],ct=[1,1],from=[38,1,0],to=[3,2,1]);
        scs_m.objs[40-1] = scicos_link(xx=[[140.34523],[140.34523],[290.29229],[290.29229]],yy=[[273.49157],[247.70767],[247.70767],[266.90654]],id="drawlink",thick=[0,0],ct=[1,1],from=[38,2,0],to=[32,2,1]);
        scs_m.objs[41-1] = scicos_block(gui="CLKSPLIT_f",graphics=scicos_graphics(orig=[[253.72572],[309.29537]],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=[],pout=[],pein=17,peout=[[42],[43]],gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="split",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=[[1],[1]],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="d",firing=[false,false,false],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[42-1] = scicos_link(xx=[[253.72572],[253.72156]],yy=[[309.29537],[305.95927]],id="drawlink",thick=[0,0],ct=[5,-1],from=[41,1,0],to=[4,1,1]);
        scs_m.objs[43-1] = scicos_link(xx=[[253.72572],[312.19705],[312.19705]],yy=[[309.29537],[309.29537],[299.28749]],id="drawlink",thick=[0,0],ct=[5,-1],from=[41,2,0],to=[32,1,1]);
        scs_m.objs[44-1] = scicos_link(xx=[[279.98293],[279.98293],[325.53038],[325.53038]],yy=[[372.50232],[315.89455],[315.89455],[299.28749]],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,2,0],to=[32,2,1]);
        this.model = scicos_model();
        this.model.sim = new ScilabString(["csuper"]);
        this.model.in = new ScilabDouble([1],[1],[1]);
        this.model.in2 = new ScilabDouble([1],[1],[1]);
        this.model.out = new ScilabDouble([1],[1]);
        this.model.out2 = new ScilabDouble([1],[1]);
        this.model.intyp = new ScilabDouble([5,1,1]);
        this.model.outtyp = new ScilabDouble([5,5]);
        this.model.blocktype = new ScilabString(["h"]);
        this.model.firing = new ScilabBoolean([false]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.model.rpar = new ScilabDouble([scs_m]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"DFLIPFLOP\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,3]),this.model,new ScilabDouble([]),this.gr_i);
        return new BasicBlock(this.x);
    }
    DFLIPFLOP.prototype.details = function DFLIPFLOP() {
        return this.x;
    }
    DFLIPFLOP.prototype.get = function DFLIPFLOP() {
        alert("parameters cannot be modified");
    }
    DFLIPFLOP.prototype.set = function DFLIPFLOP() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/IntegerOp/DLATCH.sci" */
function DLATCH() {
    DLATCH.prototype.define = function DLATCH() {
        var scs_m = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["DLATCH"],tol=[0.0001,0.000001,1.000e-10,100001,0,0],tf=100000,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m.objs[1-1] = scicos_block(gui="CONST_m",graphics=scicos_graphics(orig=[109.62561,263.44465],sz=[[20],[20]],flip=true,theta=0,exprs="int8(0)",pin=[],pout=7,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim=list("cstblk4_m",4),in1=[],in2=[],intyp=1,out=1,out2=1,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(int8(0)),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[2-1] = scicos_block(gui="IFTHEL_f",graphics=scicos_graphics(orig=[233.37693,320.30536],sz=[60,60],flip=true,theta=0,exprs=[["0"],["1"]],pin=13,pout=[],pein=[],peout=[[6],[0]],gr_i=list([["txt=[\'If in>0\';\' \';\' then    else\'];"],["xstringb(orig(1),orig(2),txt,sz(1),sz(2),\'fill\');"]],8),id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim=list("ifthel",-1),in1=1,in2=1,intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[[1],[1]],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="l",firing=[-1,-1],dep_ut=[true,false],label="",nzcross=1,nmode=1,equations=list()),doc=list());
        scs_m.objs[3-1] = scicos_block(gui="LOGICAL_OP",graphics=scicos_graphics(orig=[152.88902,260.24498],sz=[60,40],flip=true,theta=0,exprs=[["2"],["1"],["5"],["0"]],pin=[[15],[7]],pout=5,pein=[],peout=[],gr_i=list("xstringb(orig(1),orig(2),[\'Logical Op \';OPER],sz(1),sz(2),\'fill\');",8),id="",in_implicit=[["E"],["E"]],out_implicit="E"),model=scicos_model(sim=list("logicalop_i8",4),in1=[[-1],[-1]],in2=[[-2],[-2]],intyp=[[5],[5]],out=-1,out2=-2,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[[1],[0]],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[4-1] = scicos_block(gui="SAMPHOLD_m",graphics=scicos_graphics(orig=[233.72156,260.24498],sz=[40,40],flip=true,theta=0,exprs="5",pin=5,pout=9,pein=6,peout=[],gr_i=list("xstringb(orig(1),orig(2),\'S/H\',sz(1),sz(2),\'fill\')",8),id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("samphold4_m",4),in1=-1,in2=-2,intyp=5,out=-1,out2=-2,outtyp=5,evtin=1,evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="d",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[5-1] = scicos_link(xx=[[221.46044],[225.15013]],yy=[[280.24498],[280.24498]],id="drawlink",thick=[0,0],ct=[1,1],from=[3,1,0],to=[4,1,1]);
        scs_m.objs[6-1] = scicos_link(xx=[[253.37693],[253.72156]],yy=[[314.59108],[305.95927]],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,1,0],to=[4,1,1]);
        scs_m.objs[7-1] = scicos_link(xx=[[138.19704],[144.31759]],yy=[[273.44465],[273.57832]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[3,2,1]);
        scs_m.objs[8-1] = scicos_block(gui="LOGICAL_OP",graphics=scicos_graphics(orig=[317.46698,309.46812],sz=[60,40],flip=true,theta=0,exprs=[["1"],["5"],["5"],["0"]],pin=11,pout=17,pein=[],peout=[],gr_i=list("xstringb(orig(1),orig(2),[\'Logical Op \';OPER],sz(1),sz(2),\'fill\');",8),id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("logicalop_i8",4),in1=-1,in2=-2,intyp=5,out=-1,out2=-2,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[[5],[0]],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[9-1] = scicos_link(xx=[[282.29299],[305.09603],[305.09603]],yy=[[280.24498],[280.52797],[280.83282]],id="drawlink",thick=[0,0],ct=[1,1],from=[4,1,0],to=[10,1,1]);
        scs_m.objs[10-1] = scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[305.09603,280.83282],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=9,pout=[[11],[19]],pein=[],peout=[],gr_i=list([],8),id="",in_implicit="E",out_implicit=[["E"],["E"],["E"]]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[[-1],[-1],[-1]],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[11-1] = scicos_link(xx=[[305.09603],[305.09603],[308.89555]],yy=[[280.83282],[329.46812],[329.46812]],id="drawlink",thick=[0,0],ct=[1,1],from=[10,1,0],to=[8,1,1]);
        scs_m.objs[12-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[184.8055,340.30536],sz=[20,20],flip=true,theta=0,exprs="2",pin=[],pout=13,pein=[],peout=[],gr_i=list(" ",8),id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[13-1] = scicos_link(xx=[[204.8055],[224.8055]],yy=[[350.30536],[350.30536]],id="drawlink",thick=[0,0],ct=[1,1],from=[12,1,0],to=[2,1,1]);
        scs_m.objs[14-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[104.31759,276.91165],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=15,pein=[],peout=[],gr_i=list(" ",8),id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[15-1] = scicos_link(xx=[[124.31759],[144.31759]],yy=[[286.91165],[286.91165]],id="drawlink",thick=[0,0],ct=[1,1],from=[14,1,0],to=[3,1,1]);
        scs_m.objs[16-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[406.03841,319.46812],sz=[20,20],flip=true,theta=0,exprs="2",pin=17,pout=[],pein=[],peout=[],gr_i=list(" ",8),id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[17-1] = scicos_link(xx=[[386.03841],[406.03841]],yy=[[329.46812],[329.46812]],id="drawlink",thick=[0,0],ct=[1,1],from=[8,1,0],to=[16,1,1]);
        scs_m.objs[18-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[325.09603,270.83282],sz=[20,20],flip=true,theta=0,exprs="1",pin=19,pout=[],pein=[],peout=[],gr_i=list(" ",8),id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[19-1] = scicos_link(xx=[[305.09603],[325.09603]],yy=[[280.83282],[280.83282]],id="drawlink",thick=[0,0],ct=[1,1],from=[10,2,0],to=[18,1,1]);
        this.model = scicos_model();
        this.model.sim = new ScilabString(["csuper"]);
        this.model.in = new ScilabDouble([1],[1]);
        this.model.in2 = new ScilabDouble([1],[1]);
        this.model.out = new ScilabDouble([1],[1]);
        this.model.out2 = new ScilabDouble([1],[1]);
        this.model.intyp = new ScilabDouble([5,-1]);
        this.model.outtyp = new ScilabDouble([5,5]);
        this.model.blocktype = new ScilabString(["h"]);
        this.model.firing = new ScilabBoolean([false]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.model.rpar = new ScilabDouble([scs_m]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"DLATCH\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,3]),this.model,new ScilabDouble([]),this.gr_i);
        return new BasicBlock(this.x);
    }
    DLATCH.prototype.details = function DLATCH() {
        return this.x;
    }
    DLATCH.prototype.get = function DLATCH() {
        alert("parameters cannot be modified");
    }
    DLATCH.prototype.set = function DLATCH() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/IntegerOp/EXTRACTBITS.sci" */
function EXTRACTBITS() {
    EXTRACTBITS.prototype.define = function EXTRACTBITS() {
        var numb = [];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["extract_bit_32_UH0"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([1]);
        this.model.in2 = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.out2 = new ScilabDouble([1]);
        this.model.intyp = new ScilabDouble([3]);
        this.model.outtyp = new ScilabDouble([3]);
        this.model.ipar = new ScilabDouble([0,numb]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[sci2exp(3)],[sci2exp(1)],[sci2exp(0)],[sci2exp(0)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"EXTRACTBITS\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([4,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    EXTRACTBITS.prototype.details = function EXTRACTBITS() {
        return this.x;
    }
    EXTRACTBITS.prototype.get = function EXTRACTBITS() {
        var options = {
            Datatype:[msprintf("Data Type %s","(3:int32, 4:int16, 5:int8, ...)"),this.Datatype],
            rule:["Bits to extract",this.rule],
            bit:["Number of Bits or Index of Bit",this.bit],
            scal:["Treat Bit Field as an Integer (0:No, 1:Yes)",this.scal],
        }
        return options;
    }
    EXTRACTBITS.prototype.set = function EXTRACTBITS() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.Datatype = arguments[0]["Datatype"];
            this.rule = parseFloat(arguments[0]["rule"]);
            this.bit = parseFloat(arguments[0]["bit"]);
            this.scal = arguments[0]["scal"];
            if (!ok) {
                break;
            }
            var bitstr = strcat(string(this.bit.slice())," ");
            if ((this.rule<1)||(this.rule>5)) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Bits to Extract",this.rule),msprintf("Must be in the interval %s.","[1, 5]"));
                var ok = false;
            } else if (this.scal<0||this.scal>1) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Treat Bit Field as an Integer",this.scal),msprintf("Must be in the interval %s.","[0, 1]"));
                var ok = false;
            } else {
                var in1 = [this.model.in,this.model.in2];
                this.bit = int(this.bit);
                this.rule = int(this.rule);
                if ((this.rule==3)||(this.rule==4)) {
                    if ((size(this.bit,"*")!=1)) {
                        block_parameter_error(msprintf("Wrong size for \'%s\' parameter: %s.","Number of Bits or Index of Bit",bitstr),"Must be a single value.");
                        var ok = false;
                    } else {
                        var numb = this.bit;
                    }
                } else if ((this.rule==5)) {
                    if ((size(this.bit,"*")!=2)) {
                        block_parameter_error(msprintf("Wrong size for \'%s\' parameter: %s.","Number of Bits or Index of Bit",bitstr),"Must have this form: [Start, End].");
                        var ok = false;
                    } else if (this.bit[1-1]>this.bit[2-1]) {
                        block_parameter_error(msprintf("Wrong values for \'%s\' parameter: %s.","Number of Bits or Index of Bit",bitstr),msprintf("\'Start\' must be less than \'End\'."));
                        var ok = false;
                    } else {
                        var numb = this.bit[2-1]-this.bit[1-1];
                    }
                } else {
                    this.bit = 0;
                    var numb = [];
                }
            }
            if (ok) {
                if ((this.Datatype==3||this.Datatype==6)) {
                    if (or(this.bit.slice()>31)||or(this.bit.slice()<0)) {
                        block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %s.","Number of Bits or Index of Bit",bitstr),msprintf("Indexes must be in the interval %s.","[0, 31]"));
                        var ok = false;
                    }
                    switch (this.rule) {
                    case 1:
                        switch (this.scal) {
                        case 0:
                            this.model.sim = list(new ScilabString(["extract_bit_32_UH0"]), new ScilabDouble([4]));
                        case 1:
                            switch (this.Datatype) {
                            case 3:
                                this.model.sim = list(new ScilabString(["extract_bit_32_UH1"]), new ScilabDouble([4]));
                            case 6:
                                this.model.sim = list(new ScilabString(["extract_bit_u32_UH1"]), new ScilabDouble([4]));
                            }
                        }
                    case 2:
                        this.model.sim = list(new ScilabString(["extract_bit_32_LH"]), new ScilabDouble([4]));
                    case 3:
                        switch (this.scal) {
                        case 0:
                            this.model.sim = list(new ScilabString(["extract_bit_32_MSB0"]), new ScilabDouble([4]));
                        case 1:
                            switch (this.Datatype) {
                            case 3:
                                this.model.sim = list(new ScilabString(["extract_bit_32_MSB1"]), new ScilabDouble([4]));
                            case 6:
                                this.model.sim = list(new ScilabString(["extract_bit_u32_MSB1"]), new ScilabDouble([4]));
                            }
                        }
                    case 4:
                        this.model.sim = list(new ScilabString(["extract_bit_32_LSB"]), new ScilabDouble([4]));
                    case 5:
                        switch (this.scal) {
                        case 0:
                            this.model.sim = list(new ScilabString(["extract_bit_32_RB0"]), new ScilabDouble([4]));
                        case 1:
                            switch (this.Datatype) {
                            case 3:
                                this.model.sim = list(new ScilabString(["extract_bit_32_RB1"]), new ScilabDouble([4]));
                            case 6:
                                this.model.sim = list(new ScilabString(["extract_bit_u32_RB1"]), new ScilabDouble([4]));
                            }
                        }
                    }
                } else if ((this.Datatype==4||this.Datatype==7)) {
                    if (or(this.bit.slice()>15)||or(this.bit.slice()<0)) {
                        block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %s.","Number of Bits or Index of Bit",bitstr),msprintf("Indexes must be in the interval %s.","[0, 15]"));
                        var ok = false;
                    }
                    switch (this.rule) {
                    case 1:
                        switch (this.scal) {
                        case 0:
                            this.model.sim = list(new ScilabString(["extract_bit_16_UH0"]), new ScilabDouble([4]));
                        case 1:
                            switch (this.Datatype) {
                            case 4:
                                this.model.sim = list(new ScilabString(["extract_bit_16_UH1"]), new ScilabDouble([4]));
                            case 7:
                                this.model.sim = list(new ScilabString(["extract_bit_u16_UH1"]), new ScilabDouble([4]));
                            }
                        }
                    case 2:
                        this.model.sim = list(new ScilabString(["extract_bit_16_LH"]), new ScilabDouble([4]));
                    case 3:
                        switch (this.scal) {
                        case 0:
                            this.model.sim = list(new ScilabString(["extract_bit_16_MSB0"]), new ScilabDouble([4]));
                        case 1:
                            switch (this.Datatype) {
                            case 4:
                                this.model.sim = list(new ScilabString(["extract_bit_16_MSB1"]), new ScilabDouble([4]));
                            case 7:
                                this.model.sim = list(new ScilabString(["extract_bit_u16_MSB1"]), new ScilabDouble([4]));
                            }
                        }
                    case 4:
                        this.model.sim = list(new ScilabString(["extract_bit_16_LSB"]), new ScilabDouble([4]));
                    case 5:
                        switch (this.scal) {
                        case 0:
                            this.model.sim = list(new ScilabString(["extract_bit_16_RB0"]), new ScilabDouble([4]));
                        case 1:
                            switch (this.Datatype) {
                            case 4:
                                this.model.sim = list(new ScilabString(["extract_bit_16_RB1"]), new ScilabDouble([4]));
                            case 7:
                                this.model.sim = list(new ScilabString(["extract_bit_u16_RB1"]), new ScilabDouble([4]));
                            }
                        }
                    }
                } else if ((this.Datatype==5||this.Datatype==8)) {
                    if (or(this.bit.slice()>7)||or(this.bit.slice()<0)) {
                        block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %s.","Number of Bits or Index of Bit",bitstr),msprintf("Indexes must be in the interval %s.","[0, 7]"));
                        var ok = false;
                    }
                    switch (this.rule) {
                    case 1:
                        switch (this.scal) {
                        case 0:
                            this.model.sim = list(new ScilabString(["extract_bit_8_UH0"]), new ScilabDouble([4]));
                        case 1:
                            switch (this.Datatype) {
                            case 5:
                                this.model.sim = list(new ScilabString(["extract_bit_8_UH1"]), new ScilabDouble([4]));
                            case 8:
                                this.model.sim = list(new ScilabString(["extract_bit_u8_UH1"]), new ScilabDouble([4]));
                            }
                        }
                    case 2:
                        this.model.sim = list(new ScilabString(["extract_bit_8_LH"]), new ScilabDouble([4]));
                    case 3:
                        switch (this.scal) {
                        case 0:
                            this.model.sim = list(new ScilabString(["extract_bit_8_MSB0"]), new ScilabDouble([4]));
                        case 1:
                            switch (this.Datatype) {
                            case 5:
                                this.model.sim = list(new ScilabString(["extract_bit_8_MSB1"]), new ScilabDouble([4]));
                            case 8:
                                this.model.sim = list(new ScilabString(["extract_bit_u8_MSB1"]), new ScilabDouble([4]));
                            }
                        }
                    case 4:
                        this.model.sim = list(new ScilabString(["extract_bit_8_LSB"]), new ScilabDouble([4]));
                    case 5:
                        switch (this.scal) {
                        case 0:
                            this.model.sim = list(new ScilabString(["extract_bit_8_RB0"]), new ScilabDouble([4]));
                        case 1:
                            switch (this.Datatype) {
                            case 5:
                                this.model.sim = list(new ScilabString(["extract_bit_8_RB1"]), new ScilabDouble([4]));
                            case 8:
                                this.model.sim = list(new ScilabString(["extract_bit_u8_RB1"]), new ScilabDouble([4]));
                            }
                        }
                    }
                } else {
                    block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Data Type",this.Datatype),msprintf("Must be in the interval %s.","[3, 8]"));
                    var ok = false;
                }
            }
            if (ok) {
                var it = this.Datatype;
                var ot = this.Datatype;
                var out = [1,1];
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.ipar = new ScilabDouble([int(this.bit.slice())],[int(numb.slice())]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/IntegerOp/INTMUL.sci" */
function INTMUL() {
    INTMUL.prototype.define = function INTMUL() {
        var sgn = 0;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["matmul_i32"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([-1],[-2]);
        this.model.out = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2],[-3]);
        this.model.out2 = new ScilabDouble([-3]);
        this.model.intyp = new ScilabDouble([3,3]);
        this.model.outtyp = new ScilabDouble([3]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([sgn]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[sci2exp(3)],[sci2exp(0)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"INTMUL\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    INTMUL.prototype.details = function INTMUL() {
        return this.x;
    }
    INTMUL.prototype.get = function INTMUL() {
        var options = {
            Datatype:[msprintf("Data Type %s","(3:int32, 4:int16, 5:int8, ...)"),this.Datatype],
            np:["Do on Overflow (0:Nothing, 1:Saturate, 2:Error)",this.np],
        }
        return options;
    }
    INTMUL.prototype.set = function INTMUL() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.Datatype = arguments[0]["Datatype"];
            this.np = arguments[0]["np"];
            if (!ok) {
                break;
            }
            var it = this.Datatype*ones(1,2);
            var ot = this.Datatype;
            if ((this.np!=0&&this.np!=1&&this.np!=2)) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Do on Overflow",this.np),msprintf("Must be in the interval %s.","[0, 2]"));
                var ok = false;
            } else if (this.Datatype==3) {
                if (this.np==0) {
                    this.model.sim = list(new ScilabString(["matmul_i32n"]), new ScilabDouble([4]));
                } else if (this.np==1) {
                    this.model.sim = list(new ScilabString(["matmul_i32s"]), new ScilabDouble([4]));
                } else {
                    this.model.sim = list(new ScilabString(["matmul_i32e"]), new ScilabDouble([4]));
                }
            } else if (this.Datatype==4) {
                if (this.np==0) {
                    this.model.sim = list(new ScilabString(["matmul_i16n"]), new ScilabDouble([4]));
                } else if (this.np==1) {
                    this.model.sim = list(new ScilabString(["matmul_i16s"]), new ScilabDouble([4]));
                } else {
                    this.model.sim = list(new ScilabString(["matmul_i16e"]), new ScilabDouble([4]));
                }
            } else if (this.Datatype==5) {
                if (this.np==0) {
                    this.model.sim = list(new ScilabString(["matmul_i8n"]), new ScilabDouble([4]));
                } else if (this.np==1) {
                    this.model.sim = list(new ScilabString(["matmul_i8s"]), new ScilabDouble([4]));
                } else {
                    this.model.sim = list(new ScilabString(["matmul_i8e"]), new ScilabDouble([4]));
                }
            } else if (this.Datatype==6) {
                if (this.np==0) {
                    this.model.sim = list(new ScilabString(["matmul_ui32n"]), new ScilabDouble([4]));
                } else if (this.np==1) {
                    this.model.sim = list(new ScilabString(["matmul_ui32s"]), new ScilabDouble([4]));
                } else {
                    this.model.sim = list(new ScilabString(["matmul_ui32e"]), new ScilabDouble([4]));
                }
            } else if (this.Datatype==7) {
                if (this.np==0) {
                    this.model.sim = list(new ScilabString(["matmul_ui16n"]), new ScilabDouble([4]));
                } else if (this.np==1) {
                    this.model.sim = list(new ScilabString(["matmul_ui16s"]), new ScilabDouble([4]));
                } else {
                    this.model.sim = list(new ScilabString(["matmul_ui16e"]), new ScilabDouble([4]));
                }
            } else if (this.Datatype==8) {
                if (this.np==0) {
                    this.model.sim = list(new ScilabString(["matmul_ui8n"]), new ScilabDouble([4]));
                } else if (this.np==1) {
                    this.model.sim = list(new ScilabString(["matmul_ui8s"]), new ScilabDouble([4]));
                } else {
                    this.model.sim = list(new ScilabString(["matmul_ui8e"]), new ScilabDouble([4]));
                }
            } else {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Data Type",ot),msprintf("Must be in the interval %s.","[3, 8]"));
                var ok = false;
            }
            var in1 = [this.model.in,this.model.in2];
            var out = [this.model.out,this.model.out2];
            if (ok) {
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.model.ipar = new ScilabDouble([this.np]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/IntegerOp/JKFLIPFLOP.sci" */
function JKFLIPFLOP() {
    JKFLIPFLOP.prototype.define = function JKFLIPFLOP() {
        var scs_m = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["JKFLIPFLOP"],tol=[[0.0001],[0.000001],[1.000e-10],[100001],[0],[0],[0]],tf=60,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m.objs[1-1] = scicos_block(gui="DOLLAR_m",graphics=scicos_graphics(orig=[299.96961,261.584],sz=[40,40],flip=false,theta=0,exprs=[["int8(0)"],["1"]],pin=7,pout=5,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("dollar4_m",4),in1=1,in2=1,intyp=5,out=1,out2=1,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(int8(0)),rpar=[],ipar=[],opar=list(),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        var scs_m_1 = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["EDGE_TRIGGER","./"],tol=[[0.0001],[0.000001],[1.000e-10],[100001],[0],[0],[0]],tf=30,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m_1.objs[1-1] = scicos_block(gui="EDGETRIGGER",graphics=scicos_graphics(orig=[288.58631,257.1131],sz=[60,40],flip=true,theta=0,exprs="-1",pin=5,pout=3,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("edgetrig",4),in1=1,in2=[],intyp=1,out=1,out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=0,odstate=list(),rpar=[],ipar=-1,opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=1,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[2-1] = scicos_block(gui="IFTHEL_f",graphics=scicos_graphics(orig=[388.28869,247.1131],sz=[60,60],flip=true,theta=0,exprs=[["0"],["0"]],pin=3,pout=[],pein=[],peout=[[7],[0]],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim=list("ifthel",-1),in1=1,in2=[],intyp=1,out=[],out2=1,outtyp=[],evtin=[],evtout=[[1],[1]],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="l",firing=[-1,-1],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[3-1] = scicos_link(xx=[[357.15774],[362.99107],[379.71726]],yy=[[277.1131],[277.1131],[277.1131]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[2,1,1]);
        scs_m_1.objs[4-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[240.01488,267.1131],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=5,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[5-1] = scicos_link(xx=[[260.01488],[280.01488]],yy=[[277.1131],[277.1131]],id="drawlink",thick=[0,0],ct=[1,1],from=[4,1,0],to=[1,1,1]);
        scs_m_1.objs[6-1] = scicos_block(gui="CLKOUTV_f",graphics=scicos_graphics(orig=[398.28869,181.39881],sz=[20,30],flip=true,theta=0,exprs="1",pin=[],pout=[],pein=7,peout=[],gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="output",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[7-1] = scicos_link(xx=[[408.28869],[408.28869]],yy=[[241.39881],[211.39881]],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,1,0],to=[6,1,1]);
        scs_m.objs[2-1] = scicos_block(gui="EDGE_TRIGGER",graphics=scicos_graphics(orig=[292.52452,323.54888],sz=[60,40],flip=true,theta=0,exprs=[],pin=14,pout=[],pein=[],peout=8,gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="csuper",in1=-1,in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=1,state=[],dstate=[],odstate=list(),rpar=scs_m_1,ipar=[],opar=list(),blocktype="h",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[3-1] = scicos_block(gui="LOGIC",graphics=scicos_graphics(orig=[302.79613,202.52782],sz=[40,40],flip=true,theta=0,exprs=[["[0;1;1;1;0;0;1;0]"],["0"]],pin=[[5],[16],[18]],pout=4,pein=8,peout=[],gr_i=[],id="",in_implicit=[["E"],["E"],["E"]],out_implicit="E"),model=scicos_model(sim=list("logic",4),in1=[[1],[1],[1]],in2=[[1],[1],[1]],intyp=[[5],[5],[5]],out=1,out2=1,outtyp=5,evtin=1,evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(int8([[0],[1],[1],[1],[0],[0],[1],[0]])),blocktype="c",firing=false,dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[4-1] = scicos_link(xx=[[351.36756],[368.82793],[368.82793]],yy=[[222.52782],[222.52782],[223.06473]],id="drawlink",thick=[0,0],ct=[1,1],from=[3,1,0],to=[10,1,1]);
        scs_m.objs[5-1] = scicos_link(xx=[[291.39818],[274.18235],[274.18235],[294.2247]],yy=[[281.584],[281.584],[232.52782],[232.52782]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[3,1,1]);
        scs_m.objs[6-1] = scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[368.82793,243.45067],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=11,pout=[[7],[20]],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[["E"],["E"],["E"]]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[[-1],[-1],[-1]],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[7-1] = scicos_link(xx=[[368.82793],[368.82793],[345.68389]],yy=[[243.45067],[281.584],[281.584]],id="drawlink",thick=[0,0],ct=[1,1],from=[6,1,0],to=[1,1,1]);
        scs_m.objs[8-1] = scicos_link(xx=[[322.52452],[374.69743],[374.69743],[322.79613]],yy=[[317.8346],[317.8346],[248.24211],[248.24211]],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,1,0],to=[3,1,1]);
        scs_m.objs[9-1] = scicos_block(gui="LOGICAL_OP",graphics=scicos_graphics(orig=[377.63217,159.25363],sz=[60,40],flip=true,theta=0,exprs=[["1"],["5"],["5"],["0"]],pin=12,pout=22,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("logicalop_i8",4),in1=-1,in2=-2,intyp=5,out=-1,out2=-2,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[[5],[0]],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[10-1] = scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[[368.82793],[223.06473]],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=4,pout=[[11],[12]],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[["E"],["E"],["E"]]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[[-1],[-1],[-1]],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[11-1] = scicos_link(xx=[[368.82793],[368.82793]],yy=[[223.06473],[243.45067]],id="drawlink",thick=[0,0],ct=[1,1],from=[10,1,0],to=[6,1,1]);
        scs_m.objs[12-1] = scicos_link(xx=[[368.82793],[368.82793],[369.06074]],yy=[[223.06473],[177.7867],[179.25363]],id="drawlink",thick=[0,0],ct=[1,1],from=[10,2,0],to=[9,1,1]);
        scs_m.objs[13-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[243.95309,333.54888],sz=[20,20],flip=true,theta=0,exprs="2",pin=[],pout=14,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[14-1] = scicos_link(xx=[[263.95309],[283.95309]],yy=[[343.54888],[343.54888]],id="drawlink",thick=[0,0],ct=[1,1],from=[13,1,0],to=[2,1,1]);
        scs_m.objs[15-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[254.2247,212.52782],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=16,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[16-1] = scicos_link(xx=[[274.2247],[294.2247]],yy=[[222.52782],[222.52782]],id="drawlink",thick=[0,0],ct=[1,1],from=[15,1,0],to=[3,2,1]);
        scs_m.objs[17-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[254.2247,202.52782],sz=[20,20],flip=true,theta=0,exprs="3",pin=[],pout=18,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=3,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[18-1] = scicos_link(xx=[[274.2247],[294.2247]],yy=[[212.52782],[212.52782]],id="drawlink",thick=[0,0],ct=[1,1],from=[17,1,0],to=[3,3,1]);
        scs_m.objs[19-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[388.82793,233.45067],sz=[20,20],flip=true,theta=0,exprs="1",pin=20,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[20-1] = scicos_link(xx=[[368.82793],[388.82793]],yy=[[243.45067],[243.45067]],id="drawlink",thick=[0,0],ct=[1,1],from=[6,2,0],to=[19,1,1]);
        scs_m.objs[21-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[466.2036,169.25363],sz=[20,20],flip=true,theta=0,exprs="2",pin=22,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[22-1] = scicos_link(xx=[[446.2036],[466.2036]],yy=[[179.25363],[179.25363]],id="drawlink",thick=[0,0],ct=[1,1],from=[9,1,0],to=[21,1,1]);
        this.model = scicos_model();
        this.model.sim = new ScilabString(["csuper"]);
        this.model.in = new ScilabDouble([1],[1],[1]);
        this.model.in2 = new ScilabDouble([1],[1],[1]);
        this.model.out = new ScilabDouble([1],[1]);
        this.model.out2 = new ScilabDouble([1],[1]);
        this.model.intyp = new ScilabDouble([5,1,5]);
        this.model.outtyp = new ScilabDouble([5,5]);
        this.model.blocktype = new ScilabString(["h"]);
        this.model.firing = new ScilabBoolean([false]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.model.rpar = new ScilabDouble([scs_m]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"JKFLIPFLOP\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,3]),this.model,new ScilabDouble([]),this.gr_i);
        return new BasicBlock(this.x);
    }
    JKFLIPFLOP.prototype.details = function JKFLIPFLOP() {
        return this.x;
    }
    JKFLIPFLOP.prototype.get = function JKFLIPFLOP() {
        var options = {
            init:["Initial Value",this.init],
        }
        return options;
    }
    JKFLIPFLOP.prototype.set = function JKFLIPFLOP() {
            if (typeof(o)=="Block"&&o.gui=="DOLLAR_m") {
                var path = i;
                break;
            }
        }
        var newpar = list();
        this.exprs = xx.graphics.exprs[1-1];
        this.model = xx.model;
        var init_old = this.model.odstate[1-1];
        while (true) {
            var ok = true;
            this.init = parseFloat(arguments[0]["init"]);
            this.exprs0 = arguments[0]["exprs0"];
            if (!ok) {
                break;
            }
            if (this.init<=0) {
                this.init = int8(0);
            } else if (this.init>0) {
                this.init = int8(1);
            }
            if (ok) {
                xx.graphics.exprs[1-1] = this.exprs0;
                this.model.odstate[1-1] = new ScilabDouble([this.init]);
                xx.model = this.model;
                break;
            }
        }
        var needcompile = 0;
        if (init_old!=this.init) {
            newpar[size(newpar)+1-1] = 1;
            var needcompile = 2;
        }
        var y = needcompile;
        var typ = newpar;
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/IntegerOp/LOGIC.sci" */
function LOGIC() {
    LOGIC.prototype.define = function LOGIC() {
        this.mat = [[0],[0],[0],[1]];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["logic"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([1],[1]);
        this.model.in2 = new ScilabDouble([1],[1]);
        this.model.out = new ScilabDouble([1]);
        this.model.out2 = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.intyp = new ScilabDouble([5,5]);
        this.model.outtyp = new ScilabDouble([5]);
        this.model.opar = list(new ScilabDouble([int8(this.mat)]));
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabBoolean([false]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[sci2exp(this.mat)],[sci2exp(0)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"LOGIC\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    LOGIC.prototype.details = function LOGIC() {
        return this.x;
    }
    LOGIC.prototype.get = function LOGIC() {
        var options = {
            mat:["Truth Table (matrix of outputs)",this.mat.toString().replace(/,/g," ")],
            herit:["Accepts Inherited Events (0:No, 1:Yes)",this.herit],
        }
        return options;
    }
    LOGIC.prototype.set = function LOGIC() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.mat = inverse(arguments[0]["mat"]);
            this.herit = arguments[0]["herit"];
            if (!ok) {
                break;
            }
            var nout = size(this.mat,2);
            var nin = (log(size(this.mat,1))/log(2));
            var u1 = floor(nin);
            if ((u1!=nin)) {
                block_parameter_error(msprintf("Wrong size for \'%s\' parameter: %d.","Truth Table",size(this.mat,1)),"Number of rows must be a power of two.");
                var ok = false;
            } else if ((find(this.mat.slice()!=0&&this.mat.slice()!=1).length!=0)) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter.","Truth Table"),msprintf("Elements must be in the interval %s.","[0, 1]"));
                var ok = false;
            } else if (this.herit<0||this.herit>1) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Accepts Inherited Events",this.herit),msprintf("Must be in the interval %s.","[0, 1]"));
                var ok = false;
            }
            if (ok) {
                var in1 = [ones(nin,1),ones(nin,1)];
                var out = [ones(nout,1),ones(nout,1)];
                var it = 5*ones(1,nin);
                var ot = 5*ones(1,nout);
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),ones(1-this.herit,1),[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.mat = int8(this.mat);
                this.model.opar = list(new ScilabDouble([this.mat]));
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/IntegerOp/SHIFT.sci" */
function SHIFT() {
    SHIFT.prototype.define = function SHIFT() {
        var sgn = [[0],[0]];
        var OPER = 0;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["shift_32_LA"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([-1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.out2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([3]);
        this.model.outtyp = new ScilabDouble([3]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble(sgn);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[sci2exp(3)],[sci2exp(0)],[sci2exp(0)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SHIFT\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    SHIFT.prototype.details = function SHIFT() {
        return this.x;
    }
    SHIFT.prototype.get = function SHIFT() {
        var options = {
            Datatype:[msprintf("Data Type %s","(3:int32, 4:int16, 5:int8, ...)"),this.Datatype],
            nb:["Number of Bits to Shift Left (Negative number to shift right)",this.nb],
            np:["Shift Type (0:Arithmetic, 1:Circular)",this.np],
        }
        return options;
    }
    SHIFT.prototype.set = function SHIFT() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.Datatype = arguments[0]["Datatype"];
            this.nb = arguments[0]["nb"];
            this.np = arguments[0]["np"];
            if (!ok) {
                break;
            }
            if ((this.np!=0&&this.np!=1)) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Shift Type",this.np),msprintf("Must be in the interval %s.","[0, 1]"));
                var ok = false;
            }
            var it = this.Datatype;
            var ot = this.Datatype;
            if ((this.Datatype==3||this.Datatype==6)) {
                if (this.nb>0) {
                    switch (this.np) {
                    case 0:
                        this.model.sim = list(new ScilabString(["shift_32_LA"]), new ScilabDouble([4]));
                    case 1:
                        this.model.sim = list(new ScilabString(["shift_32_LC"]), new ScilabDouble([4]));
                    }
                } else if (this.nb<0) {
                    switch (this.np) {
                    case 0:
                        switch (this.Datatype) {
                        case 3:
                            this.model.sim = list(new ScilabString(["shift_32_RA"]), new ScilabDouble([4]));
                        case 6:
                            this.model.sim = list(new ScilabString(["shift_u32_RA"]), new ScilabDouble([4]));
                        }
                    case 1:
                        this.model.sim = list(new ScilabString(["shift_32_RC"]), new ScilabDouble([4]));
                    }
                }
            } else if ((this.Datatype==4||this.Datatype==7)) {
                if (this.nb>0) {
                    switch (this.np) {
                    case 0:
                        this.model.sim = list(new ScilabString(["shift_16_LA"]), new ScilabDouble([4]));
                    case 1:
                        this.model.sim = list(new ScilabString(["shift_16_LC"]), new ScilabDouble([4]));
                    }
                } else if (this.nb<0) {
                    switch (this.np) {
                    case 0:
                        switch (this.Datatype) {
                        case 4:
                            this.model.sim = list(new ScilabString(["shift_16_RA"]), new ScilabDouble([4]));
                        case 7:
                            this.model.sim = list(new ScilabString(["shift_u16_RA"]), new ScilabDouble([4]));
                        }
                    case 1:
                        this.model.sim = list(new ScilabString(["shift_16_RC"]), new ScilabDouble([4]));
                    }
                }
            } else if ((this.Datatype==5||this.Datatype==8)) {
                if (this.nb>0) {
                    switch (this.np) {
                    case 0:
                        this.model.sim = list(new ScilabString(["shift_8_LA"]), new ScilabDouble([4]));
                    case 1:
                        this.model.sim = list(new ScilabString(["shift_8_LC"]), new ScilabDouble([4]));
                    }
                } else if (this.nb<0) {
                    switch (this.np) {
                    case 0:
                        switch (this.Datatype) {
                        case 5:
                            this.model.sim = list(new ScilabString(["shift_8_RA"]), new ScilabDouble([4]));
                        case 8:
                            this.model.sim = list(new ScilabString(["shift_u8_RA"]), new ScilabDouble([4]));
                        }
                    case 1:
                        this.model.sim = list(new ScilabString(["shift_8_RC"]), new ScilabDouble([4]));
                    }
                }
            } else {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Data Type",this.Datatype),msprintf("Must be in the interval %s.","[3, 8]"));
                var ok = false;
            }
            if (ok) {
                var tmpvar0 = set_io(this.model,this.graphics,list([-1,-2],it),list([-1,-2],ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.model.ipar = new ScilabDouble([this.nb]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/IntegerOp/SRFLIPFLOP.sci" */
function SRFLIPFLOP() {
    SRFLIPFLOP.prototype.define = function SRFLIPFLOP() {
        var scs_m = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["SRFLIPFLOP"],tol=[[0.0001],[0.000001],[1.000e-10],[100001],[0],[0],[0]],tf=60,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m.objs[1-1] = scicos_block(gui="LOGIC",graphics=scicos_graphics(orig=[298.504,201.45067],sz=[40,40],flip=true,theta=0,exprs=[["[0 1;1 0;1 0;1 0;0 1;0 1;0 0;0 0]"],["1"]],pin=[[4],[10],[12]],pout=[[3],[8]],pein=[],peout=[],gr_i=[],id="",in_implicit=[["E"],["E"],["E"]],out_implicit=[["E"],["E"]]),model=scicos_model(sim=list("logic",4),in1=[[1],[1],[1]],in2=[[1],[1],[1]],intyp=[[5],[5],[5]],out=[[1],[1]],out2=[[1],[1]],outtyp=[[5],[5]],evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(int8([[0,1],[1,0],[1,0],[1,0],[0,1],[0,1],[0,0],[0,0]])),blocktype="c",firing=false,dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[2-1] = scicos_block(gui="DOLLAR_m",graphics=scicos_graphics(orig=[299.23733,254.25067],sz=[40,40],flip=false,theta=0,exprs=[["int8(0)"],["1"]],pin=6,pout=4,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("dollar4_m",4),in1=1,in2=1,intyp=5,out=1,out2=1,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(int8(0)),rpar=[],ipar=[],opar=list(),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[3-1] = scicos_link(xx=[[347.07543],[363.03733],[363.03733]],yy=[[228.11733],[228.11733],[248.584]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[5,1,1]);
        scs_m.objs[4-1] = scicos_link(xx=[[290.6659],[272.104],[272.104],[289.93257]],yy=[[274.25067],[274.25067],[231.45067],[231.45067]],id="drawlink",thick=[0,0],ct=[1,1],from=[2,1,0],to=[1,1,1]);
        scs_m.objs[5-1] = scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[363.03733,248.584],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=3,pout=[[6],[14]],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[["E"],["E"],["E"]]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[[-1],[-1],[-1]],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[6-1] = scicos_link(xx=[[363.03733],[363.03733],[344.95162]],yy=[[248.584],[274.25067],[274.25067]],id="drawlink",thick=[0,0],ct=[1,1],from=[5,1,0],to=[2,1,1]);
        scs_m.objs[7-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[367.07543,204.784],sz=[20,20],flip=true,theta=0,exprs="2",pin=8,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[8-1] = scicos_link(xx=[[347.07543],[367.07543]],yy=[[214.784],[214.784]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,2,0],to=[7,1,1]);
        scs_m.objs[9-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[249.93257,211.45067],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=10,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[10-1] = scicos_link(xx=[[269.93257],[289.93257]],yy=[[221.45067],[221.45067]],id="drawlink",thick=[0,0],ct=[1,1],from=[9,1,0],to=[1,2,1]);
        scs_m.objs[11-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[249.93257,201.45067],sz=[20,20],flip=true,theta=0,exprs="2",pin=[],pout=12,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[12-1] = scicos_link(xx=[[269.93257],[289.93257]],yy=[[211.45067],[211.45067]],id="drawlink",thick=[0,0],ct=[1,1],from=[11,1,0],to=[1,3,1]);
        scs_m.objs[13-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[383.03733,238.584],sz=[20,20],flip=true,theta=0,exprs="1",pin=14,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[14-1] = scicos_link(xx=[[363.03733],[383.03733]],yy=[[248.584],[248.584]],id="drawlink",thick=[0,0],ct=[1,1],from=[5,2,0],to=[13,1,1]);
        this.model = scicos_model();
        this.model.sim = new ScilabString(["csuper"]);
        this.model.in = new ScilabDouble([1],[1]);
        this.model.in2 = new ScilabDouble([1],[1]);
        this.model.out = new ScilabDouble([1],[1]);
        this.model.out2 = new ScilabDouble([1],[1]);
        this.model.intyp = new ScilabDouble([5,5]);
        this.model.outtyp = new ScilabDouble([5,5]);
        this.model.blocktype = new ScilabString(["h"]);
        this.model.firing = new ScilabBoolean([false]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.model.rpar = new ScilabDouble([scs_m]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SRFLIPFLOP\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,3]),this.model,new ScilabDouble([]),this.gr_i);
        return new BasicBlock(this.x);
    }
    SRFLIPFLOP.prototype.details = function SRFLIPFLOP() {
        return this.x;
    }
    SRFLIPFLOP.prototype.get = function SRFLIPFLOP() {
        var options = {
            init:["Initial Value",this.init],
        }
        return options;
    }
    SRFLIPFLOP.prototype.set = function SRFLIPFLOP() {
            if (typeof(o)=="Block"&&o.gui=="DOLLAR_m") {
                var path = i;
                break;
            }
        }
        var newpar = list();
        this.exprs = xx.graphics.exprs[1-1];
        this.model = xx.model;
        var init_old = this.model.odstate[1-1];
        while (true) {
            var ok = true;
            this.init = parseFloat(arguments[0]["init"]);
            this.exprs0 = arguments[0]["exprs0"];
            if (!ok) {
                break;
            }
            if (this.init<=0) {
                this.init = int8(0);
            } else if (this.init>0) {
                this.init = int8(1);
            }
            if (ok) {
                xx.graphics.exprs[1-1] = this.exprs0;
                this.model.odstate[1-1] = new ScilabDouble([this.init]);
                xx.model = this.model;
                break;
            }
        }
        var needcompile = 0;
        if (init_old!=this.init) {
            newpar[size(newpar)+1-1] = path;
            var needcompile = 2;
        }
        var y = needcompile;
        var typ = newpar;
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/BIGSOM_f.sci" */
function BIGSOM_f() {
    BIGSOM_f.prototype.define = function BIGSOM_f() {
        this.sgn = [[1],[1]];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["sum"]), new ScilabDouble([2]));
        this.model.in = new ScilabDouble([-1],[-1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.rpar = new ScilabDouble(this.sgn);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = sci2exp(this.sgn);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"BIGSOM_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,3]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BigSom(this.x);
    }
    BIGSOM_f.prototype.details = function BIGSOM_f() {
        return this.x;
    }
    BIGSOM_f.prototype.get = function BIGSOM_f() {
        var options = {
            sgn:["Inputs ports signs/gain",this.sgn.toString().replace(/,/g," ")],
        }
        return options;
    }
    BIGSOM_f.prototype.set = function BIGSOM_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.sgn = inverse(arguments[0]["sgn"]);
            if (!ok) {
                break;
            }
            var in1 = -ones(size(this.sgn,"*"),1);
            var tmpvar0 = check_io(this.model,this.graphics,in1,-1,[],[]);
            this.model = tmpvar0[0];
            this.graphics = tmpvar0[1];
            var ok = tmpvar0[2];
            if (ok) {
                this.model.rpar = new ScilabDouble(this.sgn.slice());
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BigSom(this.x);
    }
}
/* autogenerated from "macros/Linear/CLINDUMMY_f.sci" */
function CLINDUMMY_f() {
    CLINDUMMY_f.prototype.define = function CLINDUMMY_f() {
        var x0 = 0;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["cdummy"]), new ScilabDouble([4]));
        this.model.state = new ScilabDouble([x0]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CLINDUMMY_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble([]),this.gr_i);
        return new BasicBlock(this.x);
    }
    CLINDUMMY_f.prototype.details = function CLINDUMMY_f() {
        return this.x;
    }
    CLINDUMMY_f.prototype.get = function CLINDUMMY_f() {
        alert("parameters cannot be modified");
    }
    CLINDUMMY_f.prototype.set = function CLINDUMMY_f() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/CLR.sci" */
function CLR() {
    CLR.prototype.define = function CLR() {
        var x0 = 0;
        var A = -1;
        var B = 1;
        var C = 1;
        var D = 0;
        this.exprs = [["1"],["1+s"]];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["csslti4"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.state = new ScilabDouble([x0]);
        this.model.rpar = new ScilabDouble([A.slice()],[B.slice()],[C.slice()],[D.slice()]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CLR\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    CLR.prototype.details = function CLR() {
        return this.x;
    }
    CLR.prototype.get = function CLR() {
        var options = {
            num:["Numerator (s)",this.num],
            den:["Denominator (s)",this.den],
        }
        return options;
    }
    CLR.prototype.set = function CLR() {
        this.exprs = this.graphics.exprs;
        var x0 = this.model.state;
        var rpar = this.model.rpar;
        var ns = prod(size(x0));
        var nin = 1;
        var nout = 1;
        var PREVAR_scicos_context = PREVAR_scicos_context;
        PREVAR_scicos_context.s = %s;
        while (true) {
            var ok = true;
            this.num = arguments[0]["num"];
            this.den = arguments[0]["den"];
            if (!ok) {
                break;
            }
            if (degree(this.num)>degree(this.den)) {
                message("Transfer function must be proper or strictly proper.");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                var H = cont_frm(this.num,this.den);
                var tmpvar0 = H.slice(2-1,5);
                var A = tmpvar0[0];
                var B = tmpvar0[1];
                var C = tmpvar0[2];
                var D = tmpvar0[3];
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                var tmpvar1 = size(A);
                var ns1 = tmpvar1[0];
                var ns1 = tmpvar1[1];
                var rpar = [[matrix(A,ns1*ns1,1)],[matrix(B,ns1,1)],[matrix(C,ns1,1)],[D]];
                if (norm(D,1)!=0) {
                    var mmm = [true,true];
                } else {
                    var mmm = [false,true];
                }
                if (or(this.model.dep_ut!=mmm)) {
                    this.model.dep_ut = new ScilabBoolean(mmm);
                }
                if (ns1<=ns) {
                    var x0 = x0.slice(1-1,ns1);
                } else {
                    x0[ns1-1][1-1] = 0;
                }
                this.model.state = new ScilabDouble(x0);
                this.model.rpar = new ScilabDouble(rpar);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/CLR_f.sci" */
function CLR_f() {
    CLR_f.prototype.define = function CLR_f() {
        var x0 = 0;
        var A = -1;
        var B = 1;
        var C = 1;
        var D = 0;
        this.exprs = [["1"],["1+s"]];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["csslti"]), new ScilabDouble([1]));
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.state = new ScilabDouble([x0]);
        this.model.rpar = new ScilabDouble([A.slice()],[B.slice()],[C.slice()],[D.slice()]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CLR_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2.5,2.5]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    CLR_f.prototype.details = function CLR_f() {
        return this.x;
    }
    CLR_f.prototype.get = function CLR_f() {
        var options = {
            num:["Numerator (s)",this.num],
            den:["Denominator (s)",this.den],
        }
        return options;
    }
    CLR_f.prototype.set = function CLR_f() {
        this.exprs = this.graphics.exprs;
        var x0 = this.model.state;
        var rpar = this.model.rpar;
        var ns = prod(size(x0));
        var nin = 1;
        var nout = 1;
        var PREVAR_scicos_context = PREVAR_scicos_context;
        PREVAR_scicos_context.s = %s;
        while (true) {
            var ok = true;
            this.num = arguments[0]["num"];
            this.den = arguments[0]["den"];
            if (!ok) {
                break;
            }
            if (degree(this.num)>degree(this.den)) {
                message("Transfer must be proper or strictly proper");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                var H = cont_frm(this.num,this.den);
                var tmpvar0 = H.slice(2-1,5);
                var A = tmpvar0[0];
                var B = tmpvar0[1];
                var C = tmpvar0[2];
                var D = tmpvar0[3];
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                var tmpvar1 = size(A);
                var ns1 = tmpvar1[0];
                var ns1 = tmpvar1[1];
                var rpar = [[matrix(A,ns1*ns1,1)],[matrix(B,ns1,1)],[matrix(C,ns1,1)],[D]];
                if (norm(D,1)!=0) {
                    var mmm = [true,true];
                } else {
                    var mmm = [false,true];
                }
                if (or(this.model.dep_ut!=mmm)) {
                    this.model.dep_ut = new ScilabBoolean(mmm);
                }
                if (ns1<=ns) {
                    var x0 = x0.slice(1-1,ns1);
                } else {
                    x0[ns1-1][1-1] = 0;
                }
                this.model.state = new ScilabDouble(x0);
                this.model.rpar = new ScilabDouble(rpar);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/CLSS.sci" */
function CLSS() {
    CLSS.prototype.define = function CLSS() {
        this.x0 = 0;
        this.A = -1;
        this.B = 1;
        this.C = 1;
        this.D = 0;
        var in1 = 1;
        var out = 1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["csslti4"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([in1]);
        this.model.out = new ScilabDouble([out]);
        this.model.state = new ScilabDouble([this.x0]);
        this.model.rpar = new ScilabDouble([this.A.slice()],[this.B.slice()],[this.C.slice()],[this.D.slice()]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.exprs = [[strcat(sci2exp(this.A))],[strcat(sci2exp(this.B))],[strcat(sci2exp(this.C))],[strcat(sci2exp(this.D))],[strcat(sci2exp(this.x0))]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CLSS\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([4,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    CLSS.prototype.details = function CLSS() {
        return this.x;
    }
    CLSS.prototype.get = function CLSS() {
        var options = {
            A:["A matrix",this.A],
            B:["B matrix",this.B],
            C:["C matrix",this.C],
            D:["D matrix",this.D],
            x0:["Initial state",this.x0],
        }
        return options;
    }
    CLSS.prototype.set = function CLSS() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")==7) {
            this.exprs = this.exprs[[1:4,7]-1];
        }
        while (true) {
            var ok = true;
            this.A = parseFloat(arguments[0]["A"]);
            this.B = parseFloat(arguments[0]["B"]);
            this.C = parseFloat(arguments[0]["C"]);
            this.D = parseFloat(arguments[0]["D"]);
            this.x0 = parseFloat(arguments[0]["x0"]);
            if (!ok) {
                break;
            }
            var out = size(this.C,1);
            if (out==0) {
                var out = [];
            }
            var in1 = size(this.B,2);
            if (in1==0) {
                var in1 = [];
            }
            var tmpvar0 = size(this.A);
            var ms = tmpvar0[0];
            var ns = tmpvar0[1];
            var okD = true;
            if (size(this.D,"*")!=size(this.C,1)*size(this.B,2)) {
                if (size(this.D,"*")==1) {
                    this.D = this.D*ones(this.C*this.B);
                } else if (size(this.D,"*")==0) {
                    this.D = zeros(this.C*this.B);
                } else {
                    var okD = false;
                }
            }
            if (ms!=ns||!okD) {
                message("Matrix A is not square or D has wrong dimension");
                throw "user error";
            } else {
                var tmpvar1 = check_io(this.model,this.graphics,in1,out,[],[]);
                this.model = tmpvar1[0];
                this.graphics = tmpvar1[1];
                var ok = tmpvar1[2];
                if (ok) {
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    var rpar = [[this.A.slice()],[this.B.slice()],[this.C.slice()],[this.D.slice()]];
                    if (this.D.length!=0) {
                        if (norm(this.D,1)!=0) {
                            var mmm = [true,true];
                        } else {
                            var mmm = [false,true];
                        }
                        if (or(this.model.dep_ut!=mmm)) {
                            this.model.dep_ut = new ScilabBoolean(mmm);
                        }
                    } else {
                        this.model.dep_ut = new ScilabBoolean([false,true]);
                    }
                    this.model.state = new ScilabDouble(this.x0.slice());
                    this.model.rpar = new ScilabDouble(rpar);
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/CLSS_f.sci" */
function CLSS_f() {
    CLSS_f.prototype.define = function CLSS_f() {
        this.x0 = 0;
        this.A = -1;
        this.B = 1;
        this.C = 1;
        this.D = 0;
        var in1 = 1;
        var out = 1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["csslti"]), new ScilabDouble([1]));
        this.model.in = new ScilabDouble([in1]);
        this.model.out = new ScilabDouble([out]);
        this.model.state = new ScilabDouble([this.x0]);
        this.model.rpar = new ScilabDouble([this.A.slice()],[this.B.slice()],[this.C.slice()],[this.D.slice()]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.exprs = [[strcat(sci2exp(this.A))],[strcat(sci2exp(this.B))],[strcat(sci2exp(this.C))],[strcat(sci2exp(this.D))],[strcat(sci2exp(this.x0))]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CLSS_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([4,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    CLSS_f.prototype.details = function CLSS_f() {
        return this.x;
    }
    CLSS_f.prototype.get = function CLSS_f() {
        var options = {
            A:["A matrix",this.A],
            B:["B matrix",this.B],
            C:["C matrix",this.C],
            D:["D matrix",this.D],
            x0:["Initial state",this.x0],
        }
        return options;
    }
    CLSS_f.prototype.set = function CLSS_f() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")==7) {
            this.exprs = this.exprs[[1:4,7]-1];
        }
        while (true) {
            var ok = true;
            this.A = parseFloat(arguments[0]["A"]);
            this.B = parseFloat(arguments[0]["B"]);
            this.C = parseFloat(arguments[0]["C"]);
            this.D = parseFloat(arguments[0]["D"]);
            this.x0 = parseFloat(arguments[0]["x0"]);
            if (!ok) {
                break;
            }
            var out = size(this.C,1);
            if (out==0) {
                var out = [];
            }
            var in1 = size(this.B,2);
            if (in1==0) {
                var in1 = [];
            }
            var tmpvar0 = size(this.A);
            var ms = tmpvar0[0];
            var ns = tmpvar0[1];
            if (ms!=ns) {
                message("A matrix must be square");
                throw "user error";
            } else {
                var tmpvar1 = check_io(this.model,this.graphics,in1,out,[],[]);
                this.model = tmpvar1[0];
                this.graphics = tmpvar1[1];
                var ok = tmpvar1[2];
                if (ok) {
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    var rpar = [[this.A.slice()],[this.B.slice()],[this.C.slice()],[this.D.slice()]];
                    if (this.D.length!=0) {
                        if (norm(this.D,1)!=0) {
                            var mmm = [true,true];
                        } else {
                            var mmm = [false,true];
                        }
                        if (or(this.model.dep_ut!=mmm)) {
                            this.model.dep_ut = new ScilabBoolean(mmm);
                        }
                    } else {
                        this.model.dep_ut = new ScilabBoolean([false,true]);
                    }
                    this.model.state = new ScilabDouble(this.x0.slice());
                    this.model.rpar = new ScilabDouble(rpar);
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/DELAYV_f.sci" */
function DELAYV_f() {
    DELAYV_f.prototype.define = function DELAYV_f() {
        this.nin = 1;
        var z0 = zeros(11,1);
        this.zz0 = z0.slice(1-1,$-1);
        this.T = 1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["delayv"]), new ScilabDouble([1]));
        this.model.in = new ScilabDouble([this.nin],[1]);
        this.model.out = new ScilabDouble([this.nin]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.evtout = new ScilabDouble([1],[1]);
        this.model.dstate = new ScilabDouble([z0]);
        this.model.rpar = new ScilabDouble([this.T/(size(this.zz0,"*"))]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([0,-1]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[string(this.nin)],[strcat(string(z0.slice(1-1,$-1)),";")],[string(this.T)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"DELAYV_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    DELAYV_f.prototype.details = function DELAYV_f() {
        return this.x;
    }
    DELAYV_f.prototype.get = function DELAYV_f() {
        var options = {
            nin:["Number of inputs",this.nin],
            zz0:["Register initial condition",this.zz0],
            T:["Max delay",this.T],
        }
        return options;
    }
    DELAYV_f.prototype.set = function DELAYV_f() {
        this.exprs = this.graphics.exprs;
        this.nin = this.model.in[1-1];
        var z0 = this.model.dstate;
        this.zz0 = z0.slice(1-1,$-1);
        var told = z0[$-1];
        while (true) {
            var ok = true;
            this.nin = parseFloat(arguments[0]["nin"]);
            this.zz0 = inverse(arguments[0]["zz0"]);
            this.T = parseFloat(arguments[0]["T"]);
            if (!ok) {
                break;
            }
            if (size(this.zz0,"*")<2) {
                message("Register length must be at least 2");
                throw "user error";
                var ok = false;
            }
            if (this.T<=0) {
                message("Delay must be positive");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                var tmpvar0 = check_io(this.model,this.graphics,[[this.nin],[1]],this.nin,1,[[1],[1]]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.dstate = new ScilabDouble([this.zz0.slice()],[told]);
                this.model.rpar = new ScilabDouble([this.T/(size(this.zz0,"*"))]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/DELAY_f.sci" */
function DELAY_f() {
    DELAY_f.prototype.define = function DELAY_f() {
        var evtdly = EVTDLY_f("define");
        evtdly.graphics.orig = [243,296];
        evtdly.graphics.sz = [40,40];
        evtdly.graphics.flip = true;
        evtdly.graphics.exprs = [["0.1"],["0"]];
        evtdly.graphics.pein = 10;
        evtdly.graphics.peout = 7;
        evtdly.model.rpar = 0.1;
        evtdly.model.firing = 0;
        var register = REGISTER_f("define");
        register.graphics.orig = [238,195];
        register.graphics.sz = [50,50];
        register.graphics.flip = true;
        register.graphics.exprs = "0;0;0;0;0;0;0;0;0;0";
        register.graphics.pin = 6;
        register.graphics.pout = 5;
        register.graphics.pein = 9;
        var input_port = IN_f("define");
        input_port.graphics.orig = [92,210];
        input_port.graphics.sz = [20,20];
        input_port.graphics.flip = true;
        input_port.graphics.exprs = [["1"],["1"]];
        input_port.graphics.pout = 6;
        input_port.model.ipar = 1;
        var output_port = OUT_f("define");
        output_port.graphics.orig = [440,210];
        output_port.graphics.sz = [20,20];
        output_port.graphics.flip = true;
        output_port.graphics.exprs = [["1"],["1"]];
        output_port.graphics.pin = 5;
        output_port.model.ipar = 1;
        var split = CLKSPLIT_f("define");
        split.graphics.orig = [[263],[271.2]];
        split.graphics.pein = 7;
        split.graphics.peout = [[9],[10]];
        var diagram = scicos_diagram();
        diagram.objs[1-1] = input_port;
        diagram.objs[2-1] = output_port;
        diagram.objs[3-1] = register;
        diagram.objs[4-1] = evtdly;
        diagram.objs[5-1] = scicos_link(xx=[[296.6],[440]],yy=[[220],[220]],from=[3,1],to=[2,1]);
        diagram.objs[6-1] = scicos_link(xx=[[112],[229.4]],yy=[[220],[220]],from=[1,1],to=[3,1]);
        diagram.objs[7-1] = scicos_link(xx=[[263],[263]],yy=[[290.3],[271.2]],ct=[5,-1],from=[4,1],to=[8,1]);
        diagram.objs[8-1] = split;
        diagram.objs[9-1] = scicos_link(xx=[[263],[263]],yy=[[271.2],[250.7]],ct=[5,-1],from=[8,1],to=[3,1]);
        diagram.objs[10-1] = scicos_link(xx=[[263],[308.6],[308.6],[263],[263]],yy=[[271.2],[271.2],[367],[367],[341.7]],ct=[5,-1],from=[8,2],to=[4,1]);
        this.x = scicos_block();
        this.x.gui = "DELAY_f";
        this.x.graphics.sz = [2,2];
        this.x.graphics.gr_i = [];
        this.x.graphics.pin = 0;
        this.x.graphics.pout = 0;
        this.x.model.sim = "csuper";
        this.x.model.in = 1;
        this.x.model.out = 1;
        this.x.model.blocktype = "h";
        this.x.model.dep_ut = [false,false];
        this.x.model.rpar = diagram;
        this.x.graphics.in_implicit = ["E"];
        this.x.graphics.in_style = "";
        this.x.graphics.out_implicit = ["E"];
        this.x.graphics.out_style = "";
        return new BasicBlock(this.x);
    }
    DELAY_f.prototype.details = function DELAY_f() {
        return this.x;
    }
    DELAY_f.prototype.get = function DELAY_f() {
        var options = {
            dt:["Discretization time step",this.dt],
            z0:["Register initial state",this.z0],
        }
        return options;
    }
    DELAY_f.prototype.set = function DELAY_f() {
        var ppath = list(0,0);
            if (typeof(o)=="Block"&&o.gui=="REGISTER_f") {
                ppath[1-1] = i;
            }
            if (typeof(o)=="Block"&&o.gui=="EVTDLY_f") {
                ppath[2-1] = i;
            }
            if (and(ppath!=list(0,0))) {
                break;
            }
        }
        var newpar = list();
        var register = this.x.model.rpar.objs[ppath[1-1]-1];
        var evtdly = this.x.model.rpar.objs[ppath[2-1]-1];
        var register_exprs = register.graphics.exprs;
        var evtdly_exprs = evtdly.graphics.exprs;
        this.exprs = [[evtdly_exprs[1-1]],[register_exprs]];
        while (true) {
            var ok = true;
            this.dt = arguments[0]["dt"];
            this.z0 = arguments[0]["z0"];
            if (!ok) {
                break;
            }
            var mess = [];
            if (prod(size(this.z0))<1) {
                var mess = [[mess],["Register length must be at least 1"],[" "]];
                var ok = false;
            }
            if (this.dt<=0) {
                var mess = [[mess],["Discretization time step must be positive"],[" "]];
                var ok = false;
            }
            if (!ok) {
                message(mess);
                throw "user error";
            } else {
                evtdly.graphics.exprs[1-1] = this.exprs[1-1];
                if (evtdly.model.rpar!=this.dt) {
                    evtdly.model.rpar = this.dt;
                    newpar[$+1-1] = ppath[2-1];
                }
                this.x.model.rpar.objs[ppath[2-1]-1] = evtdly;
                register.graphics.exprs = this.exprs[2-1];
                if (or(register.model.dstate!=this.z0.slice())) {
                    register.model.dstate = this.z0.slice();
                    newpar[$+1-1] = ppath[1-1];
                }
                this.x.model.rpar.objs[ppath[1-1]-1] = register;
                break;
            }
        }
        var needcompile = 0;
        var y = needcompile;
        var typ = newpar;
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/DERIV.sci" */
function DERIV() {
    DERIV.prototype.define = function DERIV() {
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["deriv"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([-1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.blocktype = new ScilabString(["x"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"DERIV\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    DERIV.prototype.details = function DERIV() {
        return this.x;
    }
    DERIV.prototype.get = function DERIV() {
        alert("parameters cannot be modified");
    }
    DERIV.prototype.set = function DERIV() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/DIFF_c.sci" */
function DIFF_c() {
    DIFF_c.prototype.define = function DIFF_c() {
        this.x0 = [[0],[0]];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["diffblk_c"]), new ScilabDouble([10004]));
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.state = new ScilabDouble(this.x0);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.exprs = [[strcat(sci2exp(this.x0[1-1]))],[strcat(sci2exp(this.x0[2-1]))]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"DIFF_c\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    DIFF_c.prototype.details = function DIFF_c() {
        return this.x;
    }
    DIFF_c.prototype.get = function DIFF_c() {
        var options = {
            x0:["Initial state",this.x0.toString().replace(/,/g," ")],
            xd0:["Initial Derivative",this.xd0],
        }
        return options;
    }
    DIFF_c.prototype.set = function DIFF_c() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ask_again = false;
            var ok = true;
            this.x0 = inverse(arguments[0]["x0"]);
            this.xd0 = inverse(arguments[0]["xd0"]);
            if (!ok) {
                break;
            }
            this.x0 = this.x0.slice();
            var N = size(this.x0,"*");
            this.xd0 = this.xd0.slice();
            var Nxd = size(this.xd0,"*");
            if ((N!=Nxd)) {
                message("Incompatible sizes: states and their derivatives should have the same size ");
                throw "user error";
                var ask_again = true;
            }
            if ((N<=0&&!ask_again)) {
                x_message("number of states must be > 0 ");
                var ask_again = true;
            }
            if (!ask_again) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.state = new ScilabDouble([this.x0],[this.xd0]);
                this.model.out = new ScilabDouble([N]);
                this.model.in = new ScilabDouble([N]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        this.x.model.firing = [];
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/DLR.sci" */
function DLR() {
    DLR.prototype.define = function DLR() {
        var x0 = 0;
        var A = -1;
        var B = 1;
        var C = 1;
        var D = 0;
        this.exprs = [["1"],["1+z"]];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["dsslti4"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble(x0.slice());
        this.model.rpar = new ScilabDouble([A.slice()],[B.slice()],[C.slice()],[D.slice()]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"DLR\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    DLR.prototype.details = function DLR() {
        return this.x;
    }
    DLR.prototype.get = function DLR() {
        var options = {
            num:["Numerator (z)",this.num],
            den:["Denominator (z)",this.den],
        }
        return options;
    }
    DLR.prototype.set = function DLR() {
        this.exprs = this.graphics.exprs;
        var x0 = this.model.dstate;
        var ns = prod(size(x0));
        var PREVAR_scicos_context = PREVAR_scicos_context;
        PREVAR_scicos_context.z = %z;
        while (true) {
            var ok = true;
            this.num = arguments[0]["num"];
            this.den = arguments[0]["den"];
            if (!ok) {
                break;
            }
            if (degree(this.num)>degree(this.den)) {
                message("Transfer function must be proper");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                var H = cont_frm(this.num,this.den);
                var tmpvar0 = H.slice(2-1,5);
                var A = tmpvar0[0];
                var B = tmpvar0[1];
                var C = tmpvar0[2];
                var D = tmpvar0[3];
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                var tmpvar1 = size(A);
                var ns1 = tmpvar1[0];
                var ns1 = tmpvar1[1];
                if (ns1<=ns) {
                    var x0 = x0.slice(1-1,ns1);
                } else {
                    x0[ns1-1][1-1] = 0;
                }
                var rpar = [[A.slice()],[B.slice()],[C.slice()],[D.slice()]];
                this.model.dstate = new ScilabDouble(x0);
                this.model.rpar = new ScilabDouble(rpar);
                if (norm(D,1)!=0) {
                    var mmm = [true,false];
                } else {
                    var mmm = [false,false];
                }
                if (or(this.model.dep_ut!=mmm)) {
                    this.model.dep_ut = new ScilabBoolean(mmm);
                }
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        this.x.model.firing = [];
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/DLR_f.sci" */
function DLR_f() {
    DLR_f.prototype.define = function DLR_f() {
        var x0 = 0;
        var A = -1;
        var B = 1;
        var C = 1;
        var D = 0;
        this.exprs = [["1"],["1+z"]];
        this.model = scicos_model();
        this.model.sim = new ScilabString(["dsslti"]);
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble(x0.slice());
        this.model.rpar = new ScilabDouble([A.slice()],[B.slice()],[C.slice()],[D.slice()]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"DLR_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2.5,2.5]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    DLR_f.prototype.details = function DLR_f() {
        return this.x;
    }
    DLR_f.prototype.get = function DLR_f() {
        var options = {
            num:["Numerator (z)",this.num],
            den:["Denominator (z)",this.den],
        }
        return options;
    }
    DLR_f.prototype.set = function DLR_f() {
        this.exprs = this.graphics.exprs;
        var x0 = this.model.dstate;
        var ns = prod(size(x0));
        var PREVAR_scicos_context = PREVAR_scicos_context;
        PREVAR_scicos_context.z = %z;
        while (true) {
            var ok = true;
            this.num = arguments[0]["num"];
            this.den = arguments[0]["den"];
            if (!ok) {
                break;
            }
            if (degree(this.num)>degree(this.den)) {
                message("Transfer must be proper");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                var H = cont_frm(this.num,this.den);
                var tmpvar0 = H.slice(2-1,5);
                var A = tmpvar0[0];
                var B = tmpvar0[1];
                var C = tmpvar0[2];
                var D = tmpvar0[3];
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                var tmpvar1 = size(A);
                var ns1 = tmpvar1[0];
                var ns1 = tmpvar1[1];
                if (ns1<=ns) {
                    var x0 = x0.slice(1-1,ns1);
                } else {
                    x0[ns1-1][1-1] = 0;
                }
                var rpar = [[A.slice()],[B.slice()],[C.slice()],[D.slice()]];
                this.model.dstate = new ScilabDouble(x0);
                this.model.rpar = new ScilabDouble(rpar);
                if (norm(D,1)!=0) {
                    var mmm = [true,false];
                } else {
                    var mmm = [false,false];
                }
                if (or(this.model.dep_ut!=mmm)) {
                    this.model.dep_ut = new ScilabBoolean(mmm);
                }
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        this.x.model.firing = [];
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/DLSS.sci" */
function DLSS() {
    DLSS.prototype.define = function DLSS() {
        this.x0 = 0;
        this.A = -1;
        this.B = 1;
        this.C = 1;
        this.D = 0;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["dsslti4"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble(this.x0.slice());
        this.model.rpar = new ScilabDouble([this.A.slice()],[this.B.slice()],[this.C.slice()],[this.D.slice()]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [[strcat(sci2exp(this.A))],[strcat(sci2exp(this.B))],[strcat(sci2exp(this.C))],[strcat(sci2exp(this.D))],[strcat(sci2exp(this.x0))]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"DLSS\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([4,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    DLSS.prototype.details = function DLSS() {
        return this.x;
    }
    DLSS.prototype.get = function DLSS() {
        var options = {
            A:["A matrix",this.A],
            B:["B matrix",this.B],
            C:["C matrix",this.C],
            D:["D matrix",this.D],
            x0:["Initial state",this.x0],
        }
        return options;
    }
    DLSS.prototype.set = function DLSS() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")==7) {
            this.exprs = this.exprs[[1:4,7]-1];
        }
        while (true) {
            var ok = true;
            this.A = parseFloat(arguments[0]["A"]);
            this.B = parseFloat(arguments[0]["B"]);
            this.C = parseFloat(arguments[0]["C"]);
            this.D = parseFloat(arguments[0]["D"]);
            this.x0 = parseFloat(arguments[0]["x0"]);
            if (!ok) {
                break;
            }
            var out = size(this.C,1);
            if (out==0) {
                var out = [];
            }
            var in1 = size(this.B,2);
            if (in1==0) {
                var in1 = [];
            }
            var tmpvar0 = size(this.A);
            var ms = tmpvar0[0];
            var ns = tmpvar0[1];
            var okD = true;
            if (size(this.D,"*")!=size(this.C,1)*size(this.B,2)) {
                if (size(this.D,"*")==1) {
                    this.D = this.D*ones(this.C*this.B);
                } else if (size(this.D,"*")==0) {
                    this.D = zeros(this.C*this.B);
                } else {
                    var okD = false;
                }
            }
            if (ms!=ns||!okD) {
                message("Matrix A is not square or D has wrong dimension");
                throw "user error";
            } else {
                var tmpvar1 = check_io(this.model,this.graphics,in1,out,1,[]);
                this.model = tmpvar1[0];
                this.graphics = tmpvar1[1];
                var ok = tmpvar1[2];
                if (ok) {
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    var rpar = [[this.A.slice()],[this.B.slice()],[this.C.slice()],[this.D.slice()]];
                    if (this.D.length!=0) {
                        if (norm(this.D,1)!=0) {
                            var mmm = [true,false];
                        } else {
                            var mmm = [false,false];
                        }
                        if (or(this.model.dep_ut!=mmm)) {
                            this.model.dep_ut = new ScilabBoolean(mmm);
                        }
                    } else {
                        this.model.dep_ut = new ScilabBoolean([false,false]);
                    }
                    this.model.dstate = new ScilabDouble(this.x0.slice());
                    this.model.rpar = new ScilabDouble(rpar);
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/DLSS_f.sci" */
function DLSS_f() {
    DLSS_f.prototype.define = function DLSS_f() {
        this.x0 = 0;
        this.A = -1;
        this.B = 1;
        this.C = 1;
        this.D = 0;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["dsslti"]), new ScilabDouble([1]));
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble(this.x0.slice());
        this.model.rpar = new ScilabDouble([this.A.slice()],[this.B.slice()],[this.C.slice()],[this.D.slice()]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [[strcat(sci2exp(this.A))],[strcat(sci2exp(this.B))],[strcat(sci2exp(this.C))],[strcat(sci2exp(this.D))],[strcat(sci2exp(this.x0))]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"DLSS_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([4,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    DLSS_f.prototype.details = function DLSS_f() {
        return this.x;
    }
    DLSS_f.prototype.get = function DLSS_f() {
        var options = {
            A:["A matrix",this.A],
            B:["B matrix",this.B],
            C:["C matrix",this.C],
            D:["D matrix",this.D],
            x0:["Initial state",this.x0],
        }
        return options;
    }
    DLSS_f.prototype.set = function DLSS_f() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")==7) {
            this.exprs = this.exprs[[1:4,7]-1];
        }
        while (true) {
            var ok = true;
            this.A = parseFloat(arguments[0]["A"]);
            this.B = parseFloat(arguments[0]["B"]);
            this.C = parseFloat(arguments[0]["C"]);
            this.D = parseFloat(arguments[0]["D"]);
            this.x0 = parseFloat(arguments[0]["x0"]);
            if (!ok) {
                break;
            }
            var out = size(this.C,1);
            if (out==0) {
                var out = [];
            }
            var in1 = size(this.B,2);
            if (in1==0) {
                var in1 = [];
            }
            var tmpvar0 = size(this.A);
            var ms = tmpvar0[0];
            var ns = tmpvar0[1];
            if (ms!=ns) {
                message("A matrix must be square");
                throw "user error";
            } else {
                var tmpvar1 = check_io(this.model,this.graphics,in1,out,1,[]);
                this.model = tmpvar1[0];
                this.graphics = tmpvar1[1];
                var ok = tmpvar1[2];
                if (ok) {
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    var rpar = [[this.A.slice()],[this.B.slice()],[this.C.slice()],[this.D.slice()]];
                    if (this.D.length!=0) {
                        if (norm(this.D,1)!=0) {
                            var mmm = [true,false];
                        } else {
                            var mmm = [false,false];
                        }
                        if (or(this.model.dep_ut!=mmm)) {
                            this.model.dep_ut = new ScilabBoolean(mmm);
                        }
                    } else {
                        this.model.dep_ut = new ScilabBoolean([false,false]);
                    }
                    this.model.dstate = new ScilabDouble(this.x0.slice());
                    this.model.rpar = new ScilabDouble(rpar);
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/DOLLAR.sci" */
function DOLLAR() {
    DOLLAR.prototype.define = function DOLLAR() {
        var z = 0;
        this.inh = 0;
        var in1 = 1;
        this.exprs = string([[z],[this.inh]]);
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["dollar4"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([in1]);
        this.model.out = new ScilabDouble([in1]);
        this.model.evtin = new ScilabDouble([1-this.inh]);
        this.model.dstate = new ScilabDouble([z]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"DOLLAR\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    DOLLAR.prototype.details = function DOLLAR() {
        return this.x;
    }
    DOLLAR.prototype.get = function DOLLAR() {
        var options = {
            a:["initial condition",this.a],
            inh:["Inherit (no:0, yes:1)",this.inh],
        }
        return options;
    }
    DOLLAR.prototype.set = function DOLLAR() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")<2) {
            this.exprs[2-1] = "0";
        }
        while (true) {
            var ok = true;
            this.a = arguments[0]["a"];
            this.inh = parseFloat(arguments[0]["inh"]);
            if (!ok) {
                break;
            }
            var out = [size(this.a,1),size(this.a,2)];
            if (out==0) {
                var out = [];
            }
            var in1 = out;
            this.model.sim = list(new ScilabString(["dollar4_m"]), new ScilabDouble([4]));
            this.model.odstate = list(new ScilabDouble([this.a]));
            this.model.dstate = new ScilabDouble([]);
            if (this.type[(this.a)==1-1]) {
                if (isreal(this.a)) {
                    var it = 1;
                    var ot = 1;
                    if ((size(this.a,1)==1||size(this.a,2)==1)) {
                        this.model.sim = list(new ScilabString(["dollar4"]), new ScilabDouble([4]));
                        this.model.dstate = new ScilabDouble(this.a.slice());
                        this.model.odstate = list();
                    }
                } else {
                    var it = 2;
                    var ot = 2;
                }
            } else if ((typeof(this.a)=="int32")) {
                var it = 3;
                var ot = 3;
            } else if ((typeof(this.a)=="int16")) {
                var it = 4;
                var ot = 4;
            } else if ((typeof(this.a)=="int8")) {
                var it = 5;
                var ot = 5;
            } else if ((typeof(this.a)=="uint32")) {
                var it = 6;
                var ot = 6;
            } else if ((typeof(this.a)=="uint16")) {
                var it = 7;
                var ot = 7;
            } else if ((typeof(this.a)=="uint8")) {
                var it = 8;
                var ot = 8;
            } else {
                message("type is not recognized");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),ones(1-this.inh,1),[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/DOLLAR_f.sci" */
function DOLLAR_f() {
    DOLLAR_f.prototype.define = function DOLLAR_f() {
        var z = 0;
        this.inh = 0;
        var in1 = 1;
        this.exprs = string([[z],[this.inh]]);
        this.model = scicos_model();
        this.model.sim = new ScilabString(["dollar"]);
        this.model.in = new ScilabDouble([in1]);
        this.model.out = new ScilabDouble([in1]);
        this.model.evtin = new ScilabDouble([1-this.inh]);
        this.model.dstate = new ScilabDouble([z]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"DOLLAR_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    DOLLAR_f.prototype.details = function DOLLAR_f() {
        return this.x;
    }
    DOLLAR_f.prototype.get = function DOLLAR_f() {
        var options = {
            a:["initial condition",this.a],
            inh:["Inherit (no:0, yes:1)",this.inh],
        }
        return options;
    }
    DOLLAR_f.prototype.set = function DOLLAR_f() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")<2) {
            this.exprs[2-1] = "0";
        }
        while (true) {
            var ok = true;
            this.a = arguments[0]["a"];
            this.inh = parseFloat(arguments[0]["inh"]);
            if (!ok) {
                break;
            }
            var out = size(this.a,"*");
            if (out==0) {
                var out = [];
            }
            var in1 = out;
            if (ok) {
                var tmpvar0 = check_io(this.model,this.graphics,-1,-1,ones(1-this.inh,1),[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.dstate = new ScilabDouble([this.a]);
                this.model.in = new ScilabDouble(in1);
                this.model.out = new ScilabDouble(out);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/DOLLAR_m.sci" */
function DOLLAR_m() {
    DOLLAR_m.prototype.define = function DOLLAR_m() {
        var z = 0;
        this.inh = 0;
        var in1 = 1;
        this.exprs = string([[z],[this.inh]]);
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["dollar4"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([in1]);
        this.model.out = new ScilabDouble([in1]);
        this.model.evtin = new ScilabDouble([1-this.inh]);
        this.model.dstate = new ScilabDouble([z]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"DOLLAR_m\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    DOLLAR_m.prototype.details = function DOLLAR_m() {
        return this.x;
    }
    DOLLAR_m.prototype.get = function DOLLAR_m() {
        var options = {
            a:["initial condition",this.a],
            inh:["Inherit (no:0, yes:1)",this.inh],
        }
        return options;
    }
    DOLLAR_m.prototype.set = function DOLLAR_m() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")<2) {
            this.exprs[2-1] = "0";
        }
        while (true) {
            var ok = true;
            this.a = arguments[0]["a"];
            this.inh = parseFloat(arguments[0]["inh"]);
            if (!ok) {
                break;
            }
            var out = [size(this.a,1),size(this.a,2)];
            if (out==0) {
                var out = [];
            }
            var in1 = out;
            this.model.sim = list(new ScilabString(["dollar4_m"]), new ScilabDouble([4]));
            this.model.odstate = list(new ScilabDouble([this.a]));
            this.model.dstate = new ScilabDouble([]);
            if ((this.type[this.a-1]==1)) {
                if (isreal(this.a)) {
                    var it = 1;
                    var ot = 1;
                    if ((size(this.a,1)==1||size(this.a,2)==1)) {
                        this.model.sim = list(new ScilabString(["dollar4"]), new ScilabDouble([4]));
                        this.model.dstate = new ScilabDouble(this.a.slice());
                        this.model.odstate = list();
                    }
                } else {
                    var it = 2;
                    var ot = 2;
                }
            } else if ((typeof(this.a)=="int32")) {
                var it = 3;
                var ot = 3;
            } else if ((typeof(this.a)=="int16")) {
                var it = 4;
                var ot = 4;
            } else if ((typeof(this.a)=="int8")) {
                var it = 5;
                var ot = 5;
            } else if ((typeof(this.a)=="uint32")) {
                var it = 6;
                var ot = 6;
            } else if ((typeof(this.a)=="uint16")) {
                var it = 7;
                var ot = 7;
            } else if ((typeof(this.a)=="uint8")) {
                var it = 8;
                var ot = 8;
            } else {
                message("type is not recognized");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),ones(1-this.inh,1),[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/GAINBLK.sci" */
function GAINBLK() {
    GAINBLK.prototype.define = function GAINBLK() {
        this.gain = 1;
        var in1 = -1;
        var out = -1;
        var in2 = -2;
        var out2 = -2;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["gainblk"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([in1]);
        this.model.out = new ScilabDouble([out]);
        this.model.in2 = new ScilabDouble([in2]);
        this.model.out2 = new ScilabDouble([out2]);
        this.model.rpar = new ScilabDouble([this.gain]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [strcat(sci2exp(this.gain))];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"GAINBLK\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    GAINBLK.prototype.details = function GAINBLK() {
        return this.x;
    }
    GAINBLK.prototype.get = function GAINBLK() {
        var options = {
            gain:["Gain",this.gain],
            over:["Do On Overflow(0=Nothing 1=Saturate 2=Error)",this.over],
        }
        return options;
    }
    GAINBLK.prototype.set = function GAINBLK() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")==1) {
            this.exprs = [[this.exprs],[sci2exp(0)]];
        }
        while (true) {
            var ok = true;
            this.gain = parseFloat(arguments[0]["gain"]);
            this.over = arguments[0]["over"];
            if (!ok) {
                break;
            }
            if (this.gain.length==0) {
                message("Gain must have at least one element");
                throw "user error";
            } else {
                if (typeof(this.gain)=="constant") {
                    if (isreal(this.gain)) {
                        var it = 1;
                        var ot = 1;
                        this.model.sim = list(new ScilabString(["gainblk"]), new ScilabDouble([4]));
                        this.model.rpar = new ScilabDouble(this.gain.slice());
                        this.model.opar = list();
                    } else {
                        message("type is not supported");
                        throw "user error";
                        var ok = false;
                    }
                } else {
                    if ((this.over==0)) {
                        if ((typeof(this.gain)=="int32")) {
                            var ot = 3;
                            this.model.sim = list(new ScilabString(["gainblk_i32n"]), new ScilabDouble([4]));
                        } else if ((typeof(this.gain)=="int16")) {
                            var ot = 4;
                            this.model.sim = list(new ScilabString(["gainblk_i16n"]), new ScilabDouble([4]));
                        } else if ((typeof(this.gain)=="int8")) {
                            var ot = 5;
                            this.model.sim = list(new ScilabString(["gainblk_i8n"]), new ScilabDouble([4]));
                        } else if ((typeof(this.gain)=="uint32")) {
                            var ot = 6;
                            this.model.sim = list(new ScilabString(["gainblk_ui32n"]), new ScilabDouble([4]));
                        } else if ((typeof(this.gain)=="uint16")) {
                            var ot = 7;
                            this.model.sim = list(new ScilabString(["gainblk_ui16n"]), new ScilabDouble([4]));
                        } else if ((typeof(this.gain)=="uint8")) {
                            var ot = 8;
                            this.model.sim = list(new ScilabString(["gainblk_ui8n"]), new ScilabDouble([4]));
                        } else {
                            message("type is not supported.");
                            throw "user error";
                            var ok = false;
                        }
                    } else if ((this.over==1)) {
                        if ((typeof(this.gain)=="int32")) {
                            var ot = 3;
                            this.model.sim = list(new ScilabString(["gainblk_i32s"]), new ScilabDouble([4]));
                        } else if ((typeof(this.gain)=="int16")) {
                            var ot = 4;
                            this.model.sim = list(new ScilabString(["gainblk_i16s"]), new ScilabDouble([4]));
                        } else if ((typeof(this.gain)=="int8")) {
                            var ot = 5;
                            this.model.sim = list(new ScilabString(["gainblk_i8s"]), new ScilabDouble([4]));
                        } else if ((typeof(this.gain)=="uint32")) {
                            var ot = 6;
                            this.model.sim = list(new ScilabString(["gainblk_ui32s"]), new ScilabDouble([4]));
                        } else if ((typeof(this.gain)=="uint16")) {
                            var ot = 7;
                            this.model.sim = list(new ScilabString(["gainblk_ui16s"]), new ScilabDouble([4]));
                        } else if ((typeof(this.gain)=="uint8")) {
                            var ot = 8;
                            this.model.sim = list(new ScilabString(["gainblk_ui8s"]), new ScilabDouble([4]));
                        } else {
                            message("type is not supported.");
                            throw "user error";
                            var ok = false;
                        }
                    } else if ((this.over==2)) {
                        if ((typeof(this.gain)=="int32")) {
                            var ot = 3;
                            this.model.sim = list(new ScilabString(["gainblk_i32e"]), new ScilabDouble([4]));
                        } else if ((typeof(this.gain)=="int16")) {
                            var ot = 4;
                            this.model.sim = list(new ScilabString(["gainblk_i16e"]), new ScilabDouble([4]));
                        } else if ((typeof(this.gain)=="int8")) {
                            var ot = 5;
                            this.model.sim = list(new ScilabString(["gainblk_i8e"]), new ScilabDouble([4]));
                        } else if ((typeof(this.gain)=="uint32")) {
                            var ot = 6;
                            this.model.sim = list(new ScilabString(["gainblk_ui32e"]), new ScilabDouble([4]));
                        } else if ((typeof(this.gain)=="uint16")) {
                            var ot = 7;
                            this.model.sim = list(new ScilabString(["gainblk_ui16e"]), new ScilabDouble([4]));
                        } else if ((typeof(this.gain)=="uint8")) {
                            var ot = 8;
                            this.model.sim = list(new ScilabString(["gainblk_ui8e"]), new ScilabDouble([4]));
                        } else {
                            message("type is not an integer.");
                            throw "user error";
                            var ok = false;
                        }
                    } else {
                        message("Do on Overflow must be 0,1,2");
                        throw "user error";
                        var ok = false;
                    }
                    this.model.rpar = new ScilabDouble([]);
                    this.model.opar = list(this.gain.slice());
                }
                if (ok) {
                    var tmpvar0 = size(this.gain);
                    var out = tmpvar0[0];
                    var in1 = tmpvar0[1];
                    if (out*in1!=1) {
                        var tmpvar1 = set_io(this.model,this.graphics,list([in1,-1],ot),list([out,-1],ot),[],[]);
                        this.model = tmpvar1[0];
                        this.graphics = tmpvar1[1];
                        var ok = tmpvar1[2];
                    } else {
                        var tmpvar2 = set_io(this.model,this.graphics,list([-1,-2],ot),list([-1,-2],ot),[],[]);
                        this.model = tmpvar2[0];
                        this.graphics = tmpvar2[1];
                        var ok = tmpvar2[2];
                    }
                }
                if (ok) {
                    this.graphics.exprs = new ScilabDouble(this.exprs);
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/GAINBLK_f.sci" */
function GAINBLK_f() {
    GAINBLK_f.prototype.define = function GAINBLK_f() {
        this.gain = 1;
        var in1 = 1;
        var out = 1;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["gain"]);
        this.model.in = new ScilabDouble([in1]);
        this.model.out = new ScilabDouble([out]);
        this.model.rpar = new ScilabDouble([this.gain]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [strcat(sci2exp(this.gain))];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"GAINBLK_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    GAINBLK_f.prototype.details = function GAINBLK_f() {
        return this.x;
    }
    GAINBLK_f.prototype.get = function GAINBLK_f() {
        var options = {
            gain:["Gain",this.gain],
        }
        return options;
    }
    GAINBLK_f.prototype.set = function GAINBLK_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.gain = parseFloat(arguments[0]["gain"]);
            if (!ok) {
                break;
            }
            if (this.gain.length==0) {
                message("Gain must have at least one element");
                throw "user error";
            } else {
                var tmpvar0 = size(this.gain);
                var out = tmpvar0[0];
                var in1 = tmpvar0[1];
                var tmpvar1 = check_io(this.model,this.graphics,in1,out,[],[]);
                this.model = tmpvar1[0];
                this.graphics = tmpvar1[1];
                var ok = tmpvar1[2];
                if (ok) {
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    this.model.rpar = new ScilabDouble(this.gain.slice());
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/GAIN_f.sci" */
function GAIN_f() {
    GAIN_f.prototype.define = function GAIN_f() {
        this.gain = 1;
        var in1 = 1;
        var out = 1;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["gain"]);
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([this.gain]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[strcat(sci2exp(this.gain))],[strcat(sci2exp(in1))],[strcat(sci2exp(out))]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"GAIN_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    GAIN_f.prototype.details = function GAIN_f() {
        return this.x;
    }
    GAIN_f.prototype.get = function GAIN_f() {
        var options = {
            gain:["Gain",this.gain],
        }
        return options;
    }
    GAIN_f.prototype.set = function GAIN_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.gain = parseFloat(arguments[0]["gain"]);
            if (!ok) {
                break;
            }
            if (this.gain.length==0) {
                message("Gain must have at least one element");
                throw "user error";
            } else {
                var tmpvar0 = size(this.gain);
                var out = tmpvar0[0];
                var in1 = tmpvar0[1];
                var tmpvar1 = check_io(this.model,this.graphics,in1,out,[],[]);
                this.model = tmpvar1[0];
                this.graphics = tmpvar1[1];
                var ok = tmpvar1[2];
                if (ok) {
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    this.model.rpar = new ScilabDouble(this.gain.slice());
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/INTEGRAL.sci" */
function INTEGRAL() {
    INTEGRAL.prototype.define = function INTEGRAL() {
        this.maxp = 1;
        var minp = -1;
        var rpar = [];
        this.model = scicos_model();
        this.model.state = new ScilabDouble([0]);
        this.model.sim = list(new ScilabString(["integral_func"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble(rpar);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.exprs = string([[0],[0],[0],[this.maxp],[minp]]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"INTEGRAL\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        this.x.graphics.id = "1/s";
        return new BasicBlock(this.x);
    }
    INTEGRAL.prototype.details = function INTEGRAL() {
        return this.x;
    }
    INTEGRAL.prototype.get = function INTEGRAL() {
        var options = {
            x0:["Initial Condition",this.x0],
            reinit:["With re-intialization (1:yes, 0:no)",this.reinit],
            satur:["With saturation (1:yes, 0:no)",this.satur],
            maxp:["Upper limit",this.maxp],
            lowp:["Lower limit",this.lowp],
        }
        return options;
    }
    INTEGRAL.prototype.set = function INTEGRAL() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.x0 = inverse(arguments[0]["x0"]);
            this.reinit = parseFloat(arguments[0]["reinit"]);
            this.satur = parseFloat(arguments[0]["satur"]);
            this.maxp = parseFloat(arguments[0]["maxp"]);
            this.lowp = arguments[0]["lowp"];
            if (!ok) {
                break;
            }
            this.x0 = this.x0.slice();
            this.maxp = this.maxp.slice();
            this.lowp = this.lowp.slice();
            if (this.reinit!=0) {
                this.reinit = 1;
            }
            if (this.satur!=0) {
                this.satur = 1;
                if (size(this.maxp,"*")==1) {
                    this.maxp = this.maxp*ones(this.x0);
                }
                if (size(this.lowp,"*")==1) {
                    this.lowp = this.lowp*ones(this.x0);
                }
                if ((size(this.x0,1)!=size(this.maxp,1)||size(this.x0,1)!=size(this.lowp,1))) {
                    message("x0 and Upper limit and Lower limit must have same size");
                    throw "user error";
                    var ok = false;
                } else if (or(this.maxp<=this.lowp)) {
                    message("Upper limits must be > Lower limits");
                    throw "user error";
                    var ok = false;
                } else if (or(this.x0>this.maxp)||or(this.x0<this.lowp)) {
                    message("Initial condition x0 should be inside the limits");
                    throw "user error";
                    var ok = false;
                } else {
                    var rpar = [[this.maxp],[this.lowp]];
                    this.model.nzcross = new ScilabDouble([size(this.x0,1)]);
                    this.model.nmode = new ScilabDouble([size(this.x0,1)]);
                }
            } else {
                var rpar = [];
                this.model.nzcross = new ScilabDouble([0]);
                this.model.nmode = new ScilabDouble([0]);
            }
            if (ok) {
                this.model.rpar = new ScilabDouble(rpar);
                this.model.state = new ScilabDouble(this.x0);
                var tmpvar0 = check_io(this.model,this.graphics,size(this.x0,1)*[[1],[ones(this.reinit,1)]],size(this.x0,1),ones(this.reinit,1),[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/INTEGRAL_f.sci" */
function INTEGRAL_f() {
    INTEGRAL_f.prototype.define = function INTEGRAL_f() {
        this.x0 = 0;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["integr"]);
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.state = new ScilabDouble([this.x0]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.exprs = strcat(sci2exp(this.x0));
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"INTEGRAL_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    INTEGRAL_f.prototype.details = function INTEGRAL_f() {
        return this.x;
    }
    INTEGRAL_f.prototype.get = function INTEGRAL_f() {
        var options = {
            x0:["Initial state",this.x0],
        }
        return options;
    }
    INTEGRAL_f.prototype.set = function INTEGRAL_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.x0 = parseFloat(arguments[0]["x0"]);
            if (!ok) {
                break;
            }
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.model.state = new ScilabDouble([this.x0]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        this.x.model.firing = [];
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/INTEGRAL_m.sci" */
function INTEGRAL_m() {
    INTEGRAL_m.prototype.define = function INTEGRAL_m() {
        this.maxp = 1;
        var minp = -1;
        var rpar = [];
        this.model = scicos_model();
        this.model.state = new ScilabDouble([0]);
        this.model.sim = list(new ScilabString(["integral_func"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.in2 = new ScilabDouble([1]);
        this.model.out2 = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble(rpar);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.exprs = string([[0],[0],[0],[this.maxp],[minp]]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"INTEGRAL_m\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    INTEGRAL_m.prototype.details = function INTEGRAL_m() {
        return this.x;
    }
    INTEGRAL_m.prototype.get = function INTEGRAL_m() {
        var options = {
            x0:["Initial Condition",this.x0],
            reinit:["With re-intialization (1:yes, 0:no)",this.reinit],
            satur:["With saturation (1:yes, 0:no)",this.satur],
            maxp:["Upper limit",this.maxp],
            lowp:["Lower limit",this.lowp],
        }
        return options;
    }
    INTEGRAL_m.prototype.set = function INTEGRAL_m() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.x0 = arguments[0]["x0"];
            this.reinit = parseFloat(arguments[0]["reinit"]);
            this.satur = parseFloat(arguments[0]["satur"]);
            this.maxp = parseFloat(arguments[0]["maxp"]);
            this.lowp = parseFloat(arguments[0]["lowp"]);
            if (!ok) {
                break;
            }
            if (isreal(this.x0)) {
                var Datatype = 1;
            } else {
                var Datatype = 2;
            }
            if (this.reinit!=0) {
                this.reinit = 1;
            }
            if (this.satur!=0) {
                this.satur = 1;
                if (Datatype==1) {
                    if (size(this.maxp,"*")==1) {
                        this.maxp = this.maxp*ones(this.x0);
                    }
                    if (size(this.lowp,"*")==1) {
                        this.lowp = this.lowp*ones(this.x0);
                    }
                    if ((size(this.x0)!=size(this.maxp)||size(this.x0)!=size(this.lowp))) {
                        message("x0 and Upper limit and Lower limit must have same size");
                        throw "user error";
                        var ok = false;
                    } else if (or(this.maxp<=this.lowp)) {
                        message("Upper limits must be > Lower limits");
                        throw "user error";
                        var ok = false;
                    } else if (or(this.x0>this.maxp)||or(this.x0<this.lowp)) {
                        message("Initial condition x0 should be inside the limits");
                        throw "user error";
                        var ok = false;
                    } else {
                        var rpar = [[real(this.maxp.slice())],[real(this.lowp.slice())]];
                        this.model.nzcross = new ScilabDouble([size(this.x0,"*")]);
                        this.model.nmode = new ScilabDouble([size(this.x0,"*")]);
                    }
                } else if ((Datatype==2)) {
                    if (size(this.maxp,"*")==1) {
                        this.maxp = math.complex(this.maxp*ones(this.x0),(this.maxp*ones(this.x0)));
                    }
                    if (size(this.lowp,"*")==1) {
                        this.lowp = math.complex(this.lowp*ones(this.x0),(this.lowp*ones(this.x0)));
                    }
                    if ((size(this.x0)!=size(this.maxp)||size(this.x0)!=size(this.lowp))) {
                        message("x0 and Upper limit and Lower limit must have same size");
                        throw "user error";
                        var ok = false;
                    } else if (or(real(this.maxp)<=real(this.lowp))||or(imag(this.maxp)<=imag(this.lowp))) {
                        message("Upper limits must be > Lower limits");
                        throw "user error";
                        var ok = false;
                    } else if (or(real(this.x0)>real(this.maxp))||or(real(this.x0)<real(this.lowp))||or(imag(this.x0)>imag(this.maxp))||or(imag(this.x0)<imag(this.lowp))) {
                        message("Initial condition x0 should be inside the limits");
                        throw "user error";
                        var ok = false;
                    } else {
                        var rpar = [[real(this.maxp.slice())],[real(this.lowp.slice())],[imag(this.maxp.slice())],[imag(this.lowp.slice())]];
                        this.model.nzcross = new ScilabDouble([2*size(this.x0,"*")]);
                        this.model.nmode = new ScilabDouble([2*size(this.x0,"*")]);
                    }
                }
            } else {
                var rpar = [];
                this.model.nzcross = new ScilabDouble([0]);
                this.model.nmode = new ScilabDouble([0]);
            }
            if (ok) {
                this.model.rpar = new ScilabDouble(rpar);
                if ((Datatype==1)) {
                    this.model.state = new ScilabDouble([real(this.x0.slice())]);
                    this.model.sim = list(new ScilabString(["integral_func"]), new ScilabDouble([4]));
                    var it = [[1],[ones(this.reinit,1)]];
                    var ot = 1;
                } else if ((Datatype==2)) {
                    this.model.state = new ScilabDouble([real(this.x0.slice())],[imag(this.x0.slice())]);
                    this.model.sim = list(new ScilabString(["integralz_func"]), new ScilabDouble([4]));
                    var it = [[2],[2*ones(this.reinit,1)]];
                    var ot = 2;
                } else {
                    message("Datatype is not supported");
                    throw "user error";
                    var ok = false;
                }
                if (ok) {
                    var in1 = [size(this.x0,1)*[[1],[ones(this.reinit,1)]],size(this.x0,2)*[[1],[ones(this.reinit,1)]]];
                    var out = size(this.x0);
                    var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),ones(this.reinit,1),[]);
                    this.model = tmpvar0[0];
                    this.graphics = tmpvar0[1];
                    var ok = tmpvar0[2];
                }
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/PID.sci" */
function PID() {
    PID.prototype.define = function PID() {
        var scs_m = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["PID"],tol=[0.0001,0.000001,1.000e-10,100001,0,0],tf=100000,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m.objs[1-1] = scicos_block(gui="INTEGRAL_m",graphics=scicos_graphics(orig=[318.304,183.11733],sz=[40,40],flip=true,theta=0,exprs=[["0"],["0"],["0"],["1"],["-1"]],pin=7,pout=9,pein=[],peout=[],gr_i=[],id="1/s",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("integral_func",4),in1=1,in2=1,intyp=1,out=1,out2=1,outtyp=1,evtin=[],evtout=[],state=0,dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[false,true],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[2-1] = scicos_block(gui="SUMMATION",graphics=scicos_graphics(orig=[387.97067,172.85067],sz=[40,60],flip=true,theta=0,exprs=[["1"],["[1;1;1]"]],pin=[[10],[9],[11]],pout=19,pein=[],peout=[],gr_i=[],id="",in_implicit=[["E"],["E"],["E"]],out_implicit="E"),model=scicos_model(sim=list("summation",4),in1=[[-1],[-1],[-1]],in2=[[-2],[-2],[-2]],intyp=[[1],[1],[1]],out=-1,out2=-2,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[[1],[1],[1]],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[3-1] = scicos_block(gui="GAINBLK",graphics=scicos_graphics(orig=[321.23733,235.91733],sz=[40,40],flip=true,theta=0,exprs="1",pin=17,pout=10,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("gainblk",4),in1=-1,in2=-2,intyp=1,out=-1,out2=-2,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=1,ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[4-1] = scicos_block(gui="DERIV",graphics=scicos_graphics(orig=[319.03733,135.45067],sz=[40,40],flip=true,theta=0,exprs=[],pin=8,pout=11,pein=[],peout=[],gr_i=[],id="s",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("deriv",4),in1=-1,in2=-2,intyp=1,out=-1,out2=-2,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="x",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[5-1] = scicos_block(gui="GAINBLK",graphics=scicos_graphics(orig=[255.23733,183.11733],sz=[40,40],flip=true,theta=0,exprs="1",pin=13,pout=7,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("gainblk",4),in1=-1,in2=-2,intyp=1,out=-1,out2=-2,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=1,ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[6-1] = scicos_block(gui="GAINBLK",graphics=scicos_graphics(orig=[255.23733,135.45067],sz=[40,40],flip=true,theta=0,exprs="1",pin=14,pout=8,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("gainblk",4),in1=-1,in2=-2,intyp=1,out=-1,out2=-2,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=1,ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[7-1] = scicos_link(xx=[[303.80876],[309.73257]],yy=[[203.11733],[203.11733]],id="drawlink",thick=[0,0],ct=[1,1],from=[5,1,0],to=[1,1,1]);
        scs_m.objs[8-1] = scicos_link(xx=[[303.80876],[310.4659]],yy=[[155.45067],[155.45067]],id="drawlink",thick=[0,0],ct=[1,1],from=[6,1,0],to=[4,1,1]);
        scs_m.objs[9-1] = scicos_link(xx=[[366.87543],[379.39924]],yy=[[203.11733],[202.85067]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[2,2,1]);
        scs_m.objs[10-1] = scicos_link(xx=[[369.80876],[379.39924],[379.39924]],yy=[[255.91733],[255.91733],[217.85067]],id="drawlink",thick=[0,0],ct=[1,1],from=[3,1,0],to=[2,1,1]);
        scs_m.objs[11-1] = scicos_link(xx=[[367.60876],[379.39924],[379.39924]],yy=[[155.45067],[155.45067],[187.85067]],id="drawlink",thick=[0,0],ct=[1,1],from=[4,1,0],to=[2,3,1]);
        scs_m.objs[12-1] = scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[[234.704],[203.11733]],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=16,pout=[[13],[14]],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[["E"],["E"],["E"]]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[[-1],[-1],[-1]],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[13-1] = scicos_link(xx=[[234.704],[246.6659]],yy=[[203.11733],[203.11733]],id="drawlink",thick=[0,0],ct=[1,1],from=[12,1,0],to=[5,1,1]);
        scs_m.objs[14-1] = scicos_link(xx=[[234.704],[234.704],[246.6659]],yy=[[203.11733],[155.45067],[155.45067]],id="drawlink",thick=[0,0],ct=[1,1],from=[12,2,0],to=[6,1,1]);
        scs_m.objs[15-1] = scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[[233.97067],[203.11733]],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=21,pout=[[16],[17]],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[["E"],["E"],["E"]]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[[-1],[-1],[-1]],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[16-1] = scicos_link(xx=[[233.97067],[234.704]],yy=[[203.11733],[203.11733]],id="drawlink",thick=[0,0],ct=[1,1],from=[15,1,0],to=[12,1,1]);
        scs_m.objs[17-1] = scicos_link(xx=[[233.97067],[233.97067],[312.6659]],yy=[[203.11733],[255.91733],[255.91733]],id="drawlink",thick=[0,0],ct=[1,1],from=[15,2,0],to=[3,1,1]);
        scs_m.objs[18-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[456.5421,192.85067],sz=[20,20],flip=true,theta=0,exprs="1",pin=19,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[19-1] = scicos_link(xx=[[436.5421],[456.5421]],yy=[[202.85067],[202.85067]],id="drawlink",thick=[0,0],ct=[1,1],from=[2,1,0],to=[18,1,1]);
        scs_m.objs[20-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[193.97067,193.11733],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=21,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[21-1] = scicos_link(xx=[[213.97067],[233.97067]],yy=[[203.11733],[203.11733]],id="drawlink",thick=[0,0],ct=[1,1],from=[20,1,0],to=[15,1,1]);
        this.model = scicos_model();
        this.model.sim = new ScilabString(["csuper"]);
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.blocktype = new ScilabString(["h"]);
        this.model.firing = new ScilabBoolean([false]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.model.rpar = new ScilabDouble([scs_m]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"PID\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble([]),this.gr_i);
        return new BasicBlock(this.x);
    }
    PID.prototype.details = function PID() {
        return this.x;
    }
    PID.prototype.get = function PID() {
        var options = {
            p:["Proportional",this.p],
            i:["Integral",this.i],
            d:["Derivation",this.d],
        }
        return options;
    }
    PID.prototype.set = function PID() {
        var ppath = list(0,0,0);
            if (typeof(o)=="Link") {
                if (from.gui=="GAINBLK") {
                    switch (to.gui) {
                    case "SUMMATION":
                        ppath[1-1] = o.from[1-1];
                    case "INTEGRAL_m":
                        ppath[2-1] = o.from[1-1];
                    case "DERIV":
                        ppath[3-1] = o.from[1-1];
                    }
                } else if (to.gui=="GAINBLK") {
                    switch (from.gui) {
                    case "SUMMATION":
                        ppath[1-1] = o.to[1-1];
                    case "INTEGRAL_m":
                        ppath[2-1] = o.to[1-1];
                    case "DERIV":
                        ppath[3-1] = o.to[1-1];
                    }
                }
                if (and(ppath!=list(0,0,0))) {
                    break;
                }
            }
        }
        var newpar = list();
        this.exprs[1-1] = xx1.graphics.exprs[1-1];
        var p_old = xx1.model.rpar;
        this.exprs[2-1] = xx2.graphics.exprs[1-1];
        var i_old = xx2.model.rpar;
        this.exprs[3-1] = xx3.graphics.exprs[1-1];
        var d_old = xx3.model.rpar;
        var y = 0;
        while (true) {
            var ok = true;
            this.p = arguments[0]["p"];
            this.i = arguments[0]["i"];
            this.d = arguments[0]["d"];
            this.exprs0 = arguments[0]["exprs0"];
            if (!ok) {
                break;
            }
            if (ok) {
                xx1.graphics.exprs = this.exprs0[1-1];
                xx1.model.rpar = this.p;
                xx2.graphics.exprs = this.exprs0[2-1];
                xx2.model.rpar = this.i;
                xx3.graphics.exprs = this.exprs0[3-1];
                xx3.model.rpar = this.d;
                break;
            }
        }
        var needcompile = 0;
        if (!(p_old==this.p&&i_old==this.i&&d_old==this.d)) {
            newpar[size(newpar)+1-1] = ppath[1-1];
            newpar[size(newpar)+1-1] = ppath[2-1];
            newpar[size(newpar)+1-1] = ppath[3-1];
            var needcompile = 2;
        }
        var y = max(y,needcompile);
        var typ = newpar;
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/REGISTER.sci" */
function REGISTER() {
    REGISTER.prototype.define = function REGISTER() {
        this.z0 = zeros(10,1);
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["delay4"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble([this.z0]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = strcat(string(this.z0),";");
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"REGISTER\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    REGISTER.prototype.details = function REGISTER() {
        return this.x;
    }
    REGISTER.prototype.get = function REGISTER() {
        var options = {
            z0:["Register initial condition",this.z0],
            it:["Datatype (1=double 3=int32 ...)",this.it],
        }
        return options;
    }
    REGISTER.prototype.set = function REGISTER() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,1)==1) {
            this.exprs = [[this.exprs],[sci2exp(1)]];
        }
        while (true) {
            var ok = true;
            this.z0 = parseFloat(arguments[0]["z0"]);
            this.it = arguments[0]["it"];
            if (!ok) {
                break;
            }
            if (prod(size(this.z0))<1) {
                message("Register length must be at least 1");
                throw "user error";
                var ok = false;
            }
            if (this.it==1) {
                this.model.sim = list(new ScilabString(["delay4"]), new ScilabDouble([4]));
                this.z0 = double(this.z0);
                this.model.dstate = new ScilabDouble([this.z0]);
                this.model.odstate = list();
            } else {
                if (this.it==3) {
                    this.model.sim = list(new ScilabString(["delay4_i32"]), new ScilabDouble([4]));
                    this.z0 = int32(this.z0);
                } else if (this.it==4) {
                    this.model.sim = list(new ScilabString(["delay4_i16"]), new ScilabDouble([4]));
                    this.z0 = int16(this.z0);
                } else if (this.it==5) {
                    this.model.sim = list(new ScilabString(["delay4_i8"]), new ScilabDouble([4]));
                    this.z0 = int8(this.z0);
                } else if (this.it==6) {
                    this.model.sim = list(new ScilabString(["delay4_ui32"]), new ScilabDouble([4]));
                    this.z0 = uint32(this.z0);
                } else if (this.it==7) {
                    this.model.sim = list(new ScilabString(["delay4_ui16"]), new ScilabDouble([4]));
                    this.z0 = uint16(this.z0);
                } else if (this.it==8) {
                    this.model.sim = list(new ScilabString(["delay4_ui8"]), new ScilabDouble([4]));
                    this.z0 = uint8(this.z0);
                } else {
                    message("Datatype is not supported");
                    throw "user error";
                    var ok = false;
                }
                this.model.odstate = list(new ScilabDouble([this.z0]));
                this.model.dstate = new ScilabDouble([]);
            }
            if (ok) {
                var in1 = [1,1];
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,this.it),list(in1,this.it),1,[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble(this.exprs);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/REGISTER_f.sci" */
function REGISTER_f() {
    REGISTER_f.prototype.define = function REGISTER_f() {
        this.z0 = zeros(10,1);
        this.model = scicos_model();
        this.model.sim = new ScilabString(["delay"]);
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble([this.z0]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = strcat(string(this.z0),";");
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"REGISTER_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2.5,2.5]),this.model,new ScilabDouble([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    REGISTER_f.prototype.details = function REGISTER_f() {
        return this.x;
    }
    REGISTER_f.prototype.get = function REGISTER_f() {
        var options = {
            z0:["Register initial condition",this.z0],
        }
        return options;
    }
    REGISTER_f.prototype.set = function REGISTER_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.z0 = parseFloat(arguments[0]["z0"]);
            if (!ok) {
                break;
            }
            if (prod(size(this.z0))<1) {
                message("Register length must be at least 1");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.dstate = new ScilabDouble([this.z0]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/SAMPHOLD.sci" */
function SAMPHOLD() {
    SAMPHOLD.prototype.define = function SAMPHOLD() {
        var in1 = -1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["samphold4"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([-1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SAMPHOLD\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([" "]),this.gr_i);
        return new BasicBlock(this.x);
    }
    SAMPHOLD.prototype.details = function SAMPHOLD() {
        return this.x;
    }
    SAMPHOLD.prototype.get = function SAMPHOLD() {
        alert("parameters cannot be modified");
    }
    SAMPHOLD.prototype.set = function SAMPHOLD() {
        this.x.model.firing = [];
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/SAMPHOLD_m.sci" */
function SAMPHOLD_m() {
    SAMPHOLD_m.prototype.define = function SAMPHOLD_m() {
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["samphold4_m"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-2]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [sci2exp(1)];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SAMPHOLD_m\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    SAMPHOLD_m.prototype.details = function SAMPHOLD_m() {
        return this.x;
    }
    SAMPHOLD_m.prototype.get = function SAMPHOLD_m() {
        var options = {
            it:["Datatype(1=real double 2=Complex 3=int32 ...)",this.it],
        }
        return options;
    }
    SAMPHOLD_m.prototype.set = function SAMPHOLD_m() {
        this.x.model.firing = [];
        var label = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.it = arguments[0]["it"];
            if (!ok) {
                break;
            }
            if (((this.it<1)||(this.it>8))) {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                var in1 = [this.model.in,this.model.in2];
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,this.it),list(in1,this.it),1,[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                if (ok) {
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/SAMPLEHOLD_f.sci" */
function SAMPLEHOLD_f() {
    SAMPLEHOLD_f.prototype.define = function SAMPLEHOLD_f() {
        var in1 = -1;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["samphold"]);
        this.model.in = new ScilabDouble([-1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SAMPLEHOLD_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([" "]),this.gr_i);
        return new BasicBlock(this.x);
    }
    SAMPLEHOLD_f.prototype.details = function SAMPLEHOLD_f() {
        return this.x;
    }
    SAMPLEHOLD_f.prototype.get = function SAMPLEHOLD_f() {
        alert("parameters cannot be modified");
    }
    SAMPLEHOLD_f.prototype.set = function SAMPLEHOLD_f() {
        this.x.model.firing = [];
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/SOM_f.sci" */
function SOM_f() {
    SOM_f.prototype.define = function SOM_f() {
        var sgn = [[1],[1],[1]];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["sum"]), new ScilabDouble([2]));
        this.model.in = new ScilabDouble([-1],[-1],[-1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.rpar = new ScilabDouble(sgn);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[sci2exp(1)],[sci2exp(sgn)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SOM_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    SOM_f.prototype.details = function SOM_f() {
        return this.x;
    }
    SOM_f.prototype.get = function SOM_f() {
        alert("parameters cannot be modified");
    }
    SOM_f.prototype.set = function SOM_f() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")==2) {
            this.exprs = this.exprs[2-1];
        }
        if (size(this.exprs,"*")!=3) {
            this.exprs = string(this.model.rpar);
        }
        if (this.graphics.flip) {
            var labs = ["down","left","up"];
        } else {
            var labs = ["down","right","up"];
        }
        var str = [["This sum block is obsolete","parameters cannot be modified. Please replace it with new sum block"],["and gain blocks in the linear palette"," ","Input ports are located at up, side and  down positions.","Current gains are:"]];
        var str = [[str],[(part(labs.slice(),1,7)+this.exprs.slice())]];
        message(str);
        throw "user error";
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/SUMMATION.sci" */
function SUMMATION() {
    SUMMATION.prototype.define = function SUMMATION() {
        this.sgn = [[1],[-1]];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["summation"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([-1],[-1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2],[-2]);
        this.model.out2 = new ScilabDouble([-2]);
        this.model.ipar = new ScilabDouble(this.sgn);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = sci2exp(this.sgn);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SUMMATION\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,3]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new Summation(this.x);
    }
    SUMMATION.prototype.details = function SUMMATION() {
        return this.x;
    }
    SUMMATION.prototype.get = function SUMMATION() {
        var options = {
            Datatype:["Datatype (1=real double  2=complex 3=int32 ...)",this.Datatype],
            sgn:["Number of inputs or sign vector (of +1, -1)",this.sgn.toString().replace(/,/g," ")],
            satur:["Do on Overflow(0=Nothing 1=Saturate 2=Error)",this.satur],
        }
        return options;
    }
    SUMMATION.prototype.set = function SUMMATION() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,1)==1) {
            this.exprs = [[sci2exp(1)],[this.exprs],[sci2exp(0)]];
        } else if (size(this.exprs,1)==2) {
            this.exprs = [[this.exprs],[sci2exp(0)]];
        }
        while (true) {
            var ok = true;
            this.Datatype = arguments[0]["Datatype"];
            this.sgn = inverse(arguments[0]["sgn"]);
            this.satur = arguments[0]["satur"];
            if (!ok) {
                break;
            }
            this.sgn = this.sgn.slice();
            if ((this.satur!=0&&this.satur!=1&&this.satur!=2)) {
                message("Do on overflow must be 0,1,2");
                throw "user error";
                var ok = false;
            }
            if (size(this.sgn,1)==1) {
                if (this.sgn<1) {
                    message("Number of inputs must be > 0");
                    throw "user error";
                    var ok = false;
                } else if (this.sgn==1) {
                    var in1 = -1;
                    var in2 = -2;
                    this.sgn = [];
                    var nout = 1;
                    var nout2 = 1;
                } else {
                    var in1 = -ones(this.sgn,1);
                    var in2 = 2*in1;
                    this.sgn = ones(this.sgn,1);
                    var nout = -1;
                    var nout2 = -2;
                }
            } else {
                if (!and(abs(this.sgn)==1)) {
                    message("Signs can only be +1 or -1");
                    throw "user error";
                    var ok = false;
                } else {
                    var in1 = -ones(size(this.sgn,1),1);
                    var in2 = 2*in1;
                    var nout = -1;
                    var nout2 = -2;
                }
            }
            var it = this.Datatype*ones(1,size(in1,1));
            var ot = this.Datatype;
            if (this.Datatype==1) {
                this.model.sim = list(new ScilabString(["summation"]), new ScilabDouble([4]));
            } else if (this.Datatype==2) {
                this.model.sim = list(new ScilabString(["summation_z"]), new ScilabDouble([4]));
            } else if (((this.Datatype<1)||(this.Datatype>8))) {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            } else {
                if (this.satur==0) {
                    if (this.Datatype==3) {
                        this.model.sim = list(new ScilabString(["summation_i32n"]), new ScilabDouble([4]));
                    } else if (this.Datatype==4) {
                        this.model.sim = list(new ScilabString(["summation_i16n"]), new ScilabDouble([4]));
                    } else if (this.Datatype==5) {
                        this.model.sim = list(new ScilabString(["summation_i8n"]), new ScilabDouble([4]));
                    } else if (this.Datatype==6) {
                        this.model.sim = list(new ScilabString(["summation_ui32n"]), new ScilabDouble([4]));
                    } else if (this.Datatype==7) {
                        this.model.sim = list(new ScilabString(["summation_ui16n"]), new ScilabDouble([4]));
                    } else if (this.Datatype==8) {
                        this.model.sim = list(new ScilabString(["summation_ui8n"]), new ScilabDouble([4]));
                    }
                } else if (this.satur==1) {
                    if (this.Datatype==3) {
                        this.model.sim = list(new ScilabString(["summation_i32s"]), new ScilabDouble([4]));
                    } else if (this.Datatype==4) {
                        this.model.sim = list(new ScilabString(["summation_i16s"]), new ScilabDouble([4]));
                    } else if (this.Datatype==5) {
                        this.model.sim = list(new ScilabString(["summation_i8s"]), new ScilabDouble([4]));
                    } else if (this.Datatype==6) {
                        this.model.sim = list(new ScilabString(["summation_ui32s"]), new ScilabDouble([4]));
                    } else if (this.Datatype==7) {
                        this.model.sim = list(new ScilabString(["summation_ui16s"]), new ScilabDouble([4]));
                    } else if (this.Datatype==8) {
                        this.model.sim = list(new ScilabString(["summation_ui8s"]), new ScilabDouble([4]));
                    }
                } else if (this.satur==2) {
                    if (this.Datatype==3) {
                        this.model.sim = list(new ScilabString(["summation_i32e"]), new ScilabDouble([4]));
                    } else if (this.Datatype==4) {
                        this.model.sim = list(new ScilabString(["summation_i16e"]), new ScilabDouble([4]));
                    } else if (this.Datatype==5) {
                        this.model.sim = list(new ScilabString(["summation_i8e"]), new ScilabDouble([4]));
                    } else if (this.Datatype==6) {
                        this.model.sim = list(new ScilabString(["summation_ui32e"]), new ScilabDouble([4]));
                    } else if (this.Datatype==7) {
                        this.model.sim = list(new ScilabString(["summation_ui16e"]), new ScilabDouble([4]));
                    } else if (this.Datatype==8) {
                        this.model.sim = list(new ScilabString(["summation_ui8e"]), new ScilabDouble([4]));
                    }
                }
            }
            if (ok) {
                var tmpvar0 = set_io(this.model,this.graphics,list([in1,in2],it),list([nout,nout2],ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.model.rpar = new ScilabDouble([this.satur]);
                this.model.ipar = new ScilabDouble([this.sgn]);
                this.graphics.exprs = new ScilabDouble(this.exprs);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new Summation(this.x);
    }
}
/* autogenerated from "macros/Linear/SUM_f.sci" */
function SUM_f() {
    SUM_f.prototype.define = function SUM_f() {
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["plusblk"]), new ScilabDouble([2]));
        this.model.in = new ScilabDouble([-1],[-1],[-1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SUM_f\",sz(1),sz(2));"]);
        this.exprs = [];
        this.x = new standard_define(new ScilabDouble([1,1]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    SUM_f.prototype.details = function SUM_f() {
        return this.x;
    }
    SUM_f.prototype.get = function SUM_f() {
        alert("parameters cannot be modified");
    }
    SUM_f.prototype.set = function SUM_f() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/TCLSS.sci" */
function TCLSS() {
    TCLSS.prototype.define = function TCLSS() {
        this.x0 = 0;
        this.A = 0;
        this.B = 1;
        this.C = 1;
        this.D = 0;
        var in1 = 1;
        var nx = size(this.x0,"*");
        var out = 1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["tcslti4"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([in1],[nx]);
        this.model.out = new ScilabDouble([out]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.state = new ScilabDouble([this.x0]);
        this.model.rpar = new ScilabDouble([this.A.slice()],[this.B.slice()],[this.C.slice()],[this.D.slice()]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.exprs = [[strcat(sci2exp(this.A))],[strcat(sci2exp(this.B))],[strcat(sci2exp(this.C))],[strcat(sci2exp(this.D))],[strcat(sci2exp(this.x0))]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"TCLSS\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    TCLSS.prototype.details = function TCLSS() {
        return this.x;
    }
    TCLSS.prototype.get = function TCLSS() {
        var options = {
            A:["A matrix",this.A],
            B:["B matrix",this.B],
            C:["C matrix",this.C],
            D:["D matrix",this.D],
            x0:["Initial state",this.x0],
        }
        return options;
    }
    TCLSS.prototype.set = function TCLSS() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")==7) {
            this.exprs = this.exprs[[1:4,7]-1];
        }
        while (true) {
            var ok = true;
            this.A = parseFloat(arguments[0]["A"]);
            this.B = parseFloat(arguments[0]["B"]);
            this.C = parseFloat(arguments[0]["C"]);
            this.D = parseFloat(arguments[0]["D"]);
            this.x0 = parseFloat(arguments[0]["x0"]);
            if (!ok) {
                break;
            }
            var out = size(this.C,1);
            if (out==0) {
                var out = [];
            }
            var in1 = size(this.B,2);
            if (in1==0) {
                var in1 = [];
            }
            var tmpvar0 = size(this.A);
            var ms = tmpvar0[0];
            var ns = tmpvar0[1];
            if (ms!=ns) {
                message("A matrix must be square");
                throw "user error";
            } else {
                var tmpvar1 = check_io(this.model,this.graphics,[[in1],[ms]],out,1,[]);
                this.model = tmpvar1[0];
                this.graphics = tmpvar1[1];
                var ok = tmpvar1[2];
                if (ok) {
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    var rpar = [[this.A.slice()],[this.B.slice()],[this.C.slice()],[this.D.slice()]];
                    if (this.D.length!=0) {
                        if (norm(this.D,1)!=0) {
                            var mmm = [true,true];
                        } else {
                            var mmm = [false,true];
                        }
                        if (or(this.model.dep_ut!=mmm)) {
                            this.model.dep_ut = new ScilabBoolean(mmm);
                        }
                    } else {
                        this.model.dep_ut = new ScilabBoolean([false,true]);
                    }
                    this.model.state = new ScilabDouble(this.x0.slice());
                    this.model.rpar = new ScilabDouble(rpar);
                    if (this.D.length!=0) {
                        this.model.sim = list(new ScilabString(["tcslti4"]), new ScilabDouble([4]));
                    } else {
                        this.model.sim = list(new ScilabString(["tcsltj4"]), new ScilabDouble([4]));
                    }
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/TCLSS_f.sci" */
function TCLSS_f() {
    TCLSS_f.prototype.define = function TCLSS_f() {
        this.x0 = 0;
        this.A = 0;
        this.B = 1;
        this.C = 1;
        this.D = 0;
        var in1 = 1;
        var nx = size(this.x0,"*");
        var out = 1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["tcslti"]), new ScilabDouble([1]));
        this.model.in = new ScilabDouble([in1],[nx]);
        this.model.out = new ScilabDouble([out]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.state = new ScilabDouble([this.x0]);
        this.model.rpar = new ScilabDouble([this.A.slice()],[this.B.slice()],[this.C.slice()],[this.D.slice()]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.exprs = [[strcat(sci2exp(this.A))],[strcat(sci2exp(this.B))],[strcat(sci2exp(this.C))],[strcat(sci2exp(this.D))],[strcat(sci2exp(this.x0))]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"TCLSS_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    TCLSS_f.prototype.details = function TCLSS_f() {
        return this.x;
    }
    TCLSS_f.prototype.get = function TCLSS_f() {
        var options = {
            A:["A matrix",this.A],
            B:["B matrix",this.B],
            C:["C matrix",this.C],
            D:["D matrix",this.D],
            x0:["Initial state",this.x0],
        }
        return options;
    }
    TCLSS_f.prototype.set = function TCLSS_f() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")==7) {
            this.exprs = this.exprs[[1:4,7]-1];
        }
        while (true) {
            var ok = true;
            this.A = parseFloat(arguments[0]["A"]);
            this.B = parseFloat(arguments[0]["B"]);
            this.C = parseFloat(arguments[0]["C"]);
            this.D = parseFloat(arguments[0]["D"]);
            this.x0 = parseFloat(arguments[0]["x0"]);
            if (!ok) {
                break;
            }
            var out = size(this.C,1);
            if (out==0) {
                var out = [];
            }
            var in1 = size(this.B,2);
            if (in1==0) {
                var in1 = [];
            }
            var tmpvar0 = size(this.A);
            var ms = tmpvar0[0];
            var ns = tmpvar0[1];
            if (ms!=ns) {
                message("A matrix must be square");
                throw "user error";
            } else {
                var tmpvar1 = check_io(this.model,this.graphics,[[in1],[ms]],out,1,[]);
                this.model = tmpvar1[0];
                this.graphics = tmpvar1[1];
                var ok = tmpvar1[2];
                if (ok) {
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    var rpar = [[this.A.slice()],[this.B.slice()],[this.C.slice()],[this.D.slice()]];
                    if (this.D.length!=0) {
                        if (norm(this.D,1)!=0) {
                            var mmm = [true,true];
                        } else {
                            var mmm = [false,true];
                        }
                        if (or(this.model.dep_ut!=mmm)) {
                            this.model.dep_ut = new ScilabBoolean(mmm);
                        }
                    } else {
                        this.model.dep_ut = new ScilabBoolean([false,true]);
                    }
                    this.model.state = new ScilabDouble(this.x0.slice());
                    this.model.rpar = new ScilabDouble(rpar);
                    if (this.D.length!=0) {
                        this.model.sim = list(new ScilabString(["tcslti"]), new ScilabDouble([1]));
                    } else {
                        this.model.sim = list(new ScilabString(["tcsltj"]), new ScilabDouble([1]));
                    }
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/TIME_DELAY.sci" */
function TIME_DELAY() {
    TIME_DELAY.prototype.define = function TIME_DELAY() {
        var nin = 1;
        this.T = 1;
        this.init = 0;
        this.N = 1024;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["time_delay"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([nin]);
        this.model.out = new ScilabDouble([nin]);
        this.model.rpar = new ScilabDouble([this.T,this.init]);
        this.model.ipar = new ScilabDouble([this.N]);
        this.model.blocktype = new ScilabString(["x"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.exprs = [[string(this.T)],[string(this.init)],[string(this.N)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"TIME_DELAY\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3.5,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    TIME_DELAY.prototype.details = function TIME_DELAY() {
        return this.x;
    }
    TIME_DELAY.prototype.get = function TIME_DELAY() {
        var options = {
            T:["Delay",this.T],
            init:["initial input",this.init],
            N:["Buffer size",this.N],
        }
        return options;
    }
    TIME_DELAY.prototype.set = function TIME_DELAY() {
        this.exprs = this.graphics.exprs;
        var nin = this.model.in[1-1];
        while (true) {
            var ok = true;
            this.T = parseFloat(arguments[0]["T"]);
            this.init = parseFloat(arguments[0]["init"]);
            this.N = parseFloat(arguments[0]["N"]);
            if (!ok) {
                break;
            }
            if (this.N<2) {
                message("Buffer must be larger than 2");
                throw "user error";
                var ok = false;
            }
            if (this.T<=0) {
                message("Delay must be positive");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                var tmpvar0 = check_io(this.model,this.graphics,[-1],-1,[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.rpar = new ScilabDouble([this.T],[this.init]);
                this.model.ipar = new ScilabDouble([this.N]);
                this.model.dep_ut = new ScilabBoolean([false,true]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Linear/VARIABLE_DELAY.sci" */
function VARIABLE_DELAY() {
    VARIABLE_DELAY.prototype.define = function VARIABLE_DELAY() {
        var nin = 1;
        this.T = 1;
        this.init = 0;
        this.N = 1024;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["variable_delay"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([nin],[1]);
        this.model.out = new ScilabDouble([nin]);
        this.model.rpar = new ScilabDouble([this.T,this.init]);
        this.model.ipar = new ScilabDouble([this.N]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [[string(this.T)],[string(this.init)],[string(this.N)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"VARIABLE_DELAY\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    VARIABLE_DELAY.prototype.details = function VARIABLE_DELAY() {
        return this.x;
    }
    VARIABLE_DELAY.prototype.get = function VARIABLE_DELAY() {
        var options = {
            T:["Max delay",this.T],
            init:["initial input",this.init],
            N:["Buffer size",this.N],
        }
        return options;
    }
    VARIABLE_DELAY.prototype.set = function VARIABLE_DELAY() {
        this.exprs = this.graphics.exprs;
        var nin = this.model.in[1-1];
        while (true) {
            var ok = true;
            this.T = parseFloat(arguments[0]["T"]);
            this.init = parseFloat(arguments[0]["init"]);
            this.N = parseFloat(arguments[0]["N"]);
            if (!ok) {
                break;
            }
            if (this.N<2) {
                message("Buffer must be larger than 2");
                throw "user error";
                var ok = false;
            }
            if (this.T<=0) {
                message("Delay must be positive");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                var tmpvar0 = check_io(this.model,this.graphics,[[-1],[1]],-1,[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.rpar = new ScilabDouble([this.T],[this.init]);
                this.model.ipar = new ScilabDouble([this.N]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/CUMSUM.sci" */
function CUMSUM() {
    CUMSUM.prototype.define = function CUMSUM() {
        this.model = scicos_model();
        var function_name = "cumsum_m";
        var funtyp = 4;
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-2]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [[sci2exp(1)],[sci2exp(0)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CUMSUM\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    CUMSUM.prototype.details = function CUMSUM() {
        return this.x;
    }
    CUMSUM.prototype.get = function CUMSUM() {
        var options = {
            typ:["Datatype(1=real double  2=Complex)",this.typ],
            decomptyp:["Sum along (0=the first non singleton dimension  1=Rows  2=Columns)",this.decomptyp],
        }
        return options;
    }
    CUMSUM.prototype.set = function CUMSUM() {
        var label = this.graphics.exprs;
        if (size(label,"*")==14) {
            label[9-1] = [];
        }
        while (true) {
            var ok = true;
            this.typ = inverse(arguments[0]["typ"]);
            this.decomptyp = arguments[0]["decomptyp"];
            this.lab = arguments[0]["lab"];
            if (!ok) {
                break;
            }
            var label = this.lab;
            if ((this.typ==1)) {
                if ((this.decomptyp==0)) {
                    var function_name = "cumsum_m";
                    var out = [-1,-2];
                } else if ((this.decomptyp==1)) {
                    var function_name = "cumsum_r";
                    var out = [-1,1];
                } else if ((this.decomptyp==2)) {
                    var function_name = "cumsum_c";
                    var out = [1,-2];
                } else {
                    message("decomposition type is not supported");
                    throw "user error";
                    var ok = false;
                }
                var it = 1;
                var ot = 1;
            } else if ((this.typ==2)) {
                if ((this.decomptyp==0)) {
                    var function_name = "cumsumz_m";
                } else if ((this.decomptyp==1)) {
                    var function_name = "cumsumz_r";
                } else if ((this.decomptyp==2)) {
                    var function_name = "cumsumz_c";
                } else {
                    message("decomposition type is not supported");
                    throw "user error";
                    var ok = false;
                }
                var it = 2;
                var ot = 2;
            } else {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            }
            var in1 = [this.model.in,this.model.in2];
            var out = [this.model.out,this.model.out2];
            var funtyp = 4;
            if (ok) {
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/EXTRACT.sci" */
function EXTRACT() {
    EXTRACT.prototype.define = function EXTRACT() {
        this.model = scicos_model();
        var function_name = "extract";
        var funtyp = 4;
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.out2 = new ScilabDouble([1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([1,1,1,1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [[sci2exp(1)],[sci2exp([1])],[sci2exp([1])]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"EXTRACT\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    EXTRACT.prototype.details = function EXTRACT() {
        return this.x;
    }
    EXTRACT.prototype.get = function EXTRACT() {
        var options = {
            typ:["Datatype (1=real double  2=Complex)",this.typ],
            a:["Lines to extract",this.a],
            b:["Columns to extract",this.b],
        }
        return options;
    }
    EXTRACT.prototype.set = function EXTRACT() {
        var label = this.graphics.exprs;
        if (size(label,"*")==14) {
            label[9-1] = [];
        }
        while (true) {
            var ok = true;
            this.typ = inverse(arguments[0]["typ"]);
            this.a = inverse(arguments[0]["a"]);
            this.b = inverse(arguments[0]["b"]);
            this.a = this.a.slice();
            this.b = this.b.slice();
            if (!ok) {
                break;
            }
            if ((this.typ==1)) {
                var function_name = "extract";
                var ot = 1;
                var it = 1;
            } else if ((this.typ==2)) {
                var function_name = "extractz";
                var ot = 2;
                var it = 2;
            } else {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            }
            var ma = size(this.a,1);
            var mb = size(this.b,1);
            if ((ma==0||mb==0)) {
                message("empty field");
                throw "user error";
                var ok = false;
            }
            for (i=1;i<=ma;i+=1) {
                if ((this.a[i-1]<=0)) {
                    message("invalid index");
                    throw "user error";
                    var ok = false;
                }
            }
            for (j=1;j<=mb;j+=1) {
                if ((this.b[j-1]<=0)) {
                    message("invalid index");
                    throw "user error";
                    var ok = false;
                }
            }
            this.model.ipar = new ScilabDouble([this.a],[this.b],[ma],[mb]);
            var in1 = [this.model.in,this.model.in2];
            var out = [ma,mb];
            var funtyp = 4;
            if (ok) {
                var label = this.exprs;
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/EXTTRI.sci" */
function EXTTRI() {
    EXTTRI.prototype.define = function EXTTRI() {
        this.model = scicos_model();
        var function_name = "extrilz";
        var funtyp = 4;
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-2]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [[sci2exp(1)],[sci2exp(1)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"EXTTRI\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    EXTTRI.prototype.details = function EXTTRI() {
        return this.x;
    }
    EXTTRI.prototype.get = function EXTTRI() {
        var options = {
            typ:["Datatype(1=real double  2=Complex)",this.typ],
            decomptyp:["extraction type (1=lower  2=upper  3=diagonal)",this.decomptyp],
        }
        return options;
    }
    EXTTRI.prototype.set = function EXTTRI() {
        var label = this.graphics.exprs;
        if (size(label,"*")==14) {
            label[9-1] = [];
        }
        while (true) {
            var ok = true;
            this.typ = inverse(arguments[0]["typ"]);
            this.decomptyp = arguments[0]["decomptyp"];
            this.lab = arguments[0]["lab"];
            if (!ok) {
                break;
            }
            var label = this.lab;
            if ((this.typ==1)) {
                if ((this.decomptyp==1)) {
                    var function_name = "exttril";
                } else if ((this.decomptyp==2)) {
                    var function_name = "exttriu";
                } else if ((this.decomptyp==3)) {
                    var function_name = "extdiag";
                } else {
                    message("decomposition type is not supported");
                    throw "user error";
                    var ok = false;
                }
                var it = 1;
                var ot = 1;
            } else if ((this.typ==2)) {
                if ((this.decomptyp==1)) {
                    var function_name = "exttrilz";
                } else if ((this.decomptyp==2)) {
                    var function_name = "exttriuz";
                } else if ((this.decomptyp==3)) {
                    var function_name = "extdiagz";
                } else {
                    message("decomposition type is not supported");
                    throw "user error";
                    var ok = false;
                }
                var it = 2;
                var ot = 2;
            } else {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            }
            var in1 = [this.model.in,this.model.in2];
            var out = [this.model.out,this.model.out2];
            var funtyp = 4;
            if (ok) {
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/MATBKSL.sci" */
function MATBKSL() {
    MATBKSL.prototype.define = function MATBKSL() {
        this.model = scicos_model();
        var function_name = "mat_bksl";
        var funtyp = 4;
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in = new ScilabDouble([-1],[-1]);
        this.model.in2 = new ScilabDouble([-2],[-3]);
        this.model.intyp = new ScilabDouble([1,1]);
        this.model.out = new ScilabDouble([-2]);
        this.model.out2 = new ScilabDouble([-3]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [sci2exp(1)];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MATBKSL\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    MATBKSL.prototype.details = function MATBKSL() {
        return this.x;
    }
    MATBKSL.prototype.get = function MATBKSL() {
        var options = {
            typ:["Datatype (1=real double  2=Complex)",this.typ],
        }
        return options;
    }
    MATBKSL.prototype.set = function MATBKSL() {
        var label = this.graphics.exprs;
        if (size(label,"*")==14) {
            label[9-1] = [];
        }
        while (true) {
            var ok = true;
            this.typ = inverse(arguments[0]["typ"]);
            if (!ok) {
                break;
            }
            if ((this.typ==1)) {
                var function_name = "mat_bksl";
                var ot = 1;
                var it = [1,1];
            } else if ((this.typ==2)) {
                var function_name = "matz_bksl";
                var ot = 2;
                var it = [2,2];
            } else {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            }
            var in1 = [this.model.in,this.model.in2];
            var out = [this.model.out,this.model.out2];
            var funtyp = 4;
            if (ok) {
                var label = this.exprs;
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/MATCATH.sci" */
function MATCATH() {
    MATCATH.prototype.define = function MATCATH() {
        this.model = scicos_model();
        var function_name = "mat_cath";
        var funtyp = 4;
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in = new ScilabDouble([-1],[-1]);
        this.model.in2 = new ScilabDouble([-2],[-3]);
        this.model.intyp = new ScilabDouble([1,1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([0]);
        this.model.outtyp = new ScilabDouble([-1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [sci2exp(2)];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MATCATH\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,3]),this.model,new ScilabString(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    MATCATH.prototype.details = function MATCATH() {
        return this.x;
    }
    MATCATH.prototype.get = function MATCATH() {
        var options = {
            nin:["Number of input",this.nin],
        }
        return options;
    }
    MATCATH.prototype.set = function MATCATH() {
        var label = this.graphics.exprs;
        if (size(label,"*")>1) {
            var label = "size(evstr("+label[2-1]+"),\'*\')";
        }
        while (true) {
            var ok = true;
            this.nin = arguments[0]["nin"];
            this.lab = arguments[0]["lab"];
            if (!ok) {
                break;
            }
            var label = this.lab;
            var in1 = [-1*(ones(this.nin,1)),-(transpose([2:this.nin+1]))];
            var out = [-1,0];
            var it = -1*(ones(this.nin,1));
            var ot = -1;
            var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
            this.model = tmpvar0[0];
            this.graphics = tmpvar0[1];
            var ok = tmpvar0[2];
            if (ok) {
                var funtyp = 4;
                this.model.sim = list(new ScilabString(["mat_cath"]), new ScilabDouble([funtyp]));
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/MATCATV.sci" */
function MATCATV() {
    MATCATV.prototype.define = function MATCATV() {
        var l1 = [[2],[2]];
        this.model = scicos_model();
        var function_name = "mat_catv";
        var funtyp = 4;
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in2 = new ScilabDouble([-1],[-1]);
        this.model.in = new ScilabDouble([-2],[-3]);
        this.model.intyp = new ScilabDouble([-1,-1]);
        this.model.out = new ScilabDouble([0]);
        this.model.out2 = new ScilabDouble([-1]);
        this.model.outtyp = new ScilabDouble([-1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [sci2exp(2)];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MATCATV\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,3]),this.model,new ScilabString(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    MATCATV.prototype.details = function MATCATV() {
        return this.x;
    }
    MATCATV.prototype.get = function MATCATV() {
        var options = {
            nin:["Number od inputs",this.nin],
        }
        return options;
    }
    MATCATV.prototype.set = function MATCATV() {
        var label = this.graphics.exprs;
        if (size(label,"*")>1) {
            var label = "size(evstr("+label[2-1]+"),\'*\')";
        }
        while (true) {
            var ok = true;
            this.nin = arguments[0]["nin"];
            this.lab = arguments[0]["lab"];
            if (!ok) {
                break;
            }
            var label = this.lab;
            var in1 = [-(transpose([2:this.nin+1])),-ones(this.nin,1)];
            var it = -ones(this.nin,1);
            var ot = -1;
            var out = [0,-1];
            var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
            this.model = tmpvar0[0];
            this.graphics = tmpvar0[1];
            var ok = tmpvar0[2];
            if (ok) {
                var funtyp = 4;
                this.model.sim = list(new ScilabString(["mat_catv"]), new ScilabDouble([funtyp]));
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/MATDET.sci" */
function MATDET() {
    MATDET.prototype.define = function MATDET() {
        this.model = scicos_model();
        var function_name = "mat_det";
        var funtyp = 4;
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-1]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.out2 = new ScilabDouble([1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [sci2exp(1)];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MATDET\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    MATDET.prototype.details = function MATDET() {
        return this.x;
    }
    MATDET.prototype.get = function MATDET() {
        var options = {
            typ:["Datatype(1=real double  2=Complex)",this.typ],
        }
        return options;
    }
    MATDET.prototype.set = function MATDET() {
        var label = this.graphics.exprs;
        if (size(label,"*")==14) {
            label[9-1] = [];
        }
        while (true) {
            var ok = true;
            this.typ = inverse(arguments[0]["typ"]);
            if (!ok) {
                break;
            }
            if ((this.typ==1)) {
                var function_name = "mat_det";
                var ot = 1;
                var it = 1;
            } else if ((this.typ==2)) {
                var function_name = "matz_det";
                var ot = 2;
                var it = 2;
            } else {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            }
            var in1 = [this.model.in,this.model.in2];
            var out = [this.model.out,this.model.out2];
            var funtyp = 4;
            if (ok) {
                var label = this.exprs;
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/MATDIAG.sci" */
function MATDIAG() {
    MATDIAG.prototype.define = function MATDIAG() {
        this.model = scicos_model();
        var function_name = "mat_diag";
        var funtyp = 4;
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([1]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [sci2exp(1)];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MATDIAG\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    MATDIAG.prototype.details = function MATDIAG() {
        return this.x;
    }
    MATDIAG.prototype.get = function MATDIAG() {
        var options = {
            typ:["Datatype (1=real double  2=Complex)",this.typ],
        }
        return options;
    }
    MATDIAG.prototype.set = function MATDIAG() {
        var label = this.graphics.exprs;
        if (size(label,"*")==14) {
            label[9-1] = [];
        }
        while (true) {
            var ok = true;
            this.typ = inverse(arguments[0]["typ"]);
            if (!ok) {
                break;
            }
            if ((this.typ==1)) {
                var function_name = "mat_diag";
                var ot = 1;
                var it = 1;
            } else if ((this.typ==2)) {
                var function_name = "matz_diag";
                var ot = 2;
                var it = 2;
            } else {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            }
            var in1 = [this.model.in,this.model.in2];
            var out = [this.model.out,this.model.out2];
            var funtyp = 4;
            if (ok) {
                var label = this.exprs;
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/MATDIV.sci" */
function MATDIV() {
    MATDIV.prototype.define = function MATDIV() {
        this.model = scicos_model();
        var function_name = "mat_div";
        var funtyp = 4;
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in = new ScilabDouble([-1],[-2]);
        this.model.in2 = new ScilabDouble([-3],[-3]);
        this.model.intyp = new ScilabDouble([1,1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-2]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [sci2exp(1)];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MATDIV\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    MATDIV.prototype.details = function MATDIV() {
        return this.x;
    }
    MATDIV.prototype.get = function MATDIV() {
        var options = {
            typ:["Datatype(1=real double  2=Complex)",this.typ],
        }
        return options;
    }
    MATDIV.prototype.set = function MATDIV() {
        var label = this.graphics.exprs;
        if (size(label,"*")==14) {
            label[9-1] = [];
        }
        while (true) {
            var ok = true;
            this.typ = inverse(arguments[0]["typ"]);
            if (!ok) {
                break;
            }
            if ((this.typ==1)) {
                var function_name = "mat_div";
                var ot = 1;
                var it = [1,1];
            } else if ((this.typ==2)) {
                var function_name = "matz_div";
                var ot = 2;
                var it = [2,2];
            } else {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            }
            var in1 = [this.model.in,this.model.in2];
            var out = [this.model.out,this.model.out2];
            var funtyp = 4;
            if (ok) {
                var label = this.exprs;
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/MATEIG.sci" */
function MATEIG() {
    MATEIG.prototype.define = function MATEIG() {
        this.model = scicos_model();
        var function_name = "mat_vps";
        var funtyp = 4;
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-1]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([1]);
        this.model.outtyp = new ScilabDouble([2]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [[sci2exp(1)],[sci2exp(1)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MATEIG\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    MATEIG.prototype.details = function MATEIG() {
        return this.x;
    }
    MATEIG.prototype.get = function MATEIG() {
        var options = {
            typ:["Datatype(1=real double  2=Complex)",this.typ],
            decomptyp:["decomposition type (1=eig values  2=eig values+eig vectors",this.decomptyp],
        }
        return options;
    }
    MATEIG.prototype.set = function MATEIG() {
        var label = this.graphics.exprs;
        if (size(label,"*")==14) {
            label[9-1] = [];
        }
        while (true) {
            var ok = true;
            this.typ = inverse(arguments[0]["typ"]);
            this.decomptyp = arguments[0]["decomptyp"];
            this.lab = arguments[0]["lab"];
            if (!ok) {
                break;
            }
            var label = this.lab;
            if ((this.typ==1)) {
                if ((this.decomptyp==1)) {
                    var function_name = "mat_vps";
                    var out = [-1,1];
                    var ot = 2;
                } else if ((this.decomptyp==2)) {
                    var function_name = "mat_vpv";
                    var out = [[-1,-1],[-1,-1]];
                    var ot = [2,2];
                } else {
                    message("decomposition type is not supported");
                    throw "user error";
                    var ok = false;
                }
                var it = 1;
            } else if ((this.typ==2)) {
                if ((this.decomptyp==1)) {
                    var function_name = "matz_vps";
                    var out = [-1,1];
                    var ot = 2;
                } else if ((this.decomptyp==2)) {
                    var function_name = "matz_vpv";
                    var out = [[-1,-1],[-1,-1]];
                    var ot = [2,2];
                } else {
                    message("decomposition type is not supported");
                    throw "user error";
                    var ok = false;
                }
                var it = 2;
            } else {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            }
            var in1 = [-1,-1];
            var funtyp = 4;
            if (ok) {
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/MATEXPM.sci" */
function MATEXPM() {
    MATEXPM.prototype.define = function MATEXPM() {
        this.model = scicos_model();
        var function_name = "mat_expm";
        var funtyp = 4;
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-1]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [sci2exp(1)];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MATEXPM\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    MATEXPM.prototype.details = function MATEXPM() {
        return this.x;
    }
    MATEXPM.prototype.get = function MATEXPM() {
        var options = {
            typ:["Datatype(1=real double  2=Complex)",this.typ],
        }
        return options;
    }
    MATEXPM.prototype.set = function MATEXPM() {
        var label = this.graphics.exprs;
        if (size(label,"*")==14) {
            label[9-1] = [];
        }
        while (true) {
            var ok = true;
            this.typ = inverse(arguments[0]["typ"]);
            if (!ok) {
                break;
            }
            if ((this.typ==1)) {
                var function_name = "mat_expm";
                var ot = 1;
                var it = 1;
            } else if ((this.typ==2)) {
                var function_name = "matz_expm";
                var ot = 2;
                var it = 2;
            } else {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            }
            var in1 = [this.model.in,this.model.in2];
            var out = [this.model.out,this.model.out2];
            var funtyp = 4;
            if (ok) {
                var label = this.exprs;
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/MATINV.sci" */
function MATINV() {
    MATINV.prototype.define = function MATINV() {
        this.model = scicos_model();
        var function_name = "mat_inv";
        var funtyp = 4;
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-1]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [sci2exp(1)];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MATINV\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    MATINV.prototype.details = function MATINV() {
        return this.x;
    }
    MATINV.prototype.get = function MATINV() {
        var options = {
            typ:["Datatype(1=real double  2=Complex)",this.typ],
        }
        return options;
    }
    MATINV.prototype.set = function MATINV() {
        var label = this.graphics.exprs;
        if (size(label,"*")==14) {
            label[9-1] = [];
        }
        while (true) {
            var ok = true;
            this.typ = inverse(arguments[0]["typ"]);
            if (!ok) {
                break;
            }
            if ((this.typ==1)) {
                var function_name = "mat_inv";
                var ot = 1;
                var it = 1;
            } else if ((this.typ==2)) {
                var function_name = "matz_inv";
                var ot = 2;
                var it = 2;
            } else {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            }
            var in1 = [this.model.in,this.model.in2];
            var out = [this.model.out,this.model.out2];
            var funtyp = 4;
            if (ok) {
                var label = this.exprs;
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/MATLU.sci" */
function MATLU() {
    MATLU.prototype.define = function MATLU() {
        this.model = scicos_model();
        var function_name = "mat_lu";
        var funtyp = 4;
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-1]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([-1],[-1]);
        this.model.out2 = new ScilabDouble([-1],[-1]);
        this.model.outtyp = new ScilabDouble([1,1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = sci2exp(1);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MATLU\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([label]),this.gr_i);
        return new BasicBlock(this.x);
    }
    MATLU.prototype.details = function MATLU() {
        return this.x;
    }
    MATLU.prototype.get = function MATLU() {
        var options = {
            typ:["Datatype(1=real double  2=Complex)",this.typ],
        }
        return options;
    }
    MATLU.prototype.set = function MATLU() {
        var label = this.graphics.exprs;
        if (size(label,"*")==14) {
            label[9-1] = [];
        }
        while (true) {
            var ok = true;
            this.typ = inverse(arguments[0]["typ"]);
            this.lab = arguments[0]["lab"];
            if (!ok) {
                break;
            }
            if ((this.typ==1)) {
                var function_name = "mat_lu";
                var ot = [1,1];
                var it = 1;
            } else if ((this.typ==2)) {
                var function_name = "matz_lu";
                var ot = [2,2];
                var it = 2;
            } else {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                var tmpvar0 = set_io(this.model,this.graphics,list([this.model.in,this.model.in2],it),list([this.model.out,this.model.out2],ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                var funtyp = 4;
                this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
                this.graphics.exprs = new ScilabDouble([this.lab]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/MATMAGPHI.sci" */
function MATMAGPHI() {
    MATMAGPHI.prototype.define = function MATMAGPHI() {
        this.model = scicos_model();
        var function_name = "matz_abs";
        var funtyp = 4;
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([2]);
        this.model.out = new ScilabDouble([-1],[-1]);
        this.model.out2 = new ScilabDouble([-2],[-2]);
        this.model.outtyp = new ScilabDouble([1,1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [sci2exp(1)];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MATMAGPHI\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabString(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    MATMAGPHI.prototype.details = function MATMAGPHI() {
        return this.x;
    }
    MATMAGPHI.prototype.get = function MATMAGPHI() {
        var options = {
            decomptyp:["decomposition type (1=Complex2MAG&PHI 2=MAG&PHI2Complex)",this.decomptyp],
        }
        return options;
    }
    MATMAGPHI.prototype.set = function MATMAGPHI() {
        var label = this.graphics.exprs;
        if (size(label,"*")==14) {
            label[9-1] = [];
        }
        while (true) {
            var ok = true;
            this.decomptyp = arguments[0]["decomptyp"];
            this.lab = arguments[0]["lab"];
            if (!ok) {
                break;
            }
            var label = this.lab;
            if ((this.decomptyp==1)) {
                var function_name = "matz_abs";
                var in1 = [-1,-2];
                var it = 2;
                var out = [[-1,-2],[-1,-2]];
                var ot = [1,1];
            } else if ((this.decomptyp==2)) {
                var function_name = "matz_absc";
                var in1 = [[-1,-2],[-1,-2]];
                var it = [1,1];
                var out = [-1,-2];
                var ot = 2;
            } else {
                message("decomposition type is not supported");
                throw "user error";
                var ok = false;
            }
            var funtyp = 4;
            if (ok) {
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/MATMUL.sci" */
function MATMUL() {
    MATMUL.prototype.define = function MATMUL() {
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["matmul_m"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([-1],[-2]);
        this.model.in2 = new ScilabDouble([-2],[-3]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-3]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.model.ipar = new ScilabDouble([1]);
        var label = [sci2exp(this.model.ipar)];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MATMUL\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabString(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    MATMUL.prototype.details = function MATMUL() {
        return this.x;
    }
    MATMUL.prototype.get = function MATMUL() {
        var options = {
            dtype:["Datatype(1=real double 2=Complex 3=int32 ...)",this.dtype],
            rule:["Multiplication rule",this.rule],
            np:["Do on Overflow(0=Nothing 1=Saturate 2=Error)",this.np],
        }
        return options;
    }
    MATMUL.prototype.set = function MATMUL() {
        this.graphics = this.x.graphics;
        var label = this.graphics.exprs;
        this.model = this.x.model;
        if (this.model.ipar.length==0) {
            this.model.ipar = new ScilabDouble([1]);
        }
        if (size(label,"*")==1) {
            label[2-1] = sci2exp(1);
        }
        if (size(label,"*")==2) {
            label[3-1] = sci2exp(1);
        }
        while (true) {
            var ok = true;
            this.dtype = arguments[0]["dtype"];
            this.rule = parseFloat(arguments[0]["rule"]);
            this.np = parseFloat(arguments[0]["np"]);
            if (!ok) {
                break;
            }
            this.rule = int(this.rule);
            if ((this.dtype<1||this.dtype>8)) {
                message("type is not supported");
                throw "user error";
                var ok = false;
            }
            if ((this.rule<1||this.rule>3)) {
                message("Multiplication rule must be only 1,2 or 3");
                throw "user error";
                var ok = false;
            }
            if ((this.dtype==1||this.dtype==2)) {
                this.np = 0;
            }
            var TABMIN = [[0],[0],[-(2^31)],[-(2^15)],[-(2^7)],[0],[0],[0]];
            var TABMAX = [[0],[0],[(2^31)-1],[(2^15)-1],[(2^7)-1],[(2^32)-1],[(2^16)-1],[(2^8)-1]];
            if (this.rule==2) {
                if (this.np==0) {
                    this.model.sim = list(new ScilabString(["matmul2_m"]), new ScilabDouble([4]));
                } else if (this.np==1) {
                    this.model.sim = list(new ScilabString(["matmul2_s"]), new ScilabDouble([4]));
                } else {
                    this.model.sim = list(new ScilabString(["matmul2_e"]), new ScilabDouble([4]));
                }
            } else if (this.rule==3) {
                if (this.np==0) {
                    this.model.sim = list(new ScilabString(["matbyscal"]), new ScilabDouble([4]));
                } else if (this.np==1) {
                    this.model.sim = list(new ScilabString(["matbyscal_s"]), new ScilabDouble([4]));
                } else {
                    this.model.sim = list(new ScilabString(["matbyscal_e"]), new ScilabDouble([4]));
                }
            } else {
                if ((this.dtype==1)) {
                    this.model.sim = list(new ScilabString(["matmul_m"]), new ScilabDouble([4]));
                } else if ((this.dtype==2)) {
                    this.model.sim = list(new ScilabString(["matzmul_m"]), new ScilabDouble([4]));
                } else if (this.dtype==3) {
                    if (this.np==0) {
                        this.model.sim = list(new ScilabString(["matmul_i32n"]), new ScilabDouble([4]));
                    } else if (this.np==1) {
                        this.model.sim = list(new ScilabString(["matmul_i32s"]), new ScilabDouble([4]));
                    } else {
                        this.model.sim = list(new ScilabString(["matmul_i32e"]), new ScilabDouble([4]));
                    }
                } else if (this.dtype==4) {
                    if (this.np==0) {
                        this.model.sim = list(new ScilabString(["matmul_i16n"]), new ScilabDouble([4]));
                    } else if (this.np==1) {
                        this.model.sim = list(new ScilabString(["matmul_i16s"]), new ScilabDouble([4]));
                    } else {
                        this.model.sim = list(new ScilabString(["matmul_i16e"]), new ScilabDouble([4]));
                    }
                } else if (this.dtype==5) {
                    if (this.np==0) {
                        this.model.sim = list(new ScilabString(["matmul_i8n"]), new ScilabDouble([4]));
                    } else if (this.np==1) {
                        this.model.sim = list(new ScilabString(["matmul_i8s"]), new ScilabDouble([4]));
                    } else {
                        this.model.sim = list(new ScilabString(["matmul_i8e"]), new ScilabDouble([4]));
                    }
                } else if (this.dtype==6) {
                    if (this.np==0) {
                        this.model.sim = list(new ScilabString(["matmul_ui32n"]), new ScilabDouble([4]));
                    } else if (this.np==1) {
                        this.model.sim = list(new ScilabString(["matmul_ui32s"]), new ScilabDouble([4]));
                    } else {
                        this.model.sim = list(new ScilabString(["matmul_ui32e"]), new ScilabDouble([4]));
                    }
                } else if (this.dtype==7) {
                    if (this.np==0) {
                        this.model.sim = list(new ScilabString(["matmul_ui16n"]), new ScilabDouble([4]));
                    } else if (this.np==1) {
                        this.model.sim = list(new ScilabString(["matmul_ui16s"]), new ScilabDouble([4]));
                    } else {
                        this.model.sim = list(new ScilabString(["matmul_ui16e"]), new ScilabDouble([4]));
                    }
                } else if (this.dtype==8) {
                    if (this.np==0) {
                        this.model.sim = list(new ScilabString(["matmul_ui8n"]), new ScilabDouble([4]));
                    } else if (this.np==1) {
                        this.model.sim = list(new ScilabString(["matmul_ui8s"]), new ScilabDouble([4]));
                    } else {
                        this.model.sim = list(new ScilabString(["matmul_ui8e"]), new ScilabDouble([4]));
                    }
                }
            }
            var kmin = TABMIN[this.dtype-1];
            var kmax = TABMAX[this.dtype-1];
            var it = this.dtype*ones(1,2);
            var ot = this.dtype;
            if (this.rule==1) {
                var in1 = [[-1,-2],[-2,-3]];
                var out = [-1,-3];
            } else if (this.rule==2) {
                var in1 = [[-1,-2],[-1,-2]];
                var out = [-1,-2];
            } else {
                var in1 = [[-1,-2],[1,1]];
                var out = [-1,-2];
            }
            var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
            this.model = tmpvar0[0];
            this.graphics = tmpvar0[1];
            var ok = tmpvar0[2];
            if (ok) {
                var label = this.exprs;
                this.model.ipar = new ScilabDouble([this.rule]);
                this.model.rpar = new ScilabDouble([kmin],[kmax]);
                this.graphics.exprs = new ScilabDouble([label]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/MATPINV.sci" */
function MATPINV() {
    MATPINV.prototype.define = function MATPINV() {
        this.model = scicos_model();
        var function_name = "mat_pinv";
        var funtyp = 4;
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([-2]);
        this.model.out2 = new ScilabDouble([-1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [sci2exp(1)];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MATPINV\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    MATPINV.prototype.details = function MATPINV() {
        return this.x;
    }
    MATPINV.prototype.get = function MATPINV() {
        var options = {
            typ:["Datatype(1=real double  2=Complex)",this.typ],
        }
        return options;
    }
    MATPINV.prototype.set = function MATPINV() {
        var label = this.graphics.exprs;
        if (size(label,"*")==14) {
            label[9-1] = [];
        }
        while (true) {
            var ok = true;
            this.typ = inverse(arguments[0]["typ"]);
            if (!ok) {
                break;
            }
            if ((this.typ==1)) {
                var function_name = "mat_pinv";
                var ot = 1;
                var it = 1;
            } else if ((this.typ==2)) {
                var function_name = "matz_pinv";
                var ot = 2;
                var it = 2;
            } else {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            }
            var in1 = [this.model.in,this.model.in2];
            var out = [this.model.out,this.model.out2];
            var funtyp = 4;
            if (ok) {
                var label = this.exprs;
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/MATRESH.sci" */
function MATRESH() {
    MATRESH.prototype.define = function MATRESH() {
        this.model = scicos_model();
        var function_name = "mat_reshape";
        var funtyp = 4;
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-2]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [[sci2exp(1)],[sci2exp([1,1])],[sci2exp([1,1])]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MATRESH\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    MATRESH.prototype.details = function MATRESH() {
        return this.x;
    }
    MATRESH.prototype.get = function MATRESH() {
        var options = {
            typ:["Datatype(1=real double  2=Complex)",this.typ],
            l1:["input size",this.l1],
            out:["output size desired",this.out],
        }
        return options;
    }
    MATRESH.prototype.set = function MATRESH() {
        var label = this.graphics.exprs;
        if (size(label,"*")==14) {
            label[9-1] = [];
        }
        while (true) {
            var ok = true;
            this.typ = inverse(arguments[0]["typ"]);
            this.l1 = arguments[0]["l1"];
            this.out = arguments[0]["out"];
            this.lab = arguments[0]["lab"];
            if (!ok) {
                break;
            }
            var nout = size(this.out);
            var nin = size(this.l1);
            if (nout==0) {
                message("output must have at least one element");
                throw "user error";
                var ok = false;
            }
            if (nin==0) {
                message("input must have at least one element");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                if (((this.out[1-1]>(this.l1[1-1]*this.l1[2-1])))) {
                    message("the first dimension of the output is too big");
                    throw "user error";
                    var ok = false;
                }
                if (((this.out[2-1]>(this.l1[1-1]*this.l1[2-1])))) {
                    message("the second dimension of the output is too big");
                    throw "user error";
                    var ok = false;
                }
                if ((((this.out[2-1]*this.out[1-1])>(this.l1[1-1]*this.l1[2-1])))) {
                    message("the dimensions of the output are too big");
                    throw "user error";
                    var ok = false;
                }
            }
            if ((this.typ==1)) {
                var function_name = "mat_reshape";
                var ot = 1;
                var it = 1;
            } else if ((this.typ==2)) {
                var function_name = "matz_reshape";
                var ot = 2;
                var it = 2;
            } else {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                var label = this.lab;
                var tmpvar0 = set_io(this.model,this.graphics,list(this.l1,it),list(this.out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                var funtyp = 4;
                this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        needcompile = resume(needcompile)
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/MATSING.sci" */
function MATSING() {
    MATSING.prototype.define = function MATSING() {
        this.model = scicos_model();
        var function_name = "mat_sing";
        var funtyp = 4;
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [[sci2exp(1)],[sci2exp(1)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MATSING\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    MATSING.prototype.details = function MATSING() {
        return this.x;
    }
    MATSING.prototype.get = function MATSING() {
        var options = {
            typ:["Datatype(1=real double  2=Complex)",this.typ],
            decomptyp:["decomposition type (1=singular values  2=sing values+matrix U & V)",this.decomptyp],
        }
        return options;
    }
    MATSING.prototype.set = function MATSING() {
        var label = this.graphics.exprs;
        if (size(label,"*")==14) {
            label[9-1] = [];
        }
        while (true) {
            var ok = true;
            this.typ = inverse(arguments[0]["typ"]);
            this.decomptyp = arguments[0]["decomptyp"];
            this.lab = arguments[0]["lab"];
            if (!ok) {
                break;
            }
            var label = this.lab;
            if ((this.typ==1)) {
                if ((this.decomptyp==1)) {
                    var function_name = "mat_sing";
                    var in1 = [-1,-2];
                    var out = [-1,1];
                    var ot = 1;
                } else if ((this.decomptyp==2)) {
                    var function_name = "mat_svd";
                    var in1 = [-1,-2];
                    var out = [[-1,-1],[-1,-2],[-2,-2]];
                    var ot = [1,1,1];
                } else {
                    message("decomposition type is not supported");
                    throw "user error";
                    var ok = false;
                }
                var it = 1;
            } else if ((this.typ==2)) {
                if ((this.decomptyp==1)) {
                    var function_name = "matz_sing";
                    var in1 = [-1,-2];
                    var out = [-1,1];
                    var ot = 1;
                } else if ((this.decomptyp==2)) {
                    var function_name = "matz_svd";
                    var in1 = [-1,-2];
                    var out = [[-1,-1],[-1,-2],[-2,-2]];
                    var ot = [2,1,2];
                } else {
                    message("decomposition type is not supported");
                    throw "user error";
                    var ok = false;
                }
                var it = 2;
            } else {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            }
            var funtyp = 4;
            if (ok) {
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/MATSUM.sci" */
function MATSUM() {
    MATSUM.prototype.define = function MATSUM() {
        this.model = scicos_model();
        var function_name = "mat_sum";
        var funtyp = 4;
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.out2 = new ScilabDouble([1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [[sci2exp(1)],[sci2exp(0)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MATSUM\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    MATSUM.prototype.details = function MATSUM() {
        return this.x;
    }
    MATSUM.prototype.get = function MATSUM() {
        var options = {
            typ:["Datatype(1=real double  2=Complex)",this.typ],
            decomptyp:["Sum along (0=all 1=lines  2=Columns)",this.decomptyp],
        }
        return options;
    }
    MATSUM.prototype.set = function MATSUM() {
        var label = this.graphics.exprs;
        if (size(label,"*")==14) {
            label[9-1] = [];
        }
        while (true) {
            var ok = true;
            this.typ = inverse(arguments[0]["typ"]);
            this.decomptyp = arguments[0]["decomptyp"];
            this.lab = arguments[0]["lab"];
            if (!ok) {
                break;
            }
            var label = this.lab;
            if ((this.typ==1)) {
                if ((this.decomptyp==0)) {
                    var function_name = "mat_sum";
                    var out = [1,1];
                } else if ((this.decomptyp==2)) {
                    var function_name = "mat_suml";
                    var out = [-1,1];
                } else if ((this.decomptyp==1)) {
                    var function_name = "mat_sumc";
                    var out = [1,-2];
                } else {
                    message("decomposition type is not supported");
                    throw "user error";
                    var ok = false;
                }
                var it = 1;
                var ot = 1;
            } else if ((this.typ==2)) {
                if ((this.decomptyp==0)) {
                    var function_name = "matz_sum";
                    var out = [1,1];
                } else if ((this.decomptyp==2)) {
                    var function_name = "matz_suml";
                    var out = [-1,1];
                } else if ((this.decomptyp==1)) {
                    var function_name = "matz_sumc";
                    var out = [1,-2];
                } else {
                    message("decomposition type is not supported");
                    throw "user error";
                    var ok = false;
                }
                var it = 2;
                var ot = 2;
            } else {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            }
            var in1 = [this.model.in,this.model.in2];
            var funtyp = 4;
            if (ok) {
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/MATTRAN.sci" */
function MATTRAN() {
    MATTRAN.prototype.define = function MATTRAN() {
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["mattran_m"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.out = new ScilabDouble([-2]);
        this.model.out2 = new ScilabDouble([-1]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [sci2exp(1)];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MATTRAN\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabString(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    MATTRAN.prototype.details = function MATTRAN() {
        return this.x;
    }
    MATTRAN.prototype.get = function MATTRAN() {
        var options = {
            typ:["Datatype(1=real double 2=Complex)",this.typ],
            rule:["rule (1=.\' 2=\')",this.rule],
        }
        return options;
    }
    MATTRAN.prototype.set = function MATTRAN() {
        var label = this.graphics.exprs;
        if (size(label,"*")==1) {
            label[2-1] = sci2exp(1);
        }
        while (true) {
            var ok = true;
            this.typ = inverse(arguments[0]["typ"]);
            this.rule = arguments[0]["rule"];
            if (!ok) {
                break;
            }
            if ((this.typ==1)) {
                var function_name = "mattran_m";
                var ot = 1;
                var it = 1;
            } else if ((this.typ==2)) {
                if (this.rule==1) {
                    var function_name = "matztran_m";
                } else {
                    var function_name = "mathermit_m";
                }
                var ot = 2;
                var it = 2;
            } else {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            }
            var in1 = [this.model.in,this.model.in2];
            var out = [this.model.out,this.model.out2];
            var funtyp = 4;
            if (ok) {
                var label = this.exprs;
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/MATZCONJ.sci" */
function MATZCONJ() {
    MATZCONJ.prototype.define = function MATZCONJ() {
        this.model = scicos_model();
        var function_name = "matz_conj";
        var funtyp = 4;
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([2]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-2]);
        this.model.outtyp = new ScilabDouble([2]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MATZCONJ\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    MATZCONJ.prototype.details = function MATZCONJ() {
        return this.x;
    }
    MATZCONJ.prototype.get = function MATZCONJ() {
        alert("parameters cannot be modified");
    }
    MATZCONJ.prototype.set = function MATZCONJ() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/MATZREIM.sci" */
function MATZREIM() {
    MATZREIM.prototype.define = function MATZREIM() {
        this.model = scicos_model();
        var function_name = "matz_reim";
        var funtyp = 4;
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([2]);
        this.model.out = new ScilabDouble([-1],[-1]);
        this.model.out2 = new ScilabDouble([-2],[-2]);
        this.model.outtyp = new ScilabDouble([1,1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = sci2exp(1);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MATZREIM\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabString([label]),this.gr_i);
        return new BasicBlock(this.x);
    }
    MATZREIM.prototype.details = function MATZREIM() {
        return this.x;
    }
    MATZREIM.prototype.get = function MATZREIM() {
        var options = {
            decomptyp:["decomposition type (1=Complex2Real&Imag 2=Real&Imag2Complex)",this.decomptyp],
        }
        return options;
    }
    MATZREIM.prototype.set = function MATZREIM() {
        var label = this.graphics.exprs;
        if (size(label,"*")==14) {
            label[9-1] = [];
        }
        while (true) {
            var ok = true;
            this.decomptyp = arguments[0]["decomptyp"];
            this.lab = arguments[0]["lab"];
            if (!ok) {
                break;
            }
            var label = this.lab;
            if ((this.decomptyp==1)) {
                var function_name = "matz_reim";
                var in1 = [-1,-2];
                var it = 2;
                var out = [[-1,-2],[-1,-2]];
                var ot = [1,1];
            } else if ((this.decomptyp==2)) {
                var function_name = "matz_reimc";
                var in1 = [[-1,-2],[-1,-2]];
                var it = [1,1];
                var out = [-1,-2];
                var ot = 2;
            } else {
                message("decomposition type is not supported");
                throw "user error";
                var ok = false;
            }
            var funtyp = 4;
            if (ok) {
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/RICC.sci" */
function RICC() {
    RICC.prototype.define = function RICC() {
        this.model = scicos_model();
        var function_name = "ricc_m";
        var funtyp = 4;
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in = new ScilabDouble([-1],[-1],[-1]);
        this.model.in2 = new ScilabDouble([-1],[-1],[-1]);
        this.model.intyp = new ScilabDouble([1,1,1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([1],[1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [[sci2exp(1)],[sci2exp(1)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"RICC\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    RICC.prototype.details = function RICC() {
        return this.x;
    }
    RICC.prototype.get = function RICC() {
        var options = {
            tpe:["Type (1=Cont  2=Disc)",this.tpe],
            mod:["Model(1=Schr  2=sign(cont) inv(disc))",this.mod],
        }
        return options;
    }
    RICC.prototype.set = function RICC() {
        var label = this.graphics.exprs;
        if (size(label,"*")==14) {
            label[9-1] = [];
        }
        while (true) {
            var ok = true;
            this.tpe = arguments[0]["tpe"];
            this.mod = arguments[0]["mod"];
            if (!ok) {
                break;
            }
            var in1 = [this.model.in,this.model.in2];
            var out = [this.model.out,this.model.out2];
            var it = [1,1,1];
            var ot = 1;
            var label = this.exprs;
            var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
            this.model = tmpvar0[0];
            this.graphics = tmpvar0[1];
            var ok = tmpvar0[2];
            if (ok) {
                this.model.ipar = new ScilabDouble([this.tpe],[this.mod]);
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/ROOTCOEF.sci" */
function ROOTCOEF() {
    ROOTCOEF.prototype.define = function ROOTCOEF() {
        this.model = scicos_model();
        var function_name = "root_coef";
        var funtyp = 4;
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([1]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([-2]);
        this.model.out2 = new ScilabDouble([1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [[sci2exp(1)],[sci2exp(1)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"ROOTCOEF\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    ROOTCOEF.prototype.details = function ROOTCOEF() {
        return this.x;
    }
    ROOTCOEF.prototype.get = function ROOTCOEF() {
        var options = {
            typ:["Datatype(1=real double  2=Complex)",this.typ],
            inp:["input row size",this.inp],
        }
        return options;
    }
    ROOTCOEF.prototype.set = function ROOTCOEF() {
        var label = this.graphics.exprs;
        if (size(label,"*")==14) {
            label[9-1] = [];
        }
        while (true) {
            var ok = true;
            this.typ = inverse(arguments[0]["typ"]);
            this.inp = arguments[0]["inp"];
            if (!ok) {
                break;
            }
            if ((this.typ==1)) {
                var function_name = "root_coef";
                var ot = 1;
                var it = 1;
            } else if ((this.typ==2)) {
                var function_name = "rootz_coef";
                var ot = 2;
                var it = 2;
            } else {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            }
            var in1 = [this.inp,this.model.in2];
            var out = [this.inp+1,this.model.out2];
            var funtyp = 4;
            if (ok) {
                var label = this.exprs;
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/SQRT.sci" */
function SQRT() {
    SQRT.prototype.define = function SQRT() {
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["mat_sqrt"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-2]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [sci2exp(1)];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SQRT\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    SQRT.prototype.details = function SQRT() {
        return this.x;
    }
    SQRT.prototype.get = function SQRT() {
        var options = {
            typ:["Datatype(1=real double  2=Complex)",this.typ],
        }
        return options;
    }
    SQRT.prototype.set = function SQRT() {
        var label = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.typ = inverse(arguments[0]["typ"]);
            if (!ok) {
                break;
            }
            if ((this.typ==1)) {
                var function_name = "mat_sqrt";
            } else if ((this.typ==2)) {
                var function_name = "matz_sqrt";
            } else {
                message("type is not supported");
                throw "user error";
                var ok = false;
            }
            var it = this.typ;
            var ot = this.typ;
            var in1 = [this.model.in,this.model.in2];
            var out = [this.model.out,this.model.out2];
            var funtyp = 4;
            if (ok) {
                var label = this.exprs;
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/MatrixOp/SUBMAT.sci" */
function SUBMAT() {
    SUBMAT.prototype.define = function SUBMAT() {
        this.model = scicos_model();
        var function_name = "submat";
        var funtyp = 4;
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-2]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([1],[1],[1],[1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [[sci2exp(1)],[sci2exp(1)],[sci2exp(1)],[sci2exp(1)],[sci2exp(1)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SUBMAT\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2.5,2]),this.model,new ScilabDouble(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    SUBMAT.prototype.details = function SUBMAT() {
        return this.x;
    }
    SUBMAT.prototype.get = function SUBMAT() {
        var options = {
            typ:["Datatype (1=real double  2=Complex)",this.typ],
            a:["Starting Row Index",this.a],
            b:["Ending Row Index",this.b],
            c:["Starting Column Index",this.c],
            d:["Ending Column Index",this.d],
            inp:["Input Dimensions",this.inp],
        }
        return options;
    }
    SUBMAT.prototype.set = function SUBMAT() {
        var label = this.graphics.exprs;
        if (size(label,"*")==5) {
            label[6-1] = sci2exp([1,1]);
        }
        while (true) {
            var ok = true;
            this.typ = inverse(arguments[0]["typ"]);
            this.a = arguments[0]["a"];
            this.b = arguments[0]["b"];
            this.c = arguments[0]["c"];
            this.d = arguments[0]["d"];
            this.inp = arguments[0]["inp"];
            if (!ok) {
                break;
            }
            if ((this.typ==1)) {
                var function_name = "submat";
                var ot = 1;
                var it = 1;
            } else if ((this.typ==2)) {
                var function_name = "submatz";
                var ot = 2;
                var it = 2;
            } else {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            }
            if ((this.a<=0)||(this.b<=0)||(this.c<=0)||(this.d<=0)) {
                message("invalid index");
                throw "user error";
                var ok = false;
            }
            if (this.b<this.a) {
                message("ending row must be greater than starting row");
                throw "user error";
                var ok = false;
            }
            if (this.d<this.c) {
                message("ending column must be greater than starting column");
                throw "user error";
                var ok = false;
            }
            if (this.b>this.inp[1-1]) {
                message("index of ending row is out of range");
                throw "user error";
                var ok = false;
            }
            if (this.d>this.inp[2-1]) {
                message("index of ending column is out of range");
                throw "user error";
                var ok = false;
            }
            this.model.ipar = new ScilabDouble([this.a],[this.b],[this.c],[this.d]);
            var in1 = [this.inp[1-1],this.inp[2-1]];
            var out = [(this.b-this.a)+1,(this.d-this.c)+1];
            var funtyp = 4;
            var label = this.exprs;
            if (ok) {
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/AUTOMAT.sci" */
function AUTOMAT() {
    AUTOMAT.prototype.define = function AUTOMAT() {
        var NMode = 2;
        this.Minitial = 1;
        var NX = 1;
        this.X0 = [0.0];
        this.XP = [[1],[1]];
        var C1 = [2];
        var C2 = [1];
        this.exprs = [[string(NMode)],[string(this.Minitial)],[string(NX)],[sci2exp(this.X0)],[sci2exp(this.XP)],[sci2exp(C1)],[sci2exp(C2)]];
        var ipar = [[NMode],[this.Minitial],[NX],[this.XP],[C1],[C2]];
        var rpar = [this.X0];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["automat"]), new ScilabDouble([10004]));
        this.model.in = new ScilabDouble([2*NX+1],[2*NX+1]);
        this.model.out = new ScilabDouble([2],[2*NX]);
        this.model.state = new ScilabDouble([ones(2*NX,1)]);
        this.model.nzcross = new ScilabDouble([1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.evtout = new ScilabDouble([1]);
        this.model.firing = new ScilabDouble([-1]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.model.ipar = new ScilabDouble(ipar);
        this.model.rpar = new ScilabDouble(rpar);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"AUTOMAT\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([4,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    AUTOMAT.prototype.details = function AUTOMAT() {
        return this.x;
    }
    AUTOMAT.prototype.get = function AUTOMAT() {
        alert("parameters cannot be modified");
    }
    AUTOMAT.prototype.set = function AUTOMAT() {
        this.exprs = this.graphics.exprs;
        var ipar = this.model.ipar;
        var NMode = ipar[1-1];
        var NX = ipar[3-1];
        while (true) {
            var CX = "C1";
            var MSG0 = "\'Jump from Mode ";
            var MSG2 = ":[..;M_final(Guard=In(";
            var MSG3 = ").i);..]\'";
            var MSG = MSG0+"1"+MSG2+"1"+MSG3;
            var VEC = "\'mat\',[-1,1]";
            for (i=2;i<=NMode;i+=1) {
                var CX = CX+","+"C"+string(i);
                var MSG = MSG+";"+MSG0+string(i)+MSG2+string(i)+MSG3;
                var VEC = VEC+","+"\'mat\',[-1,1]";
            }
            var GTV = "[ok,NMode,Minitial,NX,X0,XP,"+CX+",exprs]=scicos_getvalue(\'Set Finite state machine model\',            [\'Number (finite-state) Modes\';\'Initial Mode\';\'Number of continuous-time states\';\'Continuous-time states intial values\';\'Xproperties of continuous-time states in each Mode\';"+MSG+"],            list(\'vec\',1,\'vec\',1,\'vec\',1,\'mat\',[-1,-1],\'mat\',[-1,-1],"+VEC+"),exprs)";
            execstr(GTV);
            if (!this.ok) {
                break;
            }
            var NMode_old = size(this.exprs,"*")-5;
            var ModifEncore = false;
            if ((NMode_old>NMode)) {
                this.exprs.slice(NMode+6-1,NMode_old+5) = [];
                var ModifEncore = true;
            }
            if ((NMode_old<NMode)) {
                this.exprs.slice(NMode_old+6-1,NMode+5) = this.exprs[NMode_old+4-1];
                var ModifEncore = true;
            }
            if ((NX!=size(this.X0,"*"))) {
                messagebox("the size of intial continuous-time states should be NX="+string(NX),"modal","error");
                var ModifEncore = true;
            }
            var tmpvar0 = size(this.XP);
            var rXP = tmpvar0[0];
            var cXP = tmpvar0[1];
            if (cXP!=NX) {
                messagebox("Xproperty matrix is not valid: it should have NX="+string(NX)+" columns","modal","error");
                var ModifEncore = true;
            } else if (((rXP!=NMode)&&(rXP>1))) {
                messagebox("Xproperty matrix is not valid: it should have NMode="+string(NMode)+" or 1 row(s)","modal","error");
                var ModifEncore = true;
            } else if ((rXP==1)) {
                for (i=1;i<=NMode-1;i+=1) {
                    this.XP = [[this.XP],[this.XP[1-1].slice()]];
                }
            }
            if ((NMode_old==NMode)&&(!ModifEncore)) {
                this.XP = matrix(transpose(this.XP),NMode*NX,1);
                var ipar = [[NMode],[this.Minitial],[NX],[this.XP]];
                var rpar = matrix(this.X0,NX,1);
                var INP = ones(NMode,1);
                if (NX>0) {
                    var OUT = [[2],[2*NX]];
                } else {
                    var OUT = [2];
                }
                var MaxModes = 1;
                var nzcross = 0;
                for (i=1;i<=NMode;i+=1) {
                    var Ci = evstr(this.exprs[5+i-1]);
                    var ipar = [[ipar],[Ci]];
                    INP[i-1][1-1] = 2*NX+length(Ci);
                    if ((nzcross<length(Ci))) {
                        var nzcross = length(Ci);
                    }
                    if ((MaxModes<max(Ci))) {
                        var MaxModes = max(Ci);
                        var imax = i;
                    }
                }
                if (MaxModes>NMode) {
                    messagebox([["Number of Modes should be "+string(MaxModes)],["A destination Mode in Mode#"+string(imax)+"\'s targets is invalid!"]],"modal","error");
                    var ModifEncore = true;
                }
                if (MaxModes<NMode) {
                    messagebox(["There is an unused Mode or the Number of Modes should be "+string(MaxModes)],"modal","error");
                    var ModifEncore = true;
                }
            }
            if (!ModifEncore) {
                var tmpvar1 = check_io(this.model,this.graphics,INP,OUT,[],[1]);
                this.model = tmpvar1[0];
                this.graphics = tmpvar1[1];
                this.ok = tmpvar1[2];
                if (!this.ok) {
                    break;
                }
                this.model.nzcross = new ScilabDouble([nzcross]);
                this.model.state = new ScilabDouble([ones(2*NX,1)]);
                this.graphics.gr_i[1-1][1-1] = new ScilabString(["txt=[\'Automaton\';\'nM="+string(NMode)+",nX="+string(NX)+"\'];"]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.model.ipar = new ScilabDouble(ipar);
                this.model.rpar = new ScilabDouble([rpar]);
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/BACKLASH.sci" */
function BACKLASH() {
    BACKLASH.prototype.define = function BACKLASH() {
        this.exprs = [["0"],["1"],["1"]];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["backlash"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([0],[1]);
        this.model.nzcross = new ScilabDouble([2]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"BACKLASH\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    BACKLASH.prototype.details = function BACKLASH() {
        return this.x;
    }
    BACKLASH.prototype.get = function BACKLASH() {
        var options = {
            ini:["initial output",this.ini],
            gap:["gap",this.gap],
            zcr:["use zero-crossing (0:no, 1:yes)",this.zcr],
        }
        return options;
    }
    BACKLASH.prototype.set = function BACKLASH() {
        this.exprs = this.graphics.exprs;
        var rpar = this.model.rpar;
        while (true) {
            var ok = true;
            this.ini = arguments[0]["ini"];
            this.gap = arguments[0]["gap"];
            this.zcr = arguments[0]["zcr"];
            if (!ok) {
                break;
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                rpar[1-1] = this.ini;
                rpar[2-1] = this.gap;
                if (this.zcr!=0) {
                    this.model.nzcross = new ScilabDouble([2]);
                } else {
                    this.model.nzcross = new ScilabDouble([0]);
                }
                this.model.rpar = new ScilabDouble(rpar);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/BOUNCE.sci" */
function BOUNCE() {
    BOUNCE.prototype.define = function BOUNCE() {
        var n = 2;
        var k = 1;
        var ipar = [];
        for (i=1;i<=n;i+=1) {
            for (j=i+1;j<=n;j+=1) {
                ipar[k-1] = i;
                var k = k+1;
                ipar[k-1] = j;
                var k = k+1;
            }
        }
        this.walls = [[0],[5],[0],[5]];
        this.x = [[2],[2.5]];
        this.xd = [[0],[0]];
        this.y = [[3],[5]];
        this.yd = [[0],[0]];
        this.g = 9.81;
        this.C = 0;
        this.rpar1 = ones(n,1);
        this.rpar2 = this.rpar1;
        var state = [this.x,this.xd,this.y,this.yd];
        var state = transpose(state);
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["bounce_ball"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([]);
        this.model.out = new ScilabDouble([n],[n]);
        this.model.state = new ScilabDouble(state.slice());
        this.model.rpar = new ScilabDouble([this.rpar1],[this.rpar2],[this.walls],[this.g],[this.C]);
        this.model.ipar = new ScilabDouble(ipar);
        this.model.nzcross = new ScilabDouble([n*(n-1)/2+4*n]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.exprs = [[strcat(sci2exp(this.rpar1))],[strcat(sci2exp(this.rpar2))],[strcat(sci2exp(this.walls))],[strcat(sci2exp(this.x))],[strcat(sci2exp(this.xd))],[strcat(sci2exp(this.y))],[strcat(sci2exp(this.yd))]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"BOUNCE\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    BOUNCE.prototype.details = function BOUNCE() {
        return this.x;
    }
    BOUNCE.prototype.get = function BOUNCE() {
        var options = {
            rpar1:["Mass",this.rpar1],
            rpar2:["Radius",this.rpar2],
            walls:["[xmin,xmax,ymin,ymax]",this.walls.toString().replace(/,/g," ")],
            xt:["xpos",this.xt],
            xd:["xdpos",this.xd.toString().replace(/,/g," ")],
            y:["ypos",this.y],
            yd:["ydpos",this.yd.toString().replace(/,/g," ")],
            g:["g (gravity)",this.g],
            C:["C (aerodynamic coeff",this.C],
        }
        return options;
    }
    BOUNCE.prototype.set = function BOUNCE() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")<9) {
            this.exprs[8-1] = "9.81";
            this.exprs[9-1] = "0";
        }
        while (true) {
            var ok = true;
            this.rpar1 = parseFloat(arguments[0]["rpar1"]);
            this.rpar2 = parseFloat(arguments[0]["rpar2"]);
            this.walls = inverse(arguments[0]["walls"]);
            this.xt = inverse(arguments[0]["xt"]);
            this.xd = inverse(arguments[0]["xd"]);
            this.y = inverse(arguments[0]["y"]);
            this.yd = inverse(arguments[0]["yd"]);
            this.g = parseFloat(arguments[0]["g"]);
            this.C = parseFloat(arguments[0]["C"]);
            if (!ok) {
                break;
            }
            this.xt = this.xt.slice();
            this.y = this.y.slice();
            this.xd = this.xd.slice();
            this.yd = this.yd.slice();
            this.rpar1 = this.rpar1.slice();
            this.rpar2 = this.rpar2.slice();
            var n = size(this.xt,"*");
            this.walls = this.walls.slice();
            if (this.walls[1-1]>this.walls[2-1]) {
                this.walls = this.walls[[2,1]-1];
            }
            if (this.walls[3-1]>this.walls[3-1]) {
                this.walls = this.walls[[3,4]-1];
            }
            if (n!=size(this.y,"*")||n!=size(this.rpar1,"*")||n!=size(this.rpar2,"*")||n!=size(this.xd,"*")||n!=size(this.yd,"*")) {
                message("All vectors must have equal size");
                throw "user error";
                var ok = false;
            } else if (!(min([[this.rpar1],[this.rpar2]])>0)) {
                message("Mass and radius must be >0");
                throw "user error";
                var ok = false;
            }
            if (!ok) {
                break;
            }
            var tmpvar0 = check_io(this.model,this.graphics,[],[n,n],[],[]);
            this.model = tmpvar0[0];
            this.graphics = tmpvar0[1];
            var ok = tmpvar0[2];
            if (ok) {
                var k = 1;
                var ipar = [];
                for (i=1;i<=n;i+=1) {
                    for (j=i+1;j<=n;j+=1) {
                        ipar[k-1] = i;
                        var k = k+1;
                        ipar[k-1] = j;
                        var k = k+1;
                    }
                }
                this.model.rpar = new ScilabDouble([this.rpar1],[this.rpar2],[this.walls],[this.g],[this.C]);
                this.model.ipar = new ScilabDouble(ipar);
                var state = [this.xt,this.xd,this.y,this.yd];
                var state = transpose(state);
                this.model.state = new ScilabDouble(state.slice());
                this.model.nzcross = new ScilabDouble([n*(n-1)/2+4*n]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/BOUNCEXY.sci" */
function BOUNCEXY() {
    BOUNCEXY.prototype.define = function BOUNCEXY() {
        this.win = -1;
        this.imode = 1;
        this.clrs = [[1],[2]];
        this.siz = [[1],[1]];
        this.xmin = -5;
        this.xmax = 5;
        this.ymin = 0;
        this.ymax = 15;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["bouncexy"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([-1],[-1]);
        this.model.in2 = new ScilabDouble([1],[1]);
        this.model.intyp = new ScilabDouble([1],[1]);
        this.model.evtin = new ScilabDouble([1]);
        var z = [];
        for (i=1;i<=size(this.clrs,"*");i+=1) {
            z[6*(i-1)+1-1] = 0;
            z[6*(i-1)+2-1] = 0;
            z[6*(i-1)+3-1] = 2*this.siz[i-1];
            z[6*(i-1)+4-1] = 2*this.siz[i-1];
            z[6*(i-1)+5-1] = 0.000;
            z[6*(i-1)+6-1] = 64.0*360.000;
        }
        this.model.dstate = new ScilabDouble(z);
        this.model.rpar = new ScilabDouble([this.xmin],[this.xmax],[this.ymin],[this.ymax]);
        this.model.ipar = new ScilabDouble([this.win],[this.imode],[this.clrs.slice()]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [[strcat(sci2exp(this.clrs))],[strcat(sci2exp(this.siz))],[strcat(sci2exp(this.win))],[strcat(sci2exp(1))],[strcat(sci2exp(this.xmin))],[strcat(sci2exp(this.xmax))],[strcat(sci2exp(this.ymin))],[strcat(sci2exp(this.ymax))]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"BOUNCEXY\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    BOUNCEXY.prototype.details = function BOUNCEXY() {
        return this.x;
    }
    BOUNCEXY.prototype.get = function BOUNCEXY() {
        var options = {
            clrs:["colors",this.clrs.toString().replace(/,/g," ")],
            siz:["radii",this.siz.toString().replace(/,/g," ")],
            win:["window number (-1 for automatic)",this.win],
            imode:["animation mode (0,1)",this.imode],
            xmin:["Xmin",this.xmin],
            xmax:["Xmax",this.xmax],
            ymin:["Ymin",this.ymin],
            ymax:["Ymax",this.ymax],
        }
        return options;
    }
    BOUNCEXY.prototype.set = function BOUNCEXY() {
        this.exprs = this.graphics.exprs;
        var dstate = this.model.dstate;
        while (true) {
            var ok = true;
            this.clrs = inverse(arguments[0]["clrs"]);
            this.siz = inverse(arguments[0]["siz"]);
            this.win = parseFloat(arguments[0]["win"]);
            this.imode = parseFloat(arguments[0]["imode"]);
            this.xmin = parseFloat(arguments[0]["xmin"]);
            this.xmax = parseFloat(arguments[0]["xmax"]);
            this.ymin = parseFloat(arguments[0]["ymin"]);
            this.ymax = parseFloat(arguments[0]["ymax"]);
            if (!ok) {
                break;
            }
            var mess = [];
            if (size(this.clrs,"*")!=size(this.siz,"*")) {
                var mess = [[mess],["colors and radii must have equal size (number of balls)"],[" "]];
                var ok = false;
            }
            if (this.win<-1) {
                var mess = [[mess],["Window number cannot be inferior than -1"],[" "]];
                var ok = false;
            }
            if (this.ymin>=this.ymax) {
                var mess = [[mess],["Ymax must be greater than Ymin"],[" "]];
                var ok = false;
            }
            if (this.xmin>=this.xmax) {
                var mess = [[mess],["Xmax must be greater than Xmin"],[" "]];
                var ok = false;
            }
            if (!ok) {
                message(mess);
                throw "user error";
            } else {
                var rpar = [[this.xmin],[this.xmax],[this.ymin],[this.ymax]];
                var ipar = [[this.win],[this.imode],[this.clrs.slice()]];
                var z = [];
                for (i=1;i<=size(this.clrs,"*");i+=1) {
                    z[6*(i-1)+1-1] = 0;
                    z[6*(i-1)+2-1] = 0;
                    z[6*(i-1)+3-1] = 2*this.siz[i-1];
                    z[6*(i-1)+4-1] = 2*this.siz[i-1];
                    z[6*(i-1)+5-1] = 0.000;
                    z[6*(i-1)+6-1] = 64.0*360.000;
                }
                this.model.dstate = new ScilabDouble(z);
                this.model.rpar = new ScilabDouble(rpar);
                this.model.ipar = new ScilabDouble(ipar);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/BPLATFORM.sci" */
function BPLATFORM() {
    BPLATFORM.prototype.define = function BPLATFORM() {
        this.plen = 2;
        this.csiz = 2;
        this.phi = 0;
        this.xmin = -5;
        this.xmax = 5;
        this.ymin = 0;
        this.ymax = 15;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["bplatform2"]), new ScilabDouble([5]));
        this.model.in = new ScilabDouble([1],[1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble([0]);
        this.model.rpar = new ScilabDouble([this.plen],[this.csiz],[this.phi],[this.xmin],[this.xmax],[this.ymin],[this.ymax]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = string(this.model.rpar);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"BPLATFORM\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    BPLATFORM.prototype.details = function BPLATFORM() {
        return this.x;
    }
    BPLATFORM.prototype.get = function BPLATFORM() {
        var options = {
            plen:["pendulum length",this.plen],
            csiz:["cart size (square side)",this.csiz],
            phi:["slope",this.phi],
            xmin:["Xmin",this.xmin],
            xmax:["Xmax",this.xmax],
            ymin:["Ymin",this.ymin],
            ymax:["Ymax",this.ymax],
        }
        return options;
    }
    BPLATFORM.prototype.set = function BPLATFORM() {
        this.exprs = this.graphics.exprs;
        var dstate = this.model.dstate;
        while (true) {
            var ok = true;
            this.plen = parseFloat(arguments[0]["plen"]);
            this.csiz = parseFloat(arguments[0]["csiz"]);
            this.phi = parseFloat(arguments[0]["phi"]);
            this.xmin = parseFloat(arguments[0]["xmin"]);
            this.xmax = parseFloat(arguments[0]["xmax"]);
            this.ymin = parseFloat(arguments[0]["ymin"]);
            this.ymax = parseFloat(arguments[0]["ymax"]);
            if (!ok) {
                break;
            }
            var mess = [];
            if (this.plen<=0||this.csiz<=0) {
                var mess = [[mess],["Pendulum length and cart size must be positive."],[" "]];
                var ok = false;
            }
            if (this.ymin>=this.ymax) {
                var mess = [[mess],["Ymax must be greater than Ymin"],[" "]];
                var ok = false;
            }
            if (this.xmin>=this.xmax) {
                var mess = [[mess],["Xmax must be greater than Xmin"],[" "]];
                var ok = false;
            }
            if (!ok) {
                message(mess);
                throw "user error";
            } else {
                var rpar = [[this.plen],[this.csiz],[this.phi],[this.xmin],[this.xmax],[this.ymin],[this.ymax]];
                this.model.rpar = new ScilabDouble(rpar);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/CBLOCK.sci" */
function CBLOCK() {
    CBLOCK.prototype.define = function CBLOCK() {
        var in1 = 1;
        var out = 1;
        var clkin = [];
        var clkout = [];
        var x0 = [];
        var z0 = [];
        var typ = "c";
        var auto = [];
        this.rpar = [];
        this.ipar = [];
        var funam = "toto";
        this.ng = 0;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString([" "]), new ScilabDouble([2004]));
        this.model.in = new ScilabDouble([in1]);
        this.model.out = new ScilabDouble([out]);
        this.model.evtin = new ScilabDouble(clkin);
        this.model.evtout = new ScilabDouble(clkout);
        this.model.state = new ScilabDouble(x0);
        this.model.dstate = new ScilabDouble(z0);
        this.model.rpar = new ScilabDouble(this.rpar);
        this.model.ipar = new ScilabDouble(this.ipar);
        this.model.blocktype = new ScilabString([typ]);
        this.model.firing = new ScilabDouble(auto);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.model.nzcross = new ScilabDouble([this.ng]);
        var label = list(transpose([funam,"n",sci2exp(in1),sci2exp(out),sci2exp(clkin),sci2exp(clkout),sci2exp(x0),sci2exp(0),sci2exp(z0),sci2exp(this.rpar),sci2exp(this.ipar),sci2exp(auto),"y","n"]),[]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CBLOCK\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([4,2]),this.model,label,this.gr_i);
        return new BasicBlock(this.x);
    }
    CBLOCK.prototype.details = function CBLOCK() {
        return this.x;
    }
    CBLOCK.prototype.get = function CBLOCK() {
        var options = {
            function_name:["simulation function",this.function_name],
            impli:["is block implicit? (y,n)",this.impli],
            i:["input ports sizes",this.i],
            o:["output ports sizes",this.o],
            ci:["input event ports sizes",this.ci],
            co:["output events ports sizes",this.co],
            xx:["initial continuous state",this.xx],
            ng:["number of zero crossing surfaces",this.ng],
            z:["initial discrete state",this.z],
            rpar:["Real parameters vector",this.rpar],
            ipar:["Integer parameters vector",this.ipar],
            auto0:["initial firing vector (<0 for no firing)",this.auto0],
            depu:["direct feedthrough (y or n)",this.depu],
            dept:["time dependence (y or n)",this.dept],
        }
        return options;
    }
    CBLOCK.prototype.set = function CBLOCK() {
        var label = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.function_name = arguments[0]["function_name"];
            this.impli = arguments[0]["impli"];
            this.i = parseFloat(arguments[0]["i"]);
            this.o = parseFloat(arguments[0]["o"]);
            this.ci = parseFloat(arguments[0]["ci"]);
            this.co = parseFloat(arguments[0]["co"]);
            this.xx = inverse(arguments[0]["xx"]);
            this.ng = parseFloat(arguments[0]["ng"]);
            this.z = inverse(arguments[0]["z"]);
            this.rpar = inverse(arguments[0]["rpar"]);
            this.ipar = inverse(arguments[0]["ipar"]);
            this.auto0 = arguments[0]["auto0"];
            this.depu = parseBoolean(arguments[0]["depu"]);
            this.dept = parseBoolean(arguments[0]["dept"]);
            this.lab = arguments[0]["lab"];
            if (!ok) {
                break;
            }
            label[1-1] = this.lab;
            var funam = stripblanks(this.function_name);
            this.xx = this.xx.slice();
            this.z = this.z.slice();
            this.rpar = this.rpar.slice();
            this.ipar = int(this.ipar.slice());
            var nx = size(this.xx,1);
            var nz = size(this.z,1);
            this.i = int(this.i.slice());
            this.o = int(this.o.slice());
            var nout = size(this.o,1);
            this.ci = int(this.ci.slice());
            var nevin = size(this.ci,1);
            this.co = int(this.co.slice());
            var nevout = size(this.co,1);
            if (part(this.impli,1)=="y") {
                var funtyp = 12004;
            } else {
                var funtyp = 2004;
            }
            if ([[this.ci],[this.co]].length!=0) {
                if (max([[this.ci],[this.co]])>1) {
                    message("vector event links not supported");
                    throw "user error";
                    var ok = false;
                }
            }
            this.depu = stripblanks(this.depu);
            if (part(this.depu,1)=="y") {
                this.depu = true;
            } else {
                this.depu = false;
            }
            this.dept = stripblanks(this.dept);
            if (part(this.dept,1)=="y") {
                this.dept = true;
            } else {
                this.dept = false;
            }
            var dep_ut = [this.depu,this.dept];
            if (funam==" ") {
                break;
            }
            if (this.model.sim[1-1]!=funam||sign(size(this.model.state,"*"))!=sign(nx)||sign(size(this.model.dstate,"*"))!=sign(nz)||this.model.nzcross!=this.ng||sign(size(this.model.evtout,"*"))!=sign(nevout)) {
                var tt = [];
            }
            var tt = label[2-1];
            while (true) {
                var tmpvar0 = CFORTR2(funam,tt);
                var ok = tmpvar0[0];
                var tt = tmpvar0[1];
                var cancel = tmpvar0[2];
                if (!ok) {
                    if (cancel) {
                        break;
                    }
                } else {
                    var tmpvar1 = check_io(this.model,this.graphics,this.i,this.o,this.ci,this.co);
                    this.model = tmpvar1[0];
                    this.graphics = tmpvar1[1];
                    var ok = tmpvar1[2];
                    if (ok) {
                        this.model.sim = list(new ScilabDouble([funam]), new ScilabDouble([funtyp]));
                        this.model.in = new ScilabDouble([this.i]);
                        this.model.out = new ScilabDouble([this.o]);
                        this.model.evtin = new ScilabDouble([this.ci]);
                        this.model.evtout = new ScilabDouble([this.co]);
                        this.model.state = new ScilabDouble(this.xx);
                        this.model.dstate = new ScilabDouble(this.z);
                        this.model.rpar = new ScilabDouble(this.rpar);
                        this.model.ipar = new ScilabDouble([this.ipar]);
                        this.model.firing = new ScilabDouble([this.auto0]);
                        this.model.dep_ut = new ScilabBoolean(dep_ut);
                        this.model.nzcross = new ScilabDouble([this.ng]);
                        label[2-1] = tt;
                        this.x.model = this.model;
                        this.graphics.exprs = new ScilabDouble([label]);
                        this.x.graphics = this.graphics;
                        break;
                    }
                }
            }
            if (ok||cancel) {
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/CBLOCK4.sci" */
function CBLOCK4() {
    CBLOCK4.prototype.define = function CBLOCK4() {
        var funam = "toto";
        this.model = scicos_model();
        this.model.sim = list(new ScilabString([" "]), new ScilabDouble([2004]));
        this.model.in = new ScilabDouble([1]);
        this.model.in2 = new ScilabDouble([1]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.out2 = new ScilabDouble([1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = list([[funam],["n"],[sci2exp([this.model.in,this.model.in2])],[sci2exp(this.model.intyp)],[sci2exp([this.model.out,this.model.out2])],[sci2exp(this.model.outtyp)],[sci2exp(this.model.evtin)],[sci2exp(this.model.evtout)],[sci2exp(this.model.state)],[sci2exp(this.model.dstate)],[sci2exp(this.model.odstate)],[sci2exp(this.model.rpar)],[sci2exp(this.model.ipar)],[sci2exp(this.model.opar)],[sci2exp(this.model.nmode)],[sci2exp(this.model.nzcross)],[sci2exp(this.model.firing)],["y"],["n"]],[]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CBLOCK4\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([4,2]),this.model,label,this.gr_i);
        return new BasicBlock(this.x);
    }
    CBLOCK4.prototype.details = function CBLOCK4() {
        return this.x;
    }
    CBLOCK4.prototype.get = function CBLOCK4() {
        var options = {
            function_name:["Simulation function",this.function_name],
            impli:["Is block implicit? (y,n)",this.impli],
            in1:["Input ports sizes",this.in1],
            it:["Input ports type",this.it],
            out:["Output port sizes",this.out],
            ot:["Output ports type",this.ot],
            ci:["Input event ports sizes",this.ci],
            co:["Output events ports sizes",this.co],
            xx:["Initial continuous state",this.xx],
            z:["Initial discrete state",this.z],
            oz:["Initial object state",this.oz],
            rpar:["Real parameters vector",this.rpar],
            ipar:["Integer parameters vector",this.ipar],
            opar:["Object parameters list",this.opar],
            nmode:["Number of modes",this.nmode],
            nzcr:["Number of zero crossings",this.nzcr],
            auto0:["Initial firing vector (<0 for no firing)",this.auto0],
            depu:["Direct feedthrough (y or n)",this.depu],
            dept:["Time dependence (y or n)",this.dept],
        }
        return options;
    }
    CBLOCK4.prototype.set = function CBLOCK4() {
        var label = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.function_name = arguments[0]["function_name"];
            this.impli = arguments[0]["impli"];
            this.in1 = arguments[0]["in1"];
            this.it = arguments[0]["it"];
            this.out = arguments[0]["out"];
            this.ot = arguments[0]["ot"];
            this.ci = parseFloat(arguments[0]["ci"]);
            this.co = parseFloat(arguments[0]["co"]);
            this.xx = inverse(arguments[0]["xx"]);
            this.z = inverse(arguments[0]["z"]);
            this.oz = arguments[0]["oz"];
            this.rpar = inverse(arguments[0]["rpar"]);
            this.ipar = parseFloat(arguments[0]["ipar"]);
            this.opar = arguments[0]["opar"];
            this.nmode = arguments[0]["nmode"];
            this.nzcr = arguments[0]["nzcr"];
            this.auto0 = arguments[0]["auto0"];
            this.depu = parseBoolean(arguments[0]["depu"]);
            this.dept = parseBoolean(arguments[0]["dept"]);
            this.lab = arguments[0]["lab"];
            if (!ok) {
                break;
            }
            label[1-1] = this.lab;
            var funam = stripblanks(this.function_name);
            this.xx = this.xx.slice();
            this.z = this.z.slice();
            this.rpar = this.rpar.slice();
            this.ipar = int(this.ipar.slice());
            var nx = size(this.xx,1);
            var nz = size(this.z,1);
            this.ci = int(this.ci.slice());
            var nevin = size(this.ci,1);
            this.co = int(this.co.slice());
            var nevout = size(this.co,1);
            if (part(this.impli,1)=="y") {
                var funtyp = 12004;
            } else {
                var funtyp = 2004;
            }
            if ([[this.ci],[this.co]].length!=0) {
                if (max([[this.ci],[this.co]])>1) {
                    message("vector event links not supported");
                    throw "user error";
                    var ok = false;
                }
            }
            if (ok) {
                this.depu = stripblanks(this.depu);
                if (part(this.depu,1)=="y") {
                    this.depu = true;
                } else {
                    this.depu = false;
                }
                this.dept = stripblanks(this.dept);
                if (part(this.dept,1)=="y") {
                    this.dept = true;
                } else {
                    this.dept = false;
                }
                var dep_ut = [this.depu,this.dept];
                if (funam==" ") {
                    break;
                }
                if (this.model.sim[1-1]!=funam||sign(size(this.model.state,"*"))!=sign(nx)||sign(size(this.model.dstate,"*"))!=sign(nz)||this.model.nzcross!=this.nzcr||sign(size(this.model.evtout,"*"))!=sign(nevout)) {
                    var tt = [];
                }
                var tt = label[2-1];
                var tmpvar0 = set_io(this.model,this.graphics,list(this.in1,this.it),list(this.out,this.ot),this.ci,this.co);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                while (true) {
                    var tmpvar1 = CC4(funam,tt);
                    var ok = tmpvar1[0];
                    var tt = tmpvar1[1];
                    var cancel = tmpvar1[2];
                    if (!ok) {
                        if (cancel) {
                            break;
                        }
                    } else {
                        this.model.sim = list(new ScilabDouble([funam]), new ScilabDouble([funtyp]));
                        this.model.state = new ScilabDouble(this.xx);
                        this.model.dstate = new ScilabDouble(this.z);
                        this.model.odstate = new ScilabDouble([this.oz]);
                        this.model.rpar = new ScilabDouble(this.rpar);
                        this.model.ipar = new ScilabDouble([this.ipar]);
                        this.model.opar = new ScilabDouble([this.opar]);
                        this.model.firing = new ScilabDouble([this.auto0]);
                        this.model.nzcross = new ScilabDouble([this.nzcr]);
                        this.model.nmode = new ScilabDouble([this.nmode]);
                        this.model.dep_ut = new ScilabBoolean(dep_ut);
                        label[2-1] = tt;
                        this.x.model = this.model;
                        this.graphics.exprs = new ScilabDouble([label]);
                        this.x.graphics = this.graphics;
                        break;
                    }
                }
                if (ok||cancel) {
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/CONSTRAINT2_c.sci" */
function CONSTRAINT2_c() {
    CONSTRAINT2_c.prototype.define = function CONSTRAINT2_c() {
        this.x0 = [0];
        this.xd0 = [0];
        this.id = [0];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["constraint_c"]), new ScilabDouble([10004]));
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1],[1]);
        this.model.state = new ScilabDouble([this.x0],[this.xd0]);
        this.model.ipar = new ScilabDouble(this.id);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.exprs = list(strcat(sci2exp(this.x0)),strcat(sci2exp(this.xd0)),strcat(sci2exp(this.id)));
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CONSTRAINT2_c\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,this.exprs,this.gr_i);
        return new BasicBlock(this.x);
    }
    CONSTRAINT2_c.prototype.details = function CONSTRAINT2_c() {
        return this.x;
    }
    CONSTRAINT2_c.prototype.get = function CONSTRAINT2_c() {
        var options = {
            x0:["Initial guess values of states x",this.x0],
            xd0:["Initial guess values of derivative x\'",this.xd0],
            id:["Id(i)=1: if x\'(i) is present in the feedback, else Id(i)=0",this.id],
        }
        return options;
    }
    CONSTRAINT2_c.prototype.set = function CONSTRAINT2_c() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ask_again = false;
            var ok = true;
            this.x0 = inverse(arguments[0]["x0"]);
            this.xd0 = inverse(arguments[0]["xd0"]);
            this.id = inverse(arguments[0]["id"]);
            if (!ok) {
                break;
            }
            this.x0 = this.x0.slice();
            var N = size(this.x0,"*");
            this.xd0 = this.xd0.slice();
            var Nxd = size(this.xd0,"*");
            this.id = this.id.slice();
            var Nid = size(this.id,"*");
            if ((N!=Nxd)||(N!=Nid)) {
                message("incompatible sizes, states, their derivatives, and ID should be the same size ");
                throw "user error";
                var ask_again = true;
            }
            if ((N<=0&&!ask_again)) {
                x_message("number of states (constraints) must be > 0 ");
                var ask_again = true;
            }
            if ((!ask_again)) {
                for (i=1;i<=N;i+=1) {
                    if (!((this.id[i-1]==0)||(this.id[i-1]==1))) {
                        var ask_again = true;
                        x_message([["Id(i) must be either"],["0 when x\'(i) is not present in the feedback"],["1: when x\'(i) is present in the feedback"]]);
                        break;
                    }
                    if ((this.id[i-1]==0)) {
                        this.id[i-1] = -1;
                    }
                }
            }
            if (!ask_again) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.state = new ScilabDouble([this.x0],[this.xd0]);
                this.model.out = new ScilabDouble([N],[N]);
                this.model.in = new ScilabDouble([N]);
                this.model.ipar = new ScilabDouble(this.id);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/CONSTRAINT_c.sci" */
function CONSTRAINT_c() {
    CONSTRAINT_c.prototype.define = function CONSTRAINT_c() {
        this.x0 = [[0],[0]];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["constraint_c"]), new ScilabDouble([10004]));
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.ipar = new ScilabDouble([0]);
        this.model.state = new ScilabDouble(this.x0);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.exprs = "0";
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CONSTRAINT_c\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    CONSTRAINT_c.prototype.details = function CONSTRAINT_c() {
        return this.x;
    }
    CONSTRAINT_c.prototype.get = function CONSTRAINT_c() {
        var options = {
            x0:["Initial guess values",this.x0.toString().replace(/,/g," ")],
        }
        return options;
    }
    CONSTRAINT_c.prototype.set = function CONSTRAINT_c() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.x0 = inverse(arguments[0]["x0"]);
            if (!ok) {
                break;
            }
            this.x0 = this.x0.slice();
            var N = size(this.x0,"*");
            if (N<=0) {
                message("number of states (constraints) must be > 0 ");
                throw "user error";
            } else {
                var tmpvar0 = check_io(this.model,this.graphics,N,N,[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                if (ok) {
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    this.model.state = new ScilabDouble([this.x0],[zeros(N,1)]);
                    this.model.out = new ScilabDouble([N]);
                    this.model.in = new ScilabDouble([N]);
                    this.model.ipar = new ScilabDouble([-1*ones(N,1)]);
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/DEADBAND.sci" */
function DEADBAND() {
    DEADBAND.prototype.define = function DEADBAND() {
        this.minp = -.5;
        this.maxp = .5;
        var rpar = [[this.maxp],[this.minp]];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["deadband"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([1]);
        this.model.nzcross = new ScilabDouble([2]);
        this.model.nmode = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble(rpar);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[string(this.maxp)],[string(this.minp)],[string(this.model.nmode)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"DEADBAND\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    DEADBAND.prototype.details = function DEADBAND() {
        return this.x;
    }
    DEADBAND.prototype.get = function DEADBAND() {
        var options = {
            maxp:["End of dead band",this.maxp],
            minp:["Start of dead band",this.minp],
            zeroc:["zero crossing (0:no, 1:yes)",this.zeroc],
        }
        return options;
    }
    DEADBAND.prototype.set = function DEADBAND() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.maxp = parseFloat(arguments[0]["maxp"]);
            this.minp = parseFloat(arguments[0]["minp"]);
            this.zeroc = arguments[0]["zeroc"];
            if (!ok) {
                break;
            }
            if (this.maxp<=this.minp) {
                message("Upper limit must be > Lower limit");
                throw "user error";
            } else {
                var rpar = [[this.maxp],[this.minp]];
                this.model.rpar = new ScilabDouble(rpar);
                if (this.zeroc!=0) {
                    this.model.nzcross = new ScilabDouble([2]);
                    this.model.nmode = new ScilabDouble([1]);
                } else {
                    this.model.nzcross = new ScilabDouble([0]);
                    this.model.nmode = new ScilabDouble([0]);
                }
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/DEBUG.sci" */
function DEBUG() {
    DEBUG.prototype.define = function DEBUG() {
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["%debug_scicos"]), new ScilabDouble([99]));
        this.model.blocktype = new ScilabString(["d"]);
        this.exprs = list("","xcos_debug_gui(flag,block);");
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"DEBUG\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([8,2]),this.model,this.exprs,this.gr_i);
        return new BasicBlock(this.x);
    }
    DEBUG.prototype.details = function DEBUG() {
        return this.x;
    }
    DEBUG.prototype.get = function DEBUG() {
        alert("parameters cannot be modified");
    }
    DEBUG.prototype.set = function DEBUG() {
        this.exprs = this.graphics.exprs;
        var textmp = this.exprs[2-1];
        var ok = true;
        while (1==1) {
            var tmpvar0 = dialog([["Enter scilab instructions for debugging."],[" Inputs are block and flag, output is block"]],textmp);
            var txt = tmpvar0[0];
            if (txt.length!=0) {
                var tt = ["block=debug_scicos(block,flag)"];
                if (execstr("deff(tt,txt)","errcatch")==0) {
                    var warnMode = warning("query");
                    warning("off");
                    save(this.TMPDIR+"/debug_scicos",this.debug_scicos);
                    warning(warnMode);
                    this.exprs[2-1] = txt;
                    if ((scicos_debug()!=2&&scicos_debug()!=3)) {
                        scicos_debug(2);
                    }
                    break;
                } else {
                    message([["Error in the instructions"],[lasterror()]]);
                    throw "user error";
                }
            } else {
                var ok = false;
                break;
            }
        }
        if (ok) {
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.x.graphics = this.graphics;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/DEBUG_SCICOS.sci" */
function DEBUG_SCICOS() {
    DEBUG_SCICOS.prototype.define = function DEBUG_SCICOS() {
        this.x = DEBUG("define");
        return new BasicBlock(this.x);
    }
    DEBUG_SCICOS.prototype.details = function DEBUG_SCICOS() {
        return this.x;
    }
    DEBUG_SCICOS.prototype.get = function DEBUG_SCICOS() {
        alert("parameters cannot be modified");
    }
    DEBUG_SCICOS.prototype.set = function DEBUG_SCICOS() {
        this.x = tmpvar0[0];
        var y = tmpvar0[1];
        var typ = tmpvar0[2];
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/DIFF_f.sci" */
function DIFF_f() {
    DIFF_f.prototype.define = function DIFF_f() {
        this.x0 = [[0],[0]];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["diffblk"]), new ScilabDouble([10001]));
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.state = new ScilabDouble(this.x0);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.exprs = [[strcat(sci2exp(this.x0[1-1]))],[strcat(sci2exp(this.x0[2-1]))]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"DIFF_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    DIFF_f.prototype.details = function DIFF_f() {
        return this.x;
    }
    DIFF_f.prototype.get = function DIFF_f() {
        var options = {
            x0:["Initial state",this.x0.toString().replace(/,/g," ")],
            xd0:["Initial Derivative",this.xd0],
        }
        return options;
    }
    DIFF_f.prototype.set = function DIFF_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.x0 = inverse(arguments[0]["x0"]);
            this.xd0 = arguments[0]["xd0"];
            if (!ok) {
                break;
            }
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.model.state = new ScilabDouble([this.x0.slice()],[this.xd0.slice()]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        this.x.model.firing = [];
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/DSUPER.sci" */
function DSUPER() {
    DSUPER.prototype.define = function DSUPER() {
        return new BasicBlock(this.x);
    }
    DSUPER.prototype.details = function DSUPER() {
        return this.x;
    }
    DSUPER.prototype.get = function DSUPER() {
        alert("parameters cannot be modified");
    }
    DSUPER.prototype.set = function DSUPER() {
        var y = this.needcompile;
        var typ = list();
        if ((length(this.graphics.exprs)==0)) {
            return;
        }
        this.exprs = this.graphics.exprs[1-1];
        var exprs0 = this.graphics.exprs[2-1][1-1];
        var btitre = this.graphics.exprs[2-1][2-1][1-1];
        var bitems = this.graphics.exprs[2-1][2-1].slice(2-1,$);
        if (exprs0.length==0) {
            return;
        }
        var tmpvar0 = script2var(context,PREVAR_scicos_context);
        var PREVAR_scicos_context = tmpvar0[0];
        var ierr = tmpvar0[1];
        if (ierr!=0) {
            return;
        }
        var tt = "scicos_context."+exprs0[1-1];
        for (i=2;i<=size(exprs0,1);i+=1) {
            var tt = tt+",scicos_context."+exprs0[i-1];
        }
        var ss = this.graphics.exprs[2-1][3-1];
        var scicos_context = PREVAR_scicos_context;
        execstr("[ok,"+tt+",exprs]=scicos_getvalue(btitre,bitems,ss,exprs)");
        if (this.ok) {
            var PREVAR_scicos_context = scicos_context;
            var sblock = this.x.model.rpar;
            var tmpvar1 = do_eval(sblock,list(),scicos_context);
            var sblock = tmpvar1[0];
            %w = tmpvar1[1];
            var needcompile2 = tmpvar1[2];
            this.ok = tmpvar1[3];
            var y = max(2,this.needcompile,needcompile2);
            this.x.graphics.exprs[1-1] = this.exprs;
            this.x.model.rpar = sblock;
        } else {
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/EDGETRIGGER.sci" */
function EDGETRIGGER() {
    EDGETRIGGER.prototype.define = function EDGETRIGGER() {
        this.edge = 1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["edgetrig"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble([0]);
        this.model.nzcross = new ScilabDouble([1]);
        this.model.ipar = new ScilabDouble([sign(this.edge)]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [string(this.edge)];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"EDGETRIGGER\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabString(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    EDGETRIGGER.prototype.details = function EDGETRIGGER() {
        return this.x;
    }
    EDGETRIGGER.prototype.get = function EDGETRIGGER() {
        var options = {
            edge:["rising (1), falling (-1), both (0)",this.edge],
        }
        return options;
    }
    EDGETRIGGER.prototype.set = function EDGETRIGGER() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.edge = parseFloat(arguments[0]["edge"]);
            if (!ok) {
                break;
            }
            this.model.ipar = new ScilabDouble([sign(this.edge)]);
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/EDGE_TRIGGER.sci" */
function EDGE_TRIGGER() {
    EDGE_TRIGGER.prototype.define = function EDGE_TRIGGER() {
        var scs_m_1 = scicos_diagram();
        scs_m_1.objs[1-1] = EDGETRIGGER("define");
        scs_m_1.objs[2-1] = IFTHEL_f("define");
        scs_m_1.objs[3-1] = IN_f("define");
        scs_m_1.objs[4-1] = CLKOUTV_f("define");
        scs_m_1.objs[5-1] = scicos_link();
        scs_m_1.objs[6-1] = scicos_link();
        scs_m_1.objs[7-1] = scicos_link();
        var blk = scs_m_1.objs[1-1];
        this.graphics = blk.graphics;
        this.model = blk.model;
        this.graphics.orig = new ScilabDouble([60,0]);
        this.graphics.sz = new ScilabDouble([60,40]);
        this.graphics.exprs = new ScilabString(["0"]);
        this.model.ipar = new ScilabDouble([0]);
        this.graphics.pin = new ScilabDouble([5]);
        this.graphics.pout = new ScilabDouble([6]);
        blk.graphics = this.graphics;
        blk.model = this.model;
        scs_m_1.objs[1-1] = blk;
        var blk = scs_m_1.objs[2-1];
        this.graphics = blk.graphics;
        this.model = blk.model;
        this.graphics.orig = new ScilabDouble([160,0]);
        this.graphics.sz = new ScilabDouble([60,40]);
        this.graphics.exprs = new ScilabDouble(["0"],["0"]);
        this.model.evtin = new ScilabDouble([]);
        this.model.nzcross = new ScilabDouble([0]);
        this.model.nmode = new ScilabDouble([0]);
        this.graphics.pin = new ScilabDouble([6]);
        this.graphics.peout = new ScilabDouble([7],[0]);
        blk.graphics = this.graphics;
        blk.model = this.model;
        scs_m_1.objs[2-1] = blk;
        var blk = scs_m_1.objs[3-1];
        this.graphics = blk.graphics;
        this.model = blk.model;
        this.graphics.orig = new ScilabDouble([0,10]);
        this.graphics.sz = new ScilabDouble([20,20]);
        this.graphics.exprs = new ScilabString(["1"]);
        this.model.ipar = new ScilabDouble([1]);
        this.graphics.pout = new ScilabDouble([5]);
        blk.graphics = this.graphics;
        blk.model = this.model;
        scs_m_1.objs[3-1] = blk;
        var blk = scs_m_1.objs[4-1];
        this.graphics = blk.graphics;
        this.model = blk.model;
        this.graphics.orig = new ScilabDouble([170,-60]);
        this.graphics.sz = new ScilabDouble([20,20]);
        this.graphics.exprs = new ScilabString(["1"]);
        this.model.ipar = new ScilabDouble([1]);
        this.graphics.pein = new ScilabDouble([7]);
        blk.graphics = this.graphics;
        blk.model = this.model;
        scs_m_1.objs[4-1] = blk;
        var lnk = scs_m_1.objs[5-1];
        lnk.from = [3,1,0];
        lnk.to = [1,1,1];
        scs_m_1.objs[5-1] = lnk;
        var lnk = scs_m_1.objs[6-1];
        lnk.from = [1,1,0];
        lnk.to = [2,1,1];
        scs_m_1.objs[6-1] = lnk;
        var lnk = scs_m_1.objs[7-1];
        lnk.ct = [5,-1];
        lnk.from = [2,1,0];
        lnk.to = [4,1,1];
        scs_m_1.objs[7-1] = lnk;
        blk={};
        lnk={};
        this.model = scicos_model();
        this.model.sim = new ScilabString(["csuper"]);
        this.model.in = new ScilabDouble([1]);
        this.model.evtout = new ScilabDouble([1]);
        this.model.rpar = scs_m_1;
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"EDGE_TRIGGER\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble([]),this.gr_i);
        return new BasicBlock(this.x);
    }
    EDGE_TRIGGER.prototype.details = function EDGE_TRIGGER() {
        return this.x;
    }
    EDGE_TRIGGER.prototype.get = function EDGE_TRIGGER() {
        alert("parameters cannot be modified");
    }
    EDGE_TRIGGER.prototype.set = function EDGE_TRIGGER() {
            if (typeof(o)=="Block"&&o.gui=="EDGETRIGGER") {
                var ppath = list(i);
                break;
            }
        }
        var newpar = list();
        var y = 0;
        for (path in ppath) {
            var np = size(path,"*");
            var spath = list();
            for (k=1;k<=np;k+=1) {
                spath[$+1-1] = "model";
                spath[$+1-1] = "rpar";
                spath[$+1-1] = "objs";
                spath[$+1-1] = path[k-1];
            }
            execstr("xxn="+xx.gui+"(\'set\',xx)");
            if (diffobjs(this.xxn,xx)) {
                this.model = xx.model;
                var model_n = this.xxn.model;
                if (!is_modelica_block(xx)) {
                    var modified = or(this.model.sim!=model_n.sim)||!isequal(this.model.state,model_n.state)||!isequal(this.model.dstate,model_n.dstate)||!isequal(this.model.rpar,model_n.rpar)||!isequal(this.model.ipar,model_n.ipar)||!isequal(this.model.label,model_n.label);
                    if (or(this.model.in!=model_n.in)||or(this.model.out!=model_n.out)) {
                        var needcompile = 1;
                    }
                    if (or(this.model.firing!=model_n.firing)) {
                        var needcompile = 2;
                    }
                    if ((size(this.model.in,"*")!=size(model_n.in,"*"))||(size(this.model.out,"*")!=size(model_n.out,"*"))) {
                        var needcompile = 4;
                    }
                    if (this.model.sim=="input"||this.model.sim=="output") {
                        if (this.model.ipar!=model_n.ipar) {
                            var needcompile = 4;
                        }
                    }
                    if (or(this.model.blocktype!=model_n.blocktype)||or(this.model.dep_ut!=model_n.dep_ut)) {
                        var needcompile = 4;
                    }
                    if ((this.model.nzcross!=model_n.nzcross)||(this.model.nmode!=model_n.nmode)) {
                        var needcompile = 4;
                    }
                    if (prod(size(model_n.sim))>1) {
                        if (model_n.sim[2-1]>1000) {
                            if (this.model.sim[1-1]!=model_n.sim[1-1]) {
                                var needcompile = 4;
                            }
                        }
                    }
                } else {
                    var modified = or(model_n!=this.model);
                    var eq = this.model.equations;
                    var eqn = model_n.equations;
                    if (or(eq.model!=eqn.model)||or(eq.inputs!=eqn.inputs)||or(eq.outputs!=eqn.outputs)) {
                        var needcompile = 4;
                    }
                }
                newpar[size(newpar)+1-1] = path;
                var y = max(y,needcompile);
            }
        }
        var typ = newpar;
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/ENDBLK.sci" */
function ENDBLK() {
    ENDBLK.prototype.define = function ENDBLK() {
        var scs_m_1 = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[-159.096,811.104,-121.216,617.984,1323,1008,331,284,630,480,0,7,1.4],Title="ENDBLK",tol=[0.0001,0.000001,1.000e-10,100001,0,0],tf=100000,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m_1.objs[1-1] = scicos_block(gui="END_c",graphics=scicos_graphics(orig=[272.104,249.11733],sz=[40,40],flip=true,theta=0,exprs="1.000E+08",pin=[],pout=[],pein=2,peout=2,gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim=list("scicosexit",4),in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=1,state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="d",firing=1.000e+08,dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[2-1] = scicos_link(xx=[[292.104],[292.104],[261.83733],[261.83733],[292.104],[292.104]],yy=[[243.40305],[234.45067],[234.45067],[305.584],[305.584],[294.83162]],id="drawlink",thick=[0,0],ct=[5,-1],from=[1,1,0],to=[1,1,1]);
        this.model = scicos_model(sim="csuper",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=scs_m_1,ipar=[],opar=list(),blocktype="h",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list());
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"ENDBLK\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble([]),this.gr_i);
        return new BasicBlock(this.x);
    }
    ENDBLK.prototype.details = function ENDBLK() {
        return this.x;
    }
    ENDBLK.prototype.get = function ENDBLK() {
        alert("parameters cannot be modified");
    }
    ENDBLK.prototype.set = function ENDBLK() {
            if (typeof(o)=="Block"&&o.gui=="END_c") {
                var ppath = list(i);
                break;
            }
        }
        var newpar = list();
        var y = 0;
        for (path in ppath) {
            var np = size(path,"*");
            var spath = list();
            for (k=1;k<=np;k+=1) {
                spath[$+1-1] = "model";
                spath[$+1-1] = "rpar";
                spath[$+1-1] = "objs";
                spath[$+1-1] = path[k-1];
            }
            execstr("xxn="+xx.gui+"(\'set\',xx)");
            if (!isequalbitwise(this.xxn,xx)) {
                this.model = xx.model;
                var model_n = this.xxn.model;
                if (!is_modelica_block(xx)) {
                    var modified = or(this.model.sim!=model_n.sim)||!isequal(this.model.state,model_n.state)||!isequal(this.model.dstate,model_n.dstate)||!isequal(this.model.odstate,model_n.odstate)||!isequal(this.model.rpar,model_n.rpar)||!isequal(this.model.ipar,model_n.ipar)||!isequal(this.model.opar,model_n.opar)||!isequal(this.model.label,model_n.label);
                    if (or(this.model.in!=model_n.in)||or(this.model.out!=model_n.out)||or(this.model.in2!=model_n.in2)||or(this.model.out2!=model_n.out2)||or(this.model.outtyp!=model_n.outtyp)||or(this.model.intyp!=model_n.intyp)) {
                        var needcompile = 1;
                    }
                    if (or(this.model.firing!=model_n.firing)) {
                        var needcompile = 2;
                    }
                    if ((size(this.model.in,"*")!=size(model_n.in,"*"))||(size(this.model.out,"*")!=size(model_n.out,"*"))||(size(this.model.evtin,"*")!=size(model_n.evtin,"*"))) {
                        var needcompile = 4;
                    }
                    if (this.model.sim=="input"||this.model.sim=="output") {
                        if (this.model.ipar!=model_n.ipar) {
                            var needcompile = 4;
                        }
                    }
                    if (or(this.model.blocktype!=model_n.blocktype)||or(this.model.dep_ut!=model_n.dep_ut)) {
                        var needcompile = 4;
                    }
                    if ((this.model.nzcross!=model_n.nzcross)||(this.model.nmode!=model_n.nmode)) {
                        var needcompile = 4;
                    }
                    if (prod(size(model_n.sim))>1) {
                        if (model_n.sim[2-1]>1000) {
                            if (this.model.sim[1-1]!=model_n.sim[1-1]) {
                                var needcompile = 4;
                            }
                        }
                    }
                } else {
                    var modified = or(model_n!=this.model);
                    var eq = this.model.equations;
                    var eqn = model_n.equations;
                    if (or(eq.model!=eqn.model)||or(eq.inputs!=eqn.inputs)||or(eq.outputs!=eqn.outputs)) {
                        var needcompile = 4;
                    }
                }
                newpar[size(newpar)+1-1] = path;
                var y = max(y,needcompile);
            }
        }
        var typ = newpar;
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/Extract_Activation.sci" */
function Extract_Activation() {
    Extract_Activation.prototype.define = function Extract_Activation() {
        var scs_m_1 = scicos_diagram();
        scs_m_1.objs[1-1] = IFTHEL_f("define");
        scs_m_1.objs[2-1] = CLKSOMV_f("define");
        scs_m_1.objs[3-1] = IN_f("define");
        scs_m_1.objs[4-1] = CLKOUTV_f("define");
        scs_m_1.objs[5-1] = scicos_link();
        scs_m_1.objs[6-1] = scicos_link();
        scs_m_1.objs[7-1] = scicos_link();
        scs_m_1.objs[8-1] = scicos_link();
        var blk = scs_m_1.objs[1-1];
        this.graphics = blk.graphics;
        this.model = blk.model;
        this.graphics.orig = new ScilabDouble([80,0]);
        this.graphics.sz = new ScilabDouble([60,40]);
        this.graphics.exprs = new ScilabDouble(["0"],["0"]);
        this.model.evtin = new ScilabDouble([]);
        this.model.nzcross = new ScilabDouble([0]);
        this.model.nmode = new ScilabDouble([0]);
        this.graphics.pin = new ScilabDouble([7]);
        this.graphics.peout = new ScilabDouble([5],[6]);
        blk.graphics = this.graphics;
        blk.model = this.model;
        scs_m_1.objs[1-1] = blk;
        var blk = scs_m_1.objs[2-1];
        this.graphics = blk.graphics;
        this.model = blk.model;
        this.graphics.orig = new ScilabDouble([80,-80]);
        this.graphics.sz = new ScilabDouble([80,40]);
        this.graphics.pein = new ScilabDouble([5],[6]);
        this.graphics.peout = new ScilabDouble([8]);
        blk.graphics = this.graphics;
        blk.model = this.model;
        scs_m_1.objs[2-1] = blk;
        var blk = scs_m_1.objs[3-1];
        this.graphics = blk.graphics;
        this.model = blk.model;
        this.graphics.orig = new ScilabDouble([0,10]);
        this.graphics.sz = new ScilabDouble([20,20]);
        this.graphics.exprs = new ScilabString(["1"]);
        this.model.ipar = new ScilabDouble([1]);
        this.graphics.pout = new ScilabDouble([7]);
        blk.graphics = this.graphics;
        blk.model = this.model;
        scs_m_1.objs[3-1] = blk;
        var blk = scs_m_1.objs[4-1];
        this.graphics = blk.graphics;
        this.model = blk.model;
        this.graphics.orig = new ScilabDouble([110,-140]);
        this.graphics.sz = new ScilabDouble([20,20]);
        this.graphics.exprs = new ScilabString(["1"]);
        this.model.ipar = new ScilabDouble([1]);
        this.graphics.pein = new ScilabDouble([8]);
        blk.graphics = this.graphics;
        blk.model = this.model;
        scs_m_1.objs[4-1] = blk;
        var lnk = scs_m_1.objs[5-1];
        lnk.ct = [5,-1];
        lnk.from = [1,1,0];
        lnk.to = [2,1,1];
        scs_m_1.objs[5-1] = lnk;
        var lnk = scs_m_1.objs[6-1];
        lnk.ct = [5,-1];
        lnk.from = [1,2,0];
        lnk.to = [2,2,1];
        scs_m_1.objs[6-1] = lnk;
        var lnk = scs_m_1.objs[7-1];
        lnk.from = [3,1,0];
        lnk.to = [1,1,1];
        scs_m_1.objs[7-1] = lnk;
        var lnk = scs_m_1.objs[8-1];
        lnk.ct = [5,-1];
        lnk.from = [2,1,0];
        lnk.to = [4,1,1];
        scs_m_1.objs[8-1] = lnk;
        blk={};
        lnk={};
        this.model = scicos_model();
        this.model.sim = new ScilabString(["csuper"]);
        this.model.in = new ScilabDouble([1]);
        this.model.evtout = new ScilabDouble([1]);
        this.model.rpar = scs_m_1;
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"Extract_Activation\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble([]),this.gr_i);
        return new BasicBlock(this.x);
    }
    Extract_Activation.prototype.details = function Extract_Activation() {
        return this.x;
    }
    Extract_Activation.prototype.get = function Extract_Activation() {
        alert("parameters cannot be modified");
    }
    Extract_Activation.prototype.set = function Extract_Activation() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/HYSTHERESIS.sci" */
function HYSTHERESIS() {
    HYSTHERESIS.prototype.define = function HYSTHERESIS() {
        var in1 = 1;
        var ipar = [0];
        this.nzz = 2;
        var rpar = [[1],[0],[1],[0]];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["hystheresis"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([in1]);
        this.model.out = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble(rpar);
        this.model.nzcross = new ScilabDouble([this.nzz]);
        this.model.nmode = new ScilabDouble([1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[string(rpar)],[string(sign(this.nzz))]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"HYSTHERESIS\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    HYSTHERESIS.prototype.details = function HYSTHERESIS() {
        return this.x;
    }
    HYSTHERESIS.prototype.get = function HYSTHERESIS() {
        var options = {
            high_lim:["switch on at",this.high_lim],
            low_lim:["switch off at",this.low_lim],
            out_high:["output when on",this.out_high],
            out_low:["output when off",this.out_low],
            nzz:["use zero crossing: yes (1), no (0)",this.nzz],
        }
        return options;
    }
    HYSTHERESIS.prototype.set = function HYSTHERESIS() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.high_lim = arguments[0]["high_lim"];
            this.low_lim = arguments[0]["low_lim"];
            this.out_high = arguments[0]["out_high"];
            this.out_low = arguments[0]["out_low"];
            this.nzz = parseFloat(arguments[0]["nzz"]);
            if (!ok) {
                break;
            }
            if (this.low_lim>this.high_lim) {
                message("switch on value must be larger than switch off value");
                throw "user error";
            } else {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.rpar = new ScilabDouble(transpose([this.high_lim,this.low_lim,this.out_high,this.out_low]));
                if (this.nzz>0) {
                    this.nzz = 2;
                }
                this.model.nzcross = new ScilabDouble([this.nzz]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/IMPSPLIT_f.sci" */
function IMPSPLIT_f() {
    IMPSPLIT_f.prototype.define = function IMPSPLIT_f() {
        this.model = scicos_model();
        this.model.sim = new ScilabString(["limpsplit"]);
        var mo = modelica();
        mo.model = "limpsplit";
        mo.inputs = "n";
        mo.outputs = [["n"],["n"]];
        this.model.equations = new ScilabDouble([mo]);
        this.model.in = new ScilabDouble([ones(size(mo.inputs,"*"),1)]);
        this.model.out = new ScilabDouble([ones(size(mo.outputs,"*"),1)]);
        this.x = new standard_define(new ScilabDouble([1,1]),this.model,new ScilabDouble([]),[]);
        this.x.graphics.in_implicit = ["I"];
        this.x.graphics.out_implicit = ["I","I"];
        return new BasicBlock(this.x);
    }
    IMPSPLIT_f.prototype.details = function IMPSPLIT_f() {
        return this.x;
    }
    IMPSPLIT_f.prototype.get = function IMPSPLIT_f() {
        alert("parameters cannot be modified");
    }
    IMPSPLIT_f.prototype.set = function IMPSPLIT_f() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/LOGICAL_OP.sci" */
function LOGICAL_OP() {
    LOGICAL_OP.prototype.define = function LOGICAL_OP() {
        var in1 = [[-1],[-1]];
        var ipar = [0];
        this.nin = 2;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["logicalop"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble(in1);
        this.model.out = new ScilabDouble([-1]);
        this.model.ipar = new ScilabDouble(ipar);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[string(this.nin)],[string(ipar)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"LOGICAL_OP\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    LOGICAL_OP.prototype.details = function LOGICAL_OP() {
        return this.x;
    }
    LOGICAL_OP.prototype.get = function LOGICAL_OP() {
        var options = {
            nin:["number of inputs",this.nin],
            rule:["Operator: AND (0), OR (1), NAND (2), NOR (3), XOR (4), NOT (5)",this.rule],
            Datatype:["Datatype (1=double 3=int32 ...)",this.Datatype],
            tp:["Bitwise Rule(0=No 1=yes)",this.tp],
        }
        return options;
    }
    LOGICAL_OP.prototype.set = function LOGICAL_OP() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,1)==2) {
            this.exprs = [[this.exprs],[sci2exp(1)],[sci2exp(0)]];
        }
        while (true) {
            var ok = true;
            this.nin = parseFloat(arguments[0]["nin"]);
            this.rule = parseFloat(arguments[0]["rule"]);
            this.Datatype = arguments[0]["Datatype"];
            this.tp = parseFloat(arguments[0]["tp"]);
            if (!ok) {
                break;
            }
            this.nin = int(this.nin);
            this.rule = int(this.rule);
            this.tp = int(this.tp);
            if (this.nin<1) {
                message("Number of inputs must be >=1 ");
                throw "user error";
                var ok = false;
            } else if ((this.rule<0)||(this.rule>5)) {
                message("Incorrect operator "+string(this.rule)+" ; must be 0 to 5.");
                throw "user error";
                var ok = false;
            } else if ((this.rule==5)&&(this.nin>1)) {
                message("Only one input allowed for NOT operation");
                throw "user error";
                this.nin = 1;
            } else if (((this.Datatype==1)&&(this.tp!=0))) {
                message("Bitwise Rule is only activated when Data type is integer");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                if ((this.tp!=0)) {
                    this.tp = 1;
                }
                if (this.Datatype==1) {
                    this.model.sim = list(new ScilabString(["logicalop"]), new ScilabDouble([4]));
                    this.model.ipar = new ScilabDouble([this.rule]);
                } else {
                    if (this.Datatype==3) {
                        this.model.sim = list(new ScilabString(["logicalop_i32"]), new ScilabDouble([4]));
                    } else if (this.Datatype==4) {
                        this.model.sim = list(new ScilabString(["logicalop_i16"]), new ScilabDouble([4]));
                    } else if (this.Datatype==5) {
                        this.model.sim = list(new ScilabString(["logicalop_i8"]), new ScilabDouble([4]));
                    } else if (this.Datatype==6) {
                        this.model.sim = list(new ScilabString(["logicalop_ui32"]), new ScilabDouble([4]));
                    } else if (this.Datatype==7) {
                        this.model.sim = list(new ScilabString(["logicalop_ui16"]), new ScilabDouble([4]));
                    } else if (this.Datatype==8) {
                        this.model.sim = list(new ScilabString(["logicalop_ui8"]), new ScilabDouble([4]));
                    } else {
                        message("Datatype is not supported");
                        throw "user error";
                        var ok = false;
                    }
                    this.model.ipar = new ScilabDouble([this.rule],[this.tp]);
                }
                if (ok) {
                    var it = this.Datatype*ones(this.nin,1);
                    var ot = this.Datatype;
                    var in1 = [-ones(this.nin,1),-2*ones(this.nin,1)];
                    if ((this.rule!=5)&&(this.nin==1)) {
                        var out = [1,1];
                        var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                        this.model = tmpvar0[0];
                        this.graphics = tmpvar0[1];
                        var ok = tmpvar0[2];
                    } else {
                        var out = [-1,-2];
                        var tmpvar1 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                        this.model = tmpvar1[0];
                        this.graphics = tmpvar1[1];
                        var ok = tmpvar1[2];
                    }
                }
                if (ok) {
                    if (this.rule==0) {
                        var label = "AND";
                    } else if (this.rule==1) {
                        var label = "OR";
                    } else if (this.rule==2) {
                        var label = "NAND";
                    } else if (this.rule==3) {
                        var label = "NOR";
                    } else if (this.rule==4) {
                        var label = "XOR";
                    } else if (this.rule==5) {
                        var label = "NOT";
                    }
                    this.graphics.exprs = new ScilabDouble(this.exprs);
                    this.graphics.style = new ScilabString(["blockWithLabel;displayedLabel="+label]);
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/MBLOCK.sci" */
function MBLOCK() {
    MBLOCK.prototype.define = function MBLOCK() {
        this.in1 = ["u1"];
        this.intype = ["I"];
        this.out = [["y1"],["y2"]];
        this.outtype = [["I"],["E"]];
        var param = [["R"],["L"]];
        var paramv = list(0.1,.0001);
        this.pprop = [[0],[0]];
        var nameF = "generic";
        this.exprs = tlist(["MBLOCK","in","intype","out","outtype","param","paramv","pprop","nameF","funtxt"],sci2exp(this.in1.slice()),sci2exp(this.intype.slice()),sci2exp(this.out.slice()),sci2exp(this.outtype.slice()),sci2exp(param.slice()),list(string(0.1),string(.0001)),sci2exp(this.pprop.slice()),nameF,[]);
        this.model = scicos_model();
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.model.rpar = new ScilabDouble([]);
        for (i=1;i<=lstsize(paramv);i+=1) {
            this.model.rpar = new ScilabDouble([this.model.rpar],[paramv[i-1].slice()]);
        }
        var mo = modelica();
        mo.model = nameF;
        mo.parameters = list(param,paramv);
        this.model.sim = list(new ScilabString([mo.model]), new ScilabDouble([30004]));
        mo.inputs = this.in1;
        mo.outputs = this.out;
        this.model.in = new ScilabDouble([ones(size(mo.inputs,"r"),1)]);
        this.model.out = new ScilabDouble([ones(size(mo.outputs,"r"),1)]);
        this.model.equations = mo;
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MBLOCK\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble([this.exprs]),this.gr_i);
        this.x.graphics.in_implicit = this.intype;
        this.x.graphics.out_implicit = this.outtype;
        return new BasicBlock(this.x);
    }
    MBLOCK.prototype.details = function MBLOCK() {
        return this.x;
    }
    MBLOCK.prototype.get = function MBLOCK() {
        var options = {
            Tin:["Input variables:       ",this.Tin],
            Tintype:["Input variables types: ",this.Tintype],
            Tout:["Output variables:      ",this.Tout],
            Touttype:["Output variables types:",this.Touttype],
            Tparam:["Parameters in Modelica:",this.Tparam],
            pprop:["Parameters properties: ",this.pprop],
            Tfunam:["Function name:         ",this.Tfunam],
        }
        return options;
    }
    MBLOCK.prototype.set = function MBLOCK() {
        this.exprs = this.graphics.exprs;
        if (this.type[this.exprs-1]==15) {
            var paramv = list();
            this.pprop = [];
            for (i=1;i<=size(this.model.rpar,"*");i+=1) {
                paramv[$+1-1] = string(this.model.rpar[i-1]);
                this.pprop[$+1-1] = 0;
            }
            this.exprs = tlist(["MBLOCK","in","intype","out","outtype","param","paramv","pprop","nameF","funtxt"],this.exprs[1-1][1-1],this.exprs[1-1][2-1],this.exprs[1-1][3-1],this.exprs[1-1][4-1],this.exprs[1-1][5-1],paramv,sci2exp(this.pprop.slice()),this.exprs[1-1][7-1],this.exprs[2-1]);
        }
        this.lab_1 = list(this.exprs.in,this.exprs.intype,this.exprs.out,this.exprs.outtype,this.exprs.param,this.exprs.pprop,this.exprs.nameF);
        var lab_2 = this.exprs.paramv;
        while (true) {
            var ok = true;
            this.Tin = arguments[0]["Tin"];
            this.Tintype = arguments[0]["Tintype"];
            this.Tout = arguments[0]["Tout"];
            this.Touttype = arguments[0]["Touttype"];
            this.Tparam = arguments[0]["Tparam"];
            this.pprop = inverse(arguments[0]["pprop"]);
            this.Tfunam = arguments[0]["Tfunam"];
            this.lab_1 = arguments[0]["lab_1"];
            if (!ok) {
                break;
            }
            var ierr = execstr("in=stripblanks(evstr(Tin));            intype=stripblanks(evstr(Tintype));            out=stripblanks(evstr(Tout));            outtype=stripblanks(evstr(Touttype));            param=stripblanks(evstr(Tparam));            funam=stripblanks(Tfunam)","errcatch");
            if (ierr!=0) {
                messagebox("Error in evaluation of variables.","modal","error");
                var ok = false;
            }
            if (ok) {
                for (i=1;i<=size(this.in1,"*");i+=1) {
                    var r = false;
                    var ierr = execstr("r=validvar(in(i))","errcatch");
                    if (!r) {
                        var ok = false;
                        break;
                    }
                }
                if (!ok) {
                    messagebox([["Invalid variable name for the input "+string(i)+"."],["\""+this.in1[i-1]+"\""],["Please choose another variable name."]],"modal","error");
                }
            }
            if (ok) {
                for (i=1;i<=size(this.out,"*");i+=1) {
                    var r = false;
                    var ierr = execstr("r=validvar(out(i))","errcatch");
                    if (!r) {
                        var ok = false;
                        break;
                    }
                }
                if (!ok) {
                    messagebox([["Invalid variable name for the output "+string(i)+"."],["\""+this.out[i-1]+"\""],["Please choose another variable name."]],"modal","error");
                }
            }
            if (ok) {
                var param = param.slice();
                for (i=1;i<=size(param,"*");i+=1) {
                    var r = false;
                    var ierr = execstr("r=validvar(param(i))","errcatch");
                    if (!r) {
                        var ok = false;
                        break;
                    }
                }
                if (!ok) {
                    messagebox([["Invalid variable name for the parameter "+string(i)+"."],["\""+param[i-1]+"\""],["Please choose another variable name."]],"modal","error");
                }
            }
            if (ok) {
                for (i=1;i<=size(this.intype,"*");i+=1) {
                    if (this.intype[i-1]!="E"&&this.intype[i-1]!="I") {
                        messagebox("Input type should be \'E\' or \'I\'!","modal","error");
                        var ok = false;
                        break;
                    }
                }
            }
            if (ok) {
                for (i=1;i<=size(this.outtype,"*");i+=1) {
                    if (this.outtype[i-1]!="E"&&this.outtype[i-1]!="I") {
                        messagebox("Output type should be \'E\' or \'I\'!","modal","error");
                        var ok = false;
                        break;
                    }
                }
            }
            if (ok) {
                if (or(size(this.intype)!=size(this.in1))) {
                    messagebox("Input variables are not well defined!","modal","error");
                    var ok = false;
                }
            }
            if (ok) {
                if (or(size(this.outtype)!=size(this.out))) {
                    messagebox("Output variables are not well defined!","modal","error");
                    var ok = false;
                }
            }
            if (ok) {
                this.pprop = this.pprop.slice();
                if ((size(param,"*")!=size(this.pprop,"*"))) {
                    messagebox([["There is differences in"],["size of param and size "],["of param properties."]],"modal","error");
                    var ok = false;
                }
            }
            if (ok) {
                if (max(this.pprop)>2||min(this.pprop)<0) {
                    messagebox([["Parameters properties must be :"],["0 : for simple paramater,"],["1 : for initial state value,"],["2 : for a fixed initial state value."]],"modal","error");
                    var ok = false;
                }
            }
            if (ok) {
                if (this.funam=="") {
                    messagebox("The filename is not defined!","modal","error");
                    var ok = false;
                }
            }
            if (ok) {
                var tmpvar0 = fileparts(this.funam);
                var dirF = tmpvar0[0];
                var nameF = tmpvar0[1];
                var extF = tmpvar0[2];
                if ((extF!=""&&extF!=".mo")||(dirF!=""&&extF!=".mo")) {
                    messagebox("Filename extention should be \'.mo \' !","modal","error");
                    var ok = false;
                }
            }
            if (ok) {
                var intypex = find(this.intype=="I");
                var outtypex = find(this.outtype=="I");
                var tmpvar1 = set_io(this.model,this.graphics,list([ones(this.in1),ones(this.in1)],ones(this.in1)),list([ones(this.out),ones(this.out)],ones(this.out)),[],[],intypex,outtypex);
                this.model = tmpvar1[0];
                this.graphics = tmpvar1[1];
                var ok = tmpvar1[2];
            }
            if (ok) {
                var Tparam_lab = evstr(this.Tparam);
                var Tparam_sz = size(Tparam_lab,"*");
                if (Tparam_sz>lstsize(lab_2)) {
                    for (i=1;i<=(Tparam_sz-lstsize(lab_2));i+=1) {
                        lab_2[$+1-1] = "0";
                    }
                } else if (Tparam_sz<lstsize(lab_2)) {
                    var lab_2_tmp = list();
                    if (Tparam_sz!=0) {
                        for (i=1;i<=(lstsize(lab_2)-Tparam_sz);i+=1) {
                            lab_2_tmp[i-1] = lab_2[i-1];
                        }
                    }
                    var lab_2 = lab_2_tmp;
                }
                if (Tparam_sz!=0) {
                    var lhs_txt = "";
                    var lab_txt = "";
                    var rhs_txt = "";
                    for (i=1;i<=Tparam_sz;i+=1) {
                        var lhs_txt = lhs_txt+"%v"+string(i)+",";
                        if (this.pprop[i-1]==0) {
                            var lab_txt = lab_txt+"\'"+Tparam_lab[i-1]+"\';";
                        } else if (this.pprop[i-1]==1) {
                            var lab_txt = lab_txt+"\'"+Tparam_lab[i-1]+" (state) \';";
                        } else if (this.pprop[i-1]==2) {
                            var lab_txt = lab_txt+"\'"+Tparam_lab[i-1]+" (fixed state) \';";
                        }
                        var rhs_txt = rhs_txt+"\'vec\',-1,";
                    }
                    var lhs_txt = part(lhs_txt,1,length(lhs_txt)-1);
                    var lab_txt = part(lab_txt,1,length(lab_txt)-1);
                    var rhs_txt = part(rhs_txt,1,length(rhs_txt)-1);
                    var getvalue_txt = "[ok,"+lhs_txt+",lab_2]=scicos_getvalue(\'Set parameters values\',["+lab_txt+"],"+"list("+rhs_txt+"),lab_2)";
                    execstr(getvalue_txt);
                    if (!ok) {
                        var lab_2 = this.exprs.paramv;
                    }
                }
            }
            if (ok) {
                var paramv = list();
                for (i=1;i<=Tparam_sz;i+=1) {
                    execstr("paramv("+string(i)+")=%v"+string(i));
                }
            }
            if (ok) {
                if (extF==".mo"&&fileinfo(this.funam).length!=0) {
                    var tt = mgetl(this.funam);
                } else {
                    var tt = this.exprs.funtxt;
                    var mo = this.model.equations;
                    if (mo.model!=nameF) {
                        var tt = [];
                    }
                }
                var tmpvar2 = MODCOM(this.funam,tt,this.in1,this.out,param,paramv,this.pprop);
                var ok = tmpvar2[0];
                var tt = tmpvar2[1];
                if (!ok) {
                    break;
                }
            }
            if (ok) {
                var mo = modelica();
                mo.model = nameF;
                mo.inputs = this.in1;
                mo.outputs = this.out;
                if (max(this.pprop)>0) {
                    mo.parameters = list(transpose(param),paramv,transpose(this.pprop));
                } else {
                    mo.parameters = list(transpose(param),paramv);
                }
                this.model.equations = new ScilabDouble([mo]);
                this.model.rpar = new ScilabDouble([]);
                for (i=1;i<=lstsize(paramv);i+=1) {
                    this.model.rpar = new ScilabDouble([this.model.rpar],[paramv[i-1].slice()]);
                }
                this.model.sim[1-1] = new ScilabDouble([this.funam]);
                this.exprs.in = this.lab_1[1-1];
                this.exprs.intype = this.lab_1[2-1];
                this.exprs.out = this.lab_1[3-1];
                this.exprs.outtype = this.lab_1[4-1];
                this.exprs.param = this.lab_1[5-1];
                this.exprs.paramv = list();
                if (Tparam_sz!=0) {
                    if (this.type[lab_2-1]==15) {
                        for (i=1;i<=lstsize(lab_2);i+=1) {
                            this.exprs.paramv[i-1] = lab_2[i-1];
                        }
                    } else {
                        for (i=1;i<=size(lab_2,"*");i+=1) {
                            this.exprs.paramv[i-1] = lab_2[i-1];
                        }
                    }
                }
                this.exprs.pprop = this.lab_1[6-1];
                this.exprs.nameF = this.lab_1[7-1];
                this.exprs.funtxt = tt;
                this.x.model = this.model;
                this.graphics.gr_i[1-1][1-1] = new ScilabString(["txt=[\'Modelica\';\' "+nameF+" \'];"]);
                this.graphics.in_implicit = new ScilabString(this.intype);
                this.graphics.out_implicit = new ScilabDouble(this.outtype);
                this.graphics.exprs = this.exprs;
                this.x.graphics = this.graphics;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/MEMORY_f.sci" */
function MEMORY_f() {
    MEMORY_f.prototype.define = function MEMORY_f() {
        var z = 0;
        var in1 = 1;
        this.exprs = [[string(z)],[string(1)]];
        this.model = scicos_model();
        this.model.sim = new ScilabString(["memo"]);
        this.model.in = new ScilabDouble([in1]);
        this.model.out = new ScilabDouble([in1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble([0]);
        this.model.rpar = new ScilabDouble([z]);
        this.model.blocktype = new ScilabString(["m"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MEMORY_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    MEMORY_f.prototype.details = function MEMORY_f() {
        return this.x;
    }
    MEMORY_f.prototype.get = function MEMORY_f() {
        var options = {
            a:["initial condition",this.a],
            inh:["Inherit (1: no, 0: yes)",this.inh],
        }
        return options;
    }
    MEMORY_f.prototype.set = function MEMORY_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.a = arguments[0]["a"];
            this.inh = parseFloat(arguments[0]["inh"]);
            if (!ok) {
                break;
            }
            if (this.inh==0) {
                this.inh = [];
            } else {
                this.inh = 1;
            }
            var tmpvar0 = check_io(this.model,this.graphics,-1,-1,this.inh,[]);
            this.model = tmpvar0[0];
            this.graphics = tmpvar0[1];
            var ok = tmpvar0[2];
            var out = size(this.a,"*");
            if (out==0) {
                var ok = false;
                messagebox("Initial condition empty","modal","error");
            }
            var in1 = out;
            if (ok) {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.rpar = new ScilabDouble([this.a]);
                this.model.in = new ScilabDouble([in1]);
                this.model.out = new ScilabDouble([out]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/MPBLOCK.sci" */
function MPBLOCK() {
    MPBLOCK.prototype.define = function MPBLOCK() {
        this.in1 = ["u"];
        this.intype = ["I"];
        this.out = [["y1"],["y2"]];
        this.outtype = [["I"],["I"]];
        var param = [];
        var paramv = list();
        var pprop = [];
        var nameF = "myModel";
        this.exprs = tlist(["MPBLOCK","in","intype","out","outtype","param","paramv","pprop","nameF","funtxt"],sci2exp(this.in1.slice()),sci2exp(this.intype.slice()),sci2exp(this.out.slice()),sci2exp(this.outtype.slice()),sci2exp(param.slice()),list(string(0.1),string(.0001)),sci2exp(pprop.slice()),nameF,[]);
        this.model = scicos_model();
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,true]);
        this.model.rpar = new ScilabDouble([]);
        for (i=1;i<=lstsize(paramv);i+=1) {
            this.model.rpar = new ScilabDouble([this.model.rpar],[paramv[i-1].slice()]);
        }
        var mo = modelica();
        mo.model = nameF;
        mo.parameters = list(param,paramv);
        this.model.sim = list(new ScilabString([mo.model]), new ScilabDouble([10004]));
        mo.inputs = this.in1;
        mo.outputs = this.out;
        this.model.in = new ScilabDouble([ones(size(mo.inputs,"r"),1)]);
        this.model.out = new ScilabDouble([ones(size(mo.outputs,"r"),1)]);
        this.model.equations = mo;
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MPBLOCK\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble([this.exprs]),this.gr_i);
        this.x.graphics.in_implicit = this.intype;
        this.x.graphics.out_implicit = this.outtype;
        return new BasicBlock(this.x);
    }
    MPBLOCK.prototype.details = function MPBLOCK() {
        return this.x;
    }
    MPBLOCK.prototype.get = function MPBLOCK() {
        alert("parameters cannot be modified");
    }
    MPBLOCK.prototype.set = function MPBLOCK() {
        this.exprs = this.graphics.exprs;
        if (this.type[this.exprs-1]==15) {
            var paramv = list();
            var pprop = [];
            for (i=1;i<=size(this.model.rpar,"*");i+=1) {
                paramv[$+1-1] = string(this.model.rpar[i-1]);
                pprop[$+1-1] = 0;
            }
            this.exprs = tlist(["MPBLOCK","in","intype","out","outtype","param","paramv","pprop","nameF","funtxt"],this.exprs[1-1][1-1],this.exprs[1-1][2-1],this.exprs[1-1][3-1],this.exprs[1-1][4-1],this.exprs[1-1][5-1],paramv,sci2exp(pprop.slice()),this.exprs[1-1][7-1],this.exprs[2-1]);
        }
        var lab_1 = list(this.exprs.in,this.exprs.intype,this.exprs.out,this.exprs.outtype,this.exprs.param,this.exprs.pprop,this.exprs.nameF);
        var lab_2 = this.exprs.paramv;
        while (true) {
            var tmpvar0 = getvalue("Set Modelica generic block parameters",[["Input variables:       "],["Input variables types: "],["Output variables:      "],["Output variables types:"],["Parameters in Modelica:"],["Parameters properties: "],["Model name in packages:"]],list("str",-1,"str",-1,"str",-1,"str",-1,"str",-1,"vec",-1,"str",-1),lab_1);
            var ok = tmpvar0[0];
            var Tin = tmpvar0[1];
            var Tintype = tmpvar0[2];
            var Tout = tmpvar0[3];
            var Touttype = tmpvar0[4];
            var Tparam = tmpvar0[5];
            var pprop = tmpvar0[6];
            var Tfunam = tmpvar0[7];
            var lab_1 = tmpvar0[8];
            if (!ok) {
                break;
            }
            var ierr = execstr("in=stripblanks(evstr(Tin));            intype=stripblanks(evstr(Tintype));            out=stripblanks(evstr(Tout));            outtype=stripblanks(evstr(Touttype));            param=stripblanks(evstr(Tparam));            funam=stripblanks(Tfunam)","errcatch");
            if (ierr!=0) {
                x_message("Error in evaluation of variables.");
                var ok = false;
            }
            if (ok) {
                for (i=1;i<=size(this.in1,"*");i+=1) {
                    var r = false;
                    var ierr = execstr("r=validvar(in(i))","errcatch");
                    if (!r) {
                        var ok = false;
                        break;
                    }
                }
                if (!ok) {
                    x_message([["Invalid variable name for the input "+string(i)+"."],["\""+this.in1[i-1]+"\""],["Please choose another variable name."]]);
                }
            }
            if (ok) {
                for (i=1;i<=size(this.out,"*");i+=1) {
                    var r = false;
                    var ierr = execstr("r=validvar(out(i))","errcatch");
                    if (!r) {
                        var ok = false;
                        break;
                    }
                }
                if (!ok) {
                    x_message([["Invalid variable name for the output "+string(i)+"."],["\""+this.out[i-1]+"\""],["Please choose another variable name."]]);
                }
            }
            if (ok) {
                var param = param.slice();
                for (i=1;i<=size(param,"*");i+=1) {
                    var r = false;
                    var ierr = execstr("r=validvar(param(i))","errcatch");
                    if (!r) {
                        var ok = false;
                        break;
                    }
                }
                if (!ok) {
                    x_message([["Invalid variable name for the parameter "+string(i)+"."],["\""+param[i-1]+"\""],["Please choose another variable name."]]);
                }
            }
            if (ok) {
                for (i=1;i<=size(this.intype,"*");i+=1) {
                    if (this.intype[i-1]!="E"&&this.intype[i-1]!="I") {
                        x_message("Input type should be \'E\' or \'I\'!");
                        var ok = false;
                        break;
                    }
                }
            }
            if (ok) {
                for (i=1;i<=size(this.outtype,"*");i+=1) {
                    if (this.outtype[i-1]!="E"&&this.outtype[i-1]!="I") {
                        x_message("Output type should be \'E\' or \'I\'!");
                        var ok = false;
                        break;
                    }
                }
            }
            if (ok) {
                if (or(size(this.intype)!=size(this.in1))) {
                    x_message("Input variables are not well defined!");
                    var ok = false;
                }
            }
            if (ok) {
                if (or(size(this.outtype)!=size(this.out))) {
                    x_message("Output variables are not well defined!");
                    var ok = false;
                }
            }
            if (ok) {
                var pprop = pprop.slice();
                if ((size(param,"*")!=size(pprop,"*"))) {
                    x_message([["There is differences in"],["size of param and size "],["of param properties."]]);
                    var ok = false;
                }
            }
            if (ok) {
                if (max(pprop)>2||min(pprop)<0) {
                    x_message([["Parameters properties must be :"],["0 : if it is a paramaters"],["1 : if it is an initial value of state,"],["2 : it it is a fixed initial state value."]]);
                    var ok = false;
                }
            }
            if (ok) {
                if (this.funam=="") {
                    x_message("The model name is not defined!");
                    var ok = false;
                }
            }
            if (ok) {
                var tmpvar1 = fileparts(this.funam);
                var dirF = tmpvar1[0];
                var nameF = tmpvar1[1];
                var extF = tmpvar1[2];
                if ((extF!="")||(dirF!="")) {
                    x_message("Invalid model name!");
                    var ok = false;
                }
            }
            if (ok) {
                var intypex = find(this.intype=="I");
                var outtypex = find(this.outtype=="I");
                var tmpvar2 = set_io(this.model,this.graphics,list([ones(this.in1),ones(this.in1)],ones(this.in1)),list([ones(this.out),ones(this.out)],ones(this.out)),[],[],intypex,outtypex);
                this.model = tmpvar2[0];
                this.graphics = tmpvar2[1];
                var ok = tmpvar2[2];
            }
            if (ok) {
                var Tparam_lab = evstr(Tparam);
                var Tparam_sz = size(Tparam_lab,"*");
                if (Tparam_sz>lstsize(lab_2)) {
                    for (i=1;i<=(Tparam_sz-lstsize(lab_2));i+=1) {
                        lab_2[$+1-1] = "0";
                    }
                } else if (Tparam_sz<lstsize(lab_2)) {
                    var lab_2_tmp = list();
                    if (Tparam_sz!=0) {
                        for (i=1;i<=Tparam_sz;i+=1) {
                            var ee = evstr(this.exprs.param);
                            for (j=1;j<=size(ee,"r");j+=1) {
                                if (ee[j-1]==Tparam_lab[i-1]) {
                                    lab_2_tmp[i-1] = lab_2[j-1];
                                }
                            }
                        }
                        var lab_2 = lab_2_tmp;
                    }
                }
                if (Tparam_sz!=0) {
                    var lhs_txt = "";
                    var lab_txt = "";
                    var rhs_txt = "";
                    for (i=1;i<=Tparam_sz;i+=1) {
                        var lhs_txt = lhs_txt+"%v"+string(i)+",";
                        if (pprop[i-1]==0) {
                            var lab_txt = lab_txt+"\'"+Tparam_lab[i-1]+"\';";
                        } else if (pprop[i-1]==1) {
                            var lab_txt = lab_txt+"\'"+Tparam_lab[i-1]+" (state) \';";
                        } else if (pprop[i-1]==2) {
                            var lab_txt = lab_txt+"\'"+Tparam_lab[i-1]+" (fixed state) \';";
                        }
                        var rhs_txt = rhs_txt+"\'vec\',-1,";
                    }
                    var lhs_txt = part(lhs_txt,1,length(lhs_txt)-1);
                    var lab_txt = part(lab_txt,1,length(lab_txt)-1);
                    var rhs_txt = part(rhs_txt,1,length(rhs_txt)-1);
                    var getvalue_txt = "[ok,"+lhs_txt+",lab_2]=scicos_getvalue(\'Set parameters values\',["+lab_txt+"],"+"list("+rhs_txt+"),lab_2)";
                    execstr(getvalue_txt);
                    if (!ok) {
                        var lab_2 = this.exprs.paramv;
                    }
                }
            }
            if (ok) {
                var paramv = list();
                for (i=1;i<=Tparam_sz;i+=1) {
                    execstr("paramv("+string(i)+")=%v"+string(i));
                }
            }
            if (ok) {
                var mo = modelica();
                mo.model = nameF;
                mo.inputs = this.in1;
                mo.outputs = this.out;
                if (pprop.length!=0) {
                    if (max(pprop)>0) {
                        mo.parameters = list(transpose(param),paramv,transpose(pprop));
                    } else {
                        mo.parameters = list(transpose(param),paramv);
                    }
                }
                this.model.equations = new ScilabDouble([mo]);
                this.model.rpar = new ScilabDouble([]);
                for (i=1;i<=lstsize(paramv);i+=1) {
                    this.model.rpar = new ScilabDouble([this.model.rpar],[double(paramv[i-1].slice())]);
                }
                this.model.sim[1-1] = new ScilabDouble([this.funam]);
                this.exprs.in = lab_1[1-1];
                this.exprs.intype = lab_1[2-1];
                this.exprs.out = lab_1[3-1];
                this.exprs.outtype = lab_1[4-1];
                this.exprs.param = lab_1[5-1];
                this.exprs.paramv = list();
                if (Tparam_sz!=0) {
                    if (this.type[lab_2-1]==15) {
                        for (i=1;i<=lstsize(lab_2);i+=1) {
                            this.exprs.paramv[i-1] = lab_2[i-1];
                        }
                    } else {
                        for (i=1;i<=size(lab_2,"*");i+=1) {
                            this.exprs.paramv[i-1] = lab_2[i-1];
                        }
                    }
                }
                this.exprs.pprop = lab_1[6-1];
                this.exprs.nameF = lab_1[7-1];
                this.exprs.funtxt = "";
                this.x.model = this.model;
                this.graphics.gr_i[1-1][1-1] = new ScilabString(["txt=[\' "+nameF+" \'];"]);
                this.graphics.in_implicit = new ScilabString(this.intype);
                this.graphics.out_implicit = new ScilabDouble(this.outtype);
                this.graphics.exprs = this.exprs;
                this.x.graphics = this.graphics;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/PAL_f.sci" */
function PAL_f() {
    PAL_f.prototype.define = function PAL_f() {
        var scs = scicos_diagram();
        scs.props.title = "Palette";
        this.model = scicos_model();
        this.model.sim = new ScilabString(["palette"]);
        this.model.in = new ScilabDouble([]);
        this.model.out = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([scs]);
        this.model.blocktype = new ScilabString(["h"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"PAL_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble([]),this.gr_i);
        this.x.graphics.id = scs.props.title[1-1];
        return new BasicBlock(this.x);
    }
    PAL_f.prototype.details = function PAL_f() {
        return this.x;
    }
    PAL_f.prototype.get = function PAL_f() {
        alert("parameters cannot be modified");
    }
    PAL_f.prototype.set = function PAL_f() {
        this.x = tmpvar0[0];
        var newparameters = tmpvar0[1];
        var needcompile = tmpvar0[2];
        var edited = tmpvar0[3];
        var y = [];
        var typ = [];
        %exit = resume(false)
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/PENDULUM_ANIM.sci" */
function PENDULUM_ANIM() {
    PENDULUM_ANIM.prototype.define = function PENDULUM_ANIM() {
        this.plen = 2;
        this.csiz = 2;
        this.phi = 0;
        this.xmin = -5;
        this.xmax = 5;
        this.ymin = -5;
        this.ymax = 5;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["anim_pen"]), new ScilabDouble([5]));
        this.model.in = new ScilabDouble([1],[1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble([0]);
        this.model.rpar = new ScilabDouble([this.plen],[this.csiz],[this.phi],[this.xmin],[this.xmax],[this.ymin],[this.ymax]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = string(this.model.rpar);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"PENDULUM_ANIM\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,3]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    PENDULUM_ANIM.prototype.details = function PENDULUM_ANIM() {
        return this.x;
    }
    PENDULUM_ANIM.prototype.get = function PENDULUM_ANIM() {
        var options = {
            plen:["pendulum length",this.plen],
            csiz:["cart size (square side)",this.csiz],
            phi:["slope",this.phi],
            xmin:["Xmin",this.xmin],
            xmax:["Xmax",this.xmax],
            ymin:["Ymin",this.ymin],
            ymax:["Ymax",this.ymax],
        }
        return options;
    }
    PENDULUM_ANIM.prototype.set = function PENDULUM_ANIM() {
        this.exprs = this.graphics.exprs;
        var dstate = this.model.dstate;
        while (true) {
            var ok = true;
            this.plen = parseFloat(arguments[0]["plen"]);
            this.csiz = parseFloat(arguments[0]["csiz"]);
            this.phi = parseFloat(arguments[0]["phi"]);
            this.xmin = parseFloat(arguments[0]["xmin"]);
            this.xmax = parseFloat(arguments[0]["xmax"]);
            this.ymin = parseFloat(arguments[0]["ymin"]);
            this.ymax = parseFloat(arguments[0]["ymax"]);
            if (!ok) {
                break;
            }
            var mess = [];
            if (this.plen<=0||this.csiz<=0) {
                var mess = [[mess],["Pendulum length and cart size must be positive."],[" "]];
                var ok = false;
            }
            if (this.ymin>=this.ymax) {
                var mess = [[mess],["Ymax must be greater than Ymin"],[" "]];
                var ok = false;
            }
            if (this.xmin>=this.xmax) {
                var mess = [[mess],["Xmax must be greater than Xmin"],[" "]];
                var ok = false;
            }
            if (!ok) {
                message(mess);
                throw "user error";
            } else {
                var rpar = [[this.plen],[this.csiz],[this.phi],[this.xmin],[this.xmax],[this.ymin],[this.ymax]];
                this.model.rpar = new ScilabDouble(rpar);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/RATELIMITER.sci" */
function RATELIMITER() {
    RATELIMITER.prototype.define = function RATELIMITER() {
        this.minp = -1;
        this.maxp = 1;
        var rpar = [[this.maxp],[this.minp]];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["ratelimiter"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble(rpar);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[string(this.maxp)],[string(this.minp)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"RATELIMITER\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3.5,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    RATELIMITER.prototype.details = function RATELIMITER() {
        return this.x;
    }
    RATELIMITER.prototype.get = function RATELIMITER() {
        var options = {
            maxp:["max slope",this.maxp],
            minp:["min slope",this.minp],
        }
        return options;
    }
    RATELIMITER.prototype.set = function RATELIMITER() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.maxp = parseFloat(arguments[0]["maxp"]);
            this.minp = parseFloat(arguments[0]["minp"]);
            if (!ok) {
                break;
            }
            if (this.maxp<=this.minp||this.maxp<=0||this.minp>=0) {
                message("We must have max_slope> 0 > min_slope.");
                throw "user error";
            } else {
                var rpar = [[this.maxp],[this.minp]];
                this.model.rpar = new ScilabDouble(rpar);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/RELATIONALOP.sci" */
function RELATIONALOP() {
    RELATIONALOP.prototype.define = function RELATIONALOP() {
        var ipar = [2];
        var label = "&lt";
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["relationalop"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([1],[1]);
        this.model.out = new ScilabDouble([1]);
        this.model.ipar = new ScilabDouble(ipar);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[string(ipar)],[string(0)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"RELATIONALOP\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        this.x.graphics.style = ["fontSize=13;fontStyle=1;displayedLabel="+label];
        return new BasicBlock(this.x);
    }
    RELATIONALOP.prototype.details = function RELATIONALOP() {
        return this.x;
    }
    RELATIONALOP.prototype.get = function RELATIONALOP() {
        var options = {
            rule:["Operator: == (0), ~= (1), < (2), <= (3), > (4), >= (5)",this.rule],
            zcr:["Use zero crossing (no: 0), (yes: 1)",this.zcr],
            Datatype:["Datatype (1=double 3=int32 ...)",this.Datatype],
        }
        return options;
    }
    RELATIONALOP.prototype.set = function RELATIONALOP() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,1)==2) {
            this.exprs = [[this.exprs],[sci2exp(1)]];
        }
        while (true) {
            var ok = true;
            this.rule = parseFloat(arguments[0]["rule"]);
            this.zcr = parseFloat(arguments[0]["zcr"]);
            this.Datatype = arguments[0]["Datatype"];
            if (!ok) {
                break;
            }
            this.rule = int(this.rule);
            if (this.zcr!=0) {
                this.zcr = 1;
            }
            if ((this.rule<0)||(this.rule>5)) {
                message("Incorrect operator "+string(this.rule)+" ; must be 0 to 5.");
                throw "user error";
                var ok = false;
            }
            if ((this.Datatype==1)) {
                this.model.sim = list(new ScilabString(["relational_op"]), new ScilabDouble([4]));
            } else if ((this.Datatype==3||this.Datatype==9)) {
                this.model.sim = list(new ScilabString(["relational_op_i32"]), new ScilabDouble([4]));
            } else if ((this.Datatype==4)) {
                this.model.sim = list(new ScilabString(["relational_op_i16"]), new ScilabDouble([4]));
            } else if ((this.Datatype==5)) {
                this.model.sim = list(new ScilabString(["relational_op_i8"]), new ScilabDouble([4]));
            } else if ((this.Datatype==6)) {
                this.model.sim = list(new ScilabString(["relational_op_ui32"]), new ScilabDouble([4]));
            } else if ((this.Datatype==7)) {
                this.model.sim = list(new ScilabString(["relational_op_ui16"]), new ScilabDouble([4]));
            } else if ((this.Datatype==8)) {
                this.model.sim = list(new ScilabString(["relational_op_ui8"]), new ScilabDouble([4]));
            } else {
                message("Datatype is not supported");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                var it = this.Datatype*ones(1,2);
                var ot = this.Datatype;
                var in1 = [[-1,-2],[-1,-2]];
                var out = [-1,-2];
                var tmpvar0 = set_io(this.model,this.graphics,list(in1,it),list(out,ot),[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                if (this.rule==0) {
                    var label = "==";
                } else if (this.rule==1) {
                    var label = "~=";
                } else if (this.rule==2) {
                    var label = "&#60;";
                } else if (this.rule==3) {
                    var label = "&#8804;";
                } else if (this.rule==4) {
                    var label = "&#62;";
                } else if (this.rule==5) {
                    var label = "&#8805;";
                }
                this.graphics.exprs = new ScilabDouble(this.exprs);
                this.graphics.style = new ScilabString(["fontSize=13;fontStyle=1;displayedLabel="+label]);
                this.model.ipar = new ScilabDouble([this.rule]);
                this.model.nzcross = new ScilabDouble([this.zcr]);
                this.model.nmode = new ScilabDouble([this.zcr]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/SPLIT_f.sci" */
function SPLIT_f() {
    SPLIT_f.prototype.define = function SPLIT_f() {
        this.model = scicos_model();
        this.model.sim = new ScilabString(["lsplit"]);
        this.model.in = new ScilabDouble([-1]);
        this.model.out = new ScilabDouble([-1],[-1],[-1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.x = new standard_define(new ScilabDouble([1,1]),this.model,new ScilabDouble([]),[]);
        return new BasicBlock(this.x);
    }
    SPLIT_f.prototype.details = function SPLIT_f() {
        return this.x;
    }
    SPLIT_f.prototype.get = function SPLIT_f() {
        alert("parameters cannot be modified");
    }
    SPLIT_f.prototype.set = function SPLIT_f() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/SUPER_f.sci" */
function SUPER_f() {
    SUPER_f.prototype.define = function SUPER_f() {
        var scs = scicos_diagram();
        scs.props.title = "Super Block";
        var in1 = IN_f("define");
        in1.graphics.orig = [40,40];
        in1.graphics.sz = [20,20];
        var out = OUT_f("define");
        out.graphics.orig = [240,40];
        out.graphics.sz = [20,20];
        scs.objs[1-1] = in1;
        scs.objs[2-1] = out;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["super"]);
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([scs]);
        this.model.blocktype = new ScilabString(["h"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SUPER_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble([]),this.gr_i);
        return new SuperBlock(this.x);
    }
    SUPER_f.prototype.details = function SUPER_f() {
        return this.x;
    }
    SUPER_f.prototype.get = function SUPER_f() {
        alert("parameters cannot be modified");
    }
    SUPER_f.prototype.set = function SUPER_f() {
        return new SuperBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/TEXT_f.sci" */
function TEXT_f() {
    TEXT_f.prototype.define = function TEXT_f() {
        this.font = 2;
        this.siz = 1;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["text"]);
        this.model.rpar = new ScilabString(["Text"]);
        this.model.ipar = new ScilabDouble([this.font],[this.siz]);
        this.exprs = [["Text"],[string(this.font)],[string(this.siz)]];
        this.graphics = scicos_graphics();
        this.graphics.orig = new ScilabDouble([0,0]);
        this.graphics.sz = new ScilabDouble([2,1]);
        this.graphics.exprs = new ScilabDouble(this.exprs);
        this.x = mlist(["Text","graphics","model","void","gui"],this.graphics,this.model," ","TEXT_f");
        return new TextBlock(this.x);
    }
    TEXT_f.prototype.details = function TEXT_f() {
        return this.x;
    }
    TEXT_f.prototype.get = function TEXT_f() {
        var options = {
            txt:["Text",this.txt],
            font:["Font number",this.font],
            siz:["Font size",this.siz],
        }
        return options;
    }
    TEXT_f.prototype.set = function TEXT_f() {
        var orig = this.graphics.orig;
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")==1) {
            this.exprs = [[this.exprs],["3"],["1"]];
        }
        while (true) {
            var ok = true;
            this.txt = arguments[0]["txt"];
            this.font = parseFloat(arguments[0]["font"]);
            this.siz = parseFloat(arguments[0]["siz"]);
            if (!ok) {
                break;
            }
            if (this.font<=0||this.font>6) {
                message("Font number must be greater than 0 and less than 7");
                throw "user error";
                var ok = false;
            }
            if (this.siz<0) {
                message("Font size must be positive");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                this.graphics.exprs = new ScilabDouble(this.exprs);
                var gh_winpal = gca();
                var default_font_style = gh_winpal.font_style;
                var default_font_size = gh_winpal.font_size;
                var default_font_color = gh_winpal.font_color;
                gh_winpal.font_style = this.font;
                gh_winpal.font_size = this.siz;
                var r = xstringl(0,0,this.exprs[1-1],evstr(this.exprs[2-1]),evstr(this.exprs[3-1]));
                gh_winpal.font_style = default_font_style;
                gh_winpal.font_size = default_font_size;
                gh_winpal.font_color = default_font_color;
                var sz = r.slice(3-1,4);
                this.graphics.sz = new ScilabDouble(sz);
                this.x.graphics = this.graphics;
                var ipar = [[this.font],[this.siz]];
                this.model.rpar = new ScilabDouble([this.txt]);
                this.model.ipar = new ScilabDouble(ipar);
                this.x.model = this.model;
                break;
            }
        }
        return new TextBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/c_block.sci" */
function c_block() {
    c_block.prototype.define = function c_block() {
        var in1 = 1;
        var out = 1;
        var clkin = [];
        var clkout = [];
        var x0 = [];
        var z0 = [];
        var typ = "c";
        var auto = [];
        this.rpar = [];
        this.funam = "toto";
        this.model = scicos_model();
        this.model.sim = list(new ScilabString([" "]), new ScilabDouble([2001]));
        this.model.in = new ScilabDouble([in1]);
        this.model.out = new ScilabDouble([out]);
        this.model.evtin = new ScilabDouble(clkin);
        this.model.evtout = new ScilabDouble(clkout);
        this.model.state = new ScilabDouble(x0);
        this.model.dstate = new ScilabDouble(z0);
        this.model.rpar = new ScilabDouble(this.rpar);
        this.model.ipar = new ScilabDouble([0]);
        this.model.blocktype = new ScilabString([typ]);
        this.model.firing = new ScilabDouble(auto);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = list([[sci2exp(in1)],[sci2exp(out)],[strcat(sci2exp(this.rpar))],[this.funam]],list([]));
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"c_block\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,label,this.gr_i);
        return new BasicBlock(this.x);
    }
    c_block.prototype.details = function c_block() {
        return this.x;
    }
    c_block.prototype.get = function c_block() {
        var options = {
            i:["input ports sizes",this.i],
            o:["output port sizes",this.o],
            rpar:["System parameters vector",this.rpar],
            funam:["function name",this.funam],
        }
        return options;
    }
    c_block.prototype.set = function c_block() {
        var label = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.i = parseFloat(arguments[0]["i"]);
            this.o = parseFloat(arguments[0]["o"]);
            this.rpar = inverse(arguments[0]["rpar"]);
            this.funam = arguments[0]["funam"];
            this.lab = arguments[0]["lab"];
            if (!ok) {
                break;
            }
            if (this.funam==" ") {
                break;
            }
            label[1-1] = this.lab;
            this.rpar = this.rpar.slice();
            this.i = int(this.i.slice());
            var ni = size(this.i,1);
            this.o = int(this.o.slice());
            var no = size(this.o,1);
            var tt = label[2-1];
            if (this.model.sim[1-1]!=this.funam||size(this.model.in,"*")!=size(this.i,"*")||size(this.model.out,"*")!=size(this.o,"*")) {
                var tt = [];
            }
            var tmpvar0 = CFORTR(this.funam,tt,this.i,this.o);
            var ok = tmpvar0[0];
            var tt = tmpvar0[1];
            if (!ok) {
                break;
            }
            var tmpvar1 = check_io(this.model,this.graphics,this.i,this.o,[],[]);
            this.model = tmpvar1[0];
            this.graphics = tmpvar1[1];
            var ok = tmpvar1[2];
            if (ok) {
                this.model.sim[1-1] = new ScilabString([this.funam]);
                this.model.rpar = new ScilabDouble(this.rpar);
                label[2-1] = tt;
                this.x.model = this.model;
                this.graphics.exprs = new ScilabDouble([label]);
                this.x.graphics = this.graphics;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/fortran_block.sci" */
function fortran_block() {
    fortran_block.prototype.define = function fortran_block() {
        this.model = scicos_model();
        this.model.sim = list(new ScilabString([" "]), new ScilabDouble([1001]));
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([0]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.funam = "forty";
        var label = list([[sci2exp(this.model.in)],[sci2exp(this.model.out)],[strcat(sci2exp(this.model.rpar))],[this.funam]],list([]));
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"fortran_block\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([4,2]),this.model,label,this.gr_i);
        return new BasicBlock(this.x);
    }
    fortran_block.prototype.details = function fortran_block() {
        return this.x;
    }
    fortran_block.prototype.get = function fortran_block() {
        var options = {
            i:["input ports sizes",this.i],
            o:["output port sizes",this.o],
            rpar:["System parameters vector",this.rpar],
            funam:["function name",this.funam],
        }
        return options;
    }
    fortran_block.prototype.set = function fortran_block() {
        var label = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.i = parseFloat(arguments[0]["i"]);
            this.o = parseFloat(arguments[0]["o"]);
            this.rpar = inverse(arguments[0]["rpar"]);
            this.funam = arguments[0]["funam"];
            this.lab = arguments[0]["lab"];
            if (!ok) {
                break;
            }
            if (this.funam==" ") {
                break;
            }
            label[1-1] = this.lab;
            this.rpar = this.rpar.slice();
            this.i = int(this.i.slice());
            var ni = size(this.i,1);
            this.o = int(this.o.slice());
            var no = size(this.o,1);
            var tt = label[2-1];
            if (this.model.sim[1-1]!=this.funam||size(this.model.in,"*")!=size(this.i,"*")||size(this.model.out,"*")!=size(this.o,"*")) {
                var tt = [];
            }
            var tmpvar0 = FORTR(this.funam,tt,this.i,this.o);
            var ok = tmpvar0[0];
            var tt = tmpvar0[1];
            if (!ok) {
                break;
            }
            var tmpvar1 = check_io(this.model,this.graphics,this.i,this.o,[],[]);
            this.model = tmpvar1[0];
            this.graphics = tmpvar1[1];
            var ok = tmpvar1[2];
            if (ok) {
                this.model.sim[1-1] = new ScilabString([this.funam]);
                this.model.rpar = new ScilabDouble(this.rpar);
                label[2-1] = tt;
                this.x.model = this.model;
                this.graphics.exprs = new ScilabDouble([label]);
                this.x.graphics = this.graphics;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/func_block.sci" */
function func_block() {
    func_block.prototype.define = function func_block() {
        this.model = scicos_model();
        this.model.sim = new ScilabString([" "]);
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = "v=sin(u);y=u*v";
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"func_block\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    func_block.prototype.details = function func_block() {
        return this.x;
    }
    func_block.prototype.get = function func_block() {
        alert("parameters cannot be modified");
    }
    func_block.prototype.set = function func_block() {
        this.exprs = this.graphics.exprs;
        this.model = this.x.model;
        var tmpvar0 = genfunc(this.exprs);
        var ok = tmpvar0[0];
        var mac = tmpvar0[1];
        this.exprs = tmpvar0[2];
        if (ok) {
            this.model.sim = new ScilabDouble([mac]);
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.x.model = this.model;
            this.x.graphics = this.graphics;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/generic_block.sci" */
function generic_block() {
    generic_block.prototype.define = function generic_block() {
        this.model = scicos_model();
        this.function_name = "sinblk";
        this.funtyp = 1;
        this.model.sim = list(new ScilabString([this.function_name]), new ScilabDouble([this.funtyp]));
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [[this.function_name],[sci2exp(this.funtyp)],[sci2exp(this.model.in)],[sci2exp(this.model.out)],[sci2exp(this.model.evtin)],[sci2exp(this.model.evtout)],[sci2exp(this.model.state)],[sci2exp(this.model.dstate)],[sci2exp(this.model.rpar)],[sci2exp(this.model.ipar)],[sci2exp(this.model.firing)],["y"],["n"]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"generic_block\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    generic_block.prototype.details = function generic_block() {
        return this.x;
    }
    generic_block.prototype.get = function generic_block() {
        var options = {
            function_name:["simulation function",this.function_name],
            funtyp:["function type (0,1,2,..)",this.funtyp],
            i:["input ports sizes",this.i],
            o:["output port sizes",this.o],
            ci:["input event ports sizes",this.ci],
            co:["output events ports sizes",this.co],
            xx:["initial continuous state",this.xx],
            z:["initial discrete state",this.z],
            rpar:["Real parameters vector",this.rpar],
            ipar:["Integer parameters vector",this.ipar],
            auto0:["initial firing vector (<0 for no firing)",this.auto0],
            depu:["direct feedthrough (y or n)",this.depu],
            dept:["time dependence (y or n)",this.dept],
        }
        return options;
    }
    generic_block.prototype.set = function generic_block() {
        var label = this.graphics.exprs;
        if (size(label,"*")==14) {
            label[9-1] = [];
        }
        while (true) {
            var ok = true;
            this.function_name = arguments[0]["function_name"];
            this.funtyp = parseFloat(arguments[0]["funtyp"]);
            this.i = parseFloat(arguments[0]["i"]);
            this.o = parseFloat(arguments[0]["o"]);
            this.ci = parseFloat(arguments[0]["ci"]);
            this.co = parseFloat(arguments[0]["co"]);
            this.xx = inverse(arguments[0]["xx"]);
            this.z = inverse(arguments[0]["z"]);
            this.rpar = inverse(arguments[0]["rpar"]);
            this.ipar = parseFloat(arguments[0]["ipar"]);
            this.auto0 = arguments[0]["auto0"];
            this.depu = parseBoolean(arguments[0]["depu"]);
            this.dept = parseBoolean(arguments[0]["dept"]);
            this.lab = arguments[0]["lab"];
            if (!ok) {
                break;
            }
            var label = this.lab;
            this.function_name = stripblanks(this.function_name);
            this.xx = this.xx.slice();
            this.z = this.z.slice();
            this.rpar = this.rpar.slice();
            this.ipar = int(this.ipar.slice());
            this.i = int(this.i.slice());
            this.o = int(this.o.slice());
            this.ci = int(this.ci.slice());
            this.co = int(this.co.slice());
            this.funtyp = int(this.funtyp);
            if (this.funtyp<0) {
                message("function type cannot be negative");
                throw "user error";
                var ok = false;
            }
            if ([[this.ci],[this.co]].length!=0) {
                if (max([[this.ci],[this.co]])>1) {
                    message("vector event links not supported");
                    throw "user error";
                    var ok = false;
                }
            }
            this.depu = stripblanks(this.depu);
            if (part(this.depu,1)=="y") {
                this.depu = true;
            } else {
                this.depu = false;
            }
            this.dept = stripblanks(this.dept);
            if (part(this.dept,1)=="y") {
                this.dept = true;
            } else {
                this.dept = false;
            }
            var dep_ut = [this.depu,this.dept];
            if (ok) {
                var tmpvar0 = check_io(this.model,this.graphics,this.i,this.o,this.ci,this.co);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                if (this.funtyp==3) {
                    var needcompile = 4;
                }
                this.model.sim = list(new ScilabDouble([this.function_name]), new ScilabDouble([this.funtyp]));
                this.model.state = new ScilabDouble(this.xx);
                this.model.dstate = new ScilabDouble(this.z);
                this.model.rpar = new ScilabDouble(this.rpar);
                this.model.ipar = new ScilabDouble([this.ipar]);
                this.model.firing = new ScilabDouble([this.auto0]);
                this.model.dep_ut = new ScilabBoolean(dep_ut);
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        needcompile = resume(needcompile)
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/generic_block2.sci" */
function generic_block2() {
    generic_block2.prototype.define = function generic_block2() {
        this.model = scicos_model();
        this.function_name = "sinblk";
        this.funtyp = 1;
        this.model.sim = list(new ScilabString([this.function_name]), new ScilabDouble([this.funtyp]));
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [[this.function_name],[sci2exp(this.funtyp)],[sci2exp(this.model.in)],[sci2exp(this.model.out)],[sci2exp(this.model.evtin)],[sci2exp(this.model.evtout)],[sci2exp(this.model.state)],[sci2exp(this.model.dstate)],[sci2exp(this.model.rpar)],[sci2exp(this.model.ipar)],[sci2exp(this.model.nmode)],[sci2exp(this.model.nzcross)],[sci2exp(this.model.firing)],["y"],["n"]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"generic_block2\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    generic_block2.prototype.details = function generic_block2() {
        return this.x;
    }
    generic_block2.prototype.get = function generic_block2() {
        var options = {
            function_name:["simulation function",this.function_name],
            funtyp:["function type (0,1,2,..)",this.funtyp],
            i:["input ports sizes",this.i],
            o:["output port sizes",this.o],
            ci:["input event ports sizes",this.ci],
            co:["output events ports sizes",this.co],
            xx:["initial continuous state",this.xx],
            z:["initial discrete state",this.z],
            rpar:["Real parameters vector",this.rpar],
            ipar:["Integer parameters vector",this.ipar],
            nmode:["number of modes",this.nmode],
            nzcr:["number of zero_crossings",this.nzcr],
            auto0:["initial firing vector (<0 for no firing)",this.auto0],
            depu:["direct feedthrough (y or n)",this.depu],
            dept:["time dependence (y or n)",this.dept],
        }
        return options;
    }
    generic_block2.prototype.set = function generic_block2() {
        var label = this.graphics.exprs;
        if (size(label,"*")==14) {
            label[9-1] = [];
        }
        while (true) {
            var ok = true;
            this.function_name = arguments[0]["function_name"];
            this.funtyp = parseFloat(arguments[0]["funtyp"]);
            this.i = parseFloat(arguments[0]["i"]);
            this.o = parseFloat(arguments[0]["o"]);
            this.ci = parseFloat(arguments[0]["ci"]);
            this.co = parseFloat(arguments[0]["co"]);
            this.xx = inverse(arguments[0]["xx"]);
            this.z = inverse(arguments[0]["z"]);
            this.rpar = inverse(arguments[0]["rpar"]);
            this.ipar = parseFloat(arguments[0]["ipar"]);
            this.nmode = arguments[0]["nmode"];
            this.nzcr = arguments[0]["nzcr"];
            this.auto0 = arguments[0]["auto0"];
            this.depu = parseBoolean(arguments[0]["depu"]);
            this.dept = parseBoolean(arguments[0]["dept"]);
            this.lab = arguments[0]["lab"];
            if (!ok) {
                break;
            }
            var label = this.lab;
            this.function_name = stripblanks(this.function_name);
            this.xx = this.xx.slice();
            this.z = this.z.slice();
            this.rpar = this.rpar.slice();
            this.ipar = int(this.ipar.slice());
            this.i = int(this.i.slice());
            this.o = int(this.o.slice());
            this.ci = int(this.ci.slice());
            this.co = int(this.co.slice());
            this.funtyp = int(this.funtyp);
            if (this.funtyp<0) {
                message("function type cannot be negative");
                throw "user error";
                var ok = false;
            }
            if ([[this.ci],[this.co]].length!=0) {
                if (max([[this.ci],[this.co]])>1) {
                    message("vector event links not supported");
                    throw "user error";
                    var ok = false;
                }
            }
            this.depu = stripblanks(this.depu);
            if (part(this.depu,1)=="y") {
                this.depu = true;
            } else {
                this.depu = false;
            }
            this.dept = stripblanks(this.dept);
            if (part(this.dept,1)=="y") {
                this.dept = true;
            } else {
                this.dept = false;
            }
            var dep_ut = [this.depu,this.dept];
            if (ok) {
                var tmpvar0 = check_io(this.model,this.graphics,this.i,this.o,this.ci,this.co);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                if (this.funtyp==3) {
                    var needcompile = 4;
                }
                this.model.sim = list(new ScilabDouble([this.function_name]), new ScilabDouble([this.funtyp]));
                this.model.state = new ScilabDouble(this.xx);
                this.model.dstate = new ScilabDouble(this.z);
                this.model.rpar = new ScilabDouble(this.rpar);
                this.model.ipar = new ScilabDouble([this.ipar]);
                this.model.firing = new ScilabDouble([this.auto0]);
                this.model.nzcross = new ScilabDouble([this.nzcr]);
                this.model.nmode = new ScilabDouble([this.nmode]);
                this.model.dep_ut = new ScilabBoolean(dep_ut);
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        needcompile = resume(needcompile)
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/generic_block3.sci" */
function generic_block3() {
    generic_block3.prototype.define = function generic_block3() {
        this.model = scicos_model();
        this.function_name = "sinblk";
        this.funtyp = 4;
        this.model.sim = list(new ScilabString([this.function_name]), new ScilabDouble([this.funtyp]));
        this.model.in = new ScilabDouble([1]);
        this.model.in2 = new ScilabDouble([1]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.out2 = new ScilabDouble([1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        var label = [[this.function_name],[sci2exp(this.funtyp)],[sci2exp([this.model.in,this.model.in2])],[sci2exp(this.model.intyp)],[sci2exp([this.model.out,this.model.out2]),sci2exp(this.model.outtyp)],[sci2exp(this.model.evtin)],[sci2exp(this.model.evtout)],[sci2exp(this.model.state)],[sci2exp(this.model.dstate)],[sci2exp(this.model.odstate)],[sci2exp(this.model.rpar)],[sci2exp(this.model.ipar)],[sci2exp(this.model.opar)],[sci2exp(this.model.nmode)],[sci2exp(this.model.nzcross)],[sci2exp(this.model.firing)],["y"],["n"]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"generic_block3\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([4,2]),this.model,new ScilabDouble(label),this.gr_i);
        return new BasicBlock(this.x);
    }
    generic_block3.prototype.details = function generic_block3() {
        return this.x;
    }
    generic_block3.prototype.get = function generic_block3() {
        var options = {
            function_name:["Simulation function",this.function_name],
            funtyp:["Function type (0,1,2,..)",this.funtyp],
            in1:["Input ports sizes",this.in1],
            it:["Input ports type",this.it],
            out:["Output port sizes",this.out],
            ot:["Output ports type",this.ot],
            ci:["Input event ports sizes",this.ci],
            co:["Output events ports sizes",this.co],
            xx:["Initial continuous state",this.xx],
            z:["Initial discrete state",this.z],
            oz:["Initial object state",this.oz],
            rpar:["Real parameters vector",this.rpar],
            ipar:["Integer parameters vector",this.ipar],
            opar:["Object parameters list",this.opar],
            nmode:["Number of modes",this.nmode],
            nzcr:["Number of zero crossings",this.nzcr],
            auto0:["Initial firing vector (<0 for no firing)",this.auto0],
            depu:["Direct feedthrough (y or n)",this.depu],
            dept:["Time dependence (y or n)",this.dept],
        }
        return options;
    }
    generic_block3.prototype.set = function generic_block3() {
        var label = this.graphics.exprs;
        if (size(label,"*")==14) {
            label[9-1] = [];
        }
        while (true) {
            var ok = true;
            this.function_name = arguments[0]["function_name"];
            this.funtyp = parseFloat(arguments[0]["funtyp"]);
            this.in1 = arguments[0]["in1"];
            this.it = arguments[0]["it"];
            this.out = arguments[0]["out"];
            this.ot = arguments[0]["ot"];
            this.ci = parseFloat(arguments[0]["ci"]);
            this.co = parseFloat(arguments[0]["co"]);
            this.xx = inverse(arguments[0]["xx"]);
            this.z = inverse(arguments[0]["z"]);
            this.oz = arguments[0]["oz"];
            this.rpar = inverse(arguments[0]["rpar"]);
            this.ipar = parseFloat(arguments[0]["ipar"]);
            this.opar = arguments[0]["opar"];
            this.nmode = arguments[0]["nmode"];
            this.nzcr = arguments[0]["nzcr"];
            this.auto0 = arguments[0]["auto0"];
            this.depu = parseBoolean(arguments[0]["depu"]);
            this.dept = parseBoolean(arguments[0]["dept"]);
            this.lab = arguments[0]["lab"];
            if (!ok) {
                break;
            }
            var label = this.lab;
            this.function_name = stripblanks(this.function_name);
            this.xx = this.xx.slice();
            this.z = this.z.slice();
            this.rpar = this.rpar.slice();
            this.ipar = int(this.ipar.slice());
            this.ci = int(this.ci.slice());
            this.co = int(this.co.slice());
            this.funtyp = this.funtyp;
            if (this.funtyp<0) {
                message("function type cannot be negative");
                throw "user error";
                var ok = false;
            }
            if ([[this.ci],[this.co]].length!=0) {
                if (max([[this.ci],[this.co]])>1) {
                    message("vector event links not supported");
                    throw "user error";
                    var ok = false;
                }
            }
            if (this.type[this.opar-1]!=15) {
                message("object parameter must be a list");
                throw "user error";
                var ok = false;
            }
            if (this.type[this.oz-1]!=15) {
                message("discrete object state must be a list");
                throw "user error";
                var ok = false;
            }
            this.depu = stripblanks(this.depu);
            if (part(this.depu,1)=="y") {
                this.depu = true;
            } else {
                this.depu = false;
            }
            this.dept = stripblanks(this.dept);
            if (part(this.dept,1)=="y") {
                this.dept = true;
            } else {
                this.dept = false;
            }
            var dep_ut = [this.depu,this.dept];
            if (ok) {
                var tmpvar0 = set_io(this.model,this.graphics,list(this.in1,this.it),list(this.out,this.ot),this.ci,this.co);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                if (this.funtyp==3) {
                    var needcompile = 4;
                }
                this.model.sim = list(new ScilabDouble([this.function_name]), new ScilabDouble([this.funtyp]));
                this.model.state = new ScilabDouble(this.xx);
                this.model.dstate = new ScilabDouble(this.z);
                this.model.odstate = new ScilabDouble([this.oz]);
                this.model.rpar = new ScilabDouble(this.rpar);
                this.model.ipar = new ScilabDouble([this.ipar]);
                this.model.opar = new ScilabDouble([this.opar]);
                this.model.firing = new ScilabDouble([this.auto0]);
                this.model.nzcross = new ScilabDouble([this.nzcr]);
                this.model.nmode = new ScilabDouble([this.nmode]);
                this.model.dep_ut = new ScilabBoolean(dep_ut);
                this.graphics.exprs = new ScilabDouble([label]);
                break;
            }
        }
        needcompile = resume(needcompile)
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/scifunc_block.sci" */
function scifunc_block() {
    scifunc_block.prototype.define = function scifunc_block() {
        var in1 = 1;
        var out = 1;
        var clkin = [];
        var clkout = [];
        var x0 = [];
        var z0 = [];
        var typ = "c";
        var auto = [];
        this.rpar = [];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["scifunc"]), new ScilabDouble([3]));
        this.model.in = new ScilabDouble([in1]);
        this.model.out = new ScilabDouble([out]);
        this.model.evtin = new ScilabDouble(clkin);
        this.model.evtout = new ScilabDouble(clkout);
        this.model.state = new ScilabDouble(x0);
        this.model.dstate = new ScilabDouble(z0);
        this.model.rpar = new ScilabDouble(this.rpar);
        this.model.ipar = new ScilabDouble([0]);
        this.model.opar = list();
        this.model.blocktype = new ScilabString([typ]);
        this.model.firing = new ScilabDouble(auto);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = list([[sci2exp(in1)],[sci2exp(out)],[sci2exp(clkin)],[sci2exp(clkout)],[strcat(sci2exp(x0))],[strcat(sci2exp(z0))],[strcat(sci2exp(this.rpar))],[sci2exp(auto)]],list("y1=sin(u1)"," "," ","y1=sin(u1)"," "," "," "));
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"scifunc_block\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,this.exprs,this.gr_i);
        return new BasicBlock(this.x);
    }
    scifunc_block.prototype.details = function scifunc_block() {
        return this.x;
    }
    scifunc_block.prototype.get = function scifunc_block() {
        var options = {
            i:["input ports sizes",this.i],
            o:["output port sizes",this.o],
            ci:["input event ports sizes",this.ci],
            co:["output events ports sizes",this.co],
            xx:["initial continuous state",this.xx],
            z:["initial discrete state",this.z],
            rpar:["System parameters vector",this.rpar],
            auto0:["initial firing vector (<0 for no firing)",this.auto0],
            deptime:["is block always active (0:no, 1:yes)",this.deptime],
        }
        return options;
    }
    scifunc_block.prototype.set = function scifunc_block() {
        var needcompile = 0;
        this.exprs = this.graphics.exprs;
        if (size(this.exprs[1-1],"*")==8) {
            this.exprs[1-1][9-1] = "0";
        }
        while (true) {
            var ok = true;
            this.i = parseFloat(arguments[0]["i"]);
            this.o = parseFloat(arguments[0]["o"]);
            this.ci = parseFloat(arguments[0]["ci"]);
            this.co = parseFloat(arguments[0]["co"]);
            this.xx = inverse(arguments[0]["xx"]);
            this.z = inverse(arguments[0]["z"]);
            this.rpar = inverse(arguments[0]["rpar"]);
            this.auto0 = arguments[0]["auto0"];
            this.deptime = arguments[0]["deptime"];
            this.lab = arguments[0]["lab"];
            if (!ok) {
                break;
            }
            this.exprs[1-1] = this.lab;
            this.xx = this.xx.slice();
            this.z = this.z.slice();
            this.rpar = this.rpar.slice();
            var nrp = prod(size(this.rpar));
            this.i = int(this.i.slice());
            var ni = size(this.i,1);
            this.o = int(this.o.slice());
            var no = size(this.o,1);
            this.ci = int(this.ci.slice());
            var nci = size(this.ci,1);
            this.co = int(this.co.slice());
            var nco = size(this.co,1);
            var tmpvar0 = genfunc1(this.exprs[2-1],this.i,this.o,nci,nco,size(this.xx,1),size(this.z,1),nrp,"c");
            var ok = tmpvar0[0];
            var tt = tmpvar0[1];
            var dep_ut = tmpvar0[2];
            dep_ut[2-1] = (1==this.deptime);
            if (!ok) {
                break;
            }
            var tmpvar1 = check_io(this.model,this.graphics,this.i,this.o,this.ci,this.co);
            this.model = tmpvar1[0];
            this.graphics = tmpvar1[1];
            var ok = tmpvar1[2];
            if (ok) {
                var auto = this.auto0;
                this.model.state = new ScilabDouble(this.xx);
                this.model.dstate = new ScilabDouble(this.z);
                this.model.rpar = new ScilabDouble(this.rpar);
                if (this.model.ipar!=0) {
                    this.model.opar = new ScilabDouble([this.model.ipar]);
                    this.model.ipar = new ScilabDouble([0]);
                }
                if (or(this.model.opar!=tt)) {
                    var needcompile = 4;
                }
                this.model.opar = new ScilabDouble([tt]);
                this.model.firing = new ScilabDouble([auto]);
                this.model.dep_ut = new ScilabDouble([dep_ut]);
                this.x.model = this.model;
                this.exprs[2-1] = tt;
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                break;
            }
        }
        needcompile = resume(needcompile)
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Misc/scifunc_block_m.sci" */
function scifunc_block_m() {
    scifunc_block_m.prototype.define = function scifunc_block_m() {
        var in1 = 1;
        var out = 1;
        var clkin = [];
        var clkout = [];
        var x0 = [];
        var z0 = [];
        var typ = "c";
        var auto = [];
        this.rpar = [];
        var it = 1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["scifunc"]), new ScilabDouble([3]));
        this.model.in = new ScilabDouble([in1]);
        this.model.in2 = new ScilabDouble([in1]);
        this.model.intyp = new ScilabDouble([it]);
        this.model.out = new ScilabDouble([out]);
        this.model.out2 = new ScilabDouble([out]);
        this.model.outtyp = new ScilabDouble([it]);
        this.model.evtin = new ScilabDouble(clkin);
        this.model.evtout = new ScilabDouble(clkout);
        this.model.state = new ScilabDouble(x0);
        this.model.dstate = new ScilabDouble(z0);
        this.model.rpar = new ScilabDouble(this.rpar);
        this.model.ipar = new ScilabDouble([0]);
        this.model.opar = list();
        this.model.blocktype = new ScilabString([typ]);
        this.model.firing = new ScilabDouble(auto);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = list([[sci2exp([in1,in1])],[sci2exp([out,out])],[sci2exp(clkin)],[sci2exp(clkout)],[strcat(sci2exp(x0))],[strcat(sci2exp(z0))],[strcat(sci2exp(this.rpar))],[sci2exp(auto)],[sci2exp(0)]],list("y1=sin(u1)"," "," ","y1=sin(u1)"," "," "," "));
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"scifunc_block_m\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([4,2]),this.model,this.exprs,this.gr_i);
        return new BasicBlock(this.x);
    }
    scifunc_block_m.prototype.details = function scifunc_block_m() {
        return this.x;
    }
    scifunc_block_m.prototype.get = function scifunc_block_m() {
        var options = {
            i:["input ports sizes",this.i],
            o:["output port sizes",this.o],
            ci:["input event ports sizes",this.ci],
            co:["output events ports sizes",this.co],
            xx:["initial continuous state",this.xx],
            z:["initial discrete state",this.z],
            rpar:["System parameters vector",this.rpar],
            auto0:["initial firing vector (<0 for no firing)",this.auto0],
            deptime:["is block always active (0:no, 1:yes)",this.deptime],
        }
        return options;
    }
    scifunc_block_m.prototype.set = function scifunc_block_m() {
        var needcompile = 0;
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.i = arguments[0]["i"];
            this.o = arguments[0]["o"];
            this.ci = parseFloat(arguments[0]["ci"]);
            this.co = parseFloat(arguments[0]["co"]);
            this.xx = inverse(arguments[0]["xx"]);
            this.z = inverse(arguments[0]["z"]);
            this.rpar = inverse(arguments[0]["rpar"]);
            this.auto0 = arguments[0]["auto0"];
            this.deptime = arguments[0]["deptime"];
            this.lab = arguments[0]["lab"];
            if (!ok) {
                break;
            }
            this.exprs[1-1] = this.lab;
            this.xx = this.xx.slice();
            this.z = this.z.slice();
            this.rpar = this.rpar.slice();
            var it = ones(1,size(this.i,1));
            var ot = ones(1,size(this.o,1));
            var nrp = prod(size(this.rpar));
            var ni = size(this.i,1);
            var no = size(this.o,1);
            this.ci = int(this.ci.slice());
            var nci = size(this.ci,1);
            this.co = int(this.co.slice());
            var nco = size(this.co,1);
            var tmpvar0 = genfunc2(this.exprs[2-1],this.i,this.o,nci,nco,size(this.xx,1),size(this.z,1),nrp,"c");
            var ok = tmpvar0[0];
            var tt = tmpvar0[1];
            var dep_ut = tmpvar0[2];
            dep_ut[2-1] = (1==this.deptime);
            if (!ok) {
                break;
            }
            var tmpvar1 = set_io(this.model,this.graphics,list(this.i,it),list(this.o,ot),this.ci,this.co);
            this.model = tmpvar1[0];
            this.graphics = tmpvar1[1];
            var ok = tmpvar1[2];
            if (ok) {
                var auto = this.auto0;
                this.model.state = new ScilabDouble(this.xx);
                this.model.dstate = new ScilabDouble(this.z);
                this.model.rpar = new ScilabDouble(this.rpar);
                if (this.model.ipar!=0) {
                    this.model.opar = new ScilabDouble([this.model.ipar]);
                    this.model.ipar = new ScilabDouble([0]);
                }
                if (or(this.model.opar!=tt)) {
                    var needcompile = 4;
                }
                this.model.opar = new ScilabDouble([tt]);
                this.model.firing = new ScilabDouble([auto]);
                this.model.dep_ut = new ScilabDouble([dep_ut]);
                this.x.model = this.model;
                this.exprs[2-1] = tt;
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                break;
            }
        }
        needcompile = resume(needcompile)
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/ABSBLK_f.sci" */
function ABSBLK_f() {
    ABSBLK_f.prototype.define = function ABSBLK_f() {
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["absblk"]), new ScilabDouble([1]));
        this.model.in = new ScilabDouble([-1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"ABSBLK_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble([]),this.gr_i);
        return new BasicBlock(this.x);
    }
    ABSBLK_f.prototype.details = function ABSBLK_f() {
        return this.x;
    }
    ABSBLK_f.prototype.get = function ABSBLK_f() {
        alert("parameters cannot be modified");
    }
    ABSBLK_f.prototype.set = function ABSBLK_f() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/ABS_VALUE.sci" */
function ABS_VALUE() {
    ABS_VALUE.prototype.define = function ABS_VALUE() {
        var nu = -1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["absolute_value"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([nu]);
        this.model.out = new ScilabDouble([nu]);
        this.model.nzcross = new ScilabDouble([nu]);
        this.model.nmode = new ScilabDouble([nu]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [string([1])];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"ABS_VALUE\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    ABS_VALUE.prototype.details = function ABS_VALUE() {
        return this.x;
    }
    ABS_VALUE.prototype.get = function ABS_VALUE() {
        var options = {
            zcr:["use zero_crossing (1: yes) (0:no)",this.zcr],
        }
        return options;
    }
    ABS_VALUE.prototype.set = function ABS_VALUE() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.zcr = arguments[0]["zcr"];
            if (!ok) {
                break;
            }
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            if (ok) {
                if (this.zcr!=0) {
                    this.model.nmode = new ScilabDouble([-1]);
                    this.model.nzcross = new ScilabDouble([-1]);
                } else {
                    this.model.nmode = new ScilabDouble([0]);
                    this.model.nzcross = new ScilabDouble([0]);
                }
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/COSBLK_f.sci" */
function COSBLK_f() {
    COSBLK_f.prototype.define = function COSBLK_f() {
        var in1 = 1;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["cosblk"]);
        this.model.in = new ScilabDouble([-1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"COSBLK_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble([]),this.gr_i);
        return new BasicBlock(this.x);
    }
    COSBLK_f.prototype.details = function COSBLK_f() {
        return this.x;
    }
    COSBLK_f.prototype.get = function COSBLK_f() {
        alert("parameters cannot be modified");
    }
    COSBLK_f.prototype.set = function COSBLK_f() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/DLRADAPT_f.sci" */
function DLRADAPT_f() {
    DLRADAPT_f.prototype.define = function DLRADAPT_f() {
        this.p = [[0],[1]];
        this.rn = [];
        this.rd = [[math.complex(0.2,0.8),math.complex(0.2,-0.8)],[math.complex(0.3,0.7),math.complex(0.3,-0.7)]];
        this.g = [[1],[1]];
        this.last_u = [];
        this.last_y = [[0],[0]];
        this.model = scicos_model();
        this.model.sim = new ScilabString(["dlradp"]);
        this.model.in = new ScilabDouble([1],[1]);
        this.model.out = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble([this.last_u],[this.last_y]);
        this.model.rpar = new ScilabDouble([this.p.slice()],[real(this.rn.slice())],[imag(this.rn.slice())],[real(this.rd.slice())],[imag(this.rd.slice())],[this.g.slice()]);
        this.model.ipar = new ScilabDouble([0],[2],[2]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[sci2exp(this.p)],[sci2exp(this.rn)],[sci2exp(this.rd,0)],[sci2exp(this.g)],[sci2exp(this.last_u)],[sci2exp(this.last_y)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"DLRADAPT_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    DLRADAPT_f.prototype.details = function DLRADAPT_f() {
        return this.x;
    }
    DLRADAPT_f.prototype.get = function DLRADAPT_f() {
        var options = {
            p:["Vector of p mesh points",this.p.toString().replace(/,/g," ")],
            rn:["Numerator roots (one line for each mesh)",this.rn],
            rd:["Denominator roots (one line for each mesh)",this.rd.toString().replace(/,/g," ")],
            g:["Vector of gain at mesh points",this.g.toString().replace(/,/g," ")],
            last_u:["past inputs (Num degree values)",this.last_u],
            last_y:["past outputs (Den degree values)",this.last_y.toString().replace(/,/g," ")],
        }
        return options;
    }
    DLRADAPT_f.prototype.set = function DLRADAPT_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.p = inverse(arguments[0]["p"]);
            this.rn = inverse(arguments[0]["rn"]);
            this.rd = inverse(arguments[0]["rd"]);
            this.g = inverse(arguments[0]["g"]);
            this.last_u = inverse(arguments[0]["last_u"]);
            this.last_y = inverse(arguments[0]["last_y"]);
            if (!ok) {
                break;
            }
            var m = size(this.rn,2);
            var tmpvar0 = size(this.rd);
            var npt = tmpvar0[0];
            var n = tmpvar0[1];
            if (m>=n) {
                message("Transfer must be strictly proper");
                throw "user error";
            } else if (size(this.rn,1)!=0&&size(this.rn,1)!=size(this.p,"*")) {
                message("Numerator roots matrix row size\'s is incorrect");
                throw "user error";
            } else {
                var rpar = [[this.p.slice()],[real(this.rn.slice())],[imag(this.rn.slice())],[real(this.rd.slice())],[imag(this.rd.slice())],[this.g.slice()]];
                var ipar = [[m],[n],[npt]];
                this.model.dstate = new ScilabDouble([this.last_u.slice()],[this.last_y.slice()]);
                this.model.rpar = new ScilabDouble(rpar);
                this.model.ipar = new ScilabDouble(ipar);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/EXPBLK_f.sci" */
function EXPBLK_f() {
    EXPBLK_f.prototype.define = function EXPBLK_f() {
        var in1 = 1;
        this.a = math.E;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["expblk"]);
        this.model.in = new ScilabDouble([-1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.rpar = new ScilabDouble([this.a]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = ["%e"];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"EXPBLK_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    EXPBLK_f.prototype.details = function EXPBLK_f() {
        return this.x;
    }
    EXPBLK_f.prototype.get = function EXPBLK_f() {
        var options = {
            a:["a (>0)",this.a],
        }
        return options;
    }
    EXPBLK_f.prototype.set = function EXPBLK_f() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")==2) {
            this.exprs = this.exprs[2-1];
        }
        while (true) {
            var ok = true;
            this.a = parseFloat(arguments[0]["a"]);
            if (!ok) {
                break;
            }
            if (or(this.a<=0)) {
                message("a^u : a must be positive");
                throw "user error";
            } else {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.rpar = new ScilabDouble([this.a]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/EXPBLK_m.sci" */
function EXPBLK_m() {
    EXPBLK_m.prototype.define = function EXPBLK_m() {
        var in1 = 1;
        this.a = math.E;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["expblk_m"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([this.a]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = ["%e"];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"EXPBLK_m\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    EXPBLK_m.prototype.details = function EXPBLK_m() {
        return this.x;
    }
    EXPBLK_m.prototype.get = function EXPBLK_m() {
        var options = {
            a:["a (>0)",this.a],
        }
        return options;
    }
    EXPBLK_m.prototype.set = function EXPBLK_m() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")==2) {
            this.exprs = this.exprs[2-1];
        }
        while (true) {
            var ok = true;
            this.a = parseFloat(arguments[0]["a"]);
            if (!ok) {
                break;
            }
            if (or(this.a<=0)) {
                message("a^u : a must be positive");
                throw "user error";
            } else {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.rpar = new ScilabDouble([this.a]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/FSV_f.sci" */
function FSV_f() {
    FSV_f.prototype.define = function FSV_f() {
        var in1 = 1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["fsv"]), new ScilabDouble([1]));
        this.model.in = new ScilabDouble([in1]);
        this.model.out = new ScilabDouble([in1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = " ";
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"FSV_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    FSV_f.prototype.details = function FSV_f() {
        return this.x;
    }
    FSV_f.prototype.get = function FSV_f() {
        alert("parameters cannot be modified");
    }
    FSV_f.prototype.set = function FSV_f() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/INTRP2BLK_f.sci" */
function INTRP2BLK_f() {
    INTRP2BLK_f.prototype.define = function INTRP2BLK_f() {
        this.a = [[0],[1]];
        this.b = [[0],[1]];
        this.c = [[0,1],[1,2]];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["intrp2"]), new ScilabDouble([1]));
        this.model.in = new ScilabDouble([1],[1]);
        this.model.out = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([this.a],[this.b],[this.c.slice()]);
        this.model.ipar = new ScilabDouble([2],[2]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[strcat(sci2exp(this.a))],[strcat(sci2exp(this.b))],[strcat(sci2exp(this.c,0))]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"INTRP2BLK_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    INTRP2BLK_f.prototype.details = function INTRP2BLK_f() {
        return this.x;
    }
    INTRP2BLK_f.prototype.get = function INTRP2BLK_f() {
        var options = {
            a:["X coord.",this.a.toString().replace(/,/g," ")],
            b:["Y coord.",this.b.toString().replace(/,/g," ")],
            c:["Z values",this.c.toString().replace(/,/g," ")],
        }
        return options;
    }
    INTRP2BLK_f.prototype.set = function INTRP2BLK_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.a = inverse(arguments[0]["a"]);
            this.b = inverse(arguments[0]["b"]);
            this.c = inverse(arguments[0]["c"]);
            if (!ok) {
                break;
            }
            if (size(this.a,"*")!=size(this.c,"c")||size(this.b,"*")!=size(this.c,"r")) {
                message("incompatible dimension");
                throw "user error";
            } else if (min(this.a.slice(2-1,$)-this.a.slice(1-1,$-1))<=0||min(this.b.slice(2-1,$)-this.b.slice(1-1,$-1))<=0) {
                message("X and Y must be strictly increasing");
                throw "user error";
            } else {
                if (ok) {
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    this.model.rpar = new ScilabDouble([this.a.slice()],[this.b.slice()],[this.c.slice()]);
                    this.model.ipar = new ScilabDouble([size(this.a,"*")],[size(this.b,"*")]);
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/INTRPLBLK_f.sci" */
function INTRPLBLK_f() {
    INTRPLBLK_f.prototype.define = function INTRPLBLK_f() {
        this.a = [[0],[1]];
        this.b = [[0],[1]];
        this.model = scicos_model();
        this.model.sim = new ScilabString(["intrpl"]);
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([this.a],[this.b]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[strcat(sci2exp(this.a))],[strcat(sci2exp(this.b))]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"INTRPLBLK_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    INTRPLBLK_f.prototype.details = function INTRPLBLK_f() {
        return this.x;
    }
    INTRPLBLK_f.prototype.get = function INTRPLBLK_f() {
        var options = {
            a:["X coord.",this.a.toString().replace(/,/g," ")],
            b:["Y coord.",this.b.toString().replace(/,/g," ")],
        }
        return options;
    }
    INTRPLBLK_f.prototype.set = function INTRPLBLK_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.a = inverse(arguments[0]["a"]);
            this.b = inverse(arguments[0]["b"]);
            if (!ok) {
                break;
            }
            if (size(this.a,"*")!=size(this.b,"*")) {
                message("X and Y must have the same size");
                throw "user error";
            } else if (min(this.a.slice(2-1,$)-this.a.slice(1-1,$-1))<=0) {
                message("X must be strictly increasing");
                throw "user error";
            } else {
                if (ok) {
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    this.model.rpar = new ScilabDouble([this.a.slice()],[this.b.slice()]);
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/INVBLK.sci" */
function INVBLK() {
    INVBLK.prototype.define = function INVBLK() {
        var in1 = -1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["invblk4"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([in1]);
        this.model.out = new ScilabDouble([in1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = " ";
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"INVBLK\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    INVBLK.prototype.details = function INVBLK() {
        return this.x;
    }
    INVBLK.prototype.get = function INVBLK() {
        alert("parameters cannot be modified");
    }
    INVBLK.prototype.set = function INVBLK() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/INVBLK_f.sci" */
function INVBLK_f() {
    INVBLK_f.prototype.define = function INVBLK_f() {
        var in1 = -1;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["invblk"]);
        this.model.in = new ScilabDouble([in1]);
        this.model.out = new ScilabDouble([in1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = " ";
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"INVBLK_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    INVBLK_f.prototype.details = function INVBLK_f() {
        return this.x;
    }
    INVBLK_f.prototype.get = function INVBLK_f() {
        alert("parameters cannot be modified");
    }
    INVBLK_f.prototype.set = function INVBLK_f() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/LOGBLK_f.sci" */
function LOGBLK_f() {
    LOGBLK_f.prototype.define = function LOGBLK_f() {
        var in1 = 1;
        this.a = math.E;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["logblk"]);
        this.model.in = new ScilabDouble([-1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.rpar = new ScilabDouble([this.a]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = "%e";
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"LOGBLK_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    LOGBLK_f.prototype.details = function LOGBLK_f() {
        return this.x;
    }
    LOGBLK_f.prototype.get = function LOGBLK_f() {
        var options = {
            a:["Basis (>1)",this.a],
        }
        return options;
    }
    LOGBLK_f.prototype.set = function LOGBLK_f() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")==2) {
            this.exprs = this.exprs[2-1];
        }
        while (true) {
            var ok = true;
            this.a = parseFloat(arguments[0]["a"]);
            if (!ok) {
                break;
            }
            if (this.a<=1) {
                message("Basis must be larger than 1");
                throw "user error";
            } else {
                if (ok) {
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    this.model.rpar = new ScilabDouble([this.a]);
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/LOOKUP2D.sci" */
function LOOKUP2D() {
    LOOKUP2D.prototype.define = function LOOKUP2D() {
        this.model = scicos_model();
        this.xx = [1:4];
        this.yy = [1:3];
        this.zz = [[4,5,6],[16,19,20],[10,18,23],[6,3,-1]];
        this.Method = 1;
        var Graf = "n";
        var Nx = length(this.xx);
        var Ny = length(this.yy);
        this.model.sim = list(new ScilabString(["lookup2d"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([1],[1]);
        this.model.out = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([this.xx.slice()],[this.yy.slice()],[this.zz.slice()]);
        this.model.ipar = new ScilabDouble([Nx],[Ny],[this.Method]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = list(strcat(sci2exp(this.xx)),strcat(sci2exp(this.yy)),strcat(sci2exp(this.zz)),sci2exp(this.Method),Graf);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"LOOKUP2D\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2.5,2]),this.model,this.exprs,this.gr_i);
        return new BasicBlock(this.x);
    }
    LOOKUP2D.prototype.details = function LOOKUP2D() {
        return this.x;
    }
    LOOKUP2D.prototype.get = function LOOKUP2D() {
        var options = {
            xx:["Row index input values",this.xx],
            yy:["Column index input values",this.yy],
            zz:["Table data",this.zz.toString().replace(/,/g," ")],
            Method:["Lookup method(1..5)",this.Method],
            graf:["Launch graphic window(y/n)?",this.graf],
        }
        return options;
    }
    LOOKUP2D.prototype.set = function LOOKUP2D() {
        this.exprs = this.graphics.exprs;
        var ok = false;
        var SaveExit = false;
        while (true) {
            var Ask_again = false;
            var ok = true;
            this.xx = inverse(arguments[0]["xx"]);
            this.yy = inverse(arguments[0]["yy"]);
            this.zz = inverse(arguments[0]["zz"]);
            this.Method = parseFloat(arguments[0]["Method"]);
            this.graf = arguments[0]["graf"];
            if (!ok) {
                break;
            }
            var mtd = int(this.Method);
            if (mtd<1) {
                var mtd = 1;
            }
            if (mtd>6) {
                var mtd = 6;
            }
            if (this.graf!="y"&&this.graf!="Y") {
                this.graf = "n";
            }
            this.exprs[5-1] = "n";
            this.exprs[4-1] = sci2exp(mtd);
            var METHOD = getmethod(mtd);
            if (!Ask_again) {
                this.xx = this.xx.slice();
                this.yy = this.yy.slice();
                var tmpvar0 = size(this.xx);
                var nx = tmpvar0[0];
                var mx = tmpvar0[1];
                var tmpvar1 = size(this.yy);
                var ny = tmpvar1[0];
                var my = tmpvar1[1];
                var tmpvar2 = size(this.zz);
                var nz = tmpvar2[0];
                var mz = tmpvar2[1];
                if (((nx<=1)||(ny<=1))) {
                    x_message("input row/column data size should be greater than one");
                    var Ask_again = true;
                }
                if (!((nx==nz)&&(ny==mz))) {
                    x_message("incompatible size of x and y");
                    var Ask_again = true;
                }
                var tmpvar3 = test_increasing(this.xx);
                var ok = tmpvar3[0];
                if ((!ok)) {
                    x_message("Row input values must be monotonically increasing");
                    var Ask_again = true;
                }
                var tmpvar4 = test_increasing(this.yy);
                var ok = tmpvar4[0];
                if ((!ok)) {
                    x_message("Column input values must be monotonically increasing");
                    var Ask_again = true;
                }
            }
            if (!Ask_again) {
                if ((this.graf=="Y"||this.graf=="y")) {
                    var gh = gcf();
                    var curwin = gh.figure_id;
                    var save_curwin = curwin;
                    var gh2 = scf();
                    var curwin = max(winsid())+1;
                    plot3d(this.xx,this.yy,this.zz,35,45,"X@Y@Z",[5,2,4]);
                    var curwin = save_curwin;
                    gh.figure_id = curwin;
                }
                this.model.rpar = new ScilabDouble([this.xx.slice()],[this.yy.slice()],[this.zz.slice()]);
                this.model.ipar = new ScilabDouble([nx],[ny],[mtd]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.model = this.model;
                this.x.graphics = this.graphics;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/LOOKUP_c.sci" */
function LOOKUP_c() {
    LOOKUP_c.prototype.define = function LOOKUP_c() {
        this.model = scicos_model();
        this.xx = [[-1],[0.5],[1],[1.5],[2.5]];
        this.yy = [[-6],[-1],[-3],[3],[-4]];
        var N = length(this.xx);
        this.Method = 1;
        var Graf = "n";
        this.model.sim = list(new ScilabString(["lookup_c"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.outtyp = new ScilabDouble([-1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-2]);
        this.model.outtyp = new ScilabDouble([-1]);
        this.model.rpar = new ScilabDouble([this.xx.slice()],[this.yy.slice()]);
        this.model.ipar = new ScilabDouble([N],[this.Method],[0],[0]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.firing = new ScilabDouble([0]);
        this.exprs = [[sci2exp(this.Method)],[sci2exp(this.xx)],[sci2exp(this.yy)],[sci2exp(0)],[Graf]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"LOOKUP_c\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    LOOKUP_c.prototype.details = function LOOKUP_c() {
        return this.x;
    }
    LOOKUP_c.prototype.get = function LOOKUP_c() {
        var options = {
            Method:["Spline Interpolation method (0..9)",this.Method],
            xx:["x",this.xx.toString().replace(/,/g," ")],
            yy:["y",this.yy.toString().replace(/,/g," ")],
            extrapo:["Extrapolate method (0,1)",this.extrapo],
            graf:["Launch graphic window(y/n)?",this.graf],
        }
        return options;
    }
    LOOKUP_c.prototype.set = function LOOKUP_c() {
        this.exprs = this.graphics.exprs;
        var ok = false;
        var SaveExit = false;
        while (true) {
            var Ask_again = false;
            var ok = true;
            this.Method = parseFloat(arguments[0]["Method"]);
            this.xx = inverse(arguments[0]["xx"]);
            this.yy = inverse(arguments[0]["yy"]);
            this.extrapo = parseFloat(arguments[0]["extrapo"]);
            this.graf = arguments[0]["graf"];
            if (!ok) {
                break;
            }
            var PeriodicOption = "n";
            if (PeriodicOption=="y"||PeriodicOption=="Y") {
                var PO = 1;
            } else {
                var PO = 0;
            }
            var mtd = int(this.Method);
            if (mtd<0) {
                var mtd = 0;
            }
            if (mtd>9) {
                var mtd = 9;
            }
            var METHOD = getmethod(mtd);
            this.extrapo = int(this.extrapo);
            if (this.extrapo<0) {
                this.extrapo = 0;
            }
            if (this.extrapo>1) {
                this.extrapo = 1;
            }
            if (!Ask_again) {
                this.xx = this.xx.slice();
                this.yy = this.yy.slice();
                var tmpvar0 = size(this.xx);
                var nx = tmpvar0[0];
                var mx = tmpvar0[1];
                var tmpvar1 = size(this.yy);
                var ny = tmpvar1[0];
                var my = tmpvar1[1];
                if (!((nx==ny)&&(mx==my))) {
                    x_message("incompatible size of x and y");
                    var Ask_again = true;
                }
            }
            if (!Ask_again) {
                this.xy = [this.xx,this.yy];
                var tmpvar2 = cleandata(this.xy);
                this.xy = tmpvar2[0];
                var N = size(this.xy,"r");
                this.exprs[5-1] = "n";
                if (this.graf=="y"||this.graf=="Y") {
                    var ipar = [[N],[mtd],[PO],[this.extrapo]];
                    var rpar = [];
                    if (!exists("curwin")) {
                        var gh = gcf();
                        this.curwin = gh.figure_id;
                    }
                    var save_curwin = this.curwin;
                    this.curwin = max(winsid())+1;
                    var tmpvar3 = poke_point(this.xy,ipar,rpar);
                    var orpar = tmpvar3[0];
                    var oipar = tmpvar3[1];
                    var ok = tmpvar3[2];
                    this.curwin = save_curwin;
                    if (!ok) {
                        break;
                    }
                    var N2 = oipar[1-1];
                    var xy2 = [orpar.slice(1-1,N2),orpar.slice(N2+1-1,2*N2)];
                    var New_methhod = oipar[2-1];
                    var DChange = false;
                    var METHOD = getmethod(New_methhod);
                    if (or(this.xy.slice()[1-1]!=xy2.slice()[1-1])) {
                        var DChange = true;
                    }
                    if (or(this.xy.slice(1-1,N-1)[2-1]!=xy2.slice(1-1,N2-1)[2-1])) {
                        var DChange = true;
                    }
                    if ((this.xy[N-1][2-1]!=xy2[N2-1][2-1]&&(METHOD!="periodic"))) {
                        var DChange = true;
                    }
                    if (DChange) {
                        this.exprs[2-1] = strcat(sci2exp(xy2.slice()[1-1]));
                        this.exprs[3-1] = strcat(sci2exp(xy2.slice()[2-1]));
                    }
                    this.exprs[1-1] = sci2exp(New_methhod);
                    this.exprs[4-1] = sci2exp(oipar[4-1]);
                    if (oipar[3-1]==1) {
                        var perop = "y";
                    } else {
                        var perop = "n";
                    }
                    var SaveExit = true;
                } else {
                    var tmpvar4 = Do_Spline(N,mtd,this.xy.slice()[1-1],this.xy.slice()[2-1],this.xy[$-1][1-1],this.xy[1-1][1-1],0);
                    var Xdummy = tmpvar4[0];
                    var Ydummy = tmpvar4[1];
                    var orpar = tmpvar4[2];
                    if ((METHOD=="periodic")) {
                        this.xy[N-1][2-1] = this.xy[1-1][2-1];
                    }
                    if ((METHOD=="order 2"||METHOD=="not_a_knot"||METHOD=="periodic"||METHOD=="monotone"||METHOD=="fast"||METHOD=="clamped")) {
                        var orpar = [[this.xy.slice()[1-1]],[this.xy.slice()[2-1]],[orpar]];
                    } else {
                        if ((METHOD=="zero order-below"||METHOD=="linear"||METHOD=="zero order-above"||METHOD=="zero order-nearest")) {
                            var orpar = [[this.xy.slice()[1-1]],[this.xy.slice()[2-1]]];
                        }
                    }
                    this.exprs[1-1] = sci2exp(mtd);
                    var oipar = [[N],[mtd],[PO],[this.extrapo]];
                    var SaveExit = true;
                }
            }
            if ((SaveExit)) {
                var xp = find(orpar.slice(1-1,oipar[1-1])>=0);
                if ((xp.length!=0)) {
                    this.model.firing = new ScilabDouble([orpar[xp[1-1]-1]]);
                } else {
                    this.model.firing = new ScilabDouble([-1]);
                }
                this.model.rpar = new ScilabDouble(orpar);
                this.model.ipar = new ScilabDouble(oipar);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.model = this.model;
                this.x.graphics = this.graphics;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/LOOKUP_f.sci" */
function LOOKUP_f() {
    LOOKUP_f.prototype.define = function LOOKUP_f() {
        this.model = scicos_model();
        this.model.sim = new ScilabString(["lookup"]);
        this.model.in = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([-2],[-1],[1],[2],[-1],[1],[-1],[1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"LOOKUP_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble([]),this.gr_i);
        return new BasicBlock(this.x);
    }
    LOOKUP_f.prototype.details = function LOOKUP_f() {
        return this.x;
    }
    LOOKUP_f.prototype.get = function LOOKUP_f() {
        alert("parameters cannot be modified");
    }
    LOOKUP_f.prototype.set = function LOOKUP_f() {
        this.exprs = this.graphics.exprs;
        var rpar = this.model.rpar;
        var n = size(rpar,"*")/2;
        var xx = rpar.slice(1-1,n);
        var yy = rpar.slice(n+1-1,2*n);
        while (true) {
            [ln,fun]=where()
            if (!or(fun=="do_eval")) {
                var tmpvar0 = edit_curv(xx,yy,"axy");
                var xx = tmpvar0[0];
                var yy = tmpvar0[1];
                var ok = tmpvar0[2];
                var gc = tmpvar0[3];
            } else {
                var ok = true;
            }
            if (!ok) {
                break;
            }
            var n = size(xx,"*");
            if (or(xx.slice(2-1,n)-xx.slice(1-1,n-1)<=0)) {
                message("You have not defined a function");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                this.model.rpar = new ScilabDouble([xx.slice()],[yy.slice()]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/MAXMIN.sci" */
function MAXMIN() {
    MAXMIN.prototype.define = function MAXMIN() {
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["minmax"]), new ScilabDouble([4]));
        this.model.out = new ScilabDouble([1]);
        this.model.in = new ScilabDouble([-1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.model.ipar = new ScilabDouble([0]);
        this.exprs = [string(transpose([2,1,1]))];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MAXMIN\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString(this.exprs),this.gr_i);
        this.x.graphics.style = "MAXMIN;displayedLabel=MAX";
        return new BasicBlock(this.x);
    }
    MAXMIN.prototype.details = function MAXMIN() {
        return this.x;
    }
    MAXMIN.prototype.get = function MAXMIN() {
        var options = {
            mm:["Min (1) or Max (2) ",this.mm],
            nin:["Number of input vectors (1 or 2)",this.nin],
            zcr:["zero-crossing (1: yes, 0;no)",this.zcr],
        }
        return options;
    }
    MAXMIN.prototype.set = function MAXMIN() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.mm = parseFloat(arguments[0]["mm"]);
            this.nin = arguments[0]["nin"];
            this.zcr = parseFloat(arguments[0]["zcr"]);
            if (!ok) {
                break;
            }
            if (this.zcr!=0) {
                this.zcr = -1;
            }
            if (this.mm!=1) {
                this.mm = 2;
            }
            if (this.nin!=1&&this.nin!=2) {
                message("Wrong number of inputs, only 1 and 2 allowed");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                if (this.nin==1) {
                    var tmpvar0 = check_io(this.model,this.graphics,-1,1,[],[]);
                    this.model = tmpvar0[0];
                    this.graphics = tmpvar0[1];
                    var ok = tmpvar0[2];
                } else {
                    var tmpvar1 = check_io(this.model,this.graphics,[-1,-1],-1,[],[]);
                    this.model = tmpvar1[0];
                    this.graphics = tmpvar1[1];
                    var ok = tmpvar1[2];
                }
            }
            if (ok) {
                this.model.nzcross = new ScilabDouble([this.zcr]);
                if (this.nin==1) {
                    this.model.nmode = new ScilabDouble([abs(this.zcr)]);
                } else {
                    this.model.nmode = new ScilabDouble([this.zcr]);
                }
                this.model.ipar = new ScilabDouble([this.mm]);
                if (this.mm==1) {
                    var label = "MIN";
                } else {
                    var label = "MAX";
                }
                this.graphics.style = new ScilabString(["MAXMIN;displayedLabel="+label]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/MAX_f.sci" */
function MAX_f() {
    MAX_f.prototype.define = function MAX_f() {
        var in1 = -1;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["maxblk"]);
        this.model.in = new ScilabDouble([in1]);
        this.model.out = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble([0],[0]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = " ";
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MAX_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    MAX_f.prototype.details = function MAX_f() {
        return this.x;
    }
    MAX_f.prototype.get = function MAX_f() {
        alert("parameters cannot be modified");
    }
    MAX_f.prototype.set = function MAX_f() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/MIN_f.sci" */
function MIN_f() {
    MIN_f.prototype.define = function MIN_f() {
        var in1 = -1;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["minblk"]);
        this.model.in = new ScilabDouble([in1]);
        this.model.out = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble([0],[0]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = sci2exp(in1);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"MIN_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    MIN_f.prototype.details = function MIN_f() {
        return this.x;
    }
    MIN_f.prototype.get = function MIN_f() {
        alert("parameters cannot be modified");
    }
    MIN_f.prototype.set = function MIN_f() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/POWBLK_f.sci" */
function POWBLK_f() {
    POWBLK_f.prototype.define = function POWBLK_f() {
        var in1 = 1;
        this.a = 1.5;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["powblk"]);
        this.model.in = new ScilabDouble([-1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.rpar = new ScilabDouble([this.a]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = string(this.a);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"POWBLK_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    POWBLK_f.prototype.details = function POWBLK_f() {
        return this.x;
    }
    POWBLK_f.prototype.get = function POWBLK_f() {
        var options = {
            a:["to the power of",this.a],
        }
        return options;
    }
    POWBLK_f.prototype.set = function POWBLK_f() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")==2) {
            this.exprs = this.exprs[2-1];
        }
        while (true) {
            var ok = true;
            this.a = parseFloat(arguments[0]["a"]);
            if (!ok) {
                break;
            }
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            if (this.a==int(this.a)) {
                this.model.ipar = new ScilabDouble([this.a]);
                this.model.rpar = new ScilabDouble([]);
            } else {
                this.model.rpar = new ScilabDouble([this.a]);
                this.model.ipar = new ScilabDouble([]);
            }
            this.model.firing = new ScilabDouble([]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/PRODUCT.sci" */
function PRODUCT() {
    PRODUCT.prototype.define = function PRODUCT() {
        this.sgn = [[1],[-1]];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["product"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([-1],[-1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.ipar = new ScilabDouble(this.sgn);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = sci2exp(this.sgn);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"PRODUCT\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,3]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new Product(this.x);
    }
    PRODUCT.prototype.details = function PRODUCT() {
        return this.x;
    }
    PRODUCT.prototype.get = function PRODUCT() {
        var options = {
            sgn:["Number of inputs or sign vector",this.sgn.toString().replace(/,/g," ")],
        }
        return options;
    }
    PRODUCT.prototype.set = function PRODUCT() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.sgn = inverse(arguments[0]["sgn"]);
            if (!ok) {
                break;
            }
            this.sgn = this.sgn.slice();
            if (size(this.sgn,1)==1) {
                if (this.sgn<1) {
                    message("Number of inputs must be > 0");
                    throw "user error";
                    var ok = false;
                } else if (this.sgn==1) {
                    var in1 = -1;
                    this.sgn = [];
                    var nout = 1;
                } else {
                    var in1 = -ones(this.sgn,1);
                    this.sgn = ones(this.sgn,1);
                    var nout = -1;
                }
            } else {
                if (!and(abs(this.sgn)==1)) {
                    message("Signs can only be +1 or -1");
                    throw "user error";
                    var ok = false;
                } else {
                    var in1 = -ones(size(this.sgn,1),1);
                    var nout = -1;
                }
            }
            if (ok) {
                var tmpvar0 = check_io(this.model,this.graphics,in1,nout,[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.model.ipar = new ScilabDouble([this.sgn]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new Product(this.x);
    }
}
/* autogenerated from "macros/NonLinear/PROD_f.sci" */
function PROD_f() {
    PROD_f.prototype.define = function PROD_f() {
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["prod"]), new ScilabDouble([2]));
        this.model.in = new ScilabDouble([-1],[-1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.x = new standard_define(new ScilabDouble([1,1]),this.model,new ScilabDouble([]),[]);
        return new BasicBlock(this.x);
    }
    PROD_f.prototype.details = function PROD_f() {
        return this.x;
    }
    PROD_f.prototype.get = function PROD_f() {
        alert("parameters cannot be modified");
    }
    PROD_f.prototype.set = function PROD_f() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/QUANT_f.sci" */
function QUANT_f() {
    QUANT_f.prototype.define = function QUANT_f() {
        this.pas = 0.1;
        this.meth = 1;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["qzrnd"]);
        this.model.in = new ScilabDouble([-1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.rpar = new ScilabDouble([this.pas]);
        this.model.ipar = new ScilabDouble([this.meth]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[string(this.pas)],[string(this.meth)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"QUANT_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    QUANT_f.prototype.details = function QUANT_f() {
        return this.x;
    }
    QUANT_f.prototype.get = function QUANT_f() {
        var options = {
            pas:["Step",this.pas],
            meth:["Quantization Type (1-4)",this.meth],
        }
        return options;
    }
    QUANT_f.prototype.set = function QUANT_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.pas = parseFloat(arguments[0]["pas"]);
            this.meth = parseFloat(arguments[0]["meth"]);
            if (!ok) {
                break;
            }
            if (this.meth<1||this.meth>4) {
                message("Quantization Type must be from 1 to 4");
                throw "user error";
            } else {
                var rpar = this.pas;
                this.model.rpar = new ScilabDouble([rpar]);
                this.model.ipar = new ScilabDouble([this.meth]);
                switch (this.meth) {
                case 1:
                    this.model.sim = new ScilabString(["qzrnd"]);
                case 2:
                    this.model.sim = new ScilabString(["qztrn"]);
                case 3:
                    this.model.sim = new ScilabString(["qzflr"]);
                case 4:
                    this.model.sim = new ScilabString(["qzcel"]);
                }
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/SATURATION.sci" */
function SATURATION() {
    SATURATION.prototype.define = function SATURATION() {
        this.minp = -1;
        this.maxp = 1;
        var rpar = [[this.maxp],[this.minp]];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["satur"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([1]);
        this.model.nzcross = new ScilabDouble([2]);
        this.model.nmode = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble(rpar);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[string(this.maxp)],[string(this.minp)],[string(this.model.nmode)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SATURATION\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    SATURATION.prototype.details = function SATURATION() {
        return this.x;
    }
    SATURATION.prototype.get = function SATURATION() {
        var options = {
            maxp:["Upper limit",this.maxp],
            minp:["Lower limit",this.minp],
            zeroc:["zero crossing (0:no, 1:yes)",this.zeroc],
        }
        return options;
    }
    SATURATION.prototype.set = function SATURATION() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.maxp = parseFloat(arguments[0]["maxp"]);
            this.minp = parseFloat(arguments[0]["minp"]);
            this.zeroc = arguments[0]["zeroc"];
            if (!ok) {
                break;
            }
            if (this.maxp<=this.minp) {
                message("Upper limit must be > Lower limit");
                throw "user error";
            } else {
                var rpar = [[this.maxp],[this.minp]];
                this.model.rpar = new ScilabDouble(rpar);
                if (this.zeroc!=0) {
                    this.model.nzcross = new ScilabDouble([2]);
                    this.model.nmode = new ScilabDouble([1]);
                } else {
                    this.model.nzcross = new ScilabDouble([0]);
                    this.model.nmode = new ScilabDouble([0]);
                }
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/SAT_f.sci" */
function SAT_f() {
    SAT_f.prototype.define = function SAT_f() {
        this.minp = -1;
        this.maxp = 1;
        var slope = 1;
        var rpar = [[this.minp],[this.maxp],[slope]];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["lusat"]), new ScilabDouble([1]));
        this.model.in = new ScilabDouble([1]);
        this.model.nzcross = new ScilabDouble([2]);
        this.model.out = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([this.minp],[this.maxp],[slope]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[string(this.minp)],[string(this.maxp)],[string(slope)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SAT_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    SAT_f.prototype.details = function SAT_f() {
        return this.x;
    }
    SAT_f.prototype.get = function SAT_f() {
        var options = {
            minp:["Min",this.minp],
            maxp:["Max",this.maxp],
            pente:["Slope",this.pente],
        }
        return options;
    }
    SAT_f.prototype.set = function SAT_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.minp = parseFloat(arguments[0]["minp"]);
            this.maxp = parseFloat(arguments[0]["maxp"]);
            this.pente = arguments[0]["pente"];
            if (!ok) {
                break;
            }
            if (this.maxp<=0) {
                message("Max must be strictly positive");
                throw "user error";
            } else if (this.pente<=0) {
                message("Slope must be strictly positive");
                throw "user error";
            } else {
                var rpar = [[this.minp/this.pente],[this.maxp/this.pente],[this.pente]];
                this.model.rpar = new ScilabDouble(rpar);
                this.model.firing = new ScilabDouble([]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/SIGNUM.sci" */
function SIGNUM() {
    SIGNUM.prototype.define = function SIGNUM() {
        var nu = -1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["signum"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([nu]);
        this.model.out = new ScilabDouble([nu]);
        this.model.nzcross = new ScilabDouble([nu]);
        this.model.nmode = new ScilabDouble([nu]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [string([1])];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SIGNUM\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    SIGNUM.prototype.details = function SIGNUM() {
        return this.x;
    }
    SIGNUM.prototype.get = function SIGNUM() {
        var options = {
            zcr:["use zero_crossing (1: yes) (0:no)",this.zcr],
        }
        return options;
    }
    SIGNUM.prototype.set = function SIGNUM() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.zcr = arguments[0]["zcr"];
            if (!ok) {
                break;
            }
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            if (ok) {
                if (this.zcr!=0) {
                    this.model.nmode = new ScilabDouble([-1]);
                    this.model.nzcross = new ScilabDouble([-1]);
                } else {
                    this.model.nmode = new ScilabDouble([0]);
                    this.model.nzcross = new ScilabDouble([0]);
                }
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/SINBLK_f.sci" */
function SINBLK_f() {
    SINBLK_f.prototype.define = function SINBLK_f() {
        this.model = scicos_model();
        this.model.sim = new ScilabString(["sinblk"]);
        this.model.in = new ScilabDouble([-1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = " ";
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SINBLK_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    SINBLK_f.prototype.details = function SINBLK_f() {
        return this.x;
    }
    SINBLK_f.prototype.get = function SINBLK_f() {
        alert("parameters cannot be modified");
    }
    SINBLK_f.prototype.set = function SINBLK_f() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/TANBLK_f.sci" */
function TANBLK_f() {
    TANBLK_f.prototype.define = function TANBLK_f() {
        var in1 = -1;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["tanblk"]);
        this.model.in = new ScilabDouble([in1]);
        this.model.out = new ScilabDouble([in1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = sci2exp(in1);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"TANBLK_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    TANBLK_f.prototype.details = function TANBLK_f() {
        return this.x;
    }
    TANBLK_f.prototype.get = function TANBLK_f() {
        alert("parameters cannot be modified");
    }
    TANBLK_f.prototype.set = function TANBLK_f() {
        this.x.model.firing = [];
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/NonLinear/TrigFun.sci" */
function TrigFun() {
    TrigFun.prototype.define = function TrigFun() {
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["sin_blk"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([-1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = "sin";
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"TrigFun\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([4,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    TrigFun.prototype.details = function TrigFun() {
        return this.x;
    }
    TrigFun.prototype.get = function TrigFun() {
        var options = {
            fun:["Function",this.fun],
        }
        return options;
    }
    TrigFun.prototype.set = function TrigFun() {
        this.exprs = this.graphics.exprs;
        var PREVAR_FF = [["sin"],["cos"],["tan"],["asin"],["acos"],["atan"],["sinh"],["cosh"],["tanh"],["asinh"],["acosh"],["atanh"]];
        var PREVAR_GG = [["Choose among "+strcat(PREVAR_FF.slice(1-1,4),", ")],[strcat(PREVAR_FF.slice(5-1,$),", ")]];
        while (true) {
            var ok = true;
            this.fun = arguments[0]["fun"];
            if (!ok) {
                break;
            }
            if (find(PREVAR_FF==this.fun).length==0) {
                message("Sorry but "+this.fun+" is not in the list!");
                throw "user error";
            } else {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                execstr("model.sim=list(\'"+this.fun+"_blk\',4)");
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/PDE/PDE.sci" */
function PDE() {
    PDE.prototype.define = function PDE() {
        this.model = scicos_model();
        this.model.state = new ScilabDouble([zeros(10,1)]);
        this.model.sim = list(new ScilabString(["PDE"]), new ScilabDouble([0]));
        this.model.in = new ScilabDouble([1],[1],[1],[1],[1]);
        this.model.out = new ScilabDouble([10],[0]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        var params_pde = tlist([["paramspde"],["a"],["b"],["txt_exp"],["check_op1"],["a1"],["b1"],["check_op2"],["a2"],["b2"],["check_op3"],["a3"],["b3"],["check_op4"],["a4"],["b4"],["check_op5"],["a5"],["b5"],["check_op6"],["a6"],["b6"],["check_op7"],["a7"],["b7"],["discr_cst"],["discr_non_cst"],["signe"],["rad_automatique"],["rad_manuel"],["methode"],["ord1"],["ord2"],["ord3"],["degre"],["nnode"],["txt_pas"],["CI"],["dCI"],["CLa"],["CLa_exp"],["CLb"],["CLb_exp"],["points"]],"","","","0","","IN_EDP1(t)","0","","IN_EDP2(t)","0","","IN_EDP3(t)","0","","IN_EDP4(t)","0","","IN_EDP5(t)","0","","IN_EDP6(t)","0","","IN_EDP7(t)","0","0","0","0","0","0","","","","","","","","","0","IN_CL1(t)","0","IN_CL2(t)","");
        var label = list(params_pde,[],"");
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"PDE\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,3]),this.model,label,this.gr_i);
        return new BasicBlock(this.x);
    }
    PDE.prototype.details = function PDE() {
        return this.x;
    }
    PDE.prototype.get = function PDE() {
        var options = {
                okk:["New block\'s name :",this.okk],
        }
        return options;
    }
    PDE.prototype.set = function PDE() {
        var label = this.graphics.exprs;
        var params_pde = label[1-1];
        while (true) {
            [ln,fun]=where()
            if (!or(fun=="do_eval")) {
                var tmpvar0 = IHM_EDP(params_pde);
                var ok = tmpvar0[0];
                var a_domaine = tmpvar0[1];
                var b_domaine = tmpvar0[2];
                var discr = tmpvar0[3];
                var signe = tmpvar0[4];
                var choix = tmpvar0[5];
                var type_meth = tmpvar0[6];
                var degre = tmpvar0[7];
                var Nbr_maillage = tmpvar0[8];
                var CI = tmpvar0[9];
                var CI1 = tmpvar0[10];
                var CLa_type = tmpvar0[11];
                var CLa_exp = tmpvar0[12];
                var CLb_type = tmpvar0[13];
                var CLb_exp = tmpvar0[14];
                var oper = tmpvar0[15];
                var a1 = tmpvar0[16];
                var b1 = tmpvar0[17];
                var a2 = tmpvar0[18];
                var b2 = tmpvar0[19];
                var a3 = tmpvar0[20];
                var b3 = tmpvar0[21];
                var a4 = tmpvar0[22];
                var b4 = tmpvar0[23];
                var a5 = tmpvar0[24];
                var b5 = tmpvar0[25];
                var a6 = tmpvar0[26];
                var b6 = tmpvar0[27];
                var a7 = tmpvar0[28];
                var b7 = tmpvar0[29];
                var k = tmpvar0[30];
                var mesures = tmpvar0[31];
                var params_pde = tmpvar0[32];
                if (ok) {
                    return;
                }
            } else {
                if (exists("%scicos_context")) {
                    var tmpvar1 = setvalue_IHM_EDP(params_pde);
                    var ok = tmpvar1[0];
                    var a_domaine = tmpvar1[1];
                    var b_domaine = tmpvar1[2];
                    var discr = tmpvar1[3];
                    var signe = tmpvar1[4];
                    var choix = tmpvar1[5];
                    var type_meth = tmpvar1[6];
                    var degre = tmpvar1[7];
                    var Nbr_maillage = tmpvar1[8];
                    var CI = tmpvar1[9];
                    var CI1 = tmpvar1[10];
                    var CLa_type = tmpvar1[11];
                    var CLa_exp = tmpvar1[12];
                    var CLb_type = tmpvar1[13];
                    var CLb_exp = tmpvar1[14];
                    var oper = tmpvar1[15];
                    var a1 = tmpvar1[16];
                    var b1 = tmpvar1[17];
                    var a2 = tmpvar1[18];
                    var b2 = tmpvar1[19];
                    var a3 = tmpvar1[20];
                    var b3 = tmpvar1[21];
                    var a4 = tmpvar1[22];
                    var b4 = tmpvar1[23];
                    var a5 = tmpvar1[24];
                    var b5 = tmpvar1[25];
                    var a6 = tmpvar1[26];
                    var b6 = tmpvar1[27];
                    var a7 = tmpvar1[28];
                    var b7 = tmpvar1[29];
                    var k = tmpvar1[30];
                    var mesures = tmpvar1[31];
                    var params_pde = tmpvar1[32];
                }
            }
            this.okk = false;
            this.rdnom = "PDE";
            var ok1 = true;
            while (true) {
                var ok = true;
                this.okk = parseBoolean(arguments[0]["okk"]);
                this.rdnom = arguments[0]["rdnom"];
                this.lab = arguments[0]["lab"];
                if (this.okk==false) {
                    var ok1 = false;
                    return;
                }
                label[3-1] = this.lab;
                this.rdnom = stripblanks(this.rdnom);
                if (this.rdnom==emptystr()) {
                    var ok1 = false;
                    x_message("sorry C file name not defined");
                }
                if (ok1) {
                    break;
                }
            }
            if ((choix==0)) {
                var ind4 = strindex(a4,"x");
                var ind1 = strindex(a1,"x");
                var ind2 = strindex(a2,"x");
                if ((ind4.length!=0||ind1.length!=0||ind2.length!=0)) {
                    if ((signe==1)) {
                        var delta = 1;
                    } else if ((signe==2)) {
                        var delta = -1;
                    } else if ((signe==0)) {
                        var delta = 0;
                    } else {
                        x_message([["le discriminant n\'est pas constant,"],["Vous devez choisir son signe dans l\'IHM"]]);
                        return;
                    }
                } else {
                    var delta = evstr(a4)^2-4*evstr(a1)*evstr(a2);
                }
                if ((delta.length==0)) {
                    var delta = 0;
                }
                var type_meth = arbre_decision(delta);
            }
            var tmpvar2 = translate(CI,CI1,CLa_type,CLa_exp,CLb_type,CLb_exp,oper,type_meth,degre,a_domaine,b_domaine,Nbr_maillage,a1,b1,a2,b2,a3,b3,a4,b4,a5,b5,a6,b6,a7,b7,this.rdnom,mesures);
            var flag_type = tmpvar2[0];
            this.rdnom = tmpvar2[1];
            var DF_type = tmpvar2[2];
            var tt = tmpvar2[3];
            var Nbr = Nbr_maillage;
            if (((CLa_type==1)&&(DF_type==0||DF_type==1))||((CLb_type==1)&&(DF_type==0||DF_type==2))) {
                var Nbr = Nbr+1;
            }
            if ((mesures.length==0)) {
                var out = Nbr_maillage;
            } else {
                var out = [[Nbr_maillage],[size(mesures,"*")]];
            }
            if ((flag_type==1)) {
                this.model.sim = list(new ScilabDouble([this.rdnom]), new ScilabDouble([2004]));
                if ((find(oper==1).length!=0)) {
                    this.model.state = new ScilabDouble([zeros(2*Nbr_maillage,1)]);
                } else {
                    this.model.state = new ScilabDouble([zeros(Nbr_maillage,1)]);
                }
            } else if ((flag_type==2)) {
                this.model.sim = list(new ScilabDouble([this.rdnom]), new ScilabDouble([12004]));
                if ((find(oper==1).length!=0)) {
                    if ((type_meth==3&&(find(oper==2).length!=0||find(oper==4).length!=0))) {
                        this.model.state = new ScilabDouble([zeros(6*Nbr_maillage,1)]);
                    } else if ((type_meth==1)) {
                        this.model.state = new ScilabDouble([zeros(4*Nbr,1)]);
                    } else {
                        this.model.state = new ScilabDouble([zeros(4*Nbr_maillage,1)]);
                    }
                } else {
                    if ((type_meth==3&&(find(oper==2).length!=0||find(oper==4).length!=0))) {
                        this.model.state = new ScilabDouble([zeros(4*Nbr_maillage,1)]);
                    } else if ((type_meth==1)) {
                        this.model.state = new ScilabDouble([zeros(2*Nbr,1)]);
                    } else {
                        this.model.state = new ScilabDouble([zeros(2*Nbr_maillage,1)]);
                    }
                }
            }
            var tmpvar3 = CFORTREDP(this.rdnom,tt);
            var ok1 = tmpvar3[0];
            if (!ok1) {
                break;
            }
            if (!ok) {
                var tmpvar4 = check_io(this.model,this.graphics,ones(k,1),out.slice(),[],[]);
                this.model = tmpvar4[0];
                this.graphics = tmpvar4[1];
                var ok = tmpvar4[2];
            }
            label[1-1] = params_pde;
            label[2-1] = tt;
            this.graphics.exprs = new ScilabDouble([label]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sinks/AFFICH_m.sci" */
function AFFICH_m() {
    AFFICH_m.prototype.define = function AFFICH_m() {
        this.font = 1;
        this.fontsize = 1;
        this.colr = 1;
        this.nt = 5;
        this.nd = 1;
        this.in1 = [1,1];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["affich2"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([this.in1[1-1][1-1]]);
        this.model.in2 = new ScilabDouble([this.in1[1-1][2-1]]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble([-1],[0],[0],[1],[1],[0],[zeros(this.in1[1-1][1-1]*this.in1[1-1][2-1],1)]);
        this.model.ipar = new ScilabDouble([this.font],[this.fontsize],[this.colr],[1000],[this.nt],[this.nd],[this.in1[1-1][1-1]]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.model.label = new ScilabString([""]);
        this.exprs = [[sci2exp([this.model.in,this.model.in2])],[string(this.font)],[string(this.fontsize)],[string(this.colr)],[string(this.nt)],[string(this.nd)],[string(0)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"AFFICH_m\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new AfficheBlock(this.x);
    }
    AFFICH_m.prototype.details = function AFFICH_m() {
        return this.x;
    }
    AFFICH_m.prototype.get = function AFFICH_m() {
        var options = {
            in1:["Input Size",this.in1],
            font:["Font number",this.font],
            fontsize:["Font size",this.fontsize],
            colr:["Color",this.colr],
            nt:["Total number of digits",this.nt],
            nd:["Number of rational part digits",this.nd],
            herit:["Block inherits (1) or not (0)",this.herit],
        }
        return options;
    }
    AFFICH_m.prototype.set = function AFFICH_m() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.in1 = inverse(arguments[0]["in1"]);
            this.font = parseFloat(arguments[0]["font"]);
            this.fontsize = parseFloat(arguments[0]["fontsize"]);
            this.colr = parseFloat(arguments[0]["colr"]);
            this.nt = parseFloat(arguments[0]["nt"]);
            this.nd = parseFloat(arguments[0]["nd"]);
            this.herit = arguments[0]["herit"];
            if (!ok) {
                break;
            }
            var mess = [];
            if (this.font<=0) {
                var mess = [[mess],["Font number must be positive"],[" "]];
                var ok = false;
            }
            if (this.fontsize<=0) {
                var mess = [[mess],["Font size must be positive"],[" "]];
                var ok = false;
            }
            if (this.nt<=3) {
                var mess = [[mess],["Total number of digits must be greater than 3"],[" "]];
                var ok = false;
            }
            if (this.nd<0) {
                var mess = [[mess],["Number of rational part digits must be ","greater or equal 0"],[" "]];
                var ok = false;
            }
            if (!ok) {
                message([["Some specified values are inconsistent:"],[" "],[mess]]);
                throw "user error";
            }
            if (!or(this.herit==[0,1])) {
                var mess = [[mess],["Accept inherited values are 0 and 1"],[" "]];
                var ok = false;
            }
            if (!ok) {
                message([["Some specified values are inconsistent:"],[" "],[mess]]);
                throw "user error";
            }
            if (ok) {
                var tmpvar0 = set_io(this.model,this.graphics,list(this.in1,1),list(),ones(1-this.herit,1),[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.model.ipar = new ScilabDouble([this.font],[this.fontsize],[this.colr],[this.nt],[this.nd],[this.in1[1-1][1-1]]);
                this.model.dstate = new ScilabDouble([-1],[0],[0],[1],[1],[0],[zeros(this.in1[1-1][1-1]*this.in1[1-1][2-1],1)]);
                this.model.evtin = new ScilabDouble([ones(1-this.herit,1)]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new AfficheBlock(this.x);
    }
}
/* autogenerated from "macros/Sinks/BARXY.sci" */
function BARXY() {
    BARXY.prototype.define = function BARXY() {
        this.model = scicos_model();
        this.xmin = -15;
        this.xmax = 15;
        this.ymin = -15;
        this.ymax = 15;
        this.model.sim = list(new ScilabString(["BARXY_sim"]), new ScilabDouble([5]));
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.model.in = new ScilabDouble([-1],[-1]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([this.xmin],[this.xmax],[this.ymin],[this.ymax]);
        this.model.ipar = new ScilabDouble([1]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble([]),[]);
        this.x.graphics.in_implicit = ["E","E"];
        this.x.graphics.out_implicit = [];
        this.x.graphics.exprs = [["-15"],["15"],["-15"],["15"],["1"]];
        return new BasicBlock(this.x);
    }
    BARXY.prototype.details = function BARXY() {
        return this.x;
    }
    BARXY.prototype.get = function BARXY() {
        var options = {
            xmin:["Xmin",this.xmin],
            xmax:["Xmax",this.xmax],
            ymin:["Ymin",this.ymin],
            ymax:["Ymax",this.ymax],
            thickness:["Segs Thickness",this.thickness],
        }
        return options;
    }
    BARXY.prototype.set = function BARXY() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.xmin = parseFloat(arguments[0]["xmin"]);
            this.xmax = parseFloat(arguments[0]["xmax"]);
            this.ymin = parseFloat(arguments[0]["ymin"]);
            this.ymax = parseFloat(arguments[0]["ymax"]);
            this.thickness = arguments[0]["thickness"];
            if (!ok) {
                break;
            }
            var mess = [];
            if (this.ymin>=this.ymax) {
                var mess = [[mess],["Ymax must be greater than Ymin"],[" "]];
                var ok = false;
            }
            if (this.xmin>=this.xmax) {
                var mess = [[mess],["Xmax must be greater than Xmin"],[" "]];
                var ok = false;
            }
            if (this.thickness<=0) {
                var mess = [[mess],["Thickness must be strictly positive."]];
                var ok = false;
            }
            if (!ok) {
                message(mess);
                throw "user error";
            } else {
                this.model.rpar = new ScilabDouble([this.xmin],[this.xmax],[this.ymin],[this.ymax]);
                this.model.ipar = new ScilabDouble([this.thickness]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sinks/CANIMXY.sci" */
function CANIMXY() {
    CANIMXY.prototype.define = function CANIMXY() {
        this.win = -1;
        this.clrs = -4;
        this.N = 2;
        this.siz = 1;
        this.wpos = [[-1],[-1]];
        this.wdim = [[-1],[-1]];
        this.xmin = -15;
        this.xmax = 15;
        this.ymin = -15;
        this.ymax = 15;
        this.nbr_curves = 1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["canimxy"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([1],[1]);
        this.model.in2 = new ScilabDouble([1],[1]);
        this.model.intyp = new ScilabDouble([1],[1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([this.xmin],[this.xmax],[this.ymin],[this.ymax]);
        this.model.ipar = new ScilabDouble([this.win],[1],[this.N],[this.clrs],[this.siz],[0],[this.wpos.slice()],[this.wdim.slice()],[this.nbr_curves]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [[string(this.nbr_curves)],[string(this.clrs)],[string(this.siz)],[string(this.win)],["[]"],["[]"],[string(this.xmin)],[string(this.xmax)],[string(this.ymin)],[string(this.ymax)],[string(this.N)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CANIMXY\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    CANIMXY.prototype.details = function CANIMXY() {
        return this.x;
    }
    CANIMXY.prototype.get = function CANIMXY() {
        var options = {
            nbr_curves:["Number of Curves",this.nbr_curves],
            clrs:["color (>0) or mark (<0)",this.clrs],
            siz:["line or mark size",this.siz],
            win:["Output window number (-1 for automatic)",this.win],
            wpos:["Output window position",this.wpos.toString().replace(/,/g," ")],
            wdim:["Output window sizes",this.wdim.toString().replace(/,/g," ")],
            xmin:["Xmin",this.xmin],
            xmax:["Xmax",this.xmax],
            ymin:["Ymin",this.ymin],
            ymax:["Ymax",this.ymax],
            N:["Buffer size",this.N],
        }
        return options;
    }
    CANIMXY.prototype.set = function CANIMXY() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.nbr_curves = parseFloat(arguments[0]["nbr_curves"]);
            this.clrs = parseFloat(arguments[0]["clrs"]);
            this.siz = parseFloat(arguments[0]["siz"]);
            this.win = parseFloat(arguments[0]["win"]);
            this.wpos = inverse(arguments[0]["wpos"]);
            this.wdim = inverse(arguments[0]["wdim"]);
            this.xmin = parseFloat(arguments[0]["xmin"]);
            this.xmax = parseFloat(arguments[0]["xmax"]);
            this.ymin = parseFloat(arguments[0]["ymin"]);
            this.ymax = parseFloat(arguments[0]["ymax"]);
            this.N = parseFloat(arguments[0]["N"]);
            if (!ok) {
                break;
            }
            var mess = [];
            if (size(this.wpos,"*")!=0&&size(this.wpos,"*")!=2) {
                var mess = [[mess],["Window position must be [] or a 2 vector"],[" "]];
                var ok = false;
            }
            if (size(this.wdim,"*")!=0&&size(this.wdim,"*")!=2) {
                var mess = [[mess],["Window dim must be [] or a 2 vector"],[" "]];
                var ok = false;
            }
            if (this.win<-1) {
                var mess = [[mess],["Window number cannot be inferior than -1"],[" "]];
                var ok = false;
            }
            if (this.nbr_curves<=0) {
                var mess = [[mess],["Number of curves cannot be negative or null"],[" "]];
                var ok = false;
            }
            if (this.N<1) {
                var mess = [[mess],["Buffer size must be at least 1"],[" "]];
                var ok = false;
            }
            if (this.N==1&&this.clrs>0) {
                var mess = [[mess],["Buffer size must be at least 2"],[" "]];
                var ok = false;
            }
            if (this.ymin>=this.ymax) {
                var mess = [[mess],["Ymax must be greater than Ymin"],[" "]];
                var ok = false;
            }
            if (this.xmin>=this.xmax) {
                var mess = [[mess],["Xmax must be greater than Xmin"],[" "]];
                var ok = false;
            }
            if (!ok) {
                message(mess);
                throw "user error";
            } else {
                var in1 = this.nbr_curves*ones(2,1);
                var in2 = ones(2,1);
                var tmpvar0 = set_io(this.model,this.graphics,list([in1,in2],ones(2,1)),list(),ones(1,1),[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                if (this.wpos.length==0) {
                    this.wpos = [[-1],[-1]];
                }
                if (this.wdim.length==0) {
                    this.wdim = [[-1],[-1]];
                }
                var rpar = [[this.xmin],[this.xmax],[this.ymin],[this.ymax]];
                var ipar = [[this.win],[1],[this.N],[this.clrs],[this.siz],[0],[this.wpos.slice()],[this.wdim.slice()],[this.nbr_curves]];
                this.model.rpar = new ScilabDouble(rpar);
                this.model.ipar = new ScilabDouble(ipar);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sinks/CANIMXY3D.sci" */
function CANIMXY3D() {
    CANIMXY3D.prototype.define = function CANIMXY3D() {
        this.win = -1;
        this.N = 2;
        this.clrs = [[1],[2],[3],[4],[5],[6],[7],[13]];
        this.siz = [[1],[1],[1],[1],[1],[1],[1],[1]];
        this.wpos = [[-1],[-1]];
        this.wdim = [[-1],[-1]];
        this.param3ds = [[50],[280]];
        this.vec_x = [[-15],[15]];
        this.vec_y = [[-15],[15]];
        this.vec_z = [[-15],[15]];
        this.nbr_curves = 1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["canimxy3d"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([1],[1],[1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.in2 = new ScilabDouble([1],[1],[1]);
        this.model.intyp = new ScilabDouble([1],[1],[1]);
        this.model.rpar = new ScilabDouble([this.vec_x.slice()],[this.vec_y.slice()],[this.vec_z.slice()],[this.param3ds.slice()]);
        this.model.ipar = new ScilabDouble([this.win],[8],[this.N],[this.clrs.slice()],[this.siz.slice()],[8],[this.wpos.slice()],[this.wdim.slice()],[this.nbr_curves]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [[string(this.nbr_curves)],[strcat(string(this.clrs)," ")],[strcat(string(this.siz)," ")],[string(this.win)],["[]"],["[]"],[strcat(string(this.vec_x)," ")],[strcat(string(this.vec_y)," ")],[strcat(string(this.vec_z)," ")],[strcat(string(this.param3ds)," ")],[string(this.N)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CANIMXY3D\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    CANIMXY3D.prototype.details = function CANIMXY3D() {
        return this.x;
    }
    CANIMXY3D.prototype.get = function CANIMXY3D() {
        var options = {
            nbr_curves:["Number of curves",this.nbr_curves],
            clrs:["color (>0) or mark (<0)",this.clrs.toString().replace(/,/g," ")],
            siz:["line or mark size",this.siz.toString().replace(/,/g," ")],
            win:["Output window number (-1 for automatic)",this.win],
            wpos:["Output window position",this.wpos.toString().replace(/,/g," ")],
            wdim:["Output window sizes",this.wdim.toString().replace(/,/g," ")],
            vec_x:["Xmin and Xmax",this.vec_x.toString().replace(/,/g," ")],
            vec_y:["Ymin and Ymax",this.vec_y.toString().replace(/,/g," ")],
            vec_z:["Zmin and Zmax",this.vec_z.toString().replace(/,/g," ")],
            param3ds:["Alpha and Theta",this.param3ds.toString().replace(/,/g," ")],
            N:["Buffer size",this.N],
        }
        return options;
    }
    CANIMXY3D.prototype.set = function CANIMXY3D() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.nbr_curves = parseFloat(arguments[0]["nbr_curves"]);
            this.clrs = inverse(arguments[0]["clrs"]);
            this.siz = inverse(arguments[0]["siz"]);
            this.win = parseFloat(arguments[0]["win"]);
            this.wpos = inverse(arguments[0]["wpos"]);
            this.wdim = inverse(arguments[0]["wdim"]);
            this.vec_x = inverse(arguments[0]["vec_x"]);
            this.vec_y = inverse(arguments[0]["vec_y"]);
            this.vec_z = inverse(arguments[0]["vec_z"]);
            this.param3ds = inverse(arguments[0]["param3ds"]);
            this.N = parseFloat(arguments[0]["N"]);
            if (!ok) {
                break;
            }
            var mess = [];
            if (size(this.wpos,"*")!=0&&size(this.wpos,"*")!=2) {
                var mess = [[mess],["Window position must be [] or a 2 vector"],[" "]];
                var ok = false;
            }
            if (size(this.wdim,"*")!=0&&size(this.wdim,"*")!=2) {
                var mess = [[mess],["Window dim must be [] or a 2 vector"],[" "]];
                var ok = false;
            }
            if (this.win<-1) {
                var mess = [[mess],["Window number cannot be inferior than -1"],[" "]];
                var ok = false;
            }
            if (size(this.clrs,"*")!=size(this.siz,"*")) {
                var mess = [[mess],["Colors and Size must have same size"],[" "]];
                var ok = false;
            }
            if (this.nbr_curves<=0) {
                var mess = [[mess],["Number of curves cannot be negative or null"],[" "]];
                var ok = false;
            }
            if (size(this.clrs,"*")<this.nbr_curves) {
                var mess = [[mess],["You must have at least same size for clrs and the number of curves"],[" "]];
                var ok = false;
            }
            if (this.N<1) {
                var mess = [[mess],["Buffer size must be at least 1"],[" "]];
                var ok = false;
            }
            if (this.N<2) {
                for (i=1;i<=this.nbr_curves;i+=1) {
                    if (this.clrs[i-1]>0) {
                        var mess = [[mess],["Buffer size must be at least 2 or Change a color (must be <0)"],[" "]];
                        var ok = false;
                    }
                }
            }
            if (this.vec_y[1-1]>=this.vec_y[2-1]) {
                var mess = [[mess],["Ymax must be higher than Ymin"],[" "]];
                var ok = false;
            }
            if (this.vec_x[1-1]>=this.vec_x[2-1]) {
                var mess = [[mess],["Xmax must be higher than Xmin"],[" "]];
                var ok = false;
            }
            if (this.vec_z[1-1]>=this.vec_z[2-1]) {
                var mess = [[mess],["Zmax must be higher than Zmin"],[" "]];
                var ok = false;
            }
            if (!ok) {
                message(mess);
                throw "user error";
            } else {
                var in1 = this.nbr_curves*ones(3,1);
                var in2 = ones(3,1);
                var tmpvar0 = set_io(this.model,this.graphics,list([in1,in2],ones(3,1)),list(),ones(1,1),[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                if (this.wpos.length==0) {
                    this.wpos = [[-1],[-1]];
                }
                if (this.wdim.length==0) {
                    this.wdim = [[-1],[-1]];
                }
                var rpar = [[this.vec_x.slice()],[this.vec_y.slice()],[this.vec_z.slice()],[this.param3ds.slice()]];
                var size_siz = size(this.siz,"*");
                var ipar = [[this.win],[size_siz],[this.N],[this.clrs.slice()],[this.siz.slice()],[1],[this.wpos.slice()],[this.wdim.slice()],[this.nbr_curves]];
                this.model.rpar = new ScilabDouble(rpar);
                this.model.ipar = new ScilabDouble(ipar);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sinks/CEVENTSCOPE.sci" */
function CEVENTSCOPE() {
    CEVENTSCOPE.prototype.define = function CEVENTSCOPE() {
        this.nclock = 1;
        this.win = -1;
        this.clrs = [[1],[3],[5],[7],[9],[11],[13],[15]];
        this.wdim = [[600],[400]];
        this.wpos = [[-1],[-1]];
        this.per = 30;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["cevscpe"]), new ScilabDouble([4]));
        this.model.evtin = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([this.per]);
        this.model.ipar = new ScilabDouble([this.win],[1],[this.clrs[this.nclock-1]],[this.wpos.slice()],[this.wdim.slice()]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [[sci2exp(this.nclock)],[strcat(sci2exp(this.clrs[this.nclock-1])," ")],[string(this.win)],[sci2exp([])],[sci2exp(this.wdim)],[string(this.per)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CEVENTSCOPE\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    CEVENTSCOPE.prototype.details = function CEVENTSCOPE() {
        return this.x;
    }
    CEVENTSCOPE.prototype.get = function CEVENTSCOPE() {
        var options = {
            nclock:["Number of event inputs",this.nclock],
            clrs:["colors c (>0) or mark (<0)",this.clrs.toString().replace(/,/g," ")],
            win:["Output window number (-1 for automatic)",this.win],
            wpos:["Output window position",this.wpos.toString().replace(/,/g," ")],
            wdim:["Output window sizes",this.wdim.toString().replace(/,/g," ")],
            per:["Refresh period",this.per],
        }
        return options;
    }
    CEVENTSCOPE.prototype.set = function CEVENTSCOPE() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.nclock = parseFloat(arguments[0]["nclock"]);
            this.clrs = inverse(arguments[0]["clrs"]);
            this.win = parseFloat(arguments[0]["win"]);
            this.wpos = inverse(arguments[0]["wpos"]);
            this.wdim = inverse(arguments[0]["wdim"]);
            this.per = parseFloat(arguments[0]["per"]);
            this.nclock = int(this.nclock);
            this.clrs = int(this.clrs);
            this.win = int(this.win);
            if (!ok) {
                break;
            }
            var mess = [];
            if (size(this.wpos,"*")!=0&&size(this.wpos,"*")!=2) {
                var mess = [[mess],["Window position must be [] or a 2 vector"],[" "]];
                var ok = false;
            }
            if (size(this.wdim,"*")!=0&&size(this.wdim,"*")!=2) {
                var mess = [[mess],["Window dim must be [] or a 2 vector"],[" "]];
                var ok = false;
            }
            if (this.nclock<=0) {
                var mess = [[mess],["Block must have at least one input event"],[" "]];
                var ok = false;
            }
            if (size(this.clrs,"*")!=this.nclock) {
                var mess = [[mess],["Inputs color c size must be equal to Number of inputs"],[" "]];
                var ok = false;
            }
            if (this.win<-1) {
                var mess = [[mess],["Window number cannot be inferior than -1"],[" "]];
                var ok = false;
            }
            if (this.per<=0) {
                var mess = [[mess],["Refresh period must be positive"],[" "]];
                var ok = false;
            }
            if (ok) {
                var tmpvar0 = set_io(this.model,this.graphics,list(),list(),ones(this.nclock,1),[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            } else {
                message([["Some specified values are inconsistent:"],[" "],[mess]]);
                throw "user error";
            }
            if (ok) {
                if (this.wpos.length==0) {
                    this.wpos = [[-1],[-1]];
                }
                if (this.wdim.length==0) {
                    this.wdim = [[-1],[-1]];
                }
                var rpar = this.per;
                var ipar = [[this.win],[1],[this.clrs.slice()],[this.wpos.slice()],[this.wdim.slice()]];
                this.model.rpar = new ScilabDouble([rpar]);
                this.model.ipar = new ScilabDouble(ipar);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sinks/CFSCOPE.sci" */
function CFSCOPE() {
    CFSCOPE.prototype.define = function CFSCOPE() {
        this.win = -1;
        this.wdim = [[600],[400]];
        this.wpos = [[-1],[-1]];
        this.clrs = [[1],[3],[5],[7],[9],[11],[13],[15]];
        this.N = 2;
        this.ymin = -15;
        this.ymax = 15;
        this.per = 30;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["cfscope"]), new ScilabDouble([4]));
        this.model.evtin = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([0],[this.ymin],[this.ymax],[this.per]);
        this.model.ipar = new ScilabDouble([this.win],[1],[this.N],[this.clrs],[this.wpos],[this.wdim],[1],[1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[strcat(string(this.clrs)," ")],[string(this.win)],[sci2exp([])],[sci2exp(this.wdim)],[string(this.ymin)],[string(this.ymax)],[string(this.per)],[string(this.N)],[string([1])]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CFSCOPE\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    CFSCOPE.prototype.details = function CFSCOPE() {
        return this.x;
    }
    CFSCOPE.prototype.get = function CFSCOPE() {
        var options = {
            clrs:["Color (>0) or mark (<0) vector (8 entries)",this.clrs.toString().replace(/,/g," ")],
            win:["Output window number (-1 for automatic)",this.win],
            wpos:["Output window position",this.wpos.toString().replace(/,/g," ")],
            wdim:["Output window sizes",this.wdim.toString().replace(/,/g," ")],
            ymin:["Ymin",this.ymin],
            ymax:["Ymax",this.ymax],
            per:["Refresh period",this.per],
            N:["Buffer size",this.N],
            wu:["Links to view",this.wu],
        }
        return options;
    }
    CFSCOPE.prototype.set = function CFSCOPE() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.clrs = inverse(arguments[0]["clrs"]);
            this.win = parseFloat(arguments[0]["win"]);
            this.wpos = inverse(arguments[0]["wpos"]);
            this.wdim = inverse(arguments[0]["wdim"]);
            this.ymin = parseFloat(arguments[0]["ymin"]);
            this.ymax = parseFloat(arguments[0]["ymax"]);
            this.per = parseFloat(arguments[0]["per"]);
            this.N = parseFloat(arguments[0]["N"]);
            this.wu = arguments[0]["wu"];
            if (!ok) {
                break;
            }
            var mess = [];
            if (size(this.wpos,"*")!=0&&size(this.wpos,"*")!=2) {
                var mess = [[mess],["Window position must be [] or a 2 vector"],[" "]];
                var ok = false;
            }
            if (size(this.wdim,"*")!=0&&size(this.wdim,"*")!=2) {
                var mess = [[mess],["Window dim must be [] or a 2 vector"],[" "]];
                var ok = false;
            }
            if (this.win<-1) {
                var mess = [[mess],["Window number cannot be inferior than -1"],[" "]];
                var ok = false;
            }
            if (this.per<=0) {
                var mess = [[mess],["Refresh period must be positive"],[" "]];
                var ok = false;
            }
            if (this.N<2) {
                var mess = [[mess],["Buffer size must be at least 2"],[" "]];
                var ok = false;
            }
            if (this.ymin>=this.ymax) {
                var mess = [[mess],["Ymax must be greater than Ymin"],[" "]];
                var ok = false;
            }
            if (this.wu<0) {
                var mess = [[mess],["Link to view must be positive"],[" "]];
                var ok = false;
            }
            if (!ok) {
                message([["Some specified values are inconsistent:"],[" "],[mess]]);
                throw "user error";
            }
            if (ok) {
                if (this.wpos.length==0) {
                    this.wpos = [[-1],[-1]];
                }
                if (this.wdim.length==0) {
                    this.wdim = [[-1],[-1]];
                }
                var rpar = [[0],[this.ymin],[this.ymax],[this.per]];
                if (size(this.clrs,"*")>8) {
                    this.clrs = this.clrs.slice(1-1,8);
                }
                if (size(this.clrs,"*")<8) {
                    this.clrs[8-1] = 0;
                }
                var ipar = [[this.win],[1],[this.N],[this.clrs.slice()],[this.wpos.slice()],[this.wdim.slice()],[size(this.wu,"*")],[this.wu.slice()]];
                this.model.rpar = new ScilabDouble(rpar);
                this.model.ipar = new ScilabDouble(ipar);
                this.model.firing = new ScilabDouble([]);
                this.model.dep_ut = new ScilabBoolean([true,false]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sinks/CLKOUTV_f.sci" */
function CLKOUTV_f() {
    CLKOUTV_f.prototype.define = function CLKOUTV_f() {
        this.prt = 1;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["output"]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.ipar = new ScilabDouble([this.prt]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = string(this.prt);
        this.x = new standard_define(new ScilabDouble([1,1]),this.model,new ScilabString([this.exprs])," ");
        return new EventOutBlock(this.x);
    }
    CLKOUTV_f.prototype.details = function CLKOUTV_f() {
        return this.x;
    }
    CLKOUTV_f.prototype.get = function CLKOUTV_f() {
        var options = {
            prt:["Port number",this.prt],
        }
        return options;
    }
    CLKOUTV_f.prototype.set = function CLKOUTV_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.prt = arguments[0]["prt"];
            if (!ok) {
                break;
            }
            this.prt = int(this.prt);
            if (this.prt<=0) {
                block_parameter_error(msprintf("Wrong value for \'Port Number\' parameter: %d.",this.prt),"Strictly positive integer expected.");
            } else {
                this.model.ipar = new ScilabDouble([this.prt]);
                this.model.evtin = new ScilabDouble([1]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new EventOutBlock(this.x);
    }
    CLKOUTV_f.prototype.getinputs = function CLKOUTV_f() {
        this.x = orig[1-1]+sz[1-1]/2;
        var y = orig[2-1]+sz[2-1];
        var typ = -ones(this.x);
    }
    CLKOUTV_f.prototype.getorigin = function CLKOUTV_f() {
        this.x = tmpvar0[0];
        var y = tmpvar0[1];
    }
    CLKOUTV_f.prototype.getoutputs = function CLKOUTV_f() {
        this.x = [];
        var y = [];
        var typ = [];
    }
    CLKOUTV_f.prototype.plot = function CLKOUTV_f() {
        var xf = 60;
        var yf = 40;
        var pat = xget("pattern");
        xset("pattern",this.default_color[-1-1]);
        var thick = xget("thickness");
        xset("thickness",2);
        this.x = orig[1-1]+sz[1-1]*[[1/2],[1],[1],[0],[0]];
        var y = orig[2-1]+sz[2-1]*[[0],[1/3],[1],[1],[1/3]];
        var xo = orig[1-1];
        var yo = orig[2-1]+sz[2-1]/3;
        if (this.type[this.gr_i-1]==15) {
            var coli = this.gr_i[2-1];
            var pcoli = xget("pattern");
            xfpolys(this.x,y,coli);
            xset("pattern",coli);
            xstringb(xo,yo,string(this.prt),sz[1-1],sz[2-1]/1.5);
            xset("pattern",pcoli);
            xstringb(xo,yo,string(this.prt),sz[1-1],sz[2-1]/1.5);
        } else {
            xstringb(xo,yo,string(this.prt),sz[1-1],sz[2-1]/1.5);
            xpoly(this.x,y,"lines",1);
        }
        var in1 = [-1/14,1/7,0,0,1/14,1/7,-1/14,1/7]*this.diag[[xf,yf]-1];
        xfpoly(in1.slice()[1-1]+ones(4,1)*(orig[1-1]+sz[1-1]/2),in1.slice()[2-1]+ones(4,1)*(orig[2-1]+sz[2-1]),1);
        xset("thickness",thick);
        xset("pattern",pat);
        if (ident.length!=0&&ident!="") {
            var font = xget("font");
            xset("font",this.options.ID[1-1][1-1],this.options.ID[1-1][2-1]);
            var rectangle = xstringl(orig[1-1],orig[2-1],ident);
            var w = rectangle[3-1];
            var h = rectangle[4-1];
            xstringb(orig[1-1]+sz[1-1]/2-w/2,orig[2-1]-3*h/2,ident,w,h);
            xset("font",font[1-1],font[2-1]);
        }
        this.x = [];
        var y = [];
    }
}
/* autogenerated from "macros/Sinks/CLKOUT_f.sci" */
function CLKOUT_f() {
    CLKOUT_f.prototype.define = function CLKOUT_f() {
        this.prt = 1;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["output"]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.ipar = new ScilabDouble([this.prt]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = string(this.prt);
        this.x = new standard_define(new ScilabDouble([1,1]),this.model,new ScilabString([this.exprs])," ");
        return new BasicBlock(this.x);
    }
    CLKOUT_f.prototype.details = function CLKOUT_f() {
        return this.x;
    }
    CLKOUT_f.prototype.get = function CLKOUT_f() {
        var options = {
            prt:["Port number",this.prt],
        }
        return options;
    }
    CLKOUT_f.prototype.set = function CLKOUT_f() {
        this.exprs = this.graphics.exprs;
        this.exprs = this.exprs[1-1];
        while (true) {
            var ok = true;
            this.prt = parseFloat(arguments[0]["prt"]);
            if (!ok) {
                break;
            }
            this.prt = int(this.prt);
            if (this.prt<=0) {
                message("Port number must be a positive integer");
                throw "user error";
            } else {
                this.model.ipar = new ScilabDouble([this.prt]);
                this.model.evtin = new ScilabDouble([1]);
                this.model.firing = new ScilabDouble([]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sinks/CMAT3D.sci" */
function CMAT3D() {
    CMAT3D.prototype.define = function CMAT3D() {
        this.cmin = 0;
        this.cmax = 100;
        this.colormap = jetcolormap(25);
        var size_c = 25;
        this.x = -1;
        var y = -1;
        var size_x = 1;
        var size_y = 1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["cmat3d"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.ipar = new ScilabDouble([this.cmin],[this.cmax],[size_c],[size_x],[size_y]);
        this.model.rpar = new ScilabDouble([this.colormap.slice()],[this.x],[y]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[strcat(string(this.x)," ")],[strcat(string(y)," ")],[string("jetcolormap(25)")],[string(this.cmin)],[string(this.cmax)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CMAT3D\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    CMAT3D.prototype.details = function CMAT3D() {
        return this.x;
    }
    CMAT3D.prototype.get = function CMAT3D() {
        var options = {
            vec_x:["Bounds Vector X (-1 for standard)",this.vec_x],
            vec_y:["Bounds Vector Y (-1 for standard)",this.vec_y],
            colormap:["ColorMap",this.colormap],
            cmin:["Zmin",this.cmin],
            cmax:["Zmax",this.cmax],
        }
        return options;
    }
    CMAT3D.prototype.set = function CMAT3D() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.vec_x = arguments[0]["vec_x"];
            this.vec_y = arguments[0]["vec_y"];
            this.colormap = parseFloat(arguments[0]["colormap"]);
            this.cmin = parseFloat(arguments[0]["cmin"]);
            this.cmax = parseFloat(arguments[0]["cmax"]);
            if (!ok) {
                break;
            }
            var mess = [];
            if (size(this.vec_x,"*")!=size(this.vec_y,"*")) {
                var mess = [[mess],["Vector X and Vector Y must have the same size"],[" "]];
                var ok = false;
            }
            if (this.cmax<=this.cmin) {
                var mess = [[mess],["Error with minimum and maximum value"],[" "]];
                var ok = false;
            }
            if (!ok) {
                message([["Some specified values are inconsistent:"],[" "],[mess]]);
                throw "user error";
            }
            if (ok) {
                var size_x = size(this.vec_x,"*");
                var size_c = size(this.colormap.slice(),1);
                var ipar = [[this.cmin],[this.cmax],[size_c],[size_x]];
                var rpar = [[this.colormap.slice()],[this.vec_x.slice()],[this.vec_y.slice()]];
                this.model.ipar = new ScilabDouble(ipar);
                this.model.rpar = new ScilabDouble(rpar);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sinks/CMATVIEW.sci" */
function CMATVIEW() {
    CMATVIEW.prototype.define = function CMATVIEW() {
        this.cmin = 0;
        this.cmax = 100;
        var size_c = 25;
        this.colormap = jetcolormap(size_c);
        var alpha_c = 0.24;
        var beta_c = 1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["cmatview"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.ipar = new ScilabDouble([this.cmin],[this.cmax],[size_c]);
        this.model.rpar = new ScilabDouble([alpha_c],[beta_c],[this.colormap.slice()]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[string("jetcolormap(25)")],[string(this.cmin)],[string(this.cmax)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CMATVIEW\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    CMATVIEW.prototype.details = function CMATVIEW() {
        return this.x;
    }
    CMATVIEW.prototype.get = function CMATVIEW() {
        var options = {
            colormap:["ColorMap",this.colormap],
            cmin:["Minimum level range",this.cmin],
            cmax:["Maximum level range",this.cmax],
        }
        return options;
    }
    CMATVIEW.prototype.set = function CMATVIEW() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.colormap = parseFloat(arguments[0]["colormap"]);
            this.cmin = parseFloat(arguments[0]["cmin"]);
            this.cmax = parseFloat(arguments[0]["cmax"]);
            if (!ok) {
                break;
            }
            var mess = [];
            if (this.cmax<=this.cmin) {
                var mess = [[mess],["Error with minimum and maximum value"],[" "]];
                var ok = false;
            }
            if (!ok) {
                message([["Some specified values are inconsistent:"],[" "],[mess]]);
                throw "user error";
            }
            if (ok) {
                var size_c = size(this.colormap.slice(),1);
                var sol = inv([[this.cmin,1],[this.cmax,1]])*[[1],[size_c/3]];
                var alpha_c = sol[1-1];
                var beta_c = sol[2-1];
                var ipar = [[this.cmin],[this.cmax],[size_c]];
                var rpar = [[alpha_c],[beta_c],[this.colormap.slice()]];
                this.model.ipar = new ScilabDouble(ipar);
                this.model.rpar = new ScilabDouble(rpar);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sinks/CMSCOPE.sci" */
function CMSCOPE() {
    CMSCOPE.prototype.define = function CMSCOPE() {
        this.win = -1;
        this.in1 = [[1],[1]];
        this.wdim = [[-1],[-1]];
        this.wpos = [[-1],[-1]];
        this.clrs = [[1],[3],[5],[7],[9],[11],[13],[15]];
        this.N = 20;
        this.ymin = [[-1],[-5]];
        this.ymax = [[1],[5]];
        this.per = [[30],[30]];
        var yy = [[transpose(this.ymin.slice())],[transpose(this.ymax.slice())]];
        var period = transpose(this.per.slice());
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["cmscope"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble(this.in1);
        this.model.in2 = new ScilabDouble([1],[1]);
        this.model.intyp = new ScilabDouble([1],[1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([0],[period.slice()],[yy.slice()]);
        this.model.ipar = new ScilabDouble([this.win],[size(this.in1,"*")],[this.N],[this.wpos.slice()],[this.wdim.slice()],[this.in1.slice()],[this.clrs.slice(1-1,sum(this.in1))]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[strcat(string(this.in1)," ")],[strcat(string(this.clrs)," ")],[string(this.win)],[sci2exp([])],[sci2exp([])],[strcat(string(this.ymin)," ")],[strcat(string(this.ymax)," ")],[strcat(string(this.per)," ")],[string(this.N)],[string(0)],[emptystr()]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CMSCOPE\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    CMSCOPE.prototype.details = function CMSCOPE() {
        return this.x;
    }
    CMSCOPE.prototype.get = function CMSCOPE() {
        var options = {
            in1:["Input ports sizes",this.in1.toString().replace(/,/g," ")],
            clrs:["Drawing colors (>0) or mark (<0)",this.clrs.toString().replace(/,/g," ")],
            win:["Output window number (-1 for automatic)",this.win],
            wpos:["Output window position",this.wpos.toString().replace(/,/g," ")],
            wdim:["Output window sizes",this.wdim.toString().replace(/,/g," ")],
            ymin:["Ymin vector",this.ymin.toString().replace(/,/g," ")],
            ymax:["Ymax vector",this.ymax.toString().replace(/,/g," ")],
            per:["Refresh period",this.per.toString().replace(/,/g," ")],
            N:["Buffer size",this.N],
            heritance:["Accept herited events 0/1",this.heritance],
            nom:["Name of Scope (label&Id)",this.nom],
        }
        return options;
    }
    CMSCOPE.prototype.set = function CMSCOPE() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.in1 = inverse(arguments[0]["in1"]);
            this.clrs = inverse(arguments[0]["clrs"]);
            this.win = parseFloat(arguments[0]["win"]);
            this.wpos = inverse(arguments[0]["wpos"]);
            this.wdim = inverse(arguments[0]["wdim"]);
            this.ymin = inverse(arguments[0]["ymin"]);
            this.ymax = inverse(arguments[0]["ymax"]);
            this.per = inverse(arguments[0]["per"]);
            this.N = parseFloat(arguments[0]["N"]);
            this.heritance = arguments[0]["heritance"];
            this.nom = arguments[0]["nom"];
            if (!ok) {
                break;
            }
            var mess = [];
            if (size(this.in1,"*")<=0) {
                var mess = [[mess],["Block must have at least one input port"],[" "]];
                var ok = false;
            }
            if (min(this.in1)<=0) {
                var mess = [[mess],["Port sizes must be positive"],[" "]];
                var ok = false;
            }
            if (size(this.clrs,"*")<sum(this.in1)) {
                var mess = [[mess],["Not enough colors defined (at least "+string(sum(this.in1))+")"],[" "]];
                var ok = false;
            }
            if (size(this.wpos,"*")!=0&&size(this.wpos,"*")!=2) {
                var mess = [[mess],["Window position must be [] or a 2 vector"],[" "]];
                var ok = false;
            }
            if (size(this.wdim,"*")!=0&&size(this.wdim,"*")!=2) {
                var mess = [[mess],["Window dim must be [] or a 2 vector"],[" "]];
                var ok = false;
            }
            if (this.win<-1) {
                var mess = [[mess],["Window number can\'t be  < -1"],[" "]];
                var ok = false;
            }
            if (size(this.per,"*")!=size(this.ymin,"*")) {
                var mess = [[mess],["Size of Refresh Period must equal size of Ymin/Ymax vector"],[" "]];
                var ok = false;
            }
            for (i=1;i<=size(this.per,"*");i+=1) {
                if ((this.per[i-1]<=0)) {
                    var mess = [[mess],["Refresh Period must be positive"],[" "]];
                    var ok = false;
                }
            }
            if (this.N<2) {
                var mess = [[mess],["Buffer size must be at least 2"],[" "]];
                var ok = false;
            }
            if (or(this.ymin>=this.ymax)) {
                var mess = [[mess],["Ymax must be greater than Ymin"],[" "]];
                var ok = false;
            }
            if (!or(this.heritance==[0,1])) {
                var mess = [[mess],["Accept herited events must be 0 or 1"],[" "]];
                var ok = false;
            }
            if (!ok) {
                message([["Some specified values are inconsistent:"],[" "],[mess]]);
                throw "user error";
            }
            if (ok) {
                this.in1 = this.in1.slice();
                var a = size(this.in1,1);
                var in2 = ones(a,1);
                var tmpvar0 = set_io(this.model,this.graphics,list([this.in1,in2],ones(a,1)),list(),ones(1-this.heritance,1),[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                if (this.wpos.length==0) {
                    this.wpos = [[-1],[-1]];
                }
                if (this.wdim.length==0) {
                    this.wdim = [[-1],[-1]];
                }
                if (ok) {
                    var period = transpose(this.per.slice());
                    var yy = [[transpose(this.ymin.slice())],[transpose(this.ymax.slice())]];
                    var rpar = [[0],[period.slice()],[yy.slice()]];
                    this.clrs = this.clrs.slice(1-1,sum(this.in1));
                    var ipar = [[this.win],[size(this.in1,"*")],[this.N],[this.wpos.slice()],[this.wdim.slice()],[this.in1.slice()],[this.clrs.slice()],[this.heritance]];
                    this.model.evtin = new ScilabDouble([ones(1-this.heritance,1)]);
                    this.model.dstate = new ScilabDouble([]);
                    this.model.rpar = new ScilabDouble(rpar);
                    this.model.ipar = new ScilabDouble(ipar);
                    this.model.label = new ScilabDouble([this.nom]);
                    this.graphics.id = new ScilabDouble([this.nom]);
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sinks/CSCOPE.sci" */
function CSCOPE() {
    CSCOPE.prototype.define = function CSCOPE() {
        this.win = -1;
        this.wdim = [[600],[400]];
        this.wpos = [[-1],[-1]];
        this.clrs = [[1],[3],[5],[7],[9],[11],[13],[15]];
        this.N = 20;
        this.ymin = -15;
        this.ymax = 15;
        this.per = 30;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["cscope"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([0],[this.ymin],[this.ymax],[this.per]);
        this.model.ipar = new ScilabDouble([this.win],[1],[this.N],[this.clrs],[this.wpos],[this.wdim]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[strcat(string(this.clrs)," ")],[string(this.win)],[sci2exp([])],[sci2exp(this.wdim)],[string(this.ymin)],[string(this.ymax)],[string(this.per)],[string(this.N)],[transpose(string(0))],[emptystr()]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CSCOPE\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    CSCOPE.prototype.details = function CSCOPE() {
        return this.x;
    }
    CSCOPE.prototype.get = function CSCOPE() {
        var options = {
            clrs:["Color (>0) or mark (<0) vector (8 entries)",this.clrs.toString().replace(/,/g," ")],
            win:["Output window number (-1 for automatic)",this.win],
            wpos:["Output window position",this.wpos.toString().replace(/,/g," ")],
            wdim:["Output window sizes",this.wdim.toString().replace(/,/g," ")],
            ymin:["Ymin",this.ymin],
            ymax:["Ymax",this.ymax],
            per:["Refresh period",this.per],
            N:["Buffer size",this.N],
            heritance:["Accept herited events 0/1",this.heritance],
            nom:["Name of Scope (label&Id)",this.nom],
        }
        return options;
    }
    CSCOPE.prototype.set = function CSCOPE() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.clrs = inverse(arguments[0]["clrs"]);
            this.win = parseFloat(arguments[0]["win"]);
            this.wpos = inverse(arguments[0]["wpos"]);
            this.wdim = inverse(arguments[0]["wdim"]);
            this.ymin = parseFloat(arguments[0]["ymin"]);
            this.ymax = parseFloat(arguments[0]["ymax"]);
            this.per = parseFloat(arguments[0]["per"]);
            this.N = parseFloat(arguments[0]["N"]);
            this.heritance = arguments[0]["heritance"];
            this.nom = arguments[0]["nom"];
            if (!ok) {
                break;
            }
            var mess = [];
            if (size(this.wpos,"*")!=0&&size(this.wpos,"*")!=2) {
                var mess = [[mess],["Window position must be [] or a 2 vector"],[" "]];
                var ok = false;
            }
            if (size(this.wdim,"*")!=0&&size(this.wdim,"*")!=2) {
                var mess = [[mess],["Window dim must be [] or a 2 vector"],[" "]];
                var ok = false;
            }
            if (this.win<-1) {
                var mess = [[mess],["Window number can\'t be  < -1"],[" "]];
                var ok = false;
            }
            if (this.per<=0) {
                var mess = [[mess],["Refresh period must be positive"],[" "]];
                var ok = false;
            }
            if (this.N<2) {
                var mess = [[mess],["Buffer size must be at least 2"],[" "]];
                var ok = false;
            }
            if (this.ymin>=this.ymax) {
                var mess = [[mess],["Ymax must be greater than Ymin"],[" "]];
                var ok = false;
            }
            if (!or(this.heritance==[0,1])) {
                var mess = [[mess],["Accept herited events must be 0 or 1"],[" "]];
                var ok = false;
            }
            if (!ok) {
                message([["Some specified values are inconsistent:"],[" "],[mess]]);
                throw "user error";
            }
            if (ok) {
                var tmpvar0 = set_io(this.model,this.graphics,list([-1,1],1),list(),ones(1-this.heritance,1),[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                if (this.wpos.length==0) {
                    this.wpos = [[-1],[-1]];
                }
                if (this.wdim.length==0) {
                    this.wdim = [[-1],[-1]];
                }
                var rpar = [[0],[this.ymin],[this.ymax],[this.per]];
                var ipar = [[this.win],[1],[this.N],[this.clrs.slice()],[this.wpos.slice()],[this.wdim.slice()]];
                this.model.rpar = new ScilabDouble(rpar);
                this.model.ipar = new ScilabDouble(ipar);
                this.model.evtin = new ScilabDouble([ones(1-this.heritance,1)]);
                this.model.label = new ScilabDouble([this.nom]);
                this.graphics.id = new ScilabDouble([this.nom]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sinks/CSCOPXY.sci" */
function CSCOPXY() {
    CSCOPXY.prototype.define = function CSCOPXY() {
        this.win = -1;
        this.clrs = 4;
        this.siz = 1;
        this.wdim = [[600],[400]];
        this.wpos = [[-1],[-1]];
        this.N = 2;
        this.xmin = -15;
        this.xmax = 15;
        this.ymin = -15;
        this.ymax = 15;
        this.nbr_curves = 1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["cscopxy"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([1],[1]);
        this.model.in2 = new ScilabDouble([1],[1]);
        this.model.intyp = new ScilabDouble([1],[1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([this.xmin],[this.xmax],[this.ymin],[this.ymax]);
        this.model.ipar = new ScilabDouble([this.win],[1],[this.N],[this.clrs],[this.siz],[1],[this.wpos.slice()],[this.wdim.slice()],[this.nbr_curves]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [[string(this.nbr_curves)],[sci2exp(this.clrs)],[sci2exp(this.siz)],[string(this.win)],[sci2exp([])],[sci2exp(this.wdim)],[string(this.xmin)],[string(this.xmax)],[string(this.ymin)],[string(this.ymax)],[string(this.N)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CSCOPXY\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    CSCOPXY.prototype.details = function CSCOPXY() {
        return this.x;
    }
    CSCOPXY.prototype.get = function CSCOPXY() {
        var options = {
            nbr_curves:["Number of Curves",this.nbr_curves],
            clrs:["color (>0) or mark (<0)",this.clrs],
            siz:["line or mark size",this.siz],
            win:["Output window number (-1 for automatic)",this.win],
            wpos:["Output window position",this.wpos.toString().replace(/,/g," ")],
            wdim:["Output window sizes",this.wdim.toString().replace(/,/g," ")],
            xmin:["Xmin",this.xmin],
            xmax:["Xmax",this.xmax],
            ymin:["Ymin",this.ymin],
            ymax:["Ymax",this.ymax],
            N:["Buffer size",this.N],
        }
        return options;
    }
    CSCOPXY.prototype.set = function CSCOPXY() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.nbr_curves = parseFloat(arguments[0]["nbr_curves"]);
            this.clrs = parseFloat(arguments[0]["clrs"]);
            this.siz = parseFloat(arguments[0]["siz"]);
            this.win = parseFloat(arguments[0]["win"]);
            this.wpos = inverse(arguments[0]["wpos"]);
            this.wdim = inverse(arguments[0]["wdim"]);
            this.xmin = parseFloat(arguments[0]["xmin"]);
            this.xmax = parseFloat(arguments[0]["xmax"]);
            this.ymin = parseFloat(arguments[0]["ymin"]);
            this.ymax = parseFloat(arguments[0]["ymax"]);
            this.N = parseFloat(arguments[0]["N"]);
            if (!ok) {
                break;
            }
            var mess = [];
            if (size(this.wpos,"*")!=0&&size(this.wpos,"*")!=2) {
                var mess = [[mess],["Window position must be [] or a 2 vector"],[" "]];
                var ok = false;
            }
            if (size(this.wdim,"*")!=0&&size(this.wdim,"*")!=2) {
                var mess = [[mess],["Window dim must be [] or a 2 vector"],[" "]];
                var ok = false;
            }
            if (this.nbr_curves<=0) {
                var mess = [[mess],["Number of Curves cannot be negative or null"],[" "]];
                var ok = false;
            }
            if (this.win<-1) {
                var mess = [[mess],["Window number cannot be inferior than -1"],[" "]];
                var ok = false;
            }
            if (this.N<1) {
                var mess = [[mess],["Buffer size must be at least 1"],[" "]];
                var ok = false;
            }
            if (this.N==1&&this.clrs>0) {
                var mess = [[mess],["Buffer size must be at least 2"],[" "]];
                var ok = false;
            }
            if (this.ymin>=this.ymax) {
                var mess = [[mess],["Ymax must be greater than Ymin"],[" "]];
                var ok = false;
            }
            if (this.xmin>=this.xmax) {
                var mess = [[mess],["Xmax must be greater than Xmin"],[" "]];
                var ok = false;
            }
            if (!ok) {
                message(mess);
                throw "user error";
            } else {
                var in1 = this.nbr_curves*ones(2,1);
                var in2 = ones(2,1);
                var tmpvar0 = set_io(this.model,this.graphics,list([in1,in2],ones(2,1)),list(),ones(1,1),[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                if (this.wpos.length==0) {
                    this.wpos = [[-1],[-1]];
                }
                if (this.wdim.length==0) {
                    this.wdim = [[-1],[-1]];
                }
                var rpar = [[this.xmin],[this.xmax],[this.ymin],[this.ymax]];
                var ipar = [[this.win],[1],[this.N],[this.clrs],[this.siz],[1],[this.wpos.slice()],[this.wdim.slice()],[this.nbr_curves]];
                this.model.rpar = new ScilabDouble(rpar);
                this.model.ipar = new ScilabDouble(ipar);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sinks/CSCOPXY3D.sci" */
function CSCOPXY3D() {
    CSCOPXY3D.prototype.define = function CSCOPXY3D() {
        this.win = -1;
        this.clrs = [[1],[2],[3],[4],[5],[6],[7],[13]];
        this.siz = [[1],[1],[1],[1],[1],[1],[1],[1]];
        this.wdim = [[600],[400]];
        this.wpos = [[-1],[-1]];
        this.N = 2;
        this.param3ds = [[50],[280]];
        this.vec_x = [[-15],[15]];
        this.vec_y = [[-15],[15]];
        this.vec_z = [[-15],[15]];
        this.nbr_curves = 1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["cscopxy3d"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([1],[1],[1]);
        this.model.in2 = new ScilabDouble([1],[1],[1]);
        this.model.intyp = new ScilabDouble([1],[1],[1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([this.vec_x.slice()],[this.vec_y.slice()],[this.vec_z.slice()],[this.param3ds.slice()]);
        this.model.ipar = new ScilabDouble([this.win],[8],[this.N],[this.clrs.slice()],[this.siz.slice()],[8],[this.wpos.slice()],[this.wdim.slice()],[this.nbr_curves]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [[string(this.nbr_curves)],[strcat(string(this.clrs)," ")],[strcat(string(this.siz)," ")],[string(this.win)],[sci2exp([])],[sci2exp(this.wdim)],[strcat(string(this.vec_x)," ")],[strcat(string(this.vec_y)," ")],[strcat(string(this.vec_z)," ")],[strcat(string(this.param3ds)," ")],[string(this.N)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CSCOPXY3D\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    CSCOPXY3D.prototype.details = function CSCOPXY3D() {
        return this.x;
    }
    CSCOPXY3D.prototype.get = function CSCOPXY3D() {
        var options = {
            nbr_curves:["Number of curves",this.nbr_curves],
            clrs:["color (>0) or mark (<0)",this.clrs.toString().replace(/,/g," ")],
            siz:["Line or Mark Size",this.siz.toString().replace(/,/g," ")],
            win:["Output window number (-1 for automatic)",this.win],
            wpos:["Output window position",this.wpos.toString().replace(/,/g," ")],
            wdim:["Output window sizes",this.wdim.toString().replace(/,/g," ")],
            vec_x:["Xmin and Xmax",this.vec_x.toString().replace(/,/g," ")],
            vec_y:["Ymin and Ymax",this.vec_y.toString().replace(/,/g," ")],
            vec_z:["Zmin and Zmax",this.vec_z.toString().replace(/,/g," ")],
            param3ds:["Alpha and Theta",this.param3ds.toString().replace(/,/g," ")],
            N:["Buffer size",this.N],
        }
        return options;
    }
    CSCOPXY3D.prototype.set = function CSCOPXY3D() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.nbr_curves = parseFloat(arguments[0]["nbr_curves"]);
            this.clrs = inverse(arguments[0]["clrs"]);
            this.siz = inverse(arguments[0]["siz"]);
            this.win = parseFloat(arguments[0]["win"]);
            this.wpos = inverse(arguments[0]["wpos"]);
            this.wdim = inverse(arguments[0]["wdim"]);
            this.vec_x = inverse(arguments[0]["vec_x"]);
            this.vec_y = inverse(arguments[0]["vec_y"]);
            this.vec_z = inverse(arguments[0]["vec_z"]);
            this.param3ds = inverse(arguments[0]["param3ds"]);
            this.N = parseFloat(arguments[0]["N"]);
            if (!ok) {
                break;
            }
            var mess = [];
            if (size(this.wpos,"*")!=0&&size(this.wpos,"*")!=2) {
                var mess = [[mess],["Window position must be [] or a 2 vector"],[" "]];
                var ok = false;
            }
            if (size(this.wdim,"*")!=0&&size(this.wdim,"*")!=2) {
                var mess = [[mess],["Window dim must be [] or a 2 vector"],[" "]];
                var ok = false;
            }
            if (size(this.clrs,"*")!=size(this.siz,"*")) {
                var mess = [[mess],["Colors and Size must have same size"],[" "]];
                var ok = false;
            }
            if (this.nbr_curves<=0) {
                var mess = [[mess],["Number of curves cannot be negative or null"],[" "]];
                var ok = false;
            }
            if (this.win<-1) {
                var mess = [[mess],["Window number cannot be inferior than -1"],[" "]];
                var ok = false;
            }
            if (this.N<1) {
                var mess = [[mess],["Buffer size must be at least 1"],[" "]];
                var ok = false;
            }
            if (this.N<2) {
                for (i=1;i<=size(this.clrs,"*");i+=1) {
                    if (this.clrs[i-1]>0) {
                        var mess = [[mess],["Buffer size must be at least 2 or Change a color (must be >0)"],[" "]];
                        var ok = false;
                    }
                }
            }
            if (this.vec_y[1-1]>=this.vec_y[2-1]) {
                var mess = [[mess],["Ymax must be higher than Ymin"],[" "]];
                var ok = false;
            }
            if (this.vec_x[1-1]>=this.vec_x[2-1]) {
                var mess = [[mess],["Xmax must be higher than Xmin"],[" "]];
                var ok = false;
            }
            if (this.vec_z[1-1]>=this.vec_z[2-1]) {
                var mess = [[mess],["Zmax must be higher than Zmin"],[" "]];
                var ok = false;
            }
            if (ok) {
                var in1 = this.nbr_curves*ones(3,1);
                var in2 = ones(3,1);
                var tmpvar0 = set_io(this.model,this.graphics,list([in1,in2],ones(3,1)),list(),ones(1,1),[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                if (this.wpos.length==0) {
                    this.wpos = [[-1],[-1]];
                }
                if (this.wdim.length==0) {
                    this.wdim = [[-1],[-1]];
                }
                var rpar = [[this.vec_x.slice()],[this.vec_y.slice()],[this.vec_z.slice()],[this.param3ds.slice()]];
                var size_siz = size(this.siz,"*");
                var ipar = [[this.win],[size_siz],[this.N],[this.clrs.slice()],[this.siz.slice()],[1],[this.wpos.slice()],[this.wdim.slice()],[this.nbr_curves]];
                this.model.rpar = new ScilabDouble(rpar);
                this.model.ipar = new ScilabDouble(ipar);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            } else {
                message(mess);
                throw "user error";
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sinks/OUTIMPL_f.sci" */
function OUTIMPL_f() {
    OUTIMPL_f.prototype.define = function OUTIMPL_f() {
        this.model = scicos_model();
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([1]);
        this.prt = 1;
        this.model.sim = new ScilabString(["outimpl"]);
        this.model.ipar = new ScilabDouble([1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        var mo = modelica();
        mo.model = "PORT";
        mo.inputs = "n";
        this.model.equations = new ScilabDouble([mo]);
        this.exprs = "1";
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"OUTIMPL_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([1,1]),this.model,new ScilabString([this.exprs]),this.gr_i);
        this.x.graphics.in_implicit = ["I"];
        return new ImplicitOutBlock(this.x);
    }
    OUTIMPL_f.prototype.details = function OUTIMPL_f() {
        return this.x;
    }
    OUTIMPL_f.prototype.get = function OUTIMPL_f() {
        var options = {
            prt:["Port number",this.prt],
        }
        return options;
    }
    OUTIMPL_f.prototype.set = function OUTIMPL_f() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")==2) {
            this.exprs = this.exprs[1-1];
        }
        while (true) {
            var ok = true;
            this.prt = parseFloat(arguments[0]["prt"]);
            if (!ok) {
                break;
            }
            this.prt = int(this.prt);
            if (this.prt<=0) {
                block_parameter_error(msprintf("Wrong value for \'Port Number\' parameter: %d.",this.prt),"Strictly positive integer expected.");
            } else {
                if (this.model.ipar!=this.prt) {
                    var needcompile = 4;
                    var y = needcompile;
                }
                this.model.ipar = new ScilabDouble([this.prt]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new ImplicitOutBlock(this.x);
    }
}
/* autogenerated from "macros/Sinks/OUT_f.sci" */
function OUT_f() {
    OUT_f.prototype.define = function OUT_f() {
        var n = -1;
        this.prt = 1;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["output"]);
        this.model.in = new ScilabDouble([-1]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([-1]);
        this.model.ipar = new ScilabDouble([this.prt]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = string(this.prt);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"OUT_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([1,1]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new ExplicitOutBlock(this.x);
    }
    OUT_f.prototype.details = function OUT_f() {
        return this.x;
    }
    OUT_f.prototype.get = function OUT_f() {
        var options = {
            prt:["Port number",this.prt],
        }
        return options;
    }
    OUT_f.prototype.set = function OUT_f() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")==2) {
            this.exprs = this.exprs[1-1];
        }
        while (true) {
            var ok = true;
            this.prt = parseFloat(arguments[0]["prt"]);
            if (!ok) {
                break;
            }
            this.prt = int(this.prt);
            if (this.prt<=0) {
                block_parameter_error(msprintf("Wrong value for \'Port Number\' parameter: %d.",this.prt),"Strictly positive integer expected.");
            } else {
                this.model.ipar = new ScilabDouble([this.prt]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new ExplicitOutBlock(this.x);
    }
}
/* autogenerated from "macros/Sinks/TOWS_c.sci" */
function TOWS_c() {
    TOWS_c.prototype.define = function TOWS_c() {
        var nu = -1;
        this.nz = 128;
        this.varnam = "A";
        this.herit = 0;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["tows_c"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([nu]);
        this.model.in2 = new ScilabDouble([-2]);
        this.model.intyp = new ScilabDouble([-1]);
        this.model.out = new ScilabDouble([]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.evtout = new ScilabDouble([]);
        this.model.rpar = new ScilabDouble([]);
        this.model.ipar = new ScilabDouble([this.nz],[length(this.varnam)],[transpose(this.ascii[this.varnam-1])]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"TOWS_c\",sz(1),sz(2));"]);
        this.exprs = [[string(this.nz)],[string(this.varnam)],[string(this.herit)]];
        this.x = new standard_define(new ScilabDouble([4,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    TOWS_c.prototype.details = function TOWS_c() {
        return this.x;
    }
    TOWS_c.prototype.get = function TOWS_c() {
        var options = {
            nz:["Size of buffer",this.nz],
            varnam:["Scilab variable name",this.varnam],
            herit:["Inherit (no:0, yes:1)",this.herit],
        }
        return options;
    }
    TOWS_c.prototype.set = function TOWS_c() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.nz = parseFloat(arguments[0]["nz"]);
            this.varnam = arguments[0]["varnam"];
            this.herit = parseFloat(arguments[0]["herit"]);
            if (!ok) {
                break;
            }
            if ((this.nz<=0)) {
                message("Size of buffer must be positive");
                throw "user error";
                var ok = false;
            }
            var r = false;
            var ierr = execstr("r = validvar(varnam)","errcatch");
            if (!r||ierr!=0||length(this.varnam)>19) {
                message([["Invalid variable name."],["Please choose another variable name."]]);
                throw "user error";
                var ok = false;
            }
            execstr("if type("+this.varnam+") <> 17 | or(fieldnames("+this.varnam+") <> [\"values\"; \"time\"]) then"+" message([\"Protected variable name.\"; \"Please choose another variable name.\"]);"+" ok = %f;"+" end","errcatch");
            if (ok) {
                var tmpvar0 = set_io(this.model,this.graphics,list([-1,-2],-1),list(),ones(1-this.herit,1),[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                if (this.herit==1) {
                    this.model.blocktype = new ScilabString(["x"]);
                } else {
                    this.model.blocktype = new ScilabString(["d"]);
                }
                this.model.ipar = new ScilabDouble([this.nz],[length(this.varnam)],[transpose(this.ascii[this.varnam-1])]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sinks/TRASH_f.sci" */
function TRASH_f() {
    TRASH_f.prototype.define = function TRASH_f() {
        var in1 = -1;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["trash"]);
        this.model.in = new ScilabDouble([in1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = " ";
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"TRASH_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    TRASH_f.prototype.details = function TRASH_f() {
        return this.x;
    }
    TRASH_f.prototype.get = function TRASH_f() {
        alert("parameters cannot be modified");
    }
    TRASH_f.prototype.set = function TRASH_f() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sinks/WFILE_f.sci" */
function WFILE_f() {
    WFILE_f.prototype.define = function WFILE_f() {
        this.in1 = 1;
        var nin = sum(this.in1);
        var frmt = "(7(e10.3,1x))";
        var fname = "foo";
        var lunit = 0;
        this.N = 2;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["writef"]);
        this.model.in = new ScilabDouble([this.in1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble([-1],[lunit],[zeros((nin+1)*this.N,1)]);
        this.model.ipar = new ScilabDouble([length(fname)],[length(frmt)],[0],[this.N],[this._str2code[fname-1]],[this._str2code[frmt-1]]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[sci2exp(this.in1)],[fname],[frmt],[string(this.N)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"WFILE_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    WFILE_f.prototype.details = function WFILE_f() {
        return this.x;
    }
    WFILE_f.prototype.get = function WFILE_f() {
        var options = {
            in1:["Input Size",this.in1],
            fname1:["Output File Name",this.fname1],
            frmt1:["Output Format",this.frmt1],
            N:["Buffer Size",this.N],
        }
        return options;
    }
    WFILE_f.prototype.set = function WFILE_f() {
        warnobsolete("WRITEC_f","6.0.0");
        var warnMessage = msprintf("Feature %s is obsolete.","WFILE_f");
        var warnAdvise = msprintf("Please use %s instead.","WRITEC_f");
        var warnXcosMessage = msprintf("%s %s",warnMessage,warnAdvise);
        this.exprs = this.graphics.exprs;
        var dstate = this.model.dstate;
        var lunit = dstate[2-1];
        var fname = this.exprs[2-1];
        var frmt = this.exprs[3-1];
        while (true) {
            var ok = true;
            this.in1 = parseFloat(arguments[0]["in1"]);
            this.fname1 = parseFloat(arguments[0]["fname1"]);
            this.frmt1 = parseFloat(arguments[0]["frmt1"]);
            this.N = parseFloat(arguments[0]["N"]);
            if (!ok) {
                break;
            }
            this.in1 = int(this.in1);
            var nin = this.in1;
            this.fname1 = pathconvert(stripblanks(this.fname1),false,true);
            this.frmt1 = stripblanks(this.frmt1);
            if (lunit>0&&min(length(frmt),1)!=min(length(this.frmt1),1)) {
                block_parameter_error("Simulation running !!! You cannot switch<br />between formatted and unformatted when running","End current simulation first.");
                var ok = false;
            } else if (lunit>0&&this.fname1!=fname) {
                block_parameter_error("You cannot modify \'Output File Name\' when running.","End current simulation first.");
                var ok = false;
            } else if (this.fname1=="") {
                block_parameter_error("Wrong value for \'Output File Name\' parameter","You must provide a filename.");
                var ok = false;
            } else if (fileparts(this.fname1)!="") {
                var tmpvar0 = fileparts(this.fname1);
                var pa = tmpvar0[0];
                var fn = tmpvar0[1];
                var ex = tmpvar0[2];
                if (!this.isdir[pa-1]) {
                    block_parameter_error(msprintf("Wrong value for \'%s\' parameter.","Output File Name"),msprintf("Directory \'%s\' does not exist",pa));
                    var ok = false;
                }
            } else if (this.frmt1!=""&&(part(this.frmt1,1)!="("||part(this.frmt1,length(this.frmt1))!=")")) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %s.","Input Format",this.frmt1),"You must enclose the format\'s string between parentheses.");
                var ok = false;
            } else if (this.N<2) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Buffer Size",this.N),"Must be greater than 1.");
                var ok = false;
            } else if (this.in1<=0) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Input Size",this.in1),"Strictly positive integer expected.");
                var ok = false;
            }
            if (ok) {
                var ipar = [[length(this.fname1)],[length(this.frmt1)],[0],[this.N],[this._str2code[this.fname1-1]],[this._str2code[this.frmt1-1]]];
                if (prod(size(dstate))!=(nin+1)*this.N+2) {
                    var dstate = [[-1],[lunit],[zeros((nin+1)*this.N,1)]];
                }
                this.model.in = new ScilabDouble([nin]);
                this.model.dstate = new ScilabDouble(dstate);
                this.model.ipar = new ScilabDouble(ipar);
                this.model.dep_ut = new ScilabBoolean([true,false]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sinks/WRITEAU_f.sci" */
function WRITEAU_f() {
    WRITEAU_f.prototype.define = function WRITEAU_f() {
        var in1 = 1;
        var nin = sum(in1);
        var frmt = "uc ";
        var fname = "/dev/audio";
        this.swap = 0;
        var lunit = 0;
        this.N = 2;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["writeau"]), new ScilabDouble([2]));
        this.model.in = new ScilabDouble([in1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble([-1],[lunit],[zeros((nin+1)*this.N,1)]);
        this.model.ipar = new ScilabDouble([length(fname)],[this._str2code[frmt-1]],[this.N],[this.swap],[this._str2code[fname-1]]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [string(this.N),string(this.swap)];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"WRITEAU_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([4,2]),this.model,new ScilabString(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    WRITEAU_f.prototype.details = function WRITEAU_f() {
        return this.x;
    }
    WRITEAU_f.prototype.get = function WRITEAU_f() {
        var options = {
            N:["Buffer Size",this.N],
            swap:["Swap Mode (0:No, 1:Yes)",this.swap],
        }
        return options;
    }
    WRITEAU_f.prototype.set = function WRITEAU_f() {
        this.exprs = this.graphics.exprs;
        var ipar = this.model.ipar;
        var dstate = this.model.dstate;
        var lunit = dstate[2-1];
        while (true) {
            var ok = true;
            this.N = parseFloat(arguments[0]["N"]);
            this.swap = parseFloat(arguments[0]["swap"]);
            if (!ok) {
                break;
            }
            var nin = 1;
            var fname1 = "/dev/audio";
            var frmt1 = "uc ";
            if (this.alreadyran&&(this.N!=ipar[5-1])) {
                block_parameter_error(msprintf("You cannot modify \'%s\' when running.","Buffer Size"),"End current simulation first");
                var ok = false;
            } else if (this.N<1) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Buffer Size",this.N),"Strictly positive integer expected.");
                var ok = false;
            }
            if (this.swap!=0&&this.swap!=1) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Swap Mode",this.swap),msprintf("Must be in the interval %s.","[0, 1]"));
                var ok = false;
            }
            if (ok) {
                var ipar = [[length(fname1)],[this._str2code[frmt1-1]],[this.N],[this.swap],[this._str2code[fname1-1]]];
                if (prod(size(dstate))!=(nin+1)*this.N+2) {
                    var dstate = [[-1],[lunit],[zeros((nin+1)*this.N,1)]];
                }
                this.model.in = new ScilabDouble([1]);
                this.model.dstate = new ScilabDouble(dstate);
                this.model.ipar = new ScilabDouble(ipar);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sinks/WRITEC_f.sci" */
function WRITEC_f() {
    WRITEC_f.prototype.define = function WRITEC_f() {
        this.in1 = 1;
        var nin = sum(this.in1);
        var frmt = "c  ";
        var fname = "foo";
        this.swap = 0;
        var lunit = 0;
        this.N = 2;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["writec"]), new ScilabDouble([2]));
        this.model.in = new ScilabDouble([this.in1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble([-1],[lunit],[zeros((nin+1)*this.N,1)]);
        this.model.ipar = new ScilabDouble([length(fname)],[this._str2code[frmt-1]],[this.N],[this.swap],[this._str2code[fname-1]]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[sci2exp(this.in1)],[fname],[frmt],[string(this.N),string(this.swap)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"WRITEC_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([4,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    WRITEC_f.prototype.details = function WRITEC_f() {
        return this.x;
    }
    WRITEC_f.prototype.get = function WRITEC_f() {
        var options = {
            in1:["Input Size",this.in1],
            fname1:["Output File Name",this.fname1],
            frmt1:["Output Format",this.frmt1],
            N:["Buffer Size",this.N],
            swap:["Swap Mode (0:No, 1:Yes)",this.swap],
        }
        return options;
    }
    WRITEC_f.prototype.set = function WRITEC_f() {
        this.exprs = this.graphics.exprs;
        var ipar = this.model.ipar;
        var dstate = this.model.dstate;
        var lunit = dstate[2-1];
        var fname = this.exprs[2-1];
        var frmt = this.exprs[3-1];
        while (true) {
            var ok = true;
            this.in1 = parseFloat(arguments[0]["in1"]);
            this.fname1 = parseFloat(arguments[0]["fname1"]);
            this.frmt1 = arguments[0]["frmt1"];
            this.N = parseFloat(arguments[0]["N"]);
            this.swap = parseFloat(arguments[0]["swap"]);
            if (!ok) {
                break;
            }
            this.in1 = int(this.in1);
            var nin = this.in1;
            this.fname1 = pathconvert(stripblanks(this.fname1),false,true);
            this.frmt1 = stripblanks(this.frmt1);
            var fmts = ["s","l","d","f","c","us","ul","uc","ull","uls","ubl","ubs","dl","fl","ll","sl","db","fb","lb","sb"];
            if (and(this.frmt1!=fmts)) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %s.","Input Format",this.frmt1),"Valid formats are: "+strcat(fmts,", "));
                var ok = false;
            } else if (this.alreadyran&&this.fname1!=fname) {
                block_parameter_error(msprintf("You cannot modify \'%s\' when running","Input Format"),"End current simulation first.");
                var ok = false;
            } else if (this.alreadyran&&this.N!=ipar[5-1]) {
                block_parameter_error(msprintf("You cannot modify \'Buffer Size\' when running.","Buffer Size"),"End current simulation first");
                var ok = false;
            } else if (this.fname1=="") {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter.","Output File Name"),"You must provide a filename.");
            } else if (fileparts(this.fname1)!="") {
                var tmpvar0 = fileparts(this.fname1);
                var pa = tmpvar0[0];
                var fn = tmpvar0[1];
                var ex = tmpvar0[2];
                if (!this.isdir[pa-1]) {
                    block_parameter_error(msprintf("Wrong value for \'%s\' parameter.","Output File Name"),msprintf("Directory \'%s\' does not exist",pa));
                    var ok = false;
                }
            } else if (this.N<1) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Buffer Size",this.N),"Strictly positive integer expected.");
                var ok = false;
            } else if (this.in1<=0) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Input Size",this.in1),"Strictly positive integer expected.");
                var ok = false;
            } else if (this.swap!=0&&this.swap!=1) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Swap Mode",this.swap),msprintf("Must be in the interval %s.","[0, 1]"));
                var ok = false;
            }
            this.frmt1 = part(this.frmt1,1,3);
            if (ok) {
                var ipar = [[length(this.fname1)],[this._str2code[this.frmt1-1]],[this.N],[this.swap],[this._str2code[this.fname1-1]]];
                if (prod(size(dstate))!=(nin+1)*this.N+2) {
                    var dstate = [[-1],[lunit],[zeros((nin+1)*this.N,1)]];
                }
                this.model.in = new ScilabDouble([nin]);
                this.model.dstate = new ScilabDouble(dstate);
                this.model.ipar = new ScilabDouble(ipar);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/CLKINV_f.sci" */
function CLKINV_f() {
    CLKINV_f.prototype.define = function CLKINV_f() {
        this.prt = 1;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["input"]);
        this.model.evtout = new ScilabDouble([1]);
        this.model.ipar = new ScilabDouble([this.prt]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([-1]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = string(this.prt);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CLKINV_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([1,1]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new EventInBlock(this.x);
    }
    CLKINV_f.prototype.details = function CLKINV_f() {
        return this.x;
    }
    CLKINV_f.prototype.get = function CLKINV_f() {
        var options = {
            prt:["Port Number",this.prt],
        }
        return options;
    }
    CLKINV_f.prototype.set = function CLKINV_f() {
        this.exprs = this.graphics.exprs;
        this.exprs = this.exprs[1-1];
        while (true) {
            var ok = true;
            this.prt = parseFloat(arguments[0]["prt"]);
            this.prt = int(this.prt);
            if (!ok) {
                break;
            }
            if (this.prt<=0) {
                block_parameter_error(msprintf("Wrong values for \'Port Number\' parameter: %d.",this.prt),"Strictly positive integer expected.");
            } else {
                this.model.ipar = new ScilabDouble([this.prt]);
                this.model.evtout = new ScilabDouble([1]);
                this.model.firing = new ScilabDouble([-1]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new EventInBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/CLKIN_f.sci" */
function CLKIN_f() {
    CLKIN_f.prototype.define = function CLKIN_f() {
        this.prt = 1;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["input"]);
        this.model.evtout = new ScilabDouble([1]);
        this.model.ipar = new ScilabDouble([this.prt]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([-1]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = string(this.prt);
        this.x = new standard_define(new ScilabDouble([1,1]),this.model,new ScilabString([this.exprs])," ");
        return new BasicBlock(this.x);
    }
    CLKIN_f.prototype.details = function CLKIN_f() {
        return this.x;
    }
    CLKIN_f.prototype.get = function CLKIN_f() {
        var options = {
            prt:["Port number",this.prt],
        }
        return options;
    }
    CLKIN_f.prototype.set = function CLKIN_f() {
        this.exprs = this.graphics.exprs;
        this.exprs = this.exprs[1-1];
        while (true) {
            var ok = true;
            this.prt = parseFloat(arguments[0]["prt"]);
            this.prt = int(this.prt);
            if (!ok) {
                break;
            }
            if (this.prt<=0) {
                message("Port number must be a positive integer");
                throw "user error";
            } else {
                this.model.ipar = new ScilabDouble([this.prt]);
                this.model.evtout = new ScilabDouble([1]);
                this.model.firing = new ScilabDouble([-1]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/CLOCK_c.sci" */
function CLOCK_c() {
    CLOCK_c.prototype.define = function CLOCK_c() {
        var evtdly = EVTDLY_c("define");
        evtdly.graphics.orig = [320,232];
        evtdly.graphics.sz = [40,40];
        evtdly.graphics.flip = true;
        evtdly.graphics.exprs = [["0.1"],["0.1"]];
        evtdly.graphics.pein = 6;
        evtdly.graphics.peout = 3;
        evtdly.model.rpar = [[0.1],[0.1]];
        evtdly.model.firing = 0.1;
        var output_port = CLKOUT_f("define");
        output_port.graphics.orig = [399,162];
        output_port.graphics.sz = [20,20];
        output_port.graphics.flip = true;
        output_port.graphics.exprs = "1";
        output_port.graphics.pein = 5;
        output_port.model.ipar = 1;
        var split = CLKSPLIT_f("define");
        split.graphics.orig = [[380.71066],[172]];
        split.graphics.pein = 3;
        split.graphics.peout = [[5],[6]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CLOCK_c\",sz(1),sz(2));"]);
        var diagram = scicos_diagram();
        diagram.objs[1-1] = output_port;
        diagram.objs[2-1] = evtdly;
        diagram.objs[3-1] = scicos_link(xx=[[340],[340],[380.71]],yy=[[226.29],[172],[172]],ct=[5,-1],from=[2,1],to=[4,1]);
        diagram.objs[4-1] = split;
        diagram.objs[5-1] = scicos_link(xx=[[380.71],[399]],yy=[[172],[172]],ct=[5,-1],from=[4,1],to=[1,1]);
        diagram.objs[6-1] = scicos_link(xx=[[380.71],[380.71],[340],[340]],yy=[[172],[302],[302],[277.71]],ct=[5,-1],from=[4,2],to=[2,1]);
        this.x = scicos_block();
        this.x.gui = "CLOCK_c";
        this.x.graphics.sz = [2,2];
        this.x.graphics.gr_i = this.gr_i;
        this.x.graphics.peout = 0;
        this.x.model.sim = "csuper";
        this.x.model.evtout = 1;
        this.x.model.blocktype = "h";
        this.x.model.firing = false;
        this.x.model.dep_ut = [false,false];
        this.x.model.rpar = diagram;
        return new BasicBlock(this.x);
    }
    CLOCK_c.prototype.details = function CLOCK_c() {
        return this.x;
    }
    CLOCK_c.prototype.get = function CLOCK_c() {
        var options = {
            dt:["Period",this.dt],
            t0:["Initialisation Time",this.t0],
        }
        return options;
    }
    CLOCK_c.prototype.set = function CLOCK_c() {
            if (typeof(o)=="Block"&&o.gui=="EVTDLY_c") {
                var path = i;
                break;
            }
        }
        var newpar = list();
        this.exprs = xx.graphics.exprs;
        this.model = xx.model;
        var t0_old = this.model.firing;
        var dt_old = this.model.rpar[1-1];
        var model_n = this.model;
        while (true) {
            var ok = true;
            this.dt = arguments[0]["dt"];
            this.t0 = arguments[0]["t0"];
            this.exprs0 = arguments[0]["exprs0"];
            if (!ok) {
                break;
            }
            if (this.dt<=0) {
                block_parameter_error(msprintf("Wrong values for \'%s\' parameter: %5.1e.","Period",this.dt),"Strictly positive number expected.");
                var ok = false;
            }
            if (ok) {
                xx.graphics.exprs = this.exprs0;
                this.model.rpar = new ScilabDouble([this.dt],[this.t0]);
                this.model.firing = new ScilabDouble([this.t0]);
                xx.model = this.model;
                break;
            }
        }
        if (!and([t0_old,dt_old]==[this.t0,this.dt])) {
            newpar[size(newpar)+1-1] = path;
        }
        if (t0_old!=this.t0) {
            var needcompile = 2;
        } else {
            var needcompile = 0;
        }
        var y = needcompile;
        var typ = newpar;
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/CLOCK_f.sci" */
function CLOCK_f() {
    CLOCK_f.prototype.define = function CLOCK_f() {
        var evtdly = EVTDLY_f("define");
        evtdly.graphics.orig = [320,232];
        evtdly.graphics.sz = [40,40];
        evtdly.graphics.flip = true;
        evtdly.graphics.exprs = [["0.1"],["0.1"]];
        evtdly.graphics.pein = 6;
        evtdly.graphics.peout = 3;
        evtdly.model.rpar = 0.1;
        evtdly.model.firing = 0.1;
        var output_port = CLKOUT_f("define");
        output_port.graphics.orig = [399,162];
        output_port.graphics.sz = [20,20];
        output_port.graphics.flip = true;
        output_port.graphics.exprs = "1";
        output_port.graphics.pein = 5;
        output_port.model.ipar = 1;
        var split = CLKSPLIT_f("define");
        split.graphics.orig = [[380.71066],[172]];
        split.graphics.pein = 3;
        split.graphics.peout = [[5],[6]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CLOCK_f\",sz(1),sz(2));"]);
        var diagram = scicos_diagram();
        diagram.objs[1-1] = output_port;
        diagram.objs[2-1] = evtdly;
        diagram.objs[3-1] = scicos_link(xx=[[340],[340],[380.71]],yy=[[226.29],[172],[172]],ct=[5,-1],from=[2,1],to=[4,1]);
        diagram.objs[4-1] = split;
        diagram.objs[5-1] = scicos_link(xx=[[380.71],[399]],yy=[[172],[172]],ct=[5,-1],from=[4,1],to=[1,1]);
        diagram.objs[6-1] = scicos_link(xx=[[380.71],[380.71],[340],[340]],yy=[[172],[302],[302],[277.71]],ct=[5,-1],from=[4,2],to=[2,1]);
        this.x = scicos_block();
        this.x.gui = "CLOCK_f";
        this.x.graphics.sz = [2,2];
        this.x.graphics.gr_i = this.gr_i;
        this.x.graphics.peout = 0;
        this.x.model.sim = "csuper";
        this.x.model.evtout = 1;
        this.x.model.blocktype = "h";
        this.x.model.firing = false;
        this.x.model.dep_ut = [false,false];
        this.x.model.rpar = diagram;
        return new BasicBlock(this.x);
    }
    CLOCK_f.prototype.details = function CLOCK_f() {
        return this.x;
    }
    CLOCK_f.prototype.get = function CLOCK_f() {
        var options = {
            dt:["Period",this.dt],
            t0:["Init time",this.t0],
        }
        return options;
    }
    CLOCK_f.prototype.set = function CLOCK_f() {
            if (typeof(o)=="Block"&&o.gui=="EVTDLY_f") {
                var path = i;
                break;
            }
        }
        var newpar = list();
        this.exprs = xx.graphics.exprs;
        this.model = xx.model;
        var t0_old = this.model.firing;
        var dt_old = this.model.rpar;
        var model_n = this.model;
        while (true) {
            var ok = true;
            this.dt = arguments[0]["dt"];
            this.t0 = arguments[0]["t0"];
            this.exprs0 = arguments[0]["exprs0"];
            if (!ok) {
                break;
            }
            if (this.dt<=0) {
                message("period must be positive");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                xx.graphics.exprs = this.exprs0;
                this.model.rpar = new ScilabDouble([this.dt]);
                this.model.firing = new ScilabDouble([this.t0]);
                xx.model = this.model;
                break;
            }
        }
        if (!and([t0_old,dt_old]==[this.t0,this.dt])||!and(this.exprs0==this.exprs)) {
            newpar[size(newpar)+1-1] = path;
        }
        if (t0_old!=this.t0) {
            var needcompile = 2;
        } else {
            var needcompile = 0;
        }
        var y = needcompile;
        var typ = newpar;
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/CONST.sci" */
function CONST() {
    CONST.prototype.define = function CONST() {
        this.C = 1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["cstblk4"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([]);
        this.model.out = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([this.C]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = strcat(sci2exp(this.C));
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CONST\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    CONST.prototype.details = function CONST() {
        return this.x;
    }
    CONST.prototype.get = function CONST() {
        var options = {
            C:["Constant",this.C],
        }
        return options;
    }
    CONST.prototype.set = function CONST() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.C = parseFloat(arguments[0]["C"]);
            if (!ok) {
                break;
            }
            var sz = size(this.C);
            var nout = size(this.C,"*");
            if (nout==0) {
                message("C must have at least one element");
                throw "user error";
            } else if (and(sz>1)) {
                message("C matrix is not supported, use CONST_m instead");
                throw "user error";
            } else {
                this.model.rpar = new ScilabDouble(this.C.slice());
                this.model.out = new ScilabDouble([nout]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/CONST_f.sci" */
function CONST_f() {
    CONST_f.prototype.define = function CONST_f() {
        this.C = 1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["cstblk"]), new ScilabDouble([1]));
        this.model.in = new ScilabDouble([]);
        this.model.out = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([this.C]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = strcat(sci2exp(this.C));
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CONST_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    CONST_f.prototype.details = function CONST_f() {
        return this.x;
    }
    CONST_f.prototype.get = function CONST_f() {
        var options = {
            C:["Constant",this.C],
        }
        return options;
    }
    CONST_f.prototype.set = function CONST_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.C = parseFloat(arguments[0]["C"]);
            if (!ok) {
                break;
            }
            var nout = size(this.C,"*");
            if (nout==0) {
                message("C must have at least one element");
                throw "user error";
            } else {
                this.model.rpar = new ScilabDouble(this.C.slice());
                this.model.out = new ScilabDouble([nout]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/CONST_m.sci" */
function CONST_m() {
    CONST_m.prototype.define = function CONST_m() {
        this.C = [1];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["cstblk4"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([]);
        this.model.out = new ScilabDouble([size(this.C,1)]);
        this.model.in2 = new ScilabDouble([]);
        this.model.out2 = new ScilabDouble([size(this.C,2)]);
        this.model.rpar = new ScilabDouble(this.C);
        this.model.opar = list();
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = sci2exp(this.C);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CONST_m\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    CONST_m.prototype.details = function CONST_m() {
        return this.x;
    }
    CONST_m.prototype.get = function CONST_m() {
        var options = {
            C:["Constant Value",this.C],
        }
        return options;
    }
    CONST_m.prototype.set = function CONST_m() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.C = inverse(arguments[0]["C"]);
            if (!ok) {
                break;
            }
            var nout = size(this.C);
            if (find(nout==0).length!=0) {
                block_parameter_error(msprintf("Wrong size for \'%s\' parameter","Constant Value"),"Constant value must have at least one element.");
            } else {
                this.model.sim = list(new ScilabString(["cstblk4_m"]), new ScilabDouble([4]));
                this.model.opar = list(this.C);
                if ((this.type[this.C-1]==1)) {
                    if (isreal(this.C)) {
                        var ot = 1;
                    } else {
                        var ot = 2;
                    }
                } else if ((typeof(this.C)=="int32")) {
                    var ot = 3;
                } else if ((typeof(this.C)=="int16")) {
                    var ot = 4;
                } else if ((typeof(this.C)=="int8")) {
                    var ot = 5;
                } else if ((typeof(this.C)=="uint32")) {
                    var ot = 6;
                } else if ((typeof(this.C)=="uint16")) {
                    var ot = 7;
                } else if ((typeof(this.C)=="uint8")) {
                    var ot = 8;
                } else {
                    block_parameter_error(msprintf("Wrong type for \'%s\' parameter","Constant Value"),"Value type must be a numeric type (double, complex, int, int8, ...).");
                    var ok = false;
                }
                if (ok) {
                    this.model.rpar = new ScilabDouble([]);
                    var tmpvar0 = set_io(this.model,this.graphics,list(),list(nout,ot),[],[]);
                    this.model = tmpvar0[0];
                    this.graphics = tmpvar0[1];
                    var ok = tmpvar0[2];
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/CURVE_c.sci" */
function CURVE_c() {
    CURVE_c.prototype.define = function CURVE_c() {
        this.model = scicos_model();
        this.xx = [0,1,2];
        this.yy = [10,20,-30];
        var N = 3;
        this.Method = 3;
        this.PeriodicOption = "y";
        var Graf = "n";
        this.model.sim = list(new ScilabString(["curve_c"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([]);
        this.model.out = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([this.xx.slice()],[this.yy.slice()]);
        this.model.ipar = new ScilabDouble([N],[this.Method],[1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.evtout = new ScilabDouble([1]);
        this.model.firing = new ScilabDouble([0]);
        this.exprs = [[sci2exp(this.Method)],[sci2exp(this.xx)],[sci2exp(this.yy)],[this.PeriodicOption],[Graf]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CURVE_c\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    CURVE_c.prototype.details = function CURVE_c() {
        return this.x;
    }
    CURVE_c.prototype.get = function CURVE_c() {
        var options = {
            Method:["Spline Method (0..7)",this.Method],
            xx:["x",this.xx],
            yy:["y",this.yy],
            PeriodicOption:["Periodic signal(y/n)?",this.PeriodicOption],
            graf:["Launch graphic window(y/n)?",this.graf],
        }
        return options;
    }
    CURVE_c.prototype.set = function CURVE_c() {
        this.exprs = this.graphics.exprs;
        var ok = false;
        var SaveExit = false;
        while (true) {
            var Ask_again = false;
            var ok = true;
            this.Method = parseFloat(arguments[0]["Method"]);
            this.xx = inverse(arguments[0]["xx"]);
            this.yy = inverse(arguments[0]["yy"]);
            this.PeriodicOption = arguments[0]["PeriodicOption"];
            this.graf = arguments[0]["graf"];
            if (!ok) {
                break;
            }
            if (this.PeriodicOption=="y"||this.PeriodicOption=="Y") {
                var PO = 1;
            } else {
                this.exprs[4-1] = "n";
                var PO = 0;
            }
            var mtd = int(this.Method);
            if (mtd<0) {
                var mtd = 0;
            }
            if (mtd>7) {
                var mtd = 7;
            }
            var METHOD = getmethod(mtd);
            if (!Ask_again) {
                this.xx = this.xx.slice();
                this.yy = this.yy.slice();
                var tmpvar0 = size(this.xx);
                var nx = tmpvar0[0];
                var mx = tmpvar0[1];
                var tmpvar1 = size(this.yy);
                var ny = tmpvar1[0];
                var my = tmpvar1[1];
                if (!((nx==ny)&&(mx==my))) {
                    messagebox("Incompatible size of [x] and [y]","modal","error");
                    var Ask_again = true;
                }
            }
            if (!Ask_again) {
                this.xy = [this.xx,this.yy];
                var tmpvar2 = cleandata(this.xy);
                this.xy = tmpvar2[0];
                var N = size(this.xy,"r");
                this.exprs[5-1] = "n";
                if (this.graf=="y"||this.graf=="Y") {
                    var ipar = [[N],[mtd],[PO]];
                    var rpar = [];
                    if ((winsid().length==0)) {
                        this.curwin = 0;
                    } else {
                        this.curwin = max(winsid())+1;
                    }
                    var tmpvar3 = poke_point(this.xy,ipar,rpar);
                    var orpar = tmpvar3[0];
                    var oipar = tmpvar3[1];
                    var ok = tmpvar3[2];
                    if (!ok) {
                        break;
                    }
                    var N2 = oipar[1-1];
                    var xy2 = [orpar.slice(1-1,N2),orpar.slice(N2+1-1,2*N2)];
                    var New_methhod = oipar[2-1];
                    var DChange = false;
                    var METHOD = getmethod(New_methhod);
                    if (or(this.xy.slice()[1-1]!=xy2.slice()[1-1])) {
                        var DChange = true;
                    }
                    if (or(this.xy.slice(1-1,N-1)[2-1]!=xy2.slice(1-1,N2-1)[2-1])) {
                        var DChange = true;
                    }
                    if ((this.xy[N-1][2-1]!=xy2[N2-1][2-1]&&(METHOD!="periodic"))) {
                        var DChange = true;
                    }
                    if (DChange) {
                        this.exprs[2-1] = strcat(sci2exp(xy2.slice()[1-1]));
                        this.exprs[3-1] = strcat(sci2exp(xy2.slice()[2-1]));
                    }
                    this.exprs[1-1] = sci2exp(New_methhod);
                    if (oipar[3-1]==1) {
                        var perop = "y";
                    } else {
                        var perop = "n";
                    }
                    this.exprs[4-1] = perop;
                    var SaveExit = true;
                } else {
                    var tmpvar4 = Do_Spline(N,mtd,this.xy.slice()[1-1],this.xy.slice()[2-1]);
                    var Xdummy = tmpvar4[0];
                    var Ydummy = tmpvar4[1];
                    var orpar = tmpvar4[2];
                    if ((METHOD=="periodic")) {
                        this.xy[N-1][2-1] = this.xy[1-1][2-1];
                    }
                    if ((METHOD=="order 2"||METHOD=="not_a_knot"||METHOD=="periodic"||METHOD=="monotone"||METHOD=="fast"||METHOD=="clamped")) {
                        var orpar = [[this.xy.slice()[1-1]],[this.xy.slice()[2-1]],[orpar]];
                    } else {
                        if ((METHOD=="zero order"||METHOD=="linear")) {
                            var orpar = [[this.xy.slice()[1-1]],[this.xy.slice()[2-1]]];
                        }
                    }
                    this.exprs[1-1] = sci2exp(mtd);
                    var oipar = [[N],[mtd],[PO]];
                    var SaveExit = true;
                }
            }
            if ((SaveExit)) {
                var xp = find(orpar.slice(1-1,oipar[1-1])>=0);
                if ((xp.length!=0)) {
                    this.model.firing = new ScilabDouble([orpar[xp[1-1]-1]]);
                } else {
                    this.model.firing = new ScilabDouble([-1]);
                }
                this.model.rpar = new ScilabDouble(orpar);
                this.model.ipar = new ScilabDouble(oipar);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.model = this.model;
                this.x.graphics = this.graphics;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/CURV_f.sci" */
function CURV_f() {
    CURV_f.prototype.define = function CURV_f() {
        var xx = [[0],[1],[2]];
        var yy = [[-5],[5],[0]];
        var rect = [0,-5,2,5];
        var axisdata = [[2],[10],[2],[10]];
        var ipar = [[size(xx,1)],[axisdata.slice()]];
        var rpar = [[xx],[yy],[rect.slice()]];
        this.model = scicos_model();
        this.model.sim = new ScilabString(["intplt"]);
        this.model.in = new ScilabDouble([]);
        this.model.out = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([xx],[yy],[rect.slice()]);
        this.model.ipar = new ScilabDouble([size(xx,1)],[axisdata.slice()]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"CURV_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble([]),this.gr_i);
        return new BasicBlock(this.x);
    }
    CURV_f.prototype.details = function CURV_f() {
        return this.x;
    }
    CURV_f.prototype.get = function CURV_f() {
        alert("parameters cannot be modified");
    }
    CURV_f.prototype.set = function CURV_f() {
        var rpar = this.model.rpar;
        var ipar = this.model.ipar;
        var n = ipar[1-1];
        var xx = rpar.slice(1-1,n);
        var yy = rpar.slice(n+1-1,2*n);
        var gc = list(rpar.slice(2*n+1-1,2*n+4),ipar.slice(2-1,5));
        while (true) {
            [ln,fun]=where()
            if (!or(fun=="do_eval")) {
                var tmpvar0 = edit_curv(xx,yy,"axy",[" "," "," "],gc);
                var xx = tmpvar0[0];
                var yy = tmpvar0[1];
                var ok = tmpvar0[2];
                var gc = tmpvar0[3];
            } else {
                var ok = true;
            }
            if (!ok) {
                break;
            }
            var n = size(xx,"*");
            if (or(xx.slice(2-1,n)-xx.slice(1-1,n-1)<0)) {
                message("You have not defined a function");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                this.model.sim = new ScilabString(["intplt"]);
                this.model.firing = new ScilabDouble([]);
                var rect = gc[1-1];
                this.model.rpar = new ScilabDouble([xx.slice()],[yy.slice()],[rect.slice()]);
                var axisdata = gc[2-1];
                this.model.ipar = new ScilabDouble([size(xx,"*")],[axisdata.slice()]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/Counter.sci" */
function Counter() {
    Counter.prototype.define = function Counter() {
        this.minim = 0;
        this.maxim = 2;
        this.rule = 1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["counter"]), new ScilabDouble([4]));
        this.model.evtin = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.out2 = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble([0]);
        this.model.ipar = new ScilabDouble([this.rule],[this.maxim],[this.minim]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [[string(this.minim)],[string(this.maxim)],[string(this.rule)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"Counter\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    Counter.prototype.details = function Counter() {
        return this.x;
    }
    Counter.prototype.get = function Counter() {
        var options = {
            minim:["Minimum",this.minim],
            maxim:["Maximum",this.maxim],
            rule:["Rule (1:Increment, 2:Decrement)",this.rule],
        }
        return options;
    }
    Counter.prototype.set = function Counter() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.minim = parseFloat(arguments[0]["minim"]);
            this.maxim = parseFloat(arguments[0]["maxim"]);
            this.rule = parseFloat(arguments[0]["rule"]);
            if (!ok) {
                break;
            }
            this.maxim = int(this.maxim);
            this.minim = int(this.minim);
            if (this.maxim<this.minim) {
                block_parameter_error(msprintf("Wrong values for \'Maximum\' and \'Minimum\' parameters: %d &lt; %d",this.minim,this.maxim),msprintf("\'Minimum\' must be less than \'Maximum\'."));
            } else if ((this.rule!=1&&this.rule!=2)) {
                block_parameter_error(msprintf("Wrong value for \'Rule\' parameter: %d",this.rule),msprintf("Must be in the interval %s.","[1,2]"));
            } else {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.dstate = new ScilabDouble([0]);
                this.model.ipar = new ScilabDouble([this.rule],[this.maxim],[this.minim]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/FROMWSB.sci" */
function FROMWSB() {
    FROMWSB.prototype.define = function FROMWSB() {
        var scs_m_1 = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[-159.096,811.104,-121.216,617.984,1323,1008,331,284,630,480,1426,231,1.4],Title="FROMWSB",tol=[0.0001,0.000001,1.000e-10,100001,0,0],tf=100000,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m_1.objs[1-1] = scicos_block(gui="FROMWS_c",graphics=scicos_graphics(orig=[260.37067,261.584],sz=[70,40],flip=true,theta=0,exprs=[["V"],["1"],["1"],["0"]],pin=[],pout=4,pein=2,peout=2,gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim=list("fromws_c",4),in1=[],in2=[],intyp=1,out=-1,out2=-2,outtyp=-1,evtin=1,evtout=1,state=[],dstate=[],odstate=list(),rpar=[],ipar=[[1],[-31],[1],[1],[0]],opar=list(),blocktype="d",firing=0,dep_ut=[false,true],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[2-1] = scicos_link(xx=[[295.37067],[295.37067],[233.23733],[233.23733],[295.37067],[295.37067]],yy=[[255.86971],[223.45067],[223.45067],[337.85067],[337.85067],[307.29829]],id="drawlink",thick=[0,0],ct=[5,-1],from=[1,1,0],to=[1,1,1]);
        scs_m_1.objs[3-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[358.9421,271.584],sz=[20,20],flip=true,theta=0,exprs="1",pin=4,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=-2,intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[4-1] = scicos_link(xx=[[338.9421],[358.9421]],yy=[[281.584],[281.584]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[3,1,1]);
        this.model = scicos_model(sim="csuper",in1=[],in2=[],intyp=1,out=-1,out2=-2,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=scs_m_1,ipar=[],opar=list(),blocktype="h",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list());
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"FROMWSB\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([5,2]),this.model,new ScilabDouble([]),this.gr_i);
        return new BasicBlock(this.x);
    }
    FROMWSB.prototype.details = function FROMWSB() {
        return this.x;
    }
    FROMWSB.prototype.get = function FROMWSB() {
        alert("parameters cannot be modified");
    }
    FROMWSB.prototype.set = function FROMWSB() {
            if (typeof(o)=="Block"&&o.gui=="FROMWS_c") {
                var ppath = list(i);
                break;
            }
        }
        var newpar = list();
        var y = 0;
        for (path in ppath) {
            var np = size(path,"*");
            var spath = list();
            for (k=1;k<=np;k+=1) {
                spath[$+1-1] = "model";
                spath[$+1-1] = "rpar";
                spath[$+1-1] = "objs";
                spath[$+1-1] = path[k-1];
            }
            execstr("xxn="+xx.gui+"(\'set\',xx)");
            if (!isequalbitwise(this.xxn,xx)) {
                this.model = xx.model;
                var model_n = this.xxn.model;
                if (!is_modelica_block(xx)) {
                    var modified = or(this.model.sim!=model_n.sim)||!isequal(this.model.state,model_n.state)||!isequal(this.model.dstate,model_n.dstate)||!isequal(this.model.odstate,model_n.odstate)||!isequal(this.model.rpar,model_n.rpar)||!isequal(this.model.ipar,model_n.ipar)||!isequal(this.model.opar,model_n.opar)||!isequal(this.model.label,model_n.label);
                    if (or(this.model.in!=model_n.in)||or(this.model.out!=model_n.out)||or(this.model.in2!=model_n.in2)||or(this.model.out2!=model_n.out2)||or(this.model.outtyp!=model_n.outtyp)||or(this.model.intyp!=model_n.intyp)) {
                        var needcompile = 1;
                    }
                    if (or(this.model.firing!=model_n.firing)) {
                        var needcompile = 2;
                    }
                    if ((size(this.model.in,"*")!=size(model_n.in,"*"))||(size(this.model.out,"*")!=size(model_n.out,"*"))) {
                        var needcompile = 4;
                    }
                    if (this.model.sim=="input"||this.model.sim=="output") {
                        if (this.model.ipar!=model_n.ipar) {
                            var needcompile = 4;
                        }
                    }
                    if (or(this.model.blocktype!=model_n.blocktype)||or(this.model.dep_ut!=model_n.dep_ut)) {
                        var needcompile = 4;
                    }
                    if ((this.model.nzcross!=model_n.nzcross)||(this.model.nmode!=model_n.nmode)) {
                        var needcompile = 4;
                    }
                    if (prod(size(model_n.sim))>1) {
                        if (model_n.sim[2-1]>1000) {
                            if (this.model.sim[1-1]!=model_n.sim[1-1]) {
                                var needcompile = 4;
                            }
                        }
                    }
                } else {
                    var modified = or(model_n!=this.model);
                    var eq = this.model.equations;
                    var eqn = model_n.equations;
                    if (or(eq.model!=eqn.model)||or(eq.inputs!=eqn.inputs)||or(eq.outputs!=eqn.outputs)) {
                        var needcompile = 4;
                    }
                }
                newpar[size(newpar)+1-1] = path;
                var y = max(y,needcompile);
            }
        }
        var typ = newpar;
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/FROMWS_c.sci" */
function FROMWS_c() {
    FROMWS_c.prototype.define = function FROMWS_c() {
        this.varnam = "V";
        this.Method = 1;
        this.ZC = 1;
        this.OutEnd = 0;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["fromws_c"]), new ScilabDouble([4]));
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-2]);
        this.model.outtyp = new ScilabDouble([-1]);
        this.model.ipar = new ScilabDouble([length(this.varnam)],[this._str2code[this.varnam-1]],[this.Method],[this.ZC],[this.OutEnd]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.evtout = new ScilabDouble([1]);
        this.model.firing = new ScilabDouble([0]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"FROMWS_c\",sz(1),sz(2));"]);
        this.exprs = [[string(this.varnam)],[string(this.Method)],[string(this.ZC)],[string(this.OutEnd)]];
        this.x = new standard_define(new ScilabDouble([3.5,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    FROMWS_c.prototype.details = function FROMWS_c() {
        return this.x;
    }
    FROMWS_c.prototype.get = function FROMWS_c() {
        var options = {
            varnam:["Variable name",this.varnam],
            Method:["Interpolation Method",this.Method],
            ZC:["Enable zero crossing(0:No, 1:Yes)?",this.ZC],
            OutEnd:["Output at end(0:Zero, 1:Hold, 2:Repeat)",this.OutEnd],
        }
        return options;
    }
    FROMWS_c.prototype.set = function FROMWS_c() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.varnam = arguments[0]["varnam"];
            this.Method = parseFloat(arguments[0]["Method"]);
            this.ZC = parseFloat(arguments[0]["ZC"]);
            this.OutEnd = parseFloat(arguments[0]["OutEnd"]);
            if (!ok) {
                break;
            }
            if (!(this.Method==0||this.Method==1||this.Method==2||this.Method==3)) {
                message("Interpolation method should be chosen in [0,1,2,3]");
                throw "user error";
                var ok = false;
            }
            if (!(this.ZC==0||this.ZC==1)) {
                message("Zero crossing should be either 0 or 1");
                throw "user error";
                var ok = false;
            }
            if (!(this.OutEnd==0||this.OutEnd==1||this.OutEnd==2)) {
                message("Output at end option should be either 0 or 1");
                throw "user error";
                var ok = false;
            }
            var r = false;
            var ierr = execstr("r=validvar(varnam)","errcatch");
            if (!r) {
                message([["Invalid variable name."],["Please choose another variable name."]]);
                throw "user error";
                var ok = false;
            }
            if (ok) {
                this.model.ipar = new ScilabDouble([length(this.varnam)],[this._str2code[this.varnam-1]],[this.Method],[this.ZC],[this.OutEnd]);
                var tmpvar0 = set_io(this.model,this.graphics,list(),list([-1,-2],-1),1,1);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                if (ok) {
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/GENSIN_f.sci" */
function GENSIN_f() {
    GENSIN_f.prototype.define = function GENSIN_f() {
        var rpar = [[1],[1],[0]];
        this.model = scicos_model();
        this.model.sim = new ScilabString(["gensin"]);
        this.model.in = new ScilabDouble([]);
        this.model.out = new ScilabDouble([1]);
        this.model.out2 = new ScilabDouble([1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([1],[1],[0]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.exprs = [[string(rpar[1-1])],[string(rpar[2-1])],[string(rpar[3-1])]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"GENSIN_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    GENSIN_f.prototype.details = function GENSIN_f() {
        return this.x;
    }
    GENSIN_f.prototype.get = function GENSIN_f() {
        var options = {
            M:["Magnitude",this.M],
            F:["Frequency (rad/s)",this.F],
            P:["Phase (rad)",this.P],
        }
        return options;
    }
    GENSIN_f.prototype.set = function GENSIN_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.M = arguments[0]["M"];
            this.F = arguments[0]["F"];
            this.P = arguments[0]["P"];
            if (!ok) {
                break;
            }
            if (this.F<0) {
                block_parameter_error(msprintf("Wrong value for \'Frequency\' parameter: %e.",this.F),"Strictly positive integer expected.");
                var ok = false;
            }
            if (ok) {
                var tmpvar0 = check_io(this.model,this.graphics,[],1,[],[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                this.model.rpar = new ScilabDouble([this.M],[this.F],[this.P]);
                this.model.out2 = new ScilabDouble([1]);
                this.model.outtyp = new ScilabDouble([1]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/GENSQR_f.sci" */
function GENSQR_f() {
    GENSQR_f.prototype.define = function GENSQR_f() {
        this.Amplitude = 1;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["gensqr"]);
        this.model.out = new ScilabDouble([1]);
        this.model.out2 = new ScilabDouble([1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble([this.Amplitude]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = string(this.Amplitude);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"GENSQR_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    GENSQR_f.prototype.details = function GENSQR_f() {
        return this.x;
    }
    GENSQR_f.prototype.get = function GENSQR_f() {
        var options = {
            Amplitude:["Amplitude",this.Amplitude],
        }
        return options;
    }
    GENSQR_f.prototype.set = function GENSQR_f() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")==2) {
            this.exprs = this.exprs[2-1];
        }
        while (true) {
            var ok = true;
            this.Amplitude = parseFloat(arguments[0]["Amplitude"]);
            if (!ok) {
                break;
            }
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.model.dstate = new ScilabDouble([this.Amplitude]);
            this.model.out2 = new ScilabDouble([1]);
            this.model.outtyp = new ScilabDouble([1]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
            break;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/GEN_SQR.sci" */
function GEN_SQR() {
    GEN_SQR.prototype.define = function GEN_SQR() {
        var scs_m_1 = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[-176.97473,421.18646,173.61587,524.41503,827,480,0,15,827,480,755,614,1.4],Title="SuperBlock",tol=[0.0001,0.000001,1.000e-10,100001,0,0],tf=100000,context=[["if typeof(Amin)<>typeof(Amax) then error(\'Minimum value and Maximum value must have the same type\');end"],["if and(rule<>[1;2]) then error(\'Initial Value must be 1 (for Min) or 2 (for Max)\');end"],["if Amin>Amax then error(\'Maximum value must be greater than the Minimum Value\');end"],["P=%pi/F"],[""]],void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m_1.objs[1-1] = scicos_block(gui="Counter",graphics=scicos_graphics(orig=[18.229901,339.5057],sz=[60,40],flip=true,theta=0,exprs=[["1"],["2"],["rule"]],pin=[],pout=8,pein=16,peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim=list("counter",4),in1=[],in2=[],intyp=1,out=1,out2=1,outtyp=1,evtin=1,evtout=[],state=[],dstate=0,odstate=list(),rpar=[],ipar=[[1],[2],[1]],opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[2-1] = scicos_block(gui="CONST_m",graphics=scicos_graphics(orig=[38.096074,293.82198],sz=[40,40],flip=true,theta=0,exprs="Amin",pin=[],pout=5,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim=list("cstblk4_m",4),in1=[],in2=[],intyp=1,out=1,out2=1,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(-1),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[3-1] = scicos_block(gui="CONST_m",graphics=scicos_graphics(orig=[37.378886,245.02389],sz=[40,40],flip=true,theta=0,exprs="Amax",pin=[],pout=6,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim=list("cstblk4_m",4),in1=[],in2=[],intyp=1,out=1,out2=1,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(1),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[4-1] = scicos_block(gui="SELECT_m",graphics=scicos_graphics(orig=[116.26954,269.42294],sz=[40,40],flip=true,theta=0,exprs=[["-1"],["2"],["1"]],pin=[[5],[6]],pout=14,pein=[[9],[10]],peout=[],gr_i=[],id="",in_implicit=[["E"],["E"]],out_implicit="E"),model=scicos_model(sim=list("selector_m",4),in1=[[-1],[-1]],in2=[[-2],[-2]],intyp=[[-1],[-1]],out=-1,out2=-2,outtyp=-1,evtin=[[1],[1]],evtout=[],state=[],dstate=1,odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[5-1] = scicos_link(xx=[[86.667502],[107.69811],[107.69811]],yy=[[313.82198],[313.82198],[296.0896]],id="drawlink",thick=[0,0],ct=[1,1],from=[2,1,0],to=[4,1,1]);
        scs_m_1.objs[6-1] = scicos_link(xx=[[85.950315],[107.69811],[107.69811]],yy=[[265.02389],[265.02389],[282.75627]],id="drawlink",thick=[0,0],ct=[1,1],from=[3,1,0],to=[4,2,1]);
        scs_m_1.objs[7-1] = scicos_block(gui="ESELECT_f",graphics=scicos_graphics(orig=[106.9461,339.7496],sz=[60,40],flip=true,theta=0,exprs=[["2"],["0"],["0"]],pin=8,pout=[],pein=[],peout=[[9],[10]],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim=list("eselect",-2),in1=1,in2=1,intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[[1],[1]],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="l",firing=[[-1],[-1]],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[8-1] = scicos_link(xx=[[86.80133],[98.374671]],yy=[[359.5057],[359.7496]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[7,1,1]);
        scs_m_1.objs[9-1] = scicos_link(xx=[[126.9461],[129.60287]],yy=[[334.03532],[315.13722]],id="drawlink",thick=[0,0],ct=[5,-1],from=[7,1,0],to=[4,1,1]);
        scs_m_1.objs[10-1] = scicos_link(xx=[[146.9461],[142.93621]],yy=[[334.03532],[315.13722]],id="drawlink",thick=[0,0],ct=[5,-1],from=[7,2,0],to=[4,2,1]);
        scs_m_1.objs[11-1] = mlist("Deleted");
        scs_m_1.objs[12-1] = mlist("Deleted");
        scs_m_1.objs[13-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[184.40238,278.75198],sz=[20,20],flip=true,theta=0,exprs="1",pin=14,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=-2,intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[14-1] = scicos_link(xx=[[164.84097],[184.40238]],yy=[[289.42294],[288.75198]],id="drawlink",thick=[0,0],ct=[1,1],from=[4,1,0],to=[13,1,1]);
        scs_m_1.objs[15-1] = scicos_block(gui="SampleCLK",graphics=scicos_graphics(orig=[18.313686,403.57431],sz=[60,40],flip=true,theta=0,exprs=[["F/2"],["0"]],pin=[],pout=[],pein=[],peout=16,gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="sampleclk",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=1,state=[],dstate=[],odstate=list(),rpar=[[1/2],[0]],ipar=[],opar=list(),blocktype="d",firing=-1,dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[16-1] = scicos_link(xx=[[48.313686],[48.229901]],yy=[[403.57431],[385.21998]],id="drawlink",thick=[0,0],ct=[5,-1],from=[15,1,0],to=[1,1,1]);
        this.model = scicos_model();
        this.model.sim = new ScilabString(["csuper"]);
        this.model.in = new ScilabDouble([]);
        this.model.in2 = new ScilabDouble([]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-2]);
        this.model.outtyp = new ScilabDouble([-1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.odstate = list();
        this.model.rpar = new ScilabDouble([scs_m_1]);
        this.model.ipar = new ScilabDouble([1]);
        this.model.opar = list();
        this.model.blocktype = new ScilabString(["h"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.model.label = new ScilabString([""]);
        this.model.nzcross = new ScilabDouble([0]);
        this.model.nmode = new ScilabDouble([0]);
        this.model.equations = list();
        var Amin = -1;
        var Amax = 1;
        var rule = 1;
        var F = 1;
        this.exprs = [sci2exp(Amin),sci2exp(Amax),sci2exp(rule),sci2exp(F)];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"GEN_SQR\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabString(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    GEN_SQR.prototype.details = function GEN_SQR() {
        return this.x;
    }
    GEN_SQR.prototype.get = function GEN_SQR() {
        var options = {
            scicos_context.Amin:["Minimum Value",this.scicos_context.Amin],
            scicos_context.Amax:["Maximum Value",this.scicos_context.Amax],
            scicos_context.rule:["Initial Value( 1= Minimum Value 2= Maximum Value)",this.scicos_context.rule],
            scicos_context.F:["Period (sec)",this.scicos_context.F],
        }
        return options;
    }
    GEN_SQR.prototype.set = function GEN_SQR() {
        var y = this.needcompile;
        var typ = list();
        this.exprs = this.graphics.exprs;
        var Btitre = "Set GEN_SQR parameters";
        var Exprs0 = [["Amin"],["Amax"],["rule"],["F"]];
        this.Bitems = [["Minimum Value"],["Maximum Value"],["Initial Value( 1= Minimum Value 2= Maximum Value)"],["Period (sec)"]];
        var Ss = list("mat",[-1,-1],"mat",[-1,-1],"pol",-1,"pol",-1);
        var scicos_context = struct();
        var ok = false;
        while (!ok) {
            var ok = true;
            this.scicos_context.Amin = arguments[0]["scicos_context.Amin"];
            this.scicos_context.Amax = arguments[0]["scicos_context.Amax"];
            this.scicos_context.rule = arguments[0]["scicos_context.rule"];
            this.scicos_context.F = arguments[0]["scicos_context.F"];
            if (!ok) {
                return;
            }
            var PREVAR_scicos_context = scicos_context;
            var sblock = this.x.model.rpar;
            var tmpvar0 = script2var(sblock.props.context,PREVAR_scicos_context);
            var PREVAR_scicos_context = tmpvar0[0];
            var ierr = tmpvar0[1];
            if (ierr==0) {
                var tmpvar1 = do_eval(sblock,list());
                var sblock = tmpvar1[0];
                %w = tmpvar1[1];
                var needcompile2 = tmpvar1[2];
                var ok = tmpvar1[3];
                if (ok) {
                    var y = max(2,this.needcompile,needcompile2);
                    this.x.graphics.exprs = this.exprs;
                    this.x.model.rpar = sblock;
                    break;
                }
            } else {
                message(lasterror());
                throw "user error";
                var ok = false;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/Ground_g.sci" */
function Ground_g() {
    Ground_g.prototype.define = function Ground_g() {
        var C = [0];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["cstblk4_m"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([]);
        this.model.out = new ScilabDouble([1]);
        this.model.in2 = new ScilabDouble([]);
        this.model.out2 = new ScilabDouble([1]);
        this.model.outtyp = new ScilabDouble([-1]);
        this.model.rpar = new ScilabDouble([]);
        this.model.opar = list(C);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"Ground_g\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    Ground_g.prototype.details = function Ground_g() {
        return this.x;
    }
    Ground_g.prototype.get = function Ground_g() {
        alert("parameters cannot be modified");
    }
    Ground_g.prototype.set = function Ground_g() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/INIMPL_f.sci" */
function INIMPL_f() {
    INIMPL_f.prototype.define = function INIMPL_f() {
        this.model = scicos_model();
        this.model.sim = new ScilabString(["inimpl"]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([1]);
        this.model.ipar = new ScilabDouble([1]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.model.blocktype = new ScilabString(["c"]);
        var mo = modelica();
        mo.model = "PORT";
        mo.outputs = "n";
        this.model.equations = new ScilabDouble([mo]);
        this.prt = 1;
        this.exprs = "1";
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"INIMPL_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([1,1]),this.model,new ScilabString([this.exprs]),this.gr_i);
        this.x.graphics.out_implicit = ["I"];
        return new ImplicitInBlock(this.x);
    }
    INIMPL_f.prototype.details = function INIMPL_f() {
        return this.x;
    }
    INIMPL_f.prototype.get = function INIMPL_f() {
        var options = {
            prt:["Port Number",this.prt],
        }
        return options;
    }
    INIMPL_f.prototype.set = function INIMPL_f() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")==2) {
            this.exprs = this.exprs[1-1];
        }
        while (true) {
            var ok = true;
            this.prt = parseFloat(arguments[0]["prt"]);
            if (!ok) {
                break;
            }
            this.prt = int(this.prt);
            if (this.prt<=0) {
                block_parameter_error(msprintf("Wrong value for \'Port Number\' parameter: %d.",this.prt),"Strictly positive integer expected.");
            } else {
                if (this.model.ipar!=this.prt) {
                    var needcompile = 4;
                    var y = needcompile;
                }
                this.model.ipar = new ScilabDouble([this.prt]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new ImplicitInBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/IN_f.sci" */
function IN_f() {
    IN_f.prototype.define = function IN_f() {
        var prt = 1;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["input"]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-2]);
        this.model.outtyp = new ScilabDouble([-1]);
        this.model.ipar = new ScilabDouble([prt]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = sci2exp(prt);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"IN_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([1,1]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new ExplicitInBlock(this.x);
    }
    IN_f.prototype.details = function IN_f() {
        return this.x;
    }
    IN_f.prototype.get = function IN_f() {
        alert("parameters cannot be modified");
    }
    IN_f.prototype.set = function IN_f() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")==2) {
            this.exprs = this.exprs[1-1];
        }
        if (size(this.exprs,"*")==1) {
            this.exprs = [[this.exprs[1-1]],["[-1 -2]"],["-1"]];
        }
        while (true) {
            var tmpvar0 = getvalue("Set Input block parameters",[["Port number"],["Outport size ([-1 -2] for inherit)"],["Outport Type (-1 for inherit)"]],list("vec",1,"vec",-1,"vec",1),this.exprs);
            var ok = tmpvar0[0];
            var prt = tmpvar0[1];
            var otsz = tmpvar0[2];
            var ot = tmpvar0[3];
            this.exprs = tmpvar0[4];
            if (!ok) {
                break;
            }
            var prt = int(prt);
            if (prt<=0) {
                message("Port number must be a positive integer");
                throw "user error";
            } else if (!isequal(size(otsz,"*"),2)) {
                message("Outport Size must be a 2 elements vector");
                throw "user error";
            } else if (((ot<1||ot>9)&&(ot!=-1))) {
                message("Outport type must be a number between 1 and 9, or -1 for inheritance.");
                throw "user error";
            } else {
                if (this.model.ipar!=prt) {
                    var needcompile = 4;
                    var y = needcompile;
                }
                this.model.ipar = new ScilabDouble([prt]);
                this.model.firing = new ScilabDouble([]);
                this.model.out = new ScilabDouble([otsz[1-1]]);
                this.model.out2 = new ScilabDouble([otsz[2-1]]);
                this.model.outtyp = new ScilabDouble([ot]);
                this.graphics.exprs = new ScilabDouble(this.exprs);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new ExplicitInBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/Modulo_Count.sci" */
function Modulo_Count() {
    Modulo_Count.prototype.define = function Modulo_Count() {
        this.ini_c = 0;
        this.base = 3;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["modulo_count"]), new ScilabDouble([4]));
        this.model.evtin = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble([this.ini_c]);
        this.model.ipar = new ScilabDouble([this.base]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [[string(this.ini_c)],[string(this.base)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"Modulo_Count\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    Modulo_Count.prototype.details = function Modulo_Count() {
        return this.x;
    }
    Modulo_Count.prototype.get = function Modulo_Count() {
        var options = {
            ini_c:["Initial State (zero or positive number)",this.ini_c],
            base:["Upper Limit (positive number)",this.base],
        }
        return options;
    }
    Modulo_Count.prototype.set = function Modulo_Count() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.ini_c = parseFloat(arguments[0]["ini_c"]);
            this.base = parseFloat(arguments[0]["base"]);
            this.ini_c = int(this.ini_c);
            this.base = int(this.base);
            if (!ok) {
                break;
            }
            if (this.ini_c<0) {
                block_parameter_error(msprintf("Wrong value for \'Initial State\' parameter: %d.",this.ini_c),"Null or positive integer expected.");
            } else if (this.base<=0) {
                block_parameter_error(msprintf("Wrong values for \'Upper Limit\' parameter: %d.",this.base),"Strictly positive integer expected.");
            } else {
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.ipar = new ScilabDouble([this.base]);
                this.model.dstate = new ScilabDouble([this.ini_c]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/PULSE_SC.sci" */
function PULSE_SC() {
    PULSE_SC.prototype.define = function PULSE_SC() {
        var scs_m_1 = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[-162.7581,435.54369,67.607292,416.67644,827,479,0,15,827,480,715,167,1.4],Title=["SuperBlock","/home/fady/Scicos_examples/"],tol=[[0.0001],[0.000001],[1.000e-10],[100001],[0],[0],[0]],tf=10,context=[["E2=E+W/100*F"],["if (W<0 | W>100) then error(\'Width must be between 0 and 100\');end"],["if (E2 >= F) then error (\'Offset must be lower than (frequency*(1-Width/100))\'); end"]],void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m_1.objs[1-1] = scicos_block(gui="CONST_m",graphics=scicos_graphics(orig=[30.801202,158.91733],sz=[40,40],flip=true,theta=0,exprs="A",pin=[],pout=5,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim=list("cstblk4_m",4),in1=[],in2=[],intyp=1,out=1,out2=1,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(1),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[2-1] = scicos_block(gui="Ground_g",graphics=scicos_graphics(orig=[31.534535,215.384],sz=[40,40],flip=true,theta=0,exprs=[],pin=[],pout=4,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim=list("cstblk4_m",4),in1=[],in2=[],intyp=1,out=1,out2=1,outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(0),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[3-1] = scicos_block(gui="SELECT_m",graphics=scicos_graphics(orig=[106.00652,186.09381],sz=[40,40],flip=true,theta=0,exprs=[["-1"],["2"],["1"]],pin=[[4],[5]],pout=11,pein=[[9],[8]],peout=[],gr_i=[],id="",in_implicit=[["E"],["E"]],out_implicit="E"),model=scicos_model(sim=list("selector_m",4),in1=[[-1],[-1]],in2=[[-2],[-2]],intyp=[[-1],[-1]],out=-1,out2=-2,outtyp=-1,evtin=[[1],[1]],evtout=[],state=[],dstate=1,odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[4-1] = scicos_link(xx=[[80.105964],[97.43509],[97.43509]],yy=[[235.384],[235.384],[212.76048]],id="drawlink",thick=[0,0],ct=[1,1],from=[2,1,0],to=[3,1,1]);
        scs_m_1.objs[5-1] = scicos_link(xx=[[79.372631],[97.43509],[97.43509]],yy=[[178.91733],[178.91733],[199.42714]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[3,2,1]);
        scs_m_1.objs[6-1] = scicos_block(gui="SampleCLK",graphics=scicos_graphics(orig=[82.349744,274.21741],sz=[60,40],flip=true,theta=0,exprs=[["F"],["E2"]],pin=[],pout=[],pein=[],peout=9,gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="sampleclk",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=1,state=[],dstate=[],odstate=list(),rpar=[[1],[0.4]],ipar=[],opar=list(),blocktype="d",firing=-1,dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[7-1] = scicos_block(gui="SampleCLK",graphics=scicos_graphics(orig=[160.48879,274.21741],sz=[60,40],flip=true,theta=0,exprs=[["F"],["E"]],pin=[],pout=[],pein=[],peout=8,gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="sampleclk",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=1,state=[],dstate=[],odstate=list(),rpar=[[1],[0.1]],ipar=[],opar=list(),blocktype="d",firing=-1,dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[8-1] = scicos_link(xx=[[190.48879],[190.48879],[132.67318],[132.67318]],yy=[[274.21741],[240.99048],[240.99048],[231.80809]],id="drawlink",thick=[0,0],ct=[5,-1],from=[7,1,0],to=[3,2,1]);
        scs_m_1.objs[9-1] = scicos_link(xx=[[112.34974],[112.34974],[119.33985],[119.33985]],yy=[[274.21741],[248.21372],[248.21372],[231.80809]],id="drawlink",thick=[0,0],ct=[5,-1],from=[6,1,0],to=[3,1,1]);
        scs_m_1.objs[10-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[174.57795,196.09381],sz=[20,20],flip=true,theta=0,exprs="1",pin=11,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=-2,intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[11-1] = scicos_link(xx=[[154.57795],[174.57795]],yy=[[206.09381],[206.09381]],id="drawlink",thick=[0,0],ct=[1,1],from=[3,1,0],to=[10,1,1]);
        this.model = scicos_model();
        this.model.sim = new ScilabString(["csuper"]);
        this.model.in = new ScilabDouble([]);
        this.model.in2 = new ScilabDouble([]);
        this.model.intyp = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([-1]);
        this.model.out2 = new ScilabDouble([-2]);
        this.model.outtyp = new ScilabDouble([-1]);
        this.model.evtin = new ScilabDouble([]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([]);
        this.model.odstate = list();
        this.model.rpar = new ScilabDouble([scs_m_1]);
        this.model.ipar = new ScilabDouble([1]);
        this.model.opar = list();
        this.model.blocktype = new ScilabString(["h"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.model.label = new ScilabString([""]);
        this.model.nzcross = new ScilabDouble([0]);
        this.model.nmode = new ScilabDouble([0]);
        this.model.equations = list();
        var E = 0.1;
        var W = 30;
        var F = 1;
        var A = 1;
        this.exprs = [sci2exp(E),sci2exp(W),sci2exp(F),sci2exp(A)];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"PULSE_SC\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabString(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    PULSE_SC.prototype.details = function PULSE_SC() {
        return this.x;
    }
    PULSE_SC.prototype.get = function PULSE_SC() {
        var options = {
            scicos_context.E:["Phase delay (secs):",this.scicos_context.E],
            scicos_context.W:["Pulse Width (% of period):",this.scicos_context.W],
            scicos_context.F:["Period (secs):",this.scicos_context.F],
            scicos_context.A:["Amplitude:",this.scicos_context.A],
        }
        return options;
    }
    PULSE_SC.prototype.set = function PULSE_SC() {
        var y = this.needcompile;
        var typ = list();
        this.exprs = this.graphics.exprs;
        var Btitre = "Set Pulse Generator parameters";
        var Exprs0 = [["E"],["W"],["F"],["A"]];
        this.Bitems = [["Phase delay (secs):"],["Pulse Width (% of period):"],["Period (secs):"],["Amplitude:"]];
        var Ss = list("pol",-1,"pol",-1,"pol",-1,"mat",[-1,-1]);
        var scicos_context = struct();
        var ok = false;
        while (!ok) {
            var ok = true;
            this.scicos_context.E = arguments[0]["scicos_context.E"];
            this.scicos_context.W = arguments[0]["scicos_context.W"];
            this.scicos_context.F = arguments[0]["scicos_context.F"];
            this.scicos_context.A = arguments[0]["scicos_context.A"];
            if (!ok) {
                return;
            }
            var PREVAR_scicos_context = scicos_context;
            var sblock = this.x.model.rpar;
            var tmpvar0 = script2var(sblock.props.context,PREVAR_scicos_context);
            var PREVAR_scicos_context = tmpvar0[0];
            var ierr = tmpvar0[1];
            if (ierr==0) {
                var tmpvar1 = do_eval(sblock,list());
                var sblock = tmpvar1[0];
                %w = tmpvar1[1];
                var needcompile2 = tmpvar1[2];
                var ok = tmpvar1[3];
                if (ok) {
                    var y = max(2,this.needcompile,needcompile2);
                    this.x.graphics.exprs = this.exprs;
                    this.x.model.rpar = sblock;
                    break;
                }
            } else {
                if ((lasterror().length!=0)) {
                    messagebox(lasterror());
                }
                var ok = false;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/RAMP.sci" */
function RAMP() {
    RAMP.prototype.define = function RAMP() {
        this.slope = 0;
        this.iout = 0;
        this.stt = 0;
        var rpar = [[this.slope],[this.stt],[this.iout]];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["ramp"]), new ScilabDouble([4]));
        this.model.in = new ScilabDouble([]);
        this.model.out = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble(rpar);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.nmode = new ScilabDouble([1]);
        this.model.nzcross = new ScilabDouble([1]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.exprs = [string(rpar)];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"RAMP\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabString(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    RAMP.prototype.details = function RAMP() {
        return this.x;
    }
    RAMP.prototype.get = function RAMP() {
        var options = {
            slope:["Slope",this.slope],
            stt:["Start Time",this.stt],
            iout:["Initial Value",this.iout],
        }
        return options;
    }
    RAMP.prototype.set = function RAMP() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.slope = parseFloat(arguments[0]["slope"]);
            this.stt = parseFloat(arguments[0]["stt"]);
            this.iout = parseFloat(arguments[0]["iout"]);
            if (!ok) {
                break;
            }
            if (this.stt<0) {
                block_parameter_error(msprintf("Wrong value for \'Start Time\' parameter: %e.",this.stt),"Null or positive integer expected.");
            } else {
                this.model.rpar = new ScilabDouble([this.slope],[this.stt],[this.iout]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/RAND_f.sci" */
function RAND_f() {
    RAND_f.prototype.define = function RAND_f() {
        this.a = 0;
        this.b = 1;
        var dt = 0;
        var out = 1;
        this.flag = 0;
        this.model = scicos_model();
        this.model.sim = new ScilabString(["rndblk"]);
        this.model.out = new ScilabDouble([out]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble([int(rand()*(10^7-1))],[0*this.a.slice()]);
        this.model.rpar = new ScilabDouble([this.a.slice()],[this.b.slice()]);
        this.model.ipar = new ScilabDouble([this.flag]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [[string(this.flag)],[sci2exp(this.a.slice())],[sci2exp(this.b.slice())],[string(this.model.dstate[1-1])]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"RAND_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    RAND_f.prototype.details = function RAND_f() {
        return this.x;
    }
    RAND_f.prototype.get = function RAND_f() {
        var options = {
            flag:["flag",this.flag],
            a:["A",this.a],
            b:["B",this.b],
            seed_c:["seed",this.seed_c],
        }
        return options;
    }
    RAND_f.prototype.set = function RAND_f() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")==5) {
            this.exprs = this.exprs.slice(1-1,3);
        }
        if (size(this.exprs,"*")==3) {
            this.exprs = [[this.exprs],[string(this.model.dstate[1-1])]];
        }
        while (true) {
            var ok = true;
            this.flag = parseFloat(arguments[0]["flag"]);
            this.a = parseFloat(arguments[0]["a"]);
            this.b = parseFloat(arguments[0]["b"]);
            this.seed_c = arguments[0]["seed_c"];
            if (!ok) {
                break;
            }
            if (this.flag!=0&&this.flag!=1) {
                message("flag must be equal to 1 or 0");
                throw "user error";
            } else {
                var nout = size(this.a,"*");
                this.graphics.exprs = new ScilabDouble(this.exprs);
                this.model.out = new ScilabDouble([nout]);
                this.model.ipar = new ScilabDouble([this.flag]);
                this.model.rpar = new ScilabDouble([this.a.slice()],[this.b.slice()]);
                this.model.dstate = new ScilabDouble([this.seed_c],[0*this.a.slice()]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/RAND_m.sci" */
function RAND_m() {
    RAND_m.prototype.define = function RAND_m() {
        this.a = 0;
        this.b = 1;
        var dt = 0;
        this.flag = 0;
        var function_name = "rndblk_m";
        var funtyp = 4;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([funtyp]));
        this.model.in = new ScilabDouble([]);
        this.model.in2 = new ScilabDouble([]);
        this.model.intyp = new ScilabDouble([]);
        this.model.out = new ScilabDouble([1]);
        this.model.out2 = new ScilabDouble([1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.evtout = new ScilabDouble([]);
        this.model.state = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([int(rand()*(10^7-1))],[0*this.a.slice()]);
        this.model.rpar = new ScilabDouble([this.a.slice(),this.b.slice()]);
        this.model.ipar = new ScilabDouble([this.flag]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [[sci2exp(1)],[string(this.flag)],[sci2exp([this.a])],[sci2exp([this.b])],[sci2exp([this.model.dstate[1-1],int(rand()*(10^7-1))])]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"RAND_m\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    RAND_m.prototype.details = function RAND_m() {
        return this.x;
    }
    RAND_m.prototype.get = function RAND_m() {
        var options = {
            typ:["Datatype(1=real double  2=complex)",this.typ],
            flag:["flag",this.flag],
            a:["A",this.a],
            b:["B",this.b],
            seed_c:["SEED",this.seed_c],
        }
        return options;
    }
    RAND_m.prototype.set = function RAND_m() {
        this.exprs = this.graphics.exprs;
        if (size(this.exprs,"*")==14) {
            this.exprs[9-1] = [];
        }
        while (true) {
            var ok = true;
            this.typ = inverse(arguments[0]["typ"]);
            this.flag = parseFloat(arguments[0]["flag"]);
            this.a = parseFloat(arguments[0]["a"]);
            this.b = parseFloat(arguments[0]["b"]);
            this.seed_c = arguments[0]["seed_c"];
            if (!ok) {
                break;
            }
            if (this.flag!=0&&this.flag!=1) {
                message("flag must be equal to 1 or 0");
                throw "user error";
            } else {
                var out = size(this.a);
                if (this.typ==1) {
                    var function_name = "rndblk_m";
                    this.model.rpar = new ScilabDouble([real(this.a.slice())],[real(this.b.slice())]);
                    this.model.dstate = new ScilabDouble([this.seed_c[1-1]],[0*real(this.a.slice())]);
                    var ot = 1;
                } else if (this.typ==2) {
                    var function_name = "rndblkz_m";
                    var ot = 2;
                    this.model.rpar = new ScilabDouble([real(this.a.slice())],[imag(this.a.slice())],[real(this.b.slice())],[imag(this.b.slice())]);
                    this.model.dstate = new ScilabDouble([this.seed_c.slice()],[0*[[real(this.a.slice())],[imag(this.a.slice())]]]);
                } else {
                    message("Datatype is not supported");
                    throw "user error";
                    var ok = false;
                }
                if (ok) {
                    var tmpvar0 = set_io(this.model,this.graphics,list([],[]),list(out,ot),1,[]);
                    this.model = tmpvar0[0];
                    this.graphics = tmpvar0[1];
                    var ok = tmpvar0[2];
                    if (ok) {
                        this.model.sim = list(new ScilabString([function_name]), new ScilabDouble([4]));
                        this.graphics.exprs = new ScilabDouble([this.exprs]);
                        this.model.ipar = new ScilabDouble([this.flag]);
                        this.x.graphics = this.graphics;
                        this.x.model = this.model;
                        break;
                    }
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/READAU_f.sci" */
function READAU_f() {
    READAU_f.prototype.define = function READAU_f() {
        var frmt = "uc ";
        var fname = "test.au";
        var lunit = 0;
        this.N = 20;
        var M = 1;
        var tmask = [];
        this.swap = 0;
        var offset = 1;
        var outmask = 1;
        var ievt = 0;
        var nout = size(outmask,"*");
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["readau"]), new ScilabDouble([2]));
        this.model.out = new ScilabDouble([nout]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble([1],[1],[lunit],[zeros(this.N*M,1)]);
        this.model.ipar = new ScilabDouble([length(fname)],[this._str2code[frmt-1]],[ievt],[this.N],[M],[this.swap],[offset],[this._str2code[fname-1]],[tmask],[outmask]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [[fname],[string(this.N)],[string(this.swap)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"READAU_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([5,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    READAU_f.prototype.details = function READAU_f() {
        return this.x;
    }
    READAU_f.prototype.get = function READAU_f() {
        var options = {
            fname1:["Input File Name",this.fname1],
            N:["Buffer size",this.N],
            swap:["Swap Mode (0:No, 1:Yes)",this.swap],
        }
        return options;
    }
    READAU_f.prototype.set = function READAU_f() {
        this.exprs = this.graphics.exprs;
        var out = this.model.out;
        var dstate = this.model.dstate;
        var ipar = this.model.ipar;
        var imask = 9+ipar[1-1];
        var tmask = ipar[imask-1];
        var lunit = dstate[3-1];
        var fname = this.exprs[1-1];
        while (true) {
            var ok = true;
            this.fname1 = parseFloat(arguments[0]["fname1"]);
            this.N = parseFloat(arguments[0]["N"]);
            this.swap = parseFloat(arguments[0]["swap"]);
            var tmask1 = [];
            var outmask = 1;
            var frmt1 = "uc";
            var M = 1;
            var offset = 1;
            if (!ok) {
                break;
            }
            this.fname1 = stripblanks(this.fname1);
            var frmt1 = stripblanks(frmt1);
            if (this.alreadyran&&this.fname1!=fname) {
                block_parameter_error("Simulation running !!! You cannot modify Input file name","End current simulation first.");
            } else if (this.fname1=="") {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter.","Input File Name"),"You must provide a filename.");
            } else if (this.N<1) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Buffer size",this.N),msprintf("Must be greater than %d.",1));
            } else if (this.alreadyran&&(this.N!=ipar[6-1])) {
                block_parameter_error(msprintf("You cannot modify \'%s\' when running.","Buffer Size"),"End current simulation first.");
            } else if (this.swap!=0&&this.swap!=1) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Swap Mode",this.swap),msprintf("Must be in the interval %s.","[0, 1]"));
            } else {
                var tmpvar0 = check_io(this.model,this.graphics,[],1,1,[]);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                var frmt1 = part(frmt1,1,3);
                if (ok) {
                    var ipar = [[length(this.fname1)],[this._str2code[frmt1-1]],[0],[this.N],[M],[this.swap],[offset,this._str2code[this.fname1-1]],[tmask1,outmask.slice()]];
                    if (prod(size(dstate))!=(this.N*M)+3) {
                        var dstate = [[-1],[-1],[lunit],[zeros(this.N*M,1)]];
                    }
                    this.model.dstate = new ScilabDouble(dstate);
                    this.model.ipar = new ScilabDouble(ipar);
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/READC_f.sci" */
function READC_f() {
    READC_f.prototype.define = function READC_f() {
        var frmt = "d  ";
        var fname = "foo";
        var lunit = 0;
        this.N = 20;
        this.M = 1;
        var rpar = [];
        var tmask = 0;
        this.swap = 0;
        this.offset = 1;
        this.outmask = 1;
        var ievt = 0;
        var nout = size(this.outmask,"*");
        var ipar = [[length(fname)],[this._str2code[frmt-1]],[ievt],[this.N],[this.M],[this.swap],[this.offset],[this._str2code[fname-1]],[tmask],[this.outmask]];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["readc"]), new ScilabDouble([2]));
        this.model.out = new ScilabDouble([nout]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.evtout = new ScilabDouble([]);
        this.model.dstate = new ScilabDouble([1],[1],[lunit],[zeros(this.N*this.M,1)]);
        this.model.ipar = new ScilabDouble([length(fname)],[this._str2code[frmt-1]],[ievt],[this.N],[this.M],[this.swap],[this.offset],[this._str2code[fname-1]],[tmask],[this.outmask]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([-1]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [["[]"],[sci2exp(this.outmask)],[fname],[frmt],[string(this.M)],[string(this.N)],[string(this.offset)],[string(this.swap)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"READC_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([4,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    READC_f.prototype.details = function READC_f() {
        return this.x;
    }
    READC_f.prototype.get = function READC_f() {
        var options = {
            tmask1:["Time Record Selection",this.tmask1],
            outmask:["Outputs Record Selection",this.outmask],
            fname1:["Input File Name",this.fname1],
            frmt1:["Input Format",this.frmt1],
            M:["Record Size",this.M],
            N:["Buffer Size",this.N],
            offset:["Initial Record Index",this.offset],
            swap:["Swap Mode (0:No, 1:Yes)",this.swap],
        }
        return options;
    }
    READC_f.prototype.set = function READC_f() {
        this.model = this.x.model;
        this.exprs = this.graphics.exprs;
        var out = this.model.out;
        var dstate = this.model.dstate;
        var ipar = this.model.ipar;
        var imask = 9+ipar[1-1];
        var tmask = ipar[imask-1];
        var lunit = dstate[3-1];
        var fname = this.exprs[3-1];
        var frmt = this.exprs[4-1];
        while (true) {
            var ok = true;
            this.tmask1 = parseFloat(arguments[0]["tmask1"]);
            this.outmask = parseFloat(arguments[0]["outmask"]);
            this.fname1 = parseFloat(arguments[0]["fname1"]);
            this.frmt1 = arguments[0]["frmt1"];
            this.M = parseFloat(arguments[0]["M"]);
            this.N = parseFloat(arguments[0]["N"]);
            this.offset = parseFloat(arguments[0]["offset"]);
            this.swap = parseFloat(arguments[0]["swap"]);
            if (!ok) {
                break;
            }
            this.fname1 = pathconvert(stripblanks(this.fname1),false,true);
            this.frmt1 = stripblanks(this.frmt1);
            var fmts = ["s","l","d","f","c","us","ul","uc","ull","uls","ubl","ubs","dl","fl","ll","sl","db","fb","lb","sb"];
            var nout = size(this.outmask,"*");
            if (prod(size(this.tmask1))>1) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter.","Time Record Selection"),"Must be a scalar or an empty matrix.");
            } else if (and(this.frmt1!=fmts)) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %s.","Input Format",this.frmt1),"Valid formats are: "+strcat(fmts,", "));
            } else if (this.alreadyran&&this.fname1!=fname) {
                block_parameter_error(msprintf("You cannot modify \'%s\' when running","Input File Name"),"End current simulation first.");
            } else if (this.N!=ipar[6-1]&&this.alreadyran) {
                block_parameter_error(msprintf("You cannot modify \'%s\' when running.","Buffer Size"),"End current simulation first");
            } else if (this.alreadyran&&size(this.tmask1)!=size(tmask)) {
                block_parameter_error(msprintf("You cannot modify \'%s\' when running.","Time Record Selection"),"End current simulation first.");
            } else if (this.fname1=="") {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter.","Input File Name"),"You must provide a file name.");
            } else if (this.M<1) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Record Size",this.M),"Strictly positive integer expected.");
            } else if (this.tmask1.length!=0&&(this.tmask1<1||this.tmask1>this.M)) {
                block_parameter_error(msprintf("Wrong value for  \'%s\' parameter: %d.","Time Record Selection",this.tmask1),msprintf("Must be in the interval %s.","[1, Record Size = "+string(this.M)+"]"));
            } else if (nout==0) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Outputs Record Selection",nout),"Strictly positive integer expected.");
            } else if (nout>this.M) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Outputs Record Selection",nout),msprintf("Must be in the interval %s.","[1, Record Size = "+string(this.M)+"]"));
            } else if (max(this.outmask)>this.M||min(this.outmask)<1) {
                block_parameter_error(msprintf("Wrong value for indexes in \'%s\' parameter: %s.","Outputs Record Selection",strcat(string(this.outmask.slice())," ")),msprintf("Must be in the interval %s.","[1, Record Size = "+string(this.M)+"]"));
            } else if (this.N<1) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Buffer Size",this.N),"Strictly positive integer expected.");
            } else if (this.swap!=0&&this.swap!=1) {
                block_parameter_error(msprintf("Wrong value for  \'%s\' parameter: %d.","Swap Mode",this.swap),msprintf("Must be in the interval %s.","[0, 1]"));
            } else if (this.offset<1) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Initial Record Index",this.offset),"Strictly positive integer expected.");
            } else {
                if (this.tmask1.length==0) {
                    var ievt = 0;
                    this.tmask1 = 0;
                    var outpt = [];
                } else {
                    var ievt = 1;
                    var outpt = 1;
                }
                var out = size(this.outmask,"*");
                var tmpvar0 = check_io(this.model,this.graphics,[],out,1,outpt);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                this.frmt1 = part(this.frmt1,1,3);
                if (ok) {
                    if (ievt==0) {
                        this.model.firing = new ScilabDouble([-1]);
                    } else {
                        this.model.firing = new ScilabDouble([0]);
                    }
                    var ipar = [[length(this.fname1)],[this._str2code[this.frmt1-1]],[ievt],[this.N],[this.M],[this.swap],[this.offset],[this._str2code[this.fname1-1]],[this.tmask1],[this.outmask.slice()]];
                    if (prod(size(dstate))!=(this.N*this.M)+3) {
                        var dstate = [[-1],[-1],[lunit],[zeros(this.N*this.M,1)]];
                    }
                    this.model.dstate = new ScilabDouble(dstate);
                    this.model.ipar = new ScilabDouble(ipar);
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/RFILE_f.sci" */
function RFILE_f() {
    RFILE_f.prototype.define = function RFILE_f() {
        var out = 1;
        var nout = sum(out);
        var frmt = "(7(e10.3,1x))";
        var fname = "foo";
        var lunit = 0;
        this.N = 2;
        var rpar = [];
        var tmask = 0;
        this.outmask = 1;
        var ipar = [[length(fname)],[length(frmt)],[0],[this.N],[this._str2code[fname-1]],[this._str2code[frmt-1]],[tmask],[this.outmask]];
        var dstate = [[1],[1],[lunit],[zeros((nout)*this.N,1)]];
        this.model = scicos_model();
        this.model.sim = new ScilabString(["readf"]);
        this.model.out = new ScilabDouble([nout]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble(dstate);
        this.model.ipar = new ScilabDouble([length(fname)],[length(frmt)],[0],[this.N],[this._str2code[fname-1]],[this._str2code[frmt-1]],[tmask],[this.outmask]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [[sci2exp([])],[sci2exp(this.outmask)],[fname],[frmt],[string(this.N)],[sci2exp(out)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"RFILE_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    RFILE_f.prototype.details = function RFILE_f() {
        return this.x;
    }
    RFILE_f.prototype.get = function RFILE_f() {
        var options = {
            tmask1:["Time Record Selection",this.tmask1],
            outmask:["Outputs Record Selection",this.outmask],
            fname1:["Input File Name",this.fname1],
            frmt1:["Input Format",this.frmt1],
            N:["Buffer Size",this.N],
        }
        return options;
    }
    RFILE_f.prototype.set = function RFILE_f() {
        this.exprs = this.graphics.exprs;
        var dstate = this.model.dstate;
        var ipar = this.model.ipar;
        var ievt = ipar[3-1];
        this.N = ipar[4-1];
        var imask = 5+ipar[1-1]+ipar[2-1];
        var tmask = ipar[imask-1];
        var lunit = dstate[3-1];
        var fname = this.exprs[3-1];
        var frmt = this.exprs[4-1];
        if (size(this.exprs,"*")>5) {
            this.exprs[6-1] = [];
        }
        while (true) {
            var ok = true;
            this.tmask1 = parseFloat(arguments[0]["tmask1"]);
            this.outmask = parseFloat(arguments[0]["outmask"]);
            this.fname1 = parseFloat(arguments[0]["fname1"]);
            this.frmt1 = parseFloat(arguments[0]["frmt1"]);
            this.N = parseFloat(arguments[0]["N"]);
            if (!ok) {
                break;
            }
            this.fname1 = pathconvert(stripblanks(this.fname1),false,true);
            this.frmt1 = stripblanks(this.frmt1);
            var nout = size(this.outmask,"*");
            if (prod(size(this.tmask1))>1) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %s.","Time Record Selection",strcat(string(this.tmask1.slice())," ")),"Empty matrix or scalar expected.");
            } else if (this.tmask1.length!=0&&this.tmask1<1) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d","Time Record Selection",this.tmask1),"Strictly positive integer expected.");
            } else if (lunit>0&&min(length(frmt),1)!=min(length(this.frmt1),1)) {
                block_parameter_error(["Simulation running !!! You cannot switch <br />between formatted and unformatted"],"End current simulation first.");
            } else if (lunit>0&&this.fname1!=fname) {
                block_parameter_error("Simulation running !!! You cannot modify \'Input File Name\'","End current simulation first.");
            } else if (lunit>0&&size(this.tmask1)!=size(tmask)) {
                block_parameter_error("Simulation running !!! You cannot modify \'Time Record Selection\'","End current simulation first.");
            } else if (this.fname1=="") {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %s","Input File Name",this.fname1),"You must provide a filename.");
            } else if (this.frmt1!=""&&(part(this.frmt1,1)!="("||part(this.frmt1,length(this.frmt1))!=")")) {
                block_parameter_error(msprintf("Wrong format for \'%s\' parameter: %s.","Input Format",this.frmt1),"You must enclose the format\'s string between parentheses.");
            } else if (this.N<2) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Buffer Size",this.N),"Buffer size must be at least 2.");
            } else if (nout==0) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %d.","Outputs Record Selection",nout),"You must read at least one field in record.");
            } else if (min(this.outmask)<1) {
                block_parameter_error(msprintf("Wrong value for \'%s\' parameter: %s","Outputs Record Selection",strcat(string(this.outmask.slice())," ")),"Strictly positive indexes expected.");
            } else {
                if (this.tmask1.length==0) {
                    var ievt = 0;
                    var cout = [];
                    this.tmask1 = 0;
                } else {
                    var ievt = 1;
                    var cout = 1;
                }
                var tmpvar0 = check_io(this.model,this.graphics,[],nout,1,cout);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
                if (ok) {
                    if (ievt==0) {
                        this.model.firing = new ScilabDouble([]);
                    } else {
                        this.model.firing = new ScilabDouble([0]);
                    }
                    var ipar = [[length(this.fname1)],[length(this.frmt1)],[ievt],[this.N],[this._str2code[this.fname1-1]],[this._str2code[this.frmt1-1]],[this.tmask1],[this.outmask.slice()]];
                    if (prod(size(dstate))!=(nout+ievt)*this.N+3) {
                        var dstate = [[-1],[-1],[lunit],[zeros((nout+ievt)*this.N,1)]];
                    }
                    this.model.dstate = new ScilabDouble(dstate);
                    this.model.ipar = new ScilabDouble(ipar);
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                    break;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/SAWTOOTH_f.sci" */
function SAWTOOTH_f() {
    SAWTOOTH_f.prototype.define = function SAWTOOTH_f() {
        this.model = scicos_model();
        this.model.sim = new ScilabString(["sawtth"]);
        this.model.out = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.dstate = new ScilabDouble([0]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.exprs = " ";
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"SAWTOOTH_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabString([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    SAWTOOTH_f.prototype.details = function SAWTOOTH_f() {
        return this.x;
    }
    SAWTOOTH_f.prototype.get = function SAWTOOTH_f() {
        alert("parameters cannot be modified");
    }
    SAWTOOTH_f.prototype.set = function SAWTOOTH_f() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/STEP.sci" */
function STEP() {
    STEP.prototype.define = function STEP() {
        var rpar = [[0],[1]];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["step_func"]), new ScilabDouble([4]));
        this.model.evtin = new ScilabDouble([1]);
        this.model.evtout = new ScilabDouble([1]);
        this.model.out = new ScilabDouble([1]);
        this.model.out2 = new ScilabDouble([1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.firing = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble(rpar);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [[string(1)],[string(rpar)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"STEP\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    STEP.prototype.details = function STEP() {
        return this.x;
    }
    STEP.prototype.get = function STEP() {
        var options = {
            temps:["Step Time",this.temps],
            in1:["Initial Value",this.in1],
            fi:["Final Value",this.fi],
        }
        return options;
    }
    STEP.prototype.set = function STEP() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.temps = arguments[0]["temps"];
            this.in1 = arguments[0]["in1"];
            this.fi = arguments[0]["fi"];
            if (!ok) {
                break;
            }
            this.in1 = this.in1.slice();
            this.fi = this.fi.slice();
            if (size(this.in1,"*")!=size(this.fi,"*")) {
                if (size(this.in1,"*")==1) {
                    this.in1 = this.in1*ones(this.fi);
                } else if (size(this.fi,"*")==1) {
                    this.fi = this.fi*ones(this.in1);
                } else {
                    block_parameter_error(msprintf("\'Initial Value\' and \'Final Value\': incompatible sizes: %d and %d.",size(this.in1,"*"),size(this.fi,"*")),"Same sizes expected.");
                    var ok = false;
                }
            }
            if (ok) {
                this.model.out2 = new ScilabDouble([1]);
                this.model.outtyp = new ScilabDouble([1]);
                var tmpvar0 = check_io(this.model,this.graphics,[],size(this.fi,"*"),1,1);
                this.model = tmpvar0[0];
                this.graphics = tmpvar0[1];
                var ok = tmpvar0[2];
            }
            if (ok) {
                this.model.firing = new ScilabDouble([this.temps]);
                if (this.temps==0) {
                    var rpar = [[this.fi],[this.fi]];
                } else {
                    var rpar = [[this.in1],[this.fi]];
                }
                this.model.rpar = new ScilabDouble(rpar);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/STEP_FUNCTION.sci" */
function STEP_FUNCTION() {
    STEP_FUNCTION.prototype.define = function STEP_FUNCTION() {
        var scs_m_1 = scicos_diagram();
        scs_m_1.objs[1-1] = STEP("define");
        scs_m_1.objs[2-1] = OUT_f("define");
        scs_m_1.objs[3-1] = scicos_link();
        scs_m_1.objs[4-1] = scicos_link();
        var blk = scs_m_1.objs[1-1];
        this.graphics = blk.graphics;
        this.model = blk.model;
        this.graphics.orig = new ScilabDouble([0,0]);
        this.graphics.sz = new ScilabDouble([40,40]);
        this.graphics.pein = new ScilabDouble([4]);
        this.graphics.peout = new ScilabDouble([4]);
        this.graphics.pout = new ScilabDouble([3]);
        blk.graphics = this.graphics;
        blk.model = this.model;
        scs_m_1.objs[1-1] = blk;
        var blk = scs_m_1.objs[2-1];
        this.graphics = blk.graphics;
        this.model = blk.model;
        this.graphics.orig = new ScilabDouble([80,10]);
        this.graphics.sz = new ScilabDouble([20,20]);
        this.graphics.exprs = new ScilabString(["1"]);
        this.model.ipar = new ScilabDouble([1]);
        this.graphics.pin = new ScilabDouble([3]);
        blk.graphics = this.graphics;
        blk.model = this.model;
        scs_m_1.objs[2-1] = blk;
        var lnk = scs_m_1.objs[3-1];
        lnk.from = [1,1,0];
        lnk.to = [2,1,1];
        scs_m_1.objs[3-1] = lnk;
        var lnk = scs_m_1.objs[4-1];
        lnk.xx = [0,20,-20,-20,20,1];
        lnk.yy = [0,-20,-20,60,60,1];
        lnk.ct = [5,-1];
        lnk.from = [1,1,0];
        lnk.to = [1,1,1];
        scs_m_1.objs[4-1] = lnk;
        blk={};
        lnk={};
        this.model = scicos_model();
        this.model.sim = new ScilabString(["csuper"]);
        this.model.out = new ScilabDouble([1]);
        this.model.out2 = new ScilabDouble([1]);
        this.model.outtyp = new ScilabDouble([1]);
        this.model.rpar = scs_m_1;
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"STEP_FUNCTION\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble([]),this.gr_i);
        return new BasicBlock(this.x);
    }
    STEP_FUNCTION.prototype.details = function STEP_FUNCTION() {
        return this.x;
    }
    STEP_FUNCTION.prototype.get = function STEP_FUNCTION() {
        alert("parameters cannot be modified");
    }
    STEP_FUNCTION.prototype.set = function STEP_FUNCTION() {
            if (typeof(o)=="Block"&&o.gui=="STEP") {
                var ppath = list(i);
                break;
            }
        }
        var newpar = list();
        for (path in ppath) {
            var np = size(path,"*");
            var spath = list();
            for (k=1;k<=np;k+=1) {
                spath[$+1-1] = "model";
                spath[$+1-1] = "rpar";
                spath[$+1-1] = "objs";
                spath[$+1-1] = path[k-1];
            }
            execstr("xxn="+xx.gui+"(\'set\',xx)");
            if (diffobjs(this.xxn,xx)) {
                this.model = xx.model;
                var model_n = this.xxn.model;
                if (!is_modelica_block(xx)) {
                    var modified = or(this.model.sim!=model_n.sim)||!isequal(this.model.state,model_n.state)||!isequal(this.model.dstate,model_n.dstate)||!isequal(this.model.rpar,model_n.rpar)||!isequal(this.model.ipar,model_n.ipar)||!isequal(this.model.label,model_n.label);
                    if (or(this.model.in!=model_n.in)||or(this.model.out!=model_n.out)) {
                        var needcompile = 1;
                    }
                    if (or(this.model.firing!=model_n.firing)) {
                        var needcompile = 2;
                    }
                    if (this.model.sim=="input"||this.model.sim=="output") {
                        if (this.model.ipar!=model_n.ipar) {
                            var needcompile = 4;
                        }
                    }
                    if (or(this.model.blocktype!=model_n.blocktype)||or(this.model.dep_ut!=model_n.dep_ut)) {
                        var needcompile = 4;
                    }
                    if ((this.model.nzcross!=model_n.nzcross)||(this.model.nmode!=model_n.nmode)) {
                        var needcompile = 4;
                    }
                    if (prod(size(model_n.sim))>1) {
                        if (model_n.sim[2-1]>1000) {
                            if (this.model.sim[1-1]!=model_n.sim[1-1]) {
                                var needcompile = 4;
                            }
                        }
                    }
                } else {
                    var modified = or(model_n!=this.model);
                    var eq = this.model.equations;
                    var eqn = model_n.equations;
                    if (or(eq.model!=eqn.model)||or(eq.inputs!=eqn.inputs)||or(eq.outputs!=eqn.outputs)) {
                        var needcompile = 4;
                    }
                }
                newpar[size(newpar)+1-1] = path;
            }
        }
        var y = needcompile;
        var typ = newpar;
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/SampleCLK.sci" */
function SampleCLK() {
    SampleCLK.prototype.define = function SampleCLK() {
        this.model = scicos_model();
        this.model.sim = new ScilabString(["sampleclk"]);
        this.model.evtout = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([1,0]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.firing = new ScilabDouble([-1]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [[sci2exp(1)],[sci2exp(0)]];
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble(this.exprs)," ");
        return new BasicBlock(this.x);
    }
    SampleCLK.prototype.details = function SampleCLK() {
        return this.x;
    }
    SampleCLK.prototype.get = function SampleCLK() {
        var options = {
            frequ:["Sample time",this.frequ],
            offset:["Offset",this.offset],
        }
        return options;
    }
    SampleCLK.prototype.set = function SampleCLK() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.frequ = arguments[0]["frequ"];
            this.offset = arguments[0]["offset"];
            if (!ok) {
                break;
            }
            if (this.frequ<0) {
                message("Frequency must be a positif number");
                throw "user error";
                var ok = false;
            }
            if (abs(this.offset)>this.frequ) {
                message("The |Offset| must be less than the Frequency");
                throw "user error";
                var ok = false;
            }
            if (ok) {
                if (or(this.model.rpar.slice()!=[[this.frequ],[this.offset]])) {
                    var needcompile = 4;
                    var y = needcompile;
                }
                this.model.rpar = new ScilabDouble([this.frequ],[this.offset]);
                this.model.evtout = new ScilabDouble([1]);
                this.model.firing = new ScilabDouble([-1]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        needcompile = resume(needcompile)
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/Sigbuilder.sci" */
function Sigbuilder() {
    Sigbuilder.prototype.define = function Sigbuilder() {
        var scs_m_1 = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["Sigbuilder","./"],tol=[[0.0001],[0.000001],[1.000e-10],[100001],[0],[0],[0]],tf=100,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m_1.objs[1-1] = scicos_block(gui="CURVE_c",graphics=scicos_graphics(orig=[329.63473,606.18517],sz=[40,40],flip=true,theta=0,exprs=[["3"],["[0,1,2]"],["[10,20,-30]"],["y"],["n"]],pin=[],pout=6,pein=4,peout=2,gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim=list("curve_c",4),in1=[],in2=[],intyp=1,out=1,out2=[],outtyp=1,evtin=1,evtout=1,state=[],dstate=[],odstate=list(),rpar=[[0],[1],[2],[10],[20],[-30]],ipar=[[3],[3],[1]],opar=list(),blocktype="c",firing=0,dep_ut=[false,true],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[2-1] = scicos_link(xx=[[349.63473],[349.49528]],yy=[[600.47089],[565.10704]],id="drawlink",thick=[0,0],ct=[5,-1],from=[1,1,0],to=[3,1,1]);
        scs_m_1.objs[3-1] = scicos_block(gui="CLKSPLIT_f",graphics=scicos_graphics(orig=[[349.49528],[565.10704]],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=[],pout=[],pein=2,peout=[[8],[4]],gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="split",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=[[1],[1]],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="d",firing=[false,false,false],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[4-1] = scicos_link(xx=[[349.49528],[266.69602],[266.69602],[270.35525],[342.80795],[342.80795],[349.63473]],yy=[[565.10704],[565.10704],[680.99483],[680.99483],[680.99483],[651.89946],[651.89946]],id="drawlink",thick=[0,0],ct=[5,-1],from=[3,2,0],to=[1,1,1]);
        scs_m_1.objs[5-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[398.20616,616.18517],sz=[20,20],flip=true,theta=0,exprs="1",pin=6,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=-2,intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[6-1] = scicos_link(xx=[[378.20616],[398.20616]],yy=[[626.18517],[626.18517]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[5,1,1]);
        scs_m_1.objs[7-1] = scicos_block(gui="CLKOUTV_f",graphics=scicos_graphics(orig=[339.49528,505.10704],sz=[20,30],flip=true,theta=0,exprs="1",pin=[],pout=[],pein=8,peout=[],gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="output",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[8-1] = scicos_link(xx=[[349.49528],[349.49528]],yy=[[565.10704],[535.10704]],id="drawlink",thick=[0,0],ct=[5,-1],from=[3,1,0],to=[7,1,1]);
        this.model = scicos_model(sim="csuper",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=1,evtin=[],evtout=1,state=[],dstate=[],odstate=list(),rpar=scs_m_1,ipar=[],opar=list(),blocktype="h",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list());
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"Sigbuilder\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble([]),this.gr_i);
        return new BasicBlock(this.x);
    }
    Sigbuilder.prototype.details = function Sigbuilder() {
        return this.x;
    }
    Sigbuilder.prototype.get = function Sigbuilder() {
        alert("parameters cannot be modified");
    }
    Sigbuilder.prototype.set = function Sigbuilder() {
        var ppath = list(0);
            if (typeof(o)=="Block"&&o.gui=="CURVE_c") {
                ppath[1-1] = i;
                break;
            }
        }
        var newpar = list();
        this.y = 0;
        for (path in ppath) {
            var np = size(path,"*");
            var spath = list();
            for (k=1;k<=np;k+=1) {
                spath[$+1-1] = "model";
                spath[$+1-1] = "rpar";
                spath[$+1-1] = "objs";
                spath[$+1-1] = path[k-1];
            }
            execstr("xxn="+xx.gui+"(\'set\',xx)");
            if (diffobjs(this.xxn,xx)) {
                this.model = xx.model;
                var model_n = this.xxn.model;
                if (!is_modelica_block(xx)) {
                    var modified = or(this.model.sim!=model_n.sim)||!isequal(this.model.state,model_n.state)||!isequal(this.model.dstate,model_n.dstate)||!isequal(this.model.odstate,model_n.odstate)||!isequal(this.model.rpar,model_n.rpar)||!isequal(this.model.ipar,model_n.ipar)||!isequal(this.model.opar,model_n.opar)||!isequal(this.model.label,model_n.label);
                    if (or(this.model.in!=model_n.in)||or(this.model.out!=model_n.out)||or(this.model.in2!=model_n.in2)||or(this.model.out2!=model_n.out2)||or(this.model.outtyp!=model_n.outtyp)||or(this.model.intyp!=model_n.intyp)) {
                        var needcompile = 1;
                    }
                    if (or(this.model.firing!=model_n.firing)) {
                        var needcompile = 2;
                    }
                    if ((size(this.model.in,"*")!=size(model_n.in,"*"))||(size(this.model.out,"*")!=size(model_n.out,"*"))) {
                        var needcompile = 4;
                    }
                    if (this.model.sim=="input"||this.model.sim=="output") {
                        if (this.model.ipar!=model_n.ipar) {
                            var needcompile = 4;
                        }
                    }
                    if (or(this.model.blocktype!=model_n.blocktype)||or(this.model.dep_ut!=model_n.dep_ut)) {
                        var needcompile = 4;
                    }
                    if ((this.model.nzcross!=model_n.nzcross)||(this.model.nmode!=model_n.nmode)) {
                        var needcompile = 4;
                    }
                    if (prod(size(model_n.sim))>1) {
                        if (model_n.sim[2-1]>1000) {
                            if (this.model.sim[1-1]!=model_n.sim[1-1]) {
                                var needcompile = 4;
                            }
                        }
                    }
                } else {
                    var modified = or(model_n!=this.model);
                    var eq = this.model.equations;
                    var eqn = model_n.equations;
                    if (or(eq.model!=eqn.model)||or(eq.inputs!=eqn.inputs)||or(eq.outputs!=eqn.outputs)) {
                        var needcompile = 4;
                    }
                }
                newpar[size(newpar)+1-1] = path;
                this.y = max(this.y,needcompile);
            }
        }
        var typ = newpar;
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/TIME_f.sci" */
function TIME_f() {
    TIME_f.prototype.define = function TIME_f() {
        this.model = scicos_model();
        this.model.sim = new ScilabString(["timblk"]);
        this.model.out = new ScilabDouble([1]);
        this.model.blocktype = new ScilabString(["c"]);
        this.model.dep_ut = new ScilabBoolean([false,true]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"TIME_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble([]),this.gr_i);
        return new BasicBlock(this.x);
    }
    TIME_f.prototype.details = function TIME_f() {
        return this.x;
    }
    TIME_f.prototype.get = function TIME_f() {
        alert("parameters cannot be modified");
    }
    TIME_f.prototype.set = function TIME_f() {
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Sources/TKSCALE.sci" */
function TKSCALE() {
    TKSCALE.prototype.define = function TKSCALE() {
        this.a = -10;
        this.b = 10;
        this.f = 1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["tkscaleblk"]), new ScilabDouble([5]));
        this.model.out = new ScilabDouble([1]);
        this.model.evtin = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([this.a],[this.b],[this.f]);
        this.model.blocktype = new ScilabString(["d"]);
        this.model.dep_ut = new ScilabBoolean([false,false]);
        this.exprs = [[sci2exp(this.a)],[sci2exp(this.b)],[sci2exp(this.f)]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"TKSCALE\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    TKSCALE.prototype.details = function TKSCALE() {
        return this.x;
    }
    TKSCALE.prototype.get = function TKSCALE() {
        var options = {
        a:["Min value",this.a],
        b:["Max value",this.b],
        f:["Normalization",this.f],
        }
        return options;
    }
    TKSCALE.prototype.set = function TKSCALE() {
        this.exprs = this.graphics.exprs;
        var ok = true;
        this.a = parseFloat(arguments[0]["a"]);
        this.b = parseFloat(arguments[0]["b"]);
        this.f = parseFloat(arguments[0]["f"]);
        if (ok) {
            this.graphics.exprs = new ScilabDouble([this.exprs]);
            this.model.rpar = new ScilabDouble([this.a],[this.b],[this.f]);
            this.x.graphics = this.graphics;
            this.x.model = this.model;
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Threshold/GENERAL_f.sci" */
function GENERAL_f() {
    GENERAL_f.prototype.define = function GENERAL_f() {
        var rpar = [[0],[0],[0],[0]];
        this.in1 = 1;
        this.out = 1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["zcross"]), new ScilabDouble([1]));
        this.model.nzcross = new ScilabDouble([this.in1]);
        this.model.in = new ScilabDouble([this.in1]);
        this.model.evtout = new ScilabDouble([ones(this.out,1)]);
        this.model.rpar = new ScilabDouble([0],[0],[0],[0]);
        this.model.blocktype = new ScilabString(["z"]);
        this.model.firing = new ScilabDouble([-ones(this.out,1)]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = [[strcat(sci2exp(this.in1))],[strcat(sci2exp(this.out))]];
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"GENERAL_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([3,2]),this.model,new ScilabDouble(this.exprs),this.gr_i);
        return new BasicBlock(this.x);
    }
    GENERAL_f.prototype.details = function GENERAL_f() {
        return this.x;
    }
    GENERAL_f.prototype.get = function GENERAL_f() {
        var options = {
        in1:["Input size",this.in1],
        out:["Number of event output",this.out],
        }
        return options;
    }
    GENERAL_f.prototype.set = function GENERAL_f() {
        this.exprs = this.graphics.exprs;
        var rpar = this.model.rpar;
        this.in1 = this.model.in;
        this.out = this.model.evtout;
        var nin = sum(this.in1);
        var nout = sum(this.out);
        var ok = true;
        this.in1 = parseFloat(arguments[0]["in1"]);
        this.out = parseFloat(arguments[0]["out"]);
        if (ok) {
            var tmpvar0 = check_io(this.model,this.graphics,this.in1,[],[],ones(this.out,1));
            this.model = tmpvar0[0];
            this.graphics = tmpvar0[1];
            var ok = tmpvar0[2];
            if (ok) {
                var nout1 = this.out;
                var nin1 = this.in1;
                if (nout==nout1&&nin==nin1) {
                    var rp = matrix(rpar,nout,2^(2*nin));
                } else {
                    var rp = -1*ones(nout1,2^(2*nin1));
                }
                var n = size(rp,2)/2;
                var result = x_mdialog("routing matrix",string(1,nout1),string(1,2^(2*nin1)),string(rp.slice().slice()));
                if (result.length!=0) {
                    rp.slice(1-1,nout1).slice(1-1,2*n) = evstr(result);
                    this.model.nzcross = new ScilabDouble([this.in1]);
                    this.model.rpar = new ScilabDouble(rp.slice());
                    this.model.firing = new ScilabDouble([-ones(this.out,1)]);
                    this.graphics.exprs = new ScilabDouble([this.exprs]);
                    this.x.graphics = this.graphics;
                    this.x.model = this.model;
                }
            }
        }
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Threshold/NEGTOPOS_f.sci" */
function NEGTOPOS_f() {
    NEGTOPOS_f.prototype.define = function NEGTOPOS_f() {
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["zcross"]), new ScilabDouble([1]));
        this.model.nzcross = new ScilabDouble([1]);
        this.model.in = new ScilabDouble([1]);
        this.model.evtout = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([-1],[-1],[0],[-1]);
        this.model.blocktype = new ScilabString(["z"]);
        this.model.firing = new ScilabDouble([-1]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"NEGTOPOS_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble([]),this.gr_i);
        return new BasicBlock(this.x);
    }
    NEGTOPOS_f.prototype.details = function NEGTOPOS_f() {
        return this.x;
    }
    NEGTOPOS_f.prototype.get = function NEGTOPOS_f() {
        alert("parameters cannot be modified");
    }
    NEGTOPOS_f.prototype.set = function NEGTOPOS_f() {
        this.x.model.firing = -1;
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Threshold/POSTONEG_f.sci" */
function POSTONEG_f() {
    POSTONEG_f.prototype.define = function POSTONEG_f() {
        var rpar = [[-1],[-1],[-1],[0]];
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["zcross"]), new ScilabDouble([1]));
        this.model.nzcross = new ScilabDouble([1]);
        this.model.in = new ScilabDouble([1]);
        this.model.evtout = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([-1],[-1],[-1],[0]);
        this.model.blocktype = new ScilabString(["z"]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.model.firing = new ScilabDouble([-1]);
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"POSTONEG_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble([]),this.gr_i);
        return new BasicBlock(this.x);
    }
    POSTONEG_f.prototype.details = function POSTONEG_f() {
        return this.x;
    }
    POSTONEG_f.prototype.get = function POSTONEG_f() {
        alert("parameters cannot be modified");
    }
    POSTONEG_f.prototype.set = function POSTONEG_f() {
        this.x.model.firing = [-1];
        return new BasicBlock(this.x);
    }
}
/* autogenerated from "macros/Threshold/ZCROSS_f.sci" */
function ZCROSS_f() {
    ZCROSS_f.prototype.define = function ZCROSS_f() {
        var rpar = [[-1],[-1],[0],[0]];
        this.in1 = 1;
        this.model = scicos_model();
        this.model.sim = list(new ScilabString(["zcross"]), new ScilabDouble([1]));
        this.model.in = new ScilabDouble([this.in1]);
        this.model.nzcross = new ScilabDouble([this.in1]);
        this.model.evtout = new ScilabDouble([1]);
        this.model.rpar = new ScilabDouble([-1],[-1],[0],[0]);
        this.model.blocktype = new ScilabString(["z"]);
        this.model.firing = new ScilabDouble([-1]);
        this.model.dep_ut = new ScilabBoolean([true,false]);
        this.exprs = strcat(sci2exp(this.in1));
        this.gr_i = new ScilabString(["xstringb(orig(1),orig(2),\"ZCROSS_f\",sz(1),sz(2));"]);
        this.x = new standard_define(new ScilabDouble([2,2]),this.model,new ScilabDouble([this.exprs]),this.gr_i);
        return new BasicBlock(this.x);
    }
    ZCROSS_f.prototype.details = function ZCROSS_f() {
        return this.x;
    }
    ZCROSS_f.prototype.get = function ZCROSS_f() {
        var options = {
            in1:["Input size",this.in1],
        }
        return options;
    }
    ZCROSS_f.prototype.set = function ZCROSS_f() {
        this.exprs = this.graphics.exprs;
        while (true) {
            var ok = true;
            this.in1 = parseFloat(arguments[0]["in1"]);
            if (!ok) {
                break;
            }
            this.in1 = int(this.in1);
            if (this.in1<=0) {
                message("Block must have at least one input");
                throw "user error";
            } else {
                var kk = 0;
                for (jj=1;jj<=this.in1;jj+=1) {
                    var kk = kk+2^(this.in1+jj-1);
                }
                this.model.rpar = new ScilabDouble([-ones(kk,1)],[zeros(2^(2*this.in1)-kk,1)]);
                this.graphics.exprs = new ScilabDouble([this.exprs]);
                this.model.in = new ScilabDouble([this.in1]);
                this.model.nzcross = new ScilabDouble([this.in1]);
                this.model.firing = new ScilabDouble([-1]);
                this.x.graphics = this.graphics;
                this.x.model = this.model;
                break;
            }
        }
        return new BasicBlock(this.x);
    }
}

/* made from 273/274 files */
