/* autogenerated from "macros/Branching/CLKFROM.sci" */
function CLKFROM() {
    CLKFROM.prototype.define = function CLKFROM() {
        model = scicos_model();
        model.sim = "clkfrom";
        model.evtout = 1;
        model.opar = list("A");
        model.blocktype = "d";
        model.firing = -1;
        model.dep_ut = [false,false];
        exprs = "A";
        x = standard_define([2,1],model,exprs," ");
        x.graphics.id = "From";
    }
    CLKFROM.prototype.details = function CLKFROM() {
    }
    CLKFROM.prototype.get = function CLKFROM() {
    }
    CLKFROM.prototype.set = function CLKFROM() {
        x = arg1;
        graphics = arg1.graphics;
        model = arg1.model;
        exprs = graphics.exprs;
        while (true) {
        [ok,tag,exprs] = scicos_getvalue("Set block parameters","Tag",list("str",-1),exprs);
        if (!ok) {
break;
}
        if (model.opar!=list(tag)) {
        needcompile = 4;
        y = needcompile;
}
        model.opar = list(tag);
        model.evtout = 1;
        model.firing = -1;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
needcompile=resume(needcompile)
    }
}
/* autogenerated from "macros/Branching/CLKGOTO.sci" */
function CLKGOTO() {
    CLKGOTO.prototype.define = function CLKGOTO() {
        model = scicos_model();
        model.sim = "clkgoto";
        model.evtin = 1;
        model.opar = list("A");
        model.ipar = int(1);
        model.blocktype = "d";
        model.firing = -1;
        model.dep_ut = [false,false];
        exprs = [["A"],[sci2exp(1)]];
        x = standard_define([2,1],model,exprs," ");
        x.graphics.id = "Goto";
    }
    CLKGOTO.prototype.details = function CLKGOTO() {
    }
    CLKGOTO.prototype.get = function CLKGOTO() {
    }
    CLKGOTO.prototype.set = function CLKGOTO() {
        x = arg1;
        graphics = arg1.graphics;
        model = arg1.model;
        exprs = graphics.exprs;
        while (true) {
        [ok,tag,tagvis,exprs] = scicos_getvalue("Set block parameters",[["Tag"],["Tag Visibility (1=Local 2=Scoped 3=Global)"]],list("str",-1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (((tagvis<1)||(tagvis>3))) {
message("Tag Visibility must be between 1 and 3");
        ok = false;
}
        tagvis = int(tagvis);
        if (ok) {
        if (((model.opar!=list(tag))||(model.ipar!=tagvis))) {
        needcompile = 4;
        y = needcompile;
}
        model.opar = list(tag);
        model.ipar = tagvis;
        model.evtin = 1;
        model.firing = -1;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
needcompile=resume(needcompile)
    }
}
/* autogenerated from "macros/Branching/CLKGotoTagVisibility.sci" */
function CLKGotoTagVisibility() {
    CLKGotoTagVisibility.prototype.define = function CLKGotoTagVisibility() {
        model = scicos_model();
        model.sim = "clkgototagvisibility";
        model.in1 = [];
        model.in2 = [];
        model.out = [];
        model.out2 = [];
        model.evtin = [];
        model.intyp = 1;
        model.outtyp = 1;
        model.opar = list("A");
        model.blocktype = "c";
        model.firing = false;
        model.dep_ut = [false,false];
        exprs = "A";
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    CLKGotoTagVisibility.prototype.details = function CLKGotoTagVisibility() {
    }
    CLKGotoTagVisibility.prototype.get = function CLKGotoTagVisibility() {
    }
    CLKGotoTagVisibility.prototype.set = function CLKGotoTagVisibility() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,tag,exprs] = scicos_getvalue("Set parameters",["GotoTag"],list("str",-1),exprs);
        if (!ok) {
break;
}
        if (ok) {
        if (model.opar!=list(tag)) {
        needcompile = 4;
        y = needcompile;
}
        graphics.exprs = exprs;
        model.opar = list(tag);
        x.graphics = graphics;
        x.model = model;
break;
}
}
needcompile=resume(needcompile)
    }
}
/* autogenerated from "macros/Branching/DEMUX.sci" */
function DEMUX() {
    DEMUX.prototype.define = function DEMUX() {
        out = 2;
        model = scicos_model();
        model.sim = list("multiplex",4);
        model.in1 = 0;
        model.out = -transpose([1:out]);
        model.ipar = out;
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        exprs = string(out);
        gr_i = [];
        x = standard_define([.5,2],model,exprs,gr_i);
    }
    DEMUX.prototype.details = function DEMUX() {
    }
    DEMUX.prototype.get = function DEMUX() {
    }
    DEMUX.prototype.set = function DEMUX() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,out,exprs] = scicos_getvalue("Set DEMUX block parameters",["number of output ports or vector of sizes"],list("intvec",-1),exprs);
        if (!ok) {
break;
}
        if (size(out,"*")==1) {
        if (out<2||out>31) {
message("Block must have at least 2 and at most 31 output ports");
        ok = false;
        } else {
        [model,graphics,ok] = check_io(model,graphics,0,-transpose([1:out]),[],[]);
}
        } else {
        if (size(out,"*")<2||or(out==0)||size(out,"*")>31) {
message([["Block must have at least 2 and at most 31 output ports"],["size 0 is not allowed"]]);
        ok = false;
        } else {
        if (min(out)<0) {
        nin = 0;
        } else {
        nin = sum(out);
}
        [model,graphics,ok] = check_io(model,graphics,nin,out.slice(),[],[]);
        if (ok) {
        out = size(out,"*");
}
}
}
        if (ok) {
        graphics.exprs = exprs;
        model.ipar = out;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Branching/DEMUX_f.sci" */
function DEMUX_f() {
    DEMUX_f.prototype.define = function DEMUX_f() {
        out = 2;
        model = scicos_model();
        model.sim = list("demux",1);
        model.in1 = 0;
        model.out = -transpose([1:out]);
        model.ipar = out;
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        exprs = string(out);
        gr_i = [];
        x = standard_define([.5,2],model,exprs,gr_i);
    }
    DEMUX_f.prototype.details = function DEMUX_f() {
    }
    DEMUX_f.prototype.get = function DEMUX_f() {
    }
    DEMUX_f.prototype.set = function DEMUX_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,out,exprs] = scicos_getvalue("Set DEMUX block parameters",["number of output ports or vector of sizes"],list("vec",-1),exprs);
        if (!ok) {
break;
}
        if (size(out,"*")==1) {
        if (out<2||out>8) {
message("Block must have at least 2 and at most 8 output ports");
        ok = false;
        } else {
        [model,graphics,ok] = check_io(model,graphics,0,-transpose([1:out]),[],[]);
}
        } else {
        if (size(out,"*")<2||size(out,"*")>8||or(out==0)) {
message([["Block must have at least 2 and at most 8 output ports"],["and size 0 is not allowed"]]);
        ok = false;
        } else {
        if (min(out)<0) {
        nin = 0;
        } else {
        nin = sum(out);
}
        [model,graphics,ok] = check_io(model,graphics,nin,out.slice(),[],[]);
        if (ok) {
        out = size(out,"*");
}
}
}
        if (ok) {
        graphics.exprs = exprs;
        model.ipar = out;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Branching/ESELECT_f.sci" */
function ESELECT_f() {
    ESELECT_f.prototype.define = function ESELECT_f() {
        out = 2;
        model = scicos_model();
        model.sim = list("eselect",-2);
        model.in1 = 1;
        model.in2 = 1;
        model.intyp = -1;
        model.evtin = 1;
        model.evtout = ones(out,1);
        model.blocktype = "l";
        model.firing = -ones(out,1);
        model.dep_ut = [true,false];
        model.nmode = 0;
        model.nzcross = 0;
        gr_i = [];
        exprs = [[string(out)],[string(1)],[string(model.nmode)]];
        x = standard_define([4,2],model,exprs,gr_i);
    }
    ESELECT_f.prototype.details = function ESELECT_f() {
    }
    ESELECT_f.prototype.get = function ESELECT_f() {
    }
    ESELECT_f.prototype.set = function ESELECT_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        if (size(exprs,"*")==1) {
        exprs[2-1] = string(1);
}
        if (size(exprs,"*")==2) {
        exprs[3-1] = string(0);
}
        model = arg1.model;
        while (true) {
        [ok,out,inh,nmod,exprs] = scicos_getvalue("Set ESELECT block parameters",[["number of output event ports"],["Inherit (1: no, 0: yes)"],["zero-crossing (0: no, 1: yes)"]],list("vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (nmod!=0) {
        nmod = 1;
}
        if (inh==0) {
        inh = [];
        } else {
        inh = 1;
}
        out = int(out);
        if (out<2) {
message("Block must have at least two output ports");
        } else {
        [model,graphics,ok] = check_io(model,graphics,1,[],inh,[ones(out,1)]);
        if (ok) {
        graphics.exprs = exprs;
        model.evtout = ones(out,1);
        model.firing = -ones(out,1);
        x.graphics = graphics;
        model.nmode = nmod;
        model.nzcross = nmod;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/Branching/EXTRACTOR.sci" */
function EXTRACTOR() {
    EXTRACTOR.prototype.define = function EXTRACTOR() {
        ind = 1;
        model = scicos_model();
        model.sim = list("extractor",4);
        model.in1 = -1;
        model.out = 1;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        model.ipar = ind;
        exprs = [sci2exp(ind)];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    EXTRACTOR.prototype.details = function EXTRACTOR() {
    }
    EXTRACTOR.prototype.get = function EXTRACTOR() {
    }
    EXTRACTOR.prototype.set = function EXTRACTOR() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,ind,exprs] = scicos_getvalue("Set block parameters",["indices to extract"],list("vec",-1),exprs);
        if (!ok) {
break;
}
        ind = int(ind);
        ind = ind.slice();
        [model,graphics,ok] = check_io(model,graphics,[-1],size(ind,1),[],[]);
        if (ok) {
        model.ipar = ind;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Branching/FROM.sci" */
function FROM() {
    FROM.prototype.define = function FROM() {
        model = scicos_model();
        model.sim = "from";
        model.in1 = [];
        model.in2 = [];
        model.intyp = 1;
        model.out = -1;
        model.out2 = -2;
        model.outtyp = -1;
        model.ipar = [];
        model.opar = list("A");
        model.blocktype = "c";
        model.dep_ut = [false,false];
        exprs = ["A"];
        gr_i = [];
        x = standard_define([2,1],model,exprs,gr_i);
        x.graphics.id = "From";
    }
    FROM.prototype.details = function FROM() {
    }
    FROM.prototype.get = function FROM() {
    }
    FROM.prototype.set = function FROM() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,tag,exprs] = scicos_getvalue("Set parameters",["Tag"],list("str",-1),exprs);
        if (!ok) {
break;
}
        if (ok) {
        if (model.opar!=list(tag)) {
        needcompile = 4;
        y = needcompile;
}
        graphics.exprs = exprs;
        model.opar = list(tag);
        x.model = model;
        x.graphics = graphics;
break;
}
}
needcompile=resume(needcompile)
    }
}
/* autogenerated from "macros/Branching/FROMMO.sci" */
function FROMMO() {
    FROMMO.prototype.define = function FROMMO() {
        model = scicos_model();
        model.sim = "frommo";
        model.in1 = [];
        model.in2 = [];
        model.intyp = 1;
        model.out = -1;
        model.out2 = -2;
        model.outtyp = -1;
        model.ipar = [];
        model.opar = list("A");
        model.blocktype = "c";
        model.dep_ut = [false,false];
        mo = modelica();
        mo.model = "frommo";
        mo.outputs = "n";
        exprs = ["A"];
        gr_i = [];
        x = standard_define([2,1],model,exprs,gr_i);
        x.graphics.out_implicit = ["I"];
    }
    FROMMO.prototype.details = function FROMMO() {
    }
    FROMMO.prototype.get = function FROMMO() {
    }
    FROMMO.prototype.set = function FROMMO() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,tag,exprs] = scicos_getvalue("Set parameters",["Tag"],list("str",-1),exprs);
        if (!ok) {
break;
}
        if (ok) {
        if (model.opar!=list(tag)) {
        needcompile = 4;
        y = needcompile;
}
        graphics.exprs = exprs;
        model.opar = list(tag);
        x.model = model;
        x.graphics = graphics;
break;
}
}
needcompile=resume(needcompile)
    }
}
/* autogenerated from "macros/Branching/GOTO.sci" */
function GOTO() {
    GOTO.prototype.define = function GOTO() {
        model = scicos_model();
        model.sim = "goto";
        model.in1 = -1;
        model.in2 = -2;
        model.intyp = -1;
        model.out = [];
        model.out2 = [];
        model.outtyp = 1;
        model.ipar = int(1);
        model.opar = list("A");
        model.blocktype = "c";
        model.dep_ut = [false,false];
        exprs = [["A"],[sci2exp(1)]];
        gr_i = [];
        x = standard_define([2,1],model,exprs,gr_i);
        x.graphics.id = "Goto";
    }
    GOTO.prototype.details = function GOTO() {
    }
    GOTO.prototype.get = function GOTO() {
    }
    GOTO.prototype.set = function GOTO() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,tag,tagvis,exprs] = scicos_getvalue("Set parameters",[["Tag"],["Tag Visibility(1=Local 2=scoped 3= global)"]],list("str",-1,"vec",1),exprs);
        if (!ok) {
break;
}
        tagvis = int(tagvis);
        if (((tagvis<1)||(tagvis>3))) {
message("Tag Visibility must be between 1 and 3");
        ok = false;
}
        if (ok) {
        if (((model.ipar!=tagvis)||(model.opar!=list(tag)))) {
        needcompile = 4;
        y = needcompile;
}
        graphics.exprs = exprs;
        model.opar = list(tag);
        model.ipar = tagvis;
        x.model = model;
        x.graphics = graphics;
        arg1 = x;
break;
}
}
needcompile=resume(needcompile)
    }
}
/* autogenerated from "macros/Branching/GOTOMO.sci" */
function GOTOMO() {
    GOTOMO.prototype.define = function GOTOMO() {
        model = scicos_model();
        model.sim = "gotomo";
        model.in1 = -1;
        model.in2 = -2;
        model.intyp = [];
        model.out = [];
        model.out2 = [];
        model.outtyp = 1;
        model.ipar = int(1);
        model.opar = list("A");
        model.blocktype = "c";
        model.dep_ut = [false,false];
        mo = modelica();
        mo.model = "gotomo";
        mo.inputs = "p";
        exprs = [["A"],[sci2exp(1)]];
        gr_i = [];
        x = standard_define([2,1],model,exprs,gr_i);
        x.graphics.in_implicit = ["I"];
    }
    GOTOMO.prototype.details = function GOTOMO() {
    }
    GOTOMO.prototype.get = function GOTOMO() {
    }
    GOTOMO.prototype.set = function GOTOMO() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,tag,tagvis,exprs] = scicos_getvalue("Set parameters",[["Tag"],["Tag Visibility(1=Local 2=scoped 3= global)"]],list("str",-1,"vec",1),exprs);
        if (!ok) {
break;
}
        tagvis = int(tagvis);
        if (((tagvis<1)||(tagvis>3))) {
message("Tag Visibility must be between 1 and 3");
        ok = false;
}
        if (ok) {
        if (((model.ipar!=tagvis)||(model.opar!=list(tag)))) {
        needcompile = 4;
        y = needcompile;
}
        graphics.exprs = exprs;
        model.opar = list(tag);
        model.ipar = tagvis;
        x.model = model;
        x.graphics = graphics;
        arg1 = x;
break;
}
}
needcompile=resume(needcompile)
    }
}
/* autogenerated from "macros/Branching/GotoTagVisibility.sci" */
function GotoTagVisibility() {
    GotoTagVisibility.prototype.define = function GotoTagVisibility() {
        model = scicos_model();
        model.sim = "gototagvisibility";
        model.in1 = [];
        model.in2 = [];
        model.out = [];
        model.out2 = [];
        model.evtin = [];
        model.intyp = 1;
        model.outtyp = 1;
        model.opar = list("A");
        model.blocktype = "c";
        model.firing = false;
        model.dep_ut = [false,false];
        exprs = "A";
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    GotoTagVisibility.prototype.details = function GotoTagVisibility() {
    }
    GotoTagVisibility.prototype.get = function GotoTagVisibility() {
    }
    GotoTagVisibility.prototype.set = function GotoTagVisibility() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,tag,exprs] = scicos_getvalue("Set parameters",["GotoTag"],list("str",-1),exprs);
        if (!ok) {
break;
}
        if (ok) {
        if (model.opar!=list(tag)) {
        needcompile = 4;
        y = needcompile;
}
        graphics.exprs = exprs;
        model.opar = list(tag);
        x.graphics = graphics;
        x.model = model;
break;
}
}
needcompile=resume(needcompile)
    }
}
/* autogenerated from "macros/Branching/GotoTagVisibilityMO.sci" */
function GotoTagVisibilityMO() {
    GotoTagVisibilityMO.prototype.define = function GotoTagVisibilityMO() {
        model = scicos_model();
        model.sim = "gototagvisibilitymo";
        model.in1 = [];
        model.in2 = [];
        model.out = [];
        model.out2 = [];
        model.evtin = [];
        model.intyp = 1;
        model.outtyp = 1;
        model.opar = list("A");
        model.blocktype = "c";
        model.firing = false;
        model.dep_ut = [false,false];
        exprs = "A";
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    GotoTagVisibilityMO.prototype.details = function GotoTagVisibilityMO() {
    }
    GotoTagVisibilityMO.prototype.get = function GotoTagVisibilityMO() {
    }
    GotoTagVisibilityMO.prototype.set = function GotoTagVisibilityMO() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,tag,exprs] = scicos_getvalue("Set parameters",["GotoTag"],list("str",-1),exprs);
        if (!ok) {
break;
}
        if (ok) {
        if (model.opar!=list(tag)) {
        needcompile = 4;
        y = needcompile;
}
        graphics.exprs = exprs;
        model.opar = list(tag);
        x.graphics = graphics;
        x.model = model;
break;
}
}
needcompile=resume(needcompile)
    }
}
/* autogenerated from "macros/Branching/ISELECT_f.sci" */
function ISELECT_f() {
    ISELECT_f.prototype.define = function ISELECT_f() {
        z0 = 0;
        out = [[-1],[-1]];
        nout = 2;
        model = scicos_model();
        model.sim = list("selector",2);
        model.in1 = -1;
        model.out = out;
        model.evtin = ones(out);
        model.dstate = z0;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[string(nout)],[string(z0+1)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    ISELECT_f.prototype.details = function ISELECT_f() {
    }
    ISELECT_f.prototype.get = function ISELECT_f() {
    }
    ISELECT_f.prototype.set = function ISELECT_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,nout,z0,exprs] = scicos_getvalue("Set parameters",[["number of outputs"],["initial connected output"]],list("vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (z0>nout||z0<=0) {
message("initial connected input is not a valid input port number");
        } else {
        [model,graphics,ok] = check_io(model,graphics,-1,-ones(nout,1),ones(nout,1),[]);
        if (ok) {
        graphics.exprs = exprs;
        model.dstate = z0-1;
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/Branching/ISELECT_m.sci" */
function ISELECT_m() {
    ISELECT_m.prototype.define = function ISELECT_m() {
        z0 = 1;
        nout = 2;
        model = scicos_model();
        model.sim = list("selector_m",4);
        model.out = [[-1],[-1]];
        model.out2 = [[-2],[-2]];
        model.outtyp = 1;
        model.in1 = -1;
        model.in2 = -2;
        model.intyp = 1;
        model.evtout = [];
        model.state = [];
        model.rpar = [];
        model.ipar = [];
        model.firing = [];
        model.evtin = ones(nout,1);
        model.dstate = z0;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[sci2exp(1)],[sci2exp(nout)],[sci2exp(z0)]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    ISELECT_m.prototype.details = function ISELECT_m() {
    }
    ISELECT_m.prototype.get = function ISELECT_m() {
    }
    ISELECT_m.prototype.set = function ISELECT_m() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,typ,nout,z0,exprs] = scicos_getvalue("Set parameters",[["Datatype(1= real double  2=Complex 3=int32 ...)"],["number of outputs"],["initial connected output"]],list("vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (z0>nout||z0<=0) {
message("initial connected input is not a valid input port number");
        } else if (((typ<1)||(typ>8))) {
message("Datatype is not supported");
        ok = false;
        } else {
        it = typ;
        ot = typ*ones(1,nout);
        if (ok) {
        out = [-ones(nout,1),-2*ones(nout,1)];
        in1 = [-1,-2];
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),ones(nout,1),[]);
        if (ok) {
        graphics.exprs = exprs;
        model.dstate = z0;
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
}
    }
}
/* autogenerated from "macros/Branching/MUX.sci" */
function MUX() {
    MUX.prototype.define = function MUX() {
        in1 = 2;
        model = scicos_model();
        model.sim = list("multiplex",4);
        model.in1 = -transpose([1:in1]);
        model.out = 0;
        model.ipar = in1;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = string(in1);
        gr_i = [];
        x = standard_define([.5,2],model,exprs,gr_i);
    }
    MUX.prototype.details = function MUX() {
    }
    MUX.prototype.get = function MUX() {
    }
    MUX.prototype.set = function MUX() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,in1,exprs] = scicos_getvalue("Set MUX block parameters","number of input ports or vector of sizes",list("intvec",-1),exprs);
        if (!ok) {
break;
}
        if (size(in1,"*")==1) {
        if (in1<2||in1>31) {
message("Block must have at least two input ports and at most 31");
        ok = false;
        } else {
        [model,graphics,ok] = check_io(model,graphics,-transpose([1:in1]),0,[],[]);
}
        } else {
        if (size(in1,"*")<2||or(in1==0)||size(in1,"*")>31) {
message([["Block must have at least two input ports"],["and at most 31. Size 0 is not allowed. "]]);
        ok = false;
        } else {
        if (min(in1)<0) {
        nout = 0;
        } else {
        nout = sum(in1);
}
        [model,graphics,ok] = check_io(model,graphics,in1.slice(),nout,[],[]);
        if (ok) {
        in1 = size(in1,"*");
}
}
}
        if (ok) {
        graphics.exprs = exprs;
        model.ipar = in1;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Branching/MUX_f.sci" */
function MUX_f() {
    MUX_f.prototype.define = function MUX_f() {
        in1 = 2;
        model = scicos_model();
        model.sim = list("mux",1);
        model.in1 = -transpose([1:in1]);
        model.out = 0;
        model.ipar = in1;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = string(in1);
        gr_i = [];
        x = standard_define([0.5,2],model,exprs,gr_i);
    }
    MUX_f.prototype.details = function MUX_f() {
    }
    MUX_f.prototype.get = function MUX_f() {
    }
    MUX_f.prototype.set = function MUX_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,in1,exprs] = scicos_getvalue("Set MUX block parameters","number of input ports or vector of sizes",list("vec",-1),exprs);
        if (!ok) {
break;
}
        if (size(in1,"*")==1) {
        if (in1<2||in1>8) {
message("Block must have at least two input ports and at most eight");
        ok = false;
        } else {
        [model,graphics,ok] = check_io(model,graphics,-transpose([1:in1]),0,[],[]);
}
        } else {
        if (size(in1,"*")<2||size(in1,"*")>8||or(in1==0)) {
message([["Block must have at least two input ports"],["and at most eight, and size 0 is not allowed. "]]);
        ok = false;
        } else {
        if (min(in1)<0) {
        nout = 0;
        } else {
        nout = sum(in1);
}
        [model,graphics,ok] = check_io(model,graphics,in1.slice(),nout,[],[]);
        if (ok) {
        in1 = size(in1,"*");
}
}
}
        if (ok) {
        graphics.exprs = exprs;
        model.ipar = in1;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Branching/M_SWITCH.sci" */
function M_SWITCH() {
    M_SWITCH.prototype.define = function M_SWITCH() {
        in1 = [[1],[-1],[-1]];
        ipar = [[1],[3]];
        nin = 2;
        model = scicos_model();
        model.sim = list("mswitch",4);
        model.in1 = in1;
        model.out = -1;
        model.ipar = ipar;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[string(nin)],[string(ipar)]];
        gr_i = [];
        x = standard_define([2.5,2],model,exprs,gr_i);
    }
    M_SWITCH.prototype.details = function M_SWITCH() {
    }
    M_SWITCH.prototype.get = function M_SWITCH() {
    }
    M_SWITCH.prototype.set = function M_SWITCH() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,nin,base,rule,exprs] = scicos_getvalue("Set parameters",[["number of inputs"],["zero base indexing (0), otherwise 1"],["rounding rule: int (0), round (1), ceil (2), floor (3)"]],list("vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        nin = int(nin);
        base = int(base);
        if (nin<1) {
message("Number of inputs must be >=1 ");
        } else if (!((base==1)||(base==0))) {
message("base indexing must be 1 or 0");
        } else if (!((rule==1)||(rule==0)||(rule==2)||(rule==3))) {
message("incorrect rounding rule");
        } else {
        if (nin==1) {
        in1 = [[1,1],[-1,1]];
        out = [1,1];
        } else {
        in1 = [[1],[-ones(nin,1)]];
        in2 = [[1],[-2*ones(nin,1)]];
        in1 = [in1,in2];
        out = [-1,-2];
}
        it = [[-1],[-2*ones(nin,1)]];
        ot = -2;
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
        if (ok) {
        graphics.exprs = exprs;
        model.ipar = [[base],[rule]];
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/Branching/NRMSOM_f.sci" */
function NRMSOM_f() {
    NRMSOM_f.prototype.define = function NRMSOM_f() {
        in1 = [[-1],[-1]];
        nin = 2;
        model = scicos_model();
        model.sim = "junk";
        model.in1 = in1;
        model.out = -1;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [string(nin)];
        gr_i = [];
        x = standard_define([.2,2],model,exprs,gr_i);
    }
    NRMSOM_f.prototype.details = function NRMSOM_f() {
    }
    NRMSOM_f.prototype.get = function NRMSOM_f() {
    }
    NRMSOM_f.prototype.set = function NRMSOM_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,nin,exprs] = scicos_getvalue("Set parameters",["number of inputs"],list("vec",1),exprs);
        if (!ok) {
break;
}
        [model,graphics,ok] = check_io(model,graphics,-ones(nin,1),-1,[],[]);
        if (ok) {
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Branching/RELAY_f.sci" */
function RELAY_f() {
    RELAY_f.prototype.define = function RELAY_f() {
        i0 = 0;
        in1 = [[-1],[-1]];
        nin = 2;
        model = scicos_model();
        model.sim = list("relay",2);
        model.in1 = in1;
        model.out = -1;
        model.evtin = ones(in1);
        model.dstate = i0;
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,true];
        exprs = [[string(nin)],[string(i0+1)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    RELAY_f.prototype.details = function RELAY_f() {
    }
    RELAY_f.prototype.get = function RELAY_f() {
    }
    RELAY_f.prototype.set = function RELAY_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        ipar = model.ipar;
        while (true) {
        [ok,nin,z0,exprs] = scicos_getvalue("Set parameters",[["number of inputs"],["initial connected input"]],list("vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (z0>nin||z0<=0) {
message("initial connected input is not a valid input port number");
        } else {
        [model,graphics,ok] = check_io(model,graphics,-ones(nin,1),-1,ones(nin,1),[]);
        if (ok) {
        graphics.exprs = exprs;
        model.dstate = z0-1;
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/Branching/SCALAR2VECTOR.sci" */
function SCALAR2VECTOR() {
    SCALAR2VECTOR.prototype.define = function SCALAR2VECTOR() {
        nout = -1;
        model = scicos_model();
        model.sim = list("scalar2vector",4);
        model.out = nout;
        model.in1 = 1;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [string([nout])];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    SCALAR2VECTOR.prototype.details = function SCALAR2VECTOR() {
    }
    SCALAR2VECTOR.prototype.get = function SCALAR2VECTOR() {
    }
    SCALAR2VECTOR.prototype.set = function SCALAR2VECTOR() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,nout,exprs] = scicos_getvalue("Set block parameters",["size of output (-1: if don\'t know)"],list("vec",1),exprs);
        if (!ok) {
break;
}
        nout = int(nout);
        if ((nout!=-1&&(nout<=0))) {
message("size of output must be -1 or >0");
        ok = false;
}
        if (ok) {
        [model,graphics,ok] = check_io(model,graphics,[1],nout,[],[]);
}
        if (ok) {
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Branching/SELECT_f.sci" */
function SELECT_f() {
    SELECT_f.prototype.define = function SELECT_f() {
        z0 = 0;
        in1 = [[-1],[-1]];
        nin = 2;
        model = scicos_model();
        model.sim = list("selector",2);
        model.in1 = in1;
        model.out = -1;
        model.evtin = ones(in1);
        model.dstate = z0;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[string(nin)],[string(z0+1)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    SELECT_f.prototype.details = function SELECT_f() {
    }
    SELECT_f.prototype.get = function SELECT_f() {
    }
    SELECT_f.prototype.set = function SELECT_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,nin,z0,exprs] = scicos_getvalue("Set parameters",[["number of inputs"],["initial connected input"]],list("vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (z0>nin||z0<=0) {
message("initial connected input is not a valid input port number");
        } else {
        [model,graphics,ok] = check_io(model,graphics,-ones(nin,1),-1,ones(nin,1),[]);
        if (ok) {
        graphics.exprs = exprs;
        model.dstate = z0-1;
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/Branching/SELECT_m.sci" */
function SELECT_m() {
    SELECT_m.prototype.define = function SELECT_m() {
        z0 = 1;
        nin = 2;
        model = scicos_model();
        model.sim = list("selector_m",4);
        model.in1 = [[-1],[-1]];
        model.in2 = [[-2],[-2]];
        model.intyp = 1;
        model.out = -1;
        model.out2 = -2;
        model.outtyp = 1;
        model.evtout = [];
        model.state = [];
        model.rpar = [];
        model.ipar = [];
        model.firing = [];
        model.evtin = ones(nin,1);
        model.dstate = z0;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[sci2exp(1)],[sci2exp(nin)],[sci2exp(z0)]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    SELECT_m.prototype.details = function SELECT_m() {
    }
    SELECT_m.prototype.get = function SELECT_m() {
    }
    SELECT_m.prototype.set = function SELECT_m() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,typ,nin,z0,exprs] = scicos_getvalue("Set parameters",[["Datatype(1= real double  2=Complex 3=int32 ..)"],["number of inputs"],["initial connected input"]],list("vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (z0>nin||z0<=0) {
message("initial connected input is not a valid input port number");
        } else if (((typ<1)||(typ>8))&&(typ!=-1)) {
message("Datatype is not supported");
        ok = false;
        } else {
        it = typ*ones(1,nin);
        ot = typ;
        if (ok) {
        in1 = [-ones(nin,1),-2*ones(nin,1)];
        out = [-1,-2];
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),ones(nin,1),[]);
        if (ok) {
        graphics.exprs = exprs;
        model.dstate = z0;
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
}
    }
}
/* autogenerated from "macros/Branching/SWITCH2.sci" */
function SWITCH2() {
    SWITCH2.prototype.define = function SWITCH2() {
        in1 = [[-1],[1],[-1]];
        ipar = [0];
        nzz = 1;
        rpar = 0;
        model = scicos_model();
        model.sim = list("switch2",4);
        model.in1 = in1;
        model.out = -1;
        model.ipar = ipar;
        model.rpar = rpar;
        model.nzcross = nzz;
        model.nmode = 1;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[string(ipar)],[string(rpar)],[string(nzz)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    SWITCH2.prototype.details = function SWITCH2() {
    }
    SWITCH2.prototype.get = function SWITCH2() {
    }
    SWITCH2.prototype.set = function SWITCH2() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,rule,thra,nzz,exprs] = scicos_getvalue("Set parameters",[["pass first input if: u2>=a (0), u2>a (1), u2~=a (2)"],["threshold a"],["use zero crossing: yes (1), no (0)"]],list("vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        rule = int(rule);
        if ((rule<0)) {
        rule = 0;
}
        if ((rule>2)) {
        rule = 2;
}
        graphics.exprs = exprs;
        model.ipar = rule;
        model.rpar = thra;
        if (nzz!=0) {
        model.nmode = 1;
        model.nzcross = 1;
        } else {
        model.nmode = 0;
        model.nzcross = 0;
}
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/Branching/SWITCH2_m.sci" */
function SWITCH2_m() {
    SWITCH2_m.prototype.define = function SWITCH2_m() {
        ipar = [0];
        nzz = 1;
        rpar = 0;
        model = scicos_model();
        model.sim = list("switch2_m",4);
        model.in1 = [[-1],[1],[-1]];
        model.in2 = [[-2],[1],[-2]];
        model.intyp = 1;
        model.out = -1;
        model.out2 = -2;
        model.outtyp = 1;
        model.ipar = ipar;
        model.rpar = rpar;
        model.nzcross = nzz;
        model.nmode = 1;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[sci2exp(1)],[string(ipar)],[string(rpar)],[string(nzz)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    SWITCH2_m.prototype.details = function SWITCH2_m() {
    }
    SWITCH2_m.prototype.get = function SWITCH2_m() {
    }
    SWITCH2_m.prototype.set = function SWITCH2_m() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,ot,rule,thra,nzz,exprs] = scicos_getvalue("Set parameters",[["Datatype (1=real double  2=complex 3=int32 ...)"],["pass first input if: u2>=a (0), u2>a (1), u2~=a (2)"],["threshold a"],["use zero crossing: yes (1), no (0)"]],list("vec",1,"vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        rule = int(rule);
        if ((rule<0)) {
        rule = 0;
}
        if ((rule>2)) {
        rule = 2;
}
        graphics.exprs = exprs;
        model.ipar = rule;
        model.rpar = thra;
        if (nzz!=0) {
        model.nmode = 1;
        model.nzcross = 1;
        } else {
        model.nmode = 0;
        model.nzcross = 0;
}
        if (((ot<1)||(ot>8))&&(ot!=-1)) {
message("Datatype is not supported");
        ok = false;
}
        if (ok) {
        it[1-1] = ot;
        it[2-1] = 1;
        it[3-1] = ot;
        in1 = [model.in1,model.in2];
        out = [model.out,model.out2];
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
        if (ok) {
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Branching/SWITCH_f.sci" */
function SWITCH_f() {
    SWITCH_f.prototype.define = function SWITCH_f() {
        i0 = 0;
        in1 = [[-1],[-1]];
        nin = 2;
        model = scicos_model();
        model.sim = list("switchn",2);
        model.in1 = in1;
        model.out = -1;
        model.ipar = i0;
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,true];
        exprs = [[string(nin)],[string(i0+1)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    SWITCH_f.prototype.details = function SWITCH_f() {
    }
    SWITCH_f.prototype.get = function SWITCH_f() {
    }
    SWITCH_f.prototype.set = function SWITCH_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        ipar = model.ipar;
        while (true) {
        [ok,nin,z0,exprs] = scicos_getvalue("Set switch parameters",[["number of inputs"],["connected input"]],list("vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (z0>nin||z0<=0) {
message("initial connected input is not a valid input port number");
        } else {
        [model,graphics,ok] = check_io(model,graphics,-ones(nin,1),-1,[],[]);
        if (ok) {
        graphics.exprs = exprs;
        model.ipar = z0-1;
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/Electrical/CCS.sci" */
function CCS() {
    CCS.prototype.define = function CCS() {
        ModelName = "CCS";
        PrametersValue = [];
        ParametersName = [];
        model = scicos_model();
        Typein = [];
        Typeout = [];
        MI = [];
        MO = [];
        P = [[2,50,1,0],[70,98,2,0],[70,2,-2,0]];
        PortName = [["Iin"],["p"],["n"]];
for (i=1;i<=size(P,"r");i+=1) {
        if (P[i-1][3-1]==1) {
        Typein = [[Typein],["E"]];
        MI = [[MI],[PortName[i-1]]];
}
        if (P[i-1][3-1]==2) {
        Typein = [[Typein],["I"]];
        MI = [[MI],[PortName[i-1]]];
}
        if (P[i-1][3-1]==-1) {
        Typeout = [[Typeout],["E"]];
        MO = [[MO],[PortName[i-1]]];
}
        if (P[i-1][3-1]==-2) {
        Typeout = [[Typeout],["I"]];
        MO = [[MO],[PortName[i-1]]];
}
}
        model = scicos_model();
        mo = modelica();
        model.sim = ModelName;
        mo.inputs = MI;
        mo.outputs = MO;
        model.rpar = PrametersValue;
        mo.parameters = list(ParametersName,PrametersValue,zeros(ParametersName));
        exprs = [];
        gr_i = [];
        model.blocktype = "c";
        model.dep_ut = [false,true];
        mo.model = ModelName;
        model.equations = mo;
        model.in1 = ones(size(MI,"*"),1);
        model.out = ones(size(MO,"*"),1);
        x = standard_define([2.1,3],model,exprs,list(gr_i,0));
        x.graphics.in_implicit = Typein;
        x.graphics.out_implicit = Typeout;
    }
    CCS.prototype.details = function CCS() {
    }
    CCS.prototype.get = function CCS() {
    }
    CCS.prototype.set = function CCS() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        x = arg1;
    }
}
/* autogenerated from "macros/Electrical/CVS.sci" */
function CVS() {
    CVS.prototype.define = function CVS() {
        ModelName = "CVS";
        PrametersValue = [];
        ParametersName = [];
        model = scicos_model();
        Typein = [];
        Typeout = [];
        MI = [];
        MO = [];
        P = [[2,50,1,0],[70,98,2,0],[70,2,-2,0]];
        PortName = [["vin"],["p"],["n"]];
for (i=1;i<=size(P,"r");i+=1) {
        if (P[i-1][3-1]==1) {
        Typein = [[Typein],["E"]];
        MI = [[MI],[PortName[i-1]]];
}
        if (P[i-1][3-1]==2) {
        Typein = [[Typein],["I"]];
        MI = [[MI],[PortName[i-1]]];
}
        if (P[i-1][3-1]==-1) {
        Typeout = [[Typeout],["E"]];
        MO = [[MO],[PortName[i-1]]];
}
        if (P[i-1][3-1]==-2) {
        Typeout = [[Typeout],["I"]];
        MO = [[MO],[PortName[i-1]]];
}
}
        model = scicos_model();
        mo = modelica();
        model.sim = ModelName;
        mo.inputs = MI;
        mo.outputs = MO;
        model.rpar = PrametersValue;
        mo.parameters = list(ParametersName,PrametersValue,zeros(ParametersName));
        exprs = [];
        gr_i = [];
        model.blocktype = "c";
        model.dep_ut = [false,true];
        mo.model = ModelName;
        model.equations = mo;
        model.in1 = ones(size(MI,"*"),1);
        model.out = ones(size(MO,"*"),1);
        x = standard_define([2.1,3],model,exprs,list(gr_i,0));
        x.graphics.in_implicit = Typein;
        x.graphics.out_implicit = Typeout;
    }
    CVS.prototype.details = function CVS() {
    }
    CVS.prototype.get = function CVS() {
    }
    CVS.prototype.set = function CVS() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        x = arg1;
    }
}
/* autogenerated from "macros/Electrical/Capacitor.sci" */
function Capacitor() {
    Capacitor.prototype.define = function Capacitor() {
        model = scicos_model();
        C = 0.01;
        v = 0;
        model.rpar = [[C],[v]];
        model.sim = "Capacitor";
        model.blocktype = "c";
        model.dep_ut = [true,false];
        mo = modelica();
        mo.model = "Capacitor";
        mo.inputs = "p";
        mo.outputs = "n";
        mo.parameters = list(["C","v"],list(C,v),[0,1]);
        model.equations = mo;
        model.in1 = ones(size(mo.inputs,"*"),1);
        model.out = ones(size(mo.outputs,"*"),1);
        exprs = string([[C],[v]]);
        gr_i = [];
        x = standard_define([2,1.1],model,exprs,list(gr_i,0));
        x.graphics.in_implicit = ["I"];
        x.graphics.out_implicit = ["I"];
    }
    Capacitor.prototype.details = function Capacitor() {
    }
    Capacitor.prototype.get = function Capacitor() {
    }
    Capacitor.prototype.set = function Capacitor() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,C,v,exprs] = scicos_getvalue("Set Capacitor block parameter",[["C (F)"],["Initial Voltage"]],list("vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        model.rpar = C;
        model.equations.parameters[2-1] = list(C,v);
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/Electrical/ConstantVoltage.sci" */
function ConstantVoltage() {
    ConstantVoltage.prototype.define = function ConstantVoltage() {
        V = 0.01;
        model = scicos_model();
        model.rpar = V;
        model.in1 = 1;
        model.out = 1;
        model.sim = "ConstantVoltage";
        model.blocktype = "c";
        model.dep_ut = [false,false];
        mo = modelica();
        mo.model = "ConstantVoltage";
        mo.inputs = "p";
        mo.outputs = "n";
        mo.parameters = list("V",list(V));
        model.equations = mo;
        exprs = string(V);
        gr_i = [];
        x = standard_define([1.5,1.1],model,exprs,list(gr_i,0));
        x.graphics.in_implicit = ["I"];
        x.graphics.out_implicit = ["I"];
    }
    ConstantVoltage.prototype.details = function ConstantVoltage() {
    }
    ConstantVoltage.prototype.get = function ConstantVoltage() {
    }
    ConstantVoltage.prototype.set = function ConstantVoltage() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,V,exprs] = scicos_getvalue("Set ConstantVoltage block parameter","V (volt)",list("vec",1),exprs);
        if (!ok) {
break;
}
        model.rpar = V;
        model.equations.parameters[2-1] = list(V);
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/Electrical/CurrentSensor.sci" */
function CurrentSensor() {
    CurrentSensor.prototype.define = function CurrentSensor() {
        model = scicos_model();
        model.in1 = 1;
        model.out = [[1],[1]];
        model.sim = "CurrentSensor";
        model.blocktype = "c";
        model.dep_ut = [true,false];
        mo = modelica();
        mo.model = "CurrentSensor";
        mo.inputs = "p";
        mo.outputs = [["n"],["i"]];
        model.equations = mo;
        exprs = [];
        gr_i = [];
        x = standard_define([2,2],model,exprs,list(gr_i,0));
        x.graphics.in_implicit = ["I"];
        x.graphics.out_implicit = [["I"],["E"]];
    }
    CurrentSensor.prototype.details = function CurrentSensor() {
    }
    CurrentSensor.prototype.get = function CurrentSensor() {
    }
    CurrentSensor.prototype.set = function CurrentSensor() {
        x = arg1;
    }
}
/* autogenerated from "macros/Electrical/Diode.sci" */
function Diode() {
    Diode.prototype.define = function Diode() {
        Ids = 1.e-6;
        Vt = 0.04;
        Maxexp = 15;
        R = 1.e8;
        model = scicos_model();
        model.rpar = [[Ids],[Vt],[Maxexp],[R]];
        model.in1 = 1;
        model.out = 1;
        model.sim = "Diode";
        model.blocktype = "c";
        model.dep_ut = [true,false];
        mo = modelica();
        mo.model = "Diode";
        mo.inputs = "p";
        mo.outputs = "n";
        mo.parameters = list(["Ids","Vt","Maxexp","R"],list(Ids,Vt,Maxexp,R));
        model.equations = mo;
        exprs = string([[Ids],[Vt],[Maxexp],[R]]);
        gr_i = [];
        x = standard_define([2,1],model,exprs,list(gr_i,0));
        x.graphics.in_implicit = ["I"];
        x.graphics.out_implicit = ["I"];
    }
    Diode.prototype.details = function Diode() {
    }
    Diode.prototype.get = function Diode() {
    }
    Diode.prototype.set = function Diode() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,Ids,Vt,Maxexp,R,exprs] = scicos_getvalue("Set Diode block parameter",[["Saturation cuurent (A)"],["Voltage equivalent to temperature (Volt)"],["Max exponent for linear continuation"],["R (ohm)"]],list("vec",1,"vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        model.rpar = [[Ids],[Vt],[Maxexp],[R]];
        model.equations.parameters = list(["Ids","Vt","Maxexp","R"],list(Ids,Vt,Maxexp,R));
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/Electrical/Ground.sci" */
function Ground() {
    Ground.prototype.define = function Ground() {
        model = scicos_model();
        model.in1 = [1];
        model.out = [];
        model.sim = "Ground";
        model.blocktype = "c";
        model.dep_ut = [true,false];
        mo = modelica();
        mo.model = "Ground";
        mo.inputs = "p";
        model.equations = mo;
        exprs = "";
        gr_i = [];
        x = standard_define([1,1],model,exprs,list(gr_i,0));
        x.graphics.in_implicit = ["I"];
        x.graphics.out_implicit = ["I"];
    }
    Ground.prototype.details = function Ground() {
    }
    Ground.prototype.get = function Ground() {
    }
    Ground.prototype.set = function Ground() {
        x = arg1;
    }
}
/* autogenerated from "macros/Electrical/Gyrator.sci" */
function Gyrator() {
    Gyrator.prototype.define = function Gyrator() {
        ModelName = "Gyrator";
        PrametersValue = [[1],[1]];
        ParametersName = [["G1"],["G2"]];
        model = scicos_model();
        Typein = [];
        Typeout = [];
        MI = [];
        MO = [];
        P = [[2.5,90,2,0],[2.5,10,2,0],[97.5,90,-2,0],[97.5,10,-2,0]];
        PortName = [["p1"],["n1"],["p2"],["n2"]];
for (i=1;i<=size(P,"r");i+=1) {
        if (P[i-1][3-1]==1) {
        Typein = [[Typein],["E"]];
        MI = [[MI],[PortName[i-1]]];
}
        if (P[i-1][3-1]==2) {
        Typein = [[Typein],["I"]];
        MI = [[MI],[PortName[i-1]]];
}
        if (P[i-1][3-1]==-1) {
        Typeout = [[Typeout],["E"]];
        MO = [[MO],[PortName[i-1]]];
}
        if (P[i-1][3-1]==-2) {
        Typeout = [[Typeout],["I"]];
        MO = [[MO],[PortName[i-1]]];
}
}
        model = scicos_model();
        mo = modelica();
        model.sim = ModelName;
        mo.inputs = MI;
        mo.outputs = MO;
        model.rpar = PrametersValue;
        mo.parameters = list(ParametersName,PrametersValue,zeros(ParametersName));
        exprs = [["1"],["1"]];
        gr_i = [];
        model.blocktype = "c";
        model.dep_ut = [false,true];
        mo.model = ModelName;
        model.equations = mo;
        model.in1 = ones(size(MI,"*"),1);
        model.out = ones(size(MO,"*"),1);
        x = standard_define([2,2],model,exprs,list(gr_i,0));
        x.graphics.in_implicit = Typein;
        x.graphics.out_implicit = Typeout;
    }
    Gyrator.prototype.details = function Gyrator() {
    }
    Gyrator.prototype.get = function Gyrator() {
    }
    Gyrator.prototype.set = function Gyrator() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        x = arg1;
        exprs = x.graphics.exprs;
        while (true) {
        [ok,G1,G2,exprs] = scicos_getvalue([["Set Gyrator block parameters:"],[""],["G1: Gyration conductance"],["G2: Gyration conductance"]],[["G1"],["G2"]],list("vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        x.model.equations.parameters[2-1] = list(G1,G2);
        x.graphics.exprs = exprs;
break;
}
    }
}
/* autogenerated from "macros/Electrical/IdealTransformer.sci" */
function IdealTransformer() {
    IdealTransformer.prototype.define = function IdealTransformer() {
        ModelName = "IdealTransformer";
        PrametersValue = [1];
        ParametersName = ["N"];
        model = scicos_model();
        Typein = [];
        Typeout = [];
        MI = [];
        MO = [];
        P = [[2.5,90,2,0],[2.5,10,2,0],[97.5,90,-2,0],[97.5,10,-2,0]];
        PortName = [["p1"],["n1"],["p2"],["n2"]];
for (i=1;i<=size(P,"r");i+=1) {
        if (P[i-1][3-1]==1) {
        Typein = [[Typein],["E"]];
        MI = [[MI],[PortName[i-1]]];
}
        if (P[i-1][3-1]==2) {
        Typein = [[Typein],["I"]];
        MI = [[MI],[PortName[i-1]]];
}
        if (P[i-1][3-1]==-1) {
        Typeout = [[Typeout],["E"]];
        MO = [[MO],[PortName[i-1]]];
}
        if (P[i-1][3-1]==-2) {
        Typeout = [[Typeout],["I"]];
        MO = [[MO],[PortName[i-1]]];
}
}
        model = scicos_model();
        mo = modelica();
        model.sim = ModelName;
        mo.inputs = MI;
        mo.outputs = MO;
        model.rpar = PrametersValue;
        mo.parameters = list(ParametersName,PrametersValue,zeros(ParametersName));
        exprs = ["1"];
        gr_i = [];
        model.blocktype = "c";
        model.dep_ut = [false,true];
        mo.model = ModelName;
        model.equations = mo;
        model.in1 = ones(size(MI,"*"),1);
        model.out = ones(size(MO,"*"),1);
        x = standard_define([2,2],model,exprs,list(gr_i,0));
        x.graphics.in_implicit = Typein;
        x.graphics.out_implicit = Typeout;
    }
    IdealTransformer.prototype.details = function IdealTransformer() {
    }
    IdealTransformer.prototype.get = function IdealTransformer() {
    }
    IdealTransformer.prototype.set = function IdealTransformer() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        x = arg1;
        exprs = x.graphics.exprs;
        while (true) {
        [ok,N,exprs] = scicos_getvalue([["Set Transformer block parameters:"],[""],["N:"+" Turn ratio (N1/N2)"]],["N"],list("vec",1),exprs);
        if (!ok) {
break;
}
        x.model.equations.parameters[2-1] = list(N);
        x.graphics.exprs = exprs;
break;
}
    }
}
/* autogenerated from "macros/Electrical/Inductor.sci" */
function Inductor() {
    Inductor.prototype.define = function Inductor() {
        model = scicos_model();
        model.in1 = [1];
        model.out = [1];
        L = 1.e-5;
        model.rpar = L;
        model.sim = "Inductor";
        model.blocktype = "c";
        model.dep_ut = [true,false];
        mo = modelica();
        mo.model = "Inductor";
        mo.inputs = "p";
        mo.outputs = "n";
        mo.parameters = list("L",list(L));
        model.equations = mo;
        exprs = string(L);
        gr_i = [];
        x = standard_define([2,0.9],model,exprs,list(gr_i,0));
        x.graphics.in_implicit = ["I"];
        x.graphics.out_implicit = ["I"];
    }
    Inductor.prototype.details = function Inductor() {
    }
    Inductor.prototype.get = function Inductor() {
    }
    Inductor.prototype.set = function Inductor() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,L,exprs] = scicos_getvalue("Set Inductor block parameter","L (H)",list("vec",1),exprs);
        if (!ok) {
break;
}
        model.rpar = L;
        model.equations.parameters[2-1] = list(L);
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/Electrical/MOTOR.sci" */
function MOTOR() {
    MOTOR.prototype.define = function MOTOR() {
        model = scicos_model();
        model.out = [[1],[1]];
        model.in1 = [1];
        model.sim = "motor";
        model.blocktype = "c";
        model.dep_ut = [true,false];
        gr_i = [];
        exprs = "";
        x = standard_define([2,2],model,exprs,gr_i);
        x.graphics.out_implicit = [["I"],["I"]];
        x.graphics.in_implicit = ["I"];
    }
    MOTOR.prototype.details = function MOTOR() {
    }
    MOTOR.prototype.get = function MOTOR() {
    }
    MOTOR.prototype.set = function MOTOR() {
        x = arg1;
    }
}
/* autogenerated from "macros/Electrical/NMOS.sci" */
function NMOS() {
    NMOS.prototype.define = function NMOS() {
        model = scicos_model();
        W = 20.e-6;
        L = 6.e-6;
        Beta = 0.041e-3;
        Vt = 0.8;
        K2 = 1.144;
        K5 = 0.7311;
        dW = -2.5e-6;
        dL = -1.5e-6;
        RDS = 1.e+7;
        model.sim = "NMOS";
        model.blocktype = "c";
        model.dep_ut = [true,false];
        mo = modelica();
        mo.model = "NMOS";
        mo.outputs = [["D"],["B"],["S"]];
        mo.inputs = "G";
        mo.parameters = list([["W"],["L"],["Beta"],["Vt"],["K2"],["K5"],["dW"],["dL"],["RDS"]],[[W],[L],[Beta],[Vt],[K2],[K5],[dW],[dL],[RDS]]);
        model.equations = mo;
        model.in1 = ones(size(mo.inputs,"*"),1);
        model.out = ones(size(mo.outputs,"*"),1);
        exprs = [[string(W)],[string(L)],[string(Beta)],[string(Vt)],[string(K2)],[string(K5)],[string(dW)],[string(dL)],[string(RDS)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
        x.graphics.in_implicit = ["I"];
        x.graphics.out_implicit = [["I"],["I"],["I"]];
    }
    NMOS.prototype.details = function NMOS() {
    }
    NMOS.prototype.get = function NMOS() {
    }
    NMOS.prototype.set = function NMOS() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,W,L,Beta,Vt,K2,K5,dW,dL,RDS,exprs] = scicos_getvalue("Set NMOS Transistor block parameters",[["Width [m]"],["Length [m]"],["Transconductance parameter [A/(V*V)]"],["Zero bias threshold voltage [V]"],["Bulk threshold parameter"],["Reduction of pinch-off region"],["Narrowing of channel [m]"],["Shortening of channel [m]"],["Drain-Source-Resistance [Ohm]"]],list("vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1),exprs);
        if (!ok) {
break;
}
        model.equations.parameters[2-1] = list(W,L,Beta,Vt,K2,K5,dW,dL,RDS);
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/Electrical/NPN.sci" */
function NPN() {
    NPN.prototype.define = function NPN() {
        ModelName = "NPN";
        PrametersValue = [[50],[0.1],[0],[0.02],[1.200e-10],[5.000e-09],[1.000e-12],[4.000e-13],[5.000e-13],[0.8],[0.4],[0.8],[0.333],[1.000e-15],[1.000e-15],[0.02585],[40]];
        ParametersName = [["Bf"],["Br"],["Is"],["Vak"],["Tauf"],["Taur"],["Ccs"],["Cje"],["Cjc"],["Phie"],["Me"],["Phic"],["Mc"],["Gbc"],["Gbe"],["Vt"],["EMinMax"]];
        model = scicos_model();
        Typein = [];
        Typeout = [];
        MI = [];
        MO = [];
        P = [[100,90,-2,0],[0,50,2,0],[100,10,-2,0]];
        PortName = [["C"],["B"],["E"]];
for (i=1;i<=size(P,"r");i+=1) {
        if (P[i-1][3-1]==1) {
        Typein = [[Typein],["E"]];
        MI = [[MI],[PortName[i-1]]];
}
        if (P[i-1][3-1]==2) {
        Typein = [[Typein],["I"]];
        MI = [[MI],[PortName[i-1]]];
}
        if (P[i-1][3-1]==-1) {
        Typeout = [[Typeout],["E"]];
        MO = [[MO],[PortName[i-1]]];
}
        if (P[i-1][3-1]==-2) {
        Typeout = [[Typeout],["I"]];
        MO = [[MO],[PortName[i-1]]];
}
}
        model = scicos_model();
        mo = modelica();
        model.sim = ModelName;
        mo.inputs = MI;
        mo.outputs = MO;
        model.rpar = PrametersValue;
        mo.parameters = list(ParametersName,PrametersValue,zeros(ParametersName));
        exprs = [["50"],["0.1"],["1.e-16"],["0.02"],["0.12e-9"],["5e-9"],["1e-12"],["0.4e-12"],["0.5e-12"],["0.8"],["0.4"],["0.8"],["0.333"],["1e-15"],["1e-15"],["0.02585"],["40"]];
        gr_i = [];
        model.blocktype = "c";
        model.dep_ut = [false,true];
        mo.model = ModelName;
        model.equations = mo;
        model.in1 = ones(size(MI,"*"),1);
        model.out = ones(size(MO,"*"),1);
        x = standard_define([2,2],model,exprs,list(gr_i,0));
        x.graphics.in_implicit = Typein;
        x.graphics.out_implicit = Typeout;
    }
    NPN.prototype.details = function NPN() {
    }
    NPN.prototype.get = function NPN() {
    }
    NPN.prototype.set = function NPN() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        x = arg1;
        exprs = x.graphics.exprs;
        while (true) {
        [ok,Bf,Br,Is,Vak,Tauf,Taur,Ccs,Cje,Cjc,Phie,Me,Phic,Mc,Gbc,Gbe,Vt,EMinMax,exprs] = scicos_getvalue([["Set NPN block parameters:"],[""]],[["Bf  : Forward beta"],["Br  : Reverse beta"],["Is  : Transport saturation current"],["Vak : Early voltage (inverse), 1/Volt"],["Tauf: Ideal forward transit time"],["Taur: Ideal reverse transit time"],["Ccs : Collector-substrat(ground) cap."],["Cje : Base-emitter zero bias depletion cap."],["Cjc : Base-coll. zero bias depletion cap."],["Phie: Base-emitter diffusion voltage"],["Me  : Base-emitter gradation exponent"],["Phic: Base-collector diffusion voltage"],["Mc  : Base-collector gradation exponent"],["Gbc : Base-collector conductance"],["Gbe : Base-emitter conductance"],["Vt  : Voltage equivalent of temperature"],["EMinmax: if x > EMinMax, the exp(x) is linearized"]],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        x.model.equations.parameters[2-1] = list(Bf,Br,Is,Vak,Tauf,Taur,Ccs,Cje,Cjc,Phie,Me,Phic,Mc,Gbc,Gbe,Vt,EMinMax);
        x.graphics.exprs = exprs;
break;
}
    }
}
/* autogenerated from "macros/Electrical/OpAmp.sci" */
function OpAmp() {
    OpAmp.prototype.define = function OpAmp() {
        S = [];
        Z = [];
        model = scicos_model();
        model.sim = "OpAmp";
        model.blocktype = "c";
        model.dep_ut = [true,false];
        mo = modelica();
        mo.model = model.sim;
        mo.inputs = [["in_p"],["in_n"]];
        mo.outputs = ["out"];
        mo.parameters = list(S,Z);
        model.equations = mo;
        model.in1 = ones(size(mo.inputs,"*"),1);
        model.out = ones(size(mo.outputs,"*"),1);
        model.rpar = Z;
        exprs = string(Z);
        gr_i = [];
        x = standard_define([3,5],model,exprs,gr_i);
        x.graphics.in_implicit = [["I"],["I"]];
        x.graphics.out_implicit = ["I"];
    }
    OpAmp.prototype.details = function OpAmp() {
    }
    OpAmp.prototype.get = function OpAmp() {
    }
    OpAmp.prototype.set = function OpAmp() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (false) {
        [ok,OLGain,SatH,SatL,exprs] = scicos_getvalue("Set the Operational Amplifier parameters",[["Open Loop Gain"],["Positive saturation voltage"],["Negative saturation voltage"]],list("vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        model.equations.parameters[2-1] = list(OLGain,SatH,SatL);
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/Electrical/PMOS.sci" */
function PMOS() {
    PMOS.prototype.define = function PMOS() {
        model = scicos_model();
        W = 50.0e-6;
        L = 6.0e-6;
        Beta = 0.0105e-3;
        Vt = -1;
        K2 = 0.41;
        K5 = 0.839;
        dW = -2.5e-6;
        dL = -2.1e-6;
        RDS = 1.e+7;
        model.sim = "PMOS";
        model.blocktype = "c";
        model.dep_ut = [true,false];
        mo = modelica();
        mo.model = "PMOS";
        mo.outputs = [["D"],["B"],["S"]];
        mo.inputs = "G";
        mo.parameters = list([["W"],["L"],["Beta"],["Vt"],["K2"],["K5"],["dW"],["dL"],["RDS"]],[[W],[L],[Beta],[Vt],[K2],[K5],[dW],[dL],[RDS]]);
        model.equations = mo;
        model.in1 = ones(size(mo.inputs,"*"),1);
        model.out = ones(size(mo.outputs,"*"),1);
        exprs = [[string(W)],[string(L)],[string(Beta)],[string(Vt)],[string(K2)],[string(K5)],[string(dW)],[string(dL)],[string(RDS)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
        x.graphics.in_implicit = ["I"];
        x.graphics.out_implicit = [["I"],["I"],["I"]];
    }
    PMOS.prototype.details = function PMOS() {
    }
    PMOS.prototype.get = function PMOS() {
    }
    PMOS.prototype.set = function PMOS() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,W,L,Beta,Vt,K2,K5,dW,dL,RDS,exprs] = scicos_getvalue("Set PMOS Transistor parameters",[["Width [m]"],["Length [m]"],["Transconductance parameter [A/(V*V)]"],["Zero bias threshold voltage [V]"],["Bulk threshold parameter"],["Reduction of pinch-off region"],["Narrowing of channel [m]"],["Shortening of channel [m]"],["Drain-Source-Resistance [Ohm]"]],list("vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1),exprs);
        if (!ok) {
break;
}
        model.equations.parameters[2-1] = list(W,L,Beta,Vt,K2,K5,dW,dL,RDS);
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/Electrical/PNP.sci" */
function PNP() {
    PNP.prototype.define = function PNP() {
        ModelName = "PNP";
        PrametersValue = [[50],[0.1],[0],[0.02],[1.200e-10],[5.000e-09],[1.000e-12],[4.000e-13],[5.000e-13],[0.8],[0.4],[0.8],[0.333],[1.000e-15],[1.000e-15],[0.02585],[40]];
        ParametersName = [["Bf"],["Br"],["Is"],["Vak"],["Tauf"],["Taur"],["Ccs"],["Cje"],["Cjc"],["Phie"],["Me"],["Phic"],["Mc"],["Gbc"],["Gbe"],["Vt"],["EMinMax"]];
        model = scicos_model();
        Typein = [];
        Typeout = [];
        MI = [];
        MO = [];
        P = [[100,90,-2,0],[0,50,2,0],[100,10,-2,0]];
        PortName = [["C"],["B"],["E"]];
for (i=1;i<=size(P,"r");i+=1) {
        if (P[i-1][3-1]==1) {
        Typein = [[Typein],["E"]];
        MI = [[MI],[PortName[i-1]]];
}
        if (P[i-1][3-1]==2) {
        Typein = [[Typein],["I"]];
        MI = [[MI],[PortName[i-1]]];
}
        if (P[i-1][3-1]==-1) {
        Typeout = [[Typeout],["E"]];
        MO = [[MO],[PortName[i-1]]];
}
        if (P[i-1][3-1]==-2) {
        Typeout = [[Typeout],["I"]];
        MO = [[MO],[PortName[i-1]]];
}
}
        model = scicos_model();
        mo = modelica();
        model.sim = ModelName;
        mo.inputs = MI;
        mo.outputs = MO;
        model.rpar = PrametersValue;
        mo.parameters = list(ParametersName,PrametersValue,zeros(ParametersName));
        exprs = [["50"],["0.1"],["1.e-16"],["0.02"],["0.12e-9"],["5e-9"],["1e-12"],["0.4e-12"],["0.5e-12"],["0.8"],["0.4"],["0.8"],["0.333"],["1e-15"],["1e-15"],["0.02585"],["40"]];
        gr_i = [];
        model.blocktype = "c";
        model.dep_ut = [false,true];
        mo.model = ModelName;
        model.equations = mo;
        model.in1 = ones(size(MI,"*"),1);
        model.out = ones(size(MO,"*"),1);
        x = standard_define([2,2],model,exprs,list(gr_i,0));
        x.graphics.in_implicit = Typein;
        x.graphics.out_implicit = Typeout;
    }
    PNP.prototype.details = function PNP() {
    }
    PNP.prototype.get = function PNP() {
    }
    PNP.prototype.set = function PNP() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        x = arg1;
        exprs = x.graphics.exprs;
        while (true) {
        [ok,Bf,Br,Is,Vak,Tauf,Taur,Ccs,Cje,Cjc,Phie,Me,Phic,Mc,Gbc,Gbe,Vt,EMinMax,exprs] = scicos_getvalue([["Set PNP block parameters:"],[""]],[["Bf  : Forward beta"],["Br  : Reverse beta"],["Is  : Transport saturation current"],["Vak : Early voltage (inverse), 1/Volt"],["Tauf: Ideal forward transit time"],["Taur: Ideal reverse transit time"],["Ccs : Collector-substrat(ground) cap."],["Cje : Base-emitter zero bias depletion cap."],["Cjc : Base-coll. zero bias depletion cap."],["Phie: Base-emitter diffusion voltage"],["Me  : Base-emitter gradation exponent"],["Phic: Base-collector diffusion voltage"],["Mc  : Base-collector gradation exponent"],["Gbc : Base-collector conductance"],["Gbe : Base-emitter conductance"],["Vt  : Voltage equivalent of temperature"],["EMinMax: if x > EMinMax, the exp(x) function is linearized"]],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        x.model.equations.parameters[2-1] = list(Bf,Br,Is,Vak,Tauf,Taur,Ccs,Cje,Cjc,Phie,Me,Phic,Mc,Gbc,Gbe,Vt,EMinMax);
        x.graphics.exprs = exprs;
break;
}
    }
}
/* autogenerated from "macros/Electrical/PotentialSensor.sci" */
function PotentialSensor() {
    PotentialSensor.prototype.define = function PotentialSensor() {
        model = scicos_model();
        model.in1 = [1];
        model.out = [1];
        model.rpar = [];
        model.sim = "PotentialSensor";
        model.blocktype = "c";
        model.dep_ut = [true,false];
        mo = modelica();
        mo.model = "PotentialSensor";
        mo.inputs = "p";
        mo.outputs = ["v"];
        model.equations = mo;
        gr_i = [];
        x = standard_define([2,2],model,"",list(gr_i,0));
        x.graphics.in_implicit = ["I"];
        x.graphics.out_implicit = ["E"];
    }
    PotentialSensor.prototype.details = function PotentialSensor() {
    }
    PotentialSensor.prototype.get = function PotentialSensor() {
    }
    PotentialSensor.prototype.set = function PotentialSensor() {
        x = arg1;
    }
}
/* autogenerated from "macros/Electrical/Resistor.sci" */
function Resistor() {
    Resistor.prototype.define = function Resistor() {
        model = scicos_model();
        R = 0.01;
        model.rpar = R;
        model.sim = "resistor";
        model.blocktype = "c";
        model.dep_ut = [true,false];
        mo = modelica();
        mo.model = "Resistor";
        mo.inputs = "p";
        mo.outputs = "n";
        mo.parameters = list("R",list(R));
        model.equations = mo;
        model.in1 = ones(size(mo.inputs,"*"),1);
        model.out = ones(size(mo.outputs,"*"),1);
        exprs = string(R);
        gr_i = [];
        x = standard_define([2,1],model,exprs,list(gr_i,0));
        x.graphics.in_implicit = ["I"];
        x.graphics.out_implicit = ["I"];
    }
    Resistor.prototype.details = function Resistor() {
    }
    Resistor.prototype.get = function Resistor() {
    }
    Resistor.prototype.set = function Resistor() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,R,exprs] = scicos_getvalue("Set Resistor block parameter","R (ohm)",list("vec",1),exprs);
        if (!ok) {
break;
}
        model.rpar = R;
        model.equations.parameters[2-1] = list(R);
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/Electrical/SineVoltage.sci" */
function SineVoltage() {
    SineVoltage.prototype.define = function SineVoltage() {
        model = scicos_model();
        model.in1 = [1];
        model.out = [1];
        V = 1;
        ph = 0;
        frq = 1;
        offset = 0;
        start = 0;
        model.rpar = [[V],[ph],[frq],[offset],[start]];
        model.sim = "SineVoltage";
        model.blocktype = "c";
        model.dep_ut = [true,false];
        mo = modelica();
        mo.model = "SineVoltage";
        mo.inputs = "p";
        mo.outputs = "n";
        mo.parameters = list([["V"],["phase"],["freqHz"],["offset"],["startTime"]],list(V,ph,frq,offset,start));
        model.equations = mo;
        exprs = [[string(V)],[string(ph)],[string(frq)],[string(offset)],[string(start)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
        x.graphics.in_implicit = ["I"];
        x.graphics.out_implicit = ["I"];
    }
    SineVoltage.prototype.details = function SineVoltage() {
    }
    SineVoltage.prototype.get = function SineVoltage() {
    }
    SineVoltage.prototype.set = function SineVoltage() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,V,ph,frq,offset,start,exprs] = scicos_getvalue("Set voltage source parameter",[["Amplitude (Volt)"],["phase (rad)"],["Frequency (Hz)"],["Voltageoffset (V)"],["Timeoffset (s)"]],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        model.rpar = [[V],[ph],[frq],[offset],[start]];
        model.equations.parameters[2-1] = list(V,ph,frq,offset,start);
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/Electrical/Switch.sci" */
function Switch() {
    Switch.prototype.define = function Switch() {
        model = scicos_model();
        Ron = 0.01;
        Roff = 1e5;
        S = [["Ron"],["Roff"]];
        Z = eval(S);
        model.sim = "Switch";
        model.blocktype = "c";
        model.dep_ut = [true,false];
        mo = modelica();
        mo.model = model.sim;
        mo.inputs = [["p"],["inp"]];
        mo.outputs = "n";
        mo.parameters = list(S,Z);
        model.equations = mo;
        model.in1 = ones(size(mo.inputs,"*"),1);
        model.out = ones(size(mo.outputs,"*"),1);
        model.rpar = Z;
        exprs = string(Z);
        gr_i = [];
        x = standard_define([2,2],model,exprs,list(gr_i,0));
        x.graphics.in_implicit = [["I"],["E"]];
        x.graphics.out_implicit = ["I"];
    }
    Switch.prototype.details = function Switch() {
    }
    Switch.prototype.get = function Switch() {
    }
    Switch.prototype.set = function Switch() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,Ron,Roff,exprs] = scicos_getvalue("Set non-ideal electrical switch parameters",[["Resistance in On state (Ohm)"],["Resistance in Off state (Ohm)"]],list("vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        model.equations.parameters[2-1] = list(Ron,Roff);
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/Electrical/VVsourceAC.sci" */
function VVsourceAC() {
    VVsourceAC.prototype.define = function VVsourceAC() {
        model = scicos_model();
        model.in1 = [[1],[1]];
        model.out = [1];
        VA = 220;
        FR = 50;
        model.rpar = [FR];
        model.sim = "VVsourceAC";
        model.blocktype = "c";
        model.dep_ut = [true,false];
        mo = modelica();
        mo.model = "VVsourceAC";
        mo.inputs = ["p","VA"];
        mo.outputs = "n";
        mo.parameters = list(["f"],list(FR));
        model.equations = mo;
        exprs = [string(FR)];
        gr_i = [];
        x = standard_define([2,2],model,exprs,list(gr_i,0));
        x.graphics.in_implicit = ["I","E"];
        x.graphics.out_implicit = ["I"];
    }
    VVsourceAC.prototype.details = function VVsourceAC() {
    }
    VVsourceAC.prototype.get = function VVsourceAC() {
    }
    VVsourceAC.prototype.set = function VVsourceAC() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,FR,exprs] = scicos_getvalue("Set voltage source parameter",["Frequency (Hz)"],list("vec",-1),exprs);
        if (!ok) {
break;
}
        model.rpar = [FR];
        model.equations.parameters[2-1] = list(FR);
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/Electrical/VariableResistor.sci" */
function VariableResistor() {
    VariableResistor.prototype.define = function VariableResistor() {
        model = scicos_model();
        model.sim = "VariableResistor";
        model.blocktype = "c";
        model.dep_ut = [true,false];
        mo = modelica();
        mo.model = "VariableResistor";
        mo.inputs = ["p","R"];
        mo.outputs = "n";
        model.equations = mo;
        model.in1 = ones(size(mo.inputs,"*"),1);
        model.out = ones(size(mo.outputs,"*"),1);
        exprs = [];
        gr_i = [];
        x = standard_define([2,2],model,exprs,list(gr_i,0));
        x.graphics.in_implicit = ["I","E"];
        x.graphics.out_implicit = ["I"];
    }
    VariableResistor.prototype.details = function VariableResistor() {
    }
    VariableResistor.prototype.get = function VariableResistor() {
    }
    VariableResistor.prototype.set = function VariableResistor() {
        x = arg1;
    }
}
/* autogenerated from "macros/Electrical/VoltageSensor.sci" */
function VoltageSensor() {
    VoltageSensor.prototype.define = function VoltageSensor() {
        model = scicos_model();
        model.in1 = 1;
        model.out = [[1],[1]];
        model.sim = "VoltageSensor";
        model.blocktype = "c";
        model.dep_ut = [true,false];
        mo = modelica();
        mo.model = "VoltageSensor";
        mo.inputs = "p";
        mo.outputs = [["n"],["v"]];
        model.equations = mo;
        exprs = [];
        gr_i = [];
        x = standard_define([2,2],model,exprs,list(gr_i,0));
        x.graphics.in_implicit = ["I"];
        x.graphics.out_implicit = [["I"],["E"]];
    }
    VoltageSensor.prototype.details = function VoltageSensor() {
    }
    VoltageSensor.prototype.get = function VoltageSensor() {
    }
    VoltageSensor.prototype.set = function VoltageSensor() {
        x = arg1;
    }
}
/* autogenerated from "macros/Electrical/VsourceAC.sci" */
function VsourceAC() {
    VsourceAC.prototype.define = function VsourceAC() {
        model = scicos_model();
        model.in1 = [1];
        model.out = [1];
        VA = 220;
        FR = 50;
        model.rpar = [[VA],[FR]];
        model.sim = "VsourceAC";
        model.blocktype = "c";
        model.dep_ut = [true,false];
        mo = modelica();
        mo.model = "VsourceAC";
        mo.inputs = "p";
        mo.outputs = "n";
        mo.parameters = list([["VA"],["f"]],list(VA,FR));
        model.equations = mo;
        exprs = [[string(VA)],[string(FR)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,list(gr_i,0));
        x.graphics.in_implicit = ["I"];
        x.graphics.out_implicit = ["I"];
    }
    VsourceAC.prototype.details = function VsourceAC() {
    }
    VsourceAC.prototype.get = function VsourceAC() {
    }
    VsourceAC.prototype.set = function VsourceAC() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,VA,FR,exprs] = scicos_getvalue("Set voltage source parameter",[["Amplitude (Volt)"],["Frequency (Hz)"]],list("vec",-1,"vec",-1),exprs);
        if (!ok) {
break;
}
        model.rpar = [[VA],[FR]];
        model.equations.parameters[2-1] = list(VA,FR);
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/Events/ANDBLK.sci" */
function ANDBLK() {
    ANDBLK.prototype.define = function ANDBLK() {
        andlog = ANDLOG_f("define");
        andlog.graphics.orig = [194,133];
        andlog.graphics.sz = [60,60];
        andlog.graphics.flip = true;
        andlog.graphics.pout = 9;
        andlog.graphics.pein = [[4],[11]];
        input_port1 = CLKIN_f("define");
        input_port1.graphics.orig = [149,287];
        input_port1.graphics.sz = [20,20];
        input_port1.graphics.flip = true;
        input_port1.graphics.exprs = "1";
        input_port1.graphics.peout = 4;
        input_port1.model.ipar = 1;
        output_port = CLKOUT_f("define");
        output_port.graphics.orig = [450,83];
        output_port.graphics.sz = [20,20];
        output_port.graphics.flip = true;
        output_port.graphics.exprs = "1";
        output_port.graphics.pein = 8;
        output_port.model.ipar = 1;
        input_port2 = CLKIN_f("define");
        input_port2.graphics.orig = [141,330];
        input_port2.graphics.sz = [20,20];
        input_port2.graphics.flip = true;
        input_port2.graphics.exprs = "2";
        input_port2.graphics.peout = 6;
        input_port2.model.ipar = 2;
        ifthel = IFTHEL_f("define");
        ifthel.graphics.orig = [331,137];
        ifthel.graphics.sz = [60,60];
        ifthel.graphics.flip = true;
        ifthel.graphics.pin = 9;
        ifthel.graphics.pein = 12;
        ifthel.graphics.peout = [[8],[0]];
        split = CLKSPLIT_f("define");
        split.graphics.orig = [[234],[275.78348]];
        split.graphics.pein = 6;
        split.graphics.peout = [[11],[12]];
        diagram = scicos_diagram();
        diagram.objs[1-1] = andlog;
        diagram.objs[2-1] = input_port1;
        diagram.objs[3-1] = output_port;
        diagram.objs[4-1] = scicos_link(xx=[[169],[214],[214]],yy=[[297],[297],[198.71]],ct=[5,-1],from=[2,1],to=[1,1]);
        diagram.objs[5-1] = input_port2;
        diagram.objs[6-1] = scicos_link(xx=[[161],[234],[234]],yy=[[340],[340],[275.78]],ct=[5,-1],from=[5,1],to=[10,1]);
        diagram.objs[7-1] = ifthel;
        diagram.objs[8-1] = scicos_link(xx=[[351],[351],[450]],yy=[[131.29],[93],[93]],ct=[5,-1],from=[7,1],to=[3,1]);
        diagram.objs[9-1] = scicos_link(xx=[[262.57],[322.43]],yy=[[163],[167]],ct=[1,1],from=[1,1],to=[7,1]);
        diagram.objs[10-1] = split;
        diagram.objs[11-1] = scicos_link(xx=[[234],[234]],yy=[[275.78],[198.71]],ct=[5,-1],from=[10,1],to=[1,2]);
        diagram.objs[12-1] = scicos_link(xx=[[234],[361],[361]],yy=[[275.78],[275.78],[202.71]],ct=[5,-1],from=[10,2],to=[7,1]);
        x = scicos_block();
        x.gui = "ANDBLK";
        x.graphics.sz = [2,2];
        x.graphics.gr_i = [];
        x.graphics.pein = [[0],[0]];
        x.graphics.peout = 0;
        x.model.sim = "csuper";
        x.model.evtin = [[1],[1]];
        x.model.evtout = 1;
        x.model.blocktype = "h";
        x.model.firing = false;
        x.model.dep_ut = [false,false];
        x.model.rpar = diagram;
    }
    ANDBLK.prototype.details = function ANDBLK() {
    }
    ANDBLK.prototype.get = function ANDBLK() {
    }
    ANDBLK.prototype.set = function ANDBLK() {
        x = arg1;
    }
}
/* autogenerated from "macros/Events/ANDLOG_f.sci" */
function ANDLOG_f() {
    ANDLOG_f.prototype.define = function ANDLOG_f() {
        model = scicos_model();
        model.sim = "andlog";
        model.out = 1;
        model.evtin = [[1],[1]];
        model.blocktype = "d";
        model.firing = [];
        model.dep_ut = [false,false];
        gr_i = [];
        x = standard_define([3,3],model,[],gr_i);
    }
    ANDLOG_f.prototype.details = function ANDLOG_f() {
    }
    ANDLOG_f.prototype.get = function ANDLOG_f() {
    }
    ANDLOG_f.prototype.set = function ANDLOG_f() {
        x = arg1;
    }
}
/* autogenerated from "macros/Events/CLKSOMV_f.sci" */
function CLKSOMV_f() {
    CLKSOMV_f.prototype.define = function CLKSOMV_f() {
        model = scicos_model();
        model.sim = "sum";
        model.evtin = [[1],[1],[1]];
        model.evtout = 1;
        model.blocktype = "d";
        model.firing = -1;
        model.dep_ut = [false,false];
        gr_i = [];
        x = standard_define([2,2],model,[],gr_i);
    }
    CLKSOMV_f.prototype.details = function CLKSOMV_f() {
    }
    CLKSOMV_f.prototype.get = function CLKSOMV_f() {
    }
    CLKSOMV_f.prototype.set = function CLKSOMV_f() {
        x = arg1;
    }
}
/* autogenerated from "macros/Events/CLKSOM_f.sci" */
function CLKSOM_f() {
    CLKSOM_f.prototype.define = function CLKSOM_f() {
        model = scicos_model();
        model.sim = "sum";
        model.evtin = [[1],[1],[1]];
        model.evtout = 1;
        model.blocktype = "d";
        model.firing = -1;
        model.dep_ut = [false,false];
        gr_i = [];
        x = standard_define([1,1]/1.2,model,[],gr_i);
    }
    CLKSOM_f.prototype.details = function CLKSOM_f() {
    }
    CLKSOM_f.prototype.get = function CLKSOM_f() {
    }
    CLKSOM_f.prototype.set = function CLKSOM_f() {
        x = arg1;
    }
}
/* autogenerated from "macros/Events/CLKSPLIT_f.sci" */
function CLKSPLIT_f() {
    CLKSPLIT_f.prototype.define = function CLKSPLIT_f() {
        model = scicos_model();
        model.sim = "split";
        model.evtin = 1;
        model.evtout = [[1],[1]];
        model.blocktype = "d";
        model.firing = [false,false,false];
        model.dep_ut = [false,false];
        x = standard_define([1,1]/3,model,[],[]);
    }
    CLKSPLIT_f.prototype.details = function CLKSPLIT_f() {
    }
    CLKSPLIT_f.prototype.get = function CLKSPLIT_f() {
    }
    CLKSPLIT_f.prototype.set = function CLKSPLIT_f() {
        x = arg1;
    }
}
/* autogenerated from "macros/Events/END_c.sci" */
function END_c() {
    END_c.prototype.define = function END_c() {
        tf = 100000000;
        model = scicos_model();
        model.sim = list("scicosexit",4);
        model.evtin = 1;
        model.evtout = 1;
        model.firing = tf;
        model.blocktype = "d";
        model.dep_ut = [false,false];
        exprs = string(tf);
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    END_c.prototype.details = function END_c() {
    }
    END_c.prototype.get = function END_c() {
    }
    END_c.prototype.set = function END_c() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,tf,exprs] = scicos_getvalue("Set final simulation time",["Final simulation time"],list("vec",1),exprs);
        if (!ok) {
break;
}
        if (ok) {
        graphics.exprs = exprs;
        model.firing = tf;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Events/EVTDLY_c.sci" */
function EVTDLY_c() {
    EVTDLY_c.prototype.define = function EVTDLY_c() {
        dt = 0.1;
        ff = 0.0;
        model = scicos_model();
        model.sim = list("evtdly4",4);
        model.evtin = 1;
        model.evtout = 1;
        model.rpar = [[dt],[ff]];
        model.blocktype = "d";
        model.firing = ff;
        model.dep_ut = [false,false];
        exprs = [[string(dt)],[sci2exp(ff)]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    EVTDLY_c.prototype.details = function EVTDLY_c() {
    }
    EVTDLY_c.prototype.get = function EVTDLY_c() {
    }
    EVTDLY_c.prototype.set = function EVTDLY_c() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,dt,ff,exprs] = scicos_getvalue([["Set Event Delay block parameters"],["Delay  is the delay between an input event "],["       and the generated output event"],["Block may initially generate an output event before "],["       any input event. \"Date of initial output event\""],["       gives the date of this event. Set a negative value"],["       to disable any output event."]],[["Delay"],["Date of initial output event"]],list("vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (dt<=0) {
message("Delay must be positive");
        ok = false;
}
        if (ok) {
        graphics.exprs = exprs;
        model.rpar = [[dt],[ff]];
        model.firing = ff;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Events/EVTDLY_f.sci" */
function EVTDLY_f() {
    EVTDLY_f.prototype.define = function EVTDLY_f() {
        dt = 0.1;
        ff = dt;
        model = scicos_model();
        model.sim = "evtdly";
        model.evtin = 1;
        model.evtout = 1;
        model.rpar = dt;
        model.blocktype = "d";
        model.firing = ff;
        model.dep_ut = [false,false];
        exprs = [[string(dt)],[sci2exp(ff)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    EVTDLY_f.prototype.details = function EVTDLY_f() {
    }
    EVTDLY_f.prototype.get = function EVTDLY_f() {
    }
    EVTDLY_f.prototype.set = function EVTDLY_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,dt,ff,exprs] = scicos_getvalue([["Set Event Delay  block parameters"],["Delay  is the delay between an input event "],["       and the generated output event"],["Block may initially generate an output event before "],["       any input event. \"Date of initial output event\""],["       gives the date of this event. Set a negative value"],["       if no initial event required"]],[["Delay"],["Date of initial output event"]],list("vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (dt<=0) {
message("Delay must be positive");
        ok = false;
}
        if (ok) {
        graphics.exprs = exprs;
        model.rpar = dt;
        model.firing = ff;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Events/EVTGEN_f.sci" */
function EVTGEN_f() {
    EVTGEN_f.prototype.define = function EVTGEN_f() {
        tt = 0;
        model = scicos_model();
        model.sim = "trash";
        model.evtout = 1;
        model.blocktype = "d";
        model.firing = tt;
        model.dep_ut = [false,false];
        exprs = string(tt);
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    EVTGEN_f.prototype.details = function EVTGEN_f() {
    }
    EVTGEN_f.prototype.get = function EVTGEN_f() {
    }
    EVTGEN_f.prototype.set = function EVTGEN_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,tt,exprs] = scicos_getvalue("Set Event time",["Event Time"],list("vec",1),exprs);
        if (!ok) {
break;
}
        graphics.exprs = exprs;
        if (model.firing!=tt) {
        model.firing = tt;
}
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/Events/EVTVARDLY.sci" */
function EVTVARDLY() {
    EVTVARDLY.prototype.define = function EVTVARDLY() {
        model = scicos_model();
        model.sim = list("evtvardly",4);
        model.in1 = 1;
        model.evtin = 1;
        model.evtout = 1;
        model.blocktype = "d";
        model.firing = -1;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = string(model.firing);
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    EVTVARDLY.prototype.details = function EVTVARDLY() {
    }
    EVTVARDLY.prototype.get = function EVTVARDLY() {
    }
    EVTVARDLY.prototype.set = function EVTVARDLY() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,fir,exprs] = scicos_getvalue("Set parameter of variable event delay","Initial event firing time (<0 if absent)",list("vec",1),exprs);
        if (!ok) {
break;
}
        graphics.exprs = exprs;
        model.firing = fir;
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/Events/HALT_f.sci" */
function HALT_f() {
    HALT_f.prototype.define = function HALT_f() {
        n = 0;
        model = scicos_model();
        model.sim = "hltblk";
        model.evtin = 1;
        model.dstate = 0;
        model.ipar = 0;
        model.blocktype = "d";
        model.dep_ut = [false,false];
        exprs = string(n);
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    HALT_f.prototype.details = function HALT_f() {
    }
    HALT_f.prototype.get = function HALT_f() {
    }
    HALT_f.prototype.set = function HALT_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,n,exprs] = scicos_getvalue("Set Halt block parameters",["State on halt"],list("vec",1),exprs);
        if (!ok) {
break;
}
        if (ok) {
        graphics.exprs = exprs;
        model.ipar = n;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Events/IFTHEL_f.sci" */
function IFTHEL_f() {
    IFTHEL_f.prototype.define = function IFTHEL_f() {
        model = scicos_model();
        model.sim = list("ifthel",-1);
        model.in1 = 1;
        model.in2 = 1;
        model.intyp = -1;
        model.evtin = 1;
        model.evtout = [[1],[1]];
        model.blocktype = "l";
        model.firing = [-1,-1];
        model.dep_ut = [true,false];
        model.nmode = 1;
        model.nzcross = 1;
        gr_i = [];
        exprs = [[string(model.in1)],[string(model.nmode)]];
        x = standard_define([3,3],model,exprs,gr_i);
    }
    IFTHEL_f.prototype.details = function IFTHEL_f() {
    }
    IFTHEL_f.prototype.get = function IFTHEL_f() {
    }
    IFTHEL_f.prototype.set = function IFTHEL_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        if (exprs==[]) {
        exprs = string(1);
}
        if (size(exprs,"*")==1) {
        exprs[2-1] = string(1);
}
        while (true) {
        [ok,inh,nmod,exprs] = scicos_getvalue("Set parameters",[["Inherit (1: no, 0: yes)"],["zero-crossing (0: no, 1: yes)"]],list("vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        model.dep_ut = [true,false];
        if (nmod!=0) {
        nmod = 1;
}
        if (inh!=1) {
        inh = [];
}
        [model,graphics,ok] = check_io(model,graphics,1,[],inh,[[1],[1]]);
        if (ok) {
        graphics.exprs = exprs;
        model.evtin = inh;
        model.sim[2-1] = -1;
        model.nmode = nmod;
        model.nzcross = nmod;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Events/MCLOCK_f.sci" */
function MCLOCK_f() {
    MCLOCK_f.prototype.define = function MCLOCK_f() {
        nn = 2;
        dt = 0.1;
        exprs = [[string(dt)],[string(nn)]];
        mfclck = MFCLCK_f("define");
        mfclck.graphics.orig = [334,199];
        mfclck.graphics.sz = [40,40];
        mfclck.graphics.flip = true;
        mfclck.graphics.exprs = exprs;
        mfclck.graphics.pein = 12;
        mfclck.graphics.peout = [[4],[3]];
        mfclck.model.rpar = 0.1;
        mfclck.model.ipar = nn;
        mfclck.model.firing = [-1,0];
        clksom = CLKSOM_f("define");
        clksom.graphics.orig = [457,161];
        clksom.graphics.sz = [16.666667,16.666667];
        clksom.graphics.flip = true;
        clksom.graphics.exprs = [["0.1"],["0.1"]];
        clksom.graphics.pein = [[4],[9],[0]];
        clksom.graphics.peout = 5;
        output_port1 = CLKOUT_f("define");
        output_port1.graphics.orig = [509,261];
        output_port1.graphics.sz = [20,20];
        output_port1.graphics.flip = true;
        output_port1.graphics.exprs = "1";
        output_port1.graphics.pein = 10;
        output_port1.model.ipar = 1;
        output_port2 = CLKOUT_f("define");
        output_port2.graphics.orig = [509,142];
        output_port2.graphics.sz = [20,20];
        output_port2.graphics.flip = true;
        output_port2.graphics.exprs = "2";
        output_port2.graphics.pein = 13;
        output_port2.model.ipar = 2;
        split1 = CLKSPLIT_f("define");
        split1.graphics.orig = [[411.92504],[169.33333]];
        split1.graphics.pein = 3;
        split1.graphics.peout = [[9],[10]];
        split2 = CLKSPLIT_f("define");
        split2.graphics.orig = [[482.45315],[169.33333]];
        split2.graphics.pein = 5;
        split2.graphics.peout = [[12],[13]];
        gr_i = [];
        diagram = scicos_diagram();
        diagram.objs[1-1] = mfclck;
        diagram.objs[2-1] = clksom;
        diagram.objs[3-1] = scicos_link(xx=[[360.7],[360.7],[411.9]],yy=[[193.3],[169.3],[169.3]],ct=[10,-1],from=[1,2],to=[8,1]);
        diagram.objs[4-1] = scicos_link(xx=[[347.3],[347.3],[461.8],[461.8]],yy=[[193.3],[155.5],[155.5],[161]],ct=[10,-1],from=[1,1],to=[2,1]);
        diagram.objs[5-1] = scicos_link(xx=[[468.9],[482.5]],yy=[[169.3],[169.3]],ct=[10,-1],from=[2,1],to=[11,1]);
        diagram.objs[6-1] = output_port1;
        diagram.objs[7-1] = output_port2;
        diagram.objs[8-1] = split1;
        diagram.objs[9-1] = scicos_link(xx=[[411.9],[457]],yy=[[169.3],[169.3]],ct=[10,-1],from=[8,1],to=[2,2]);
        diagram.objs[10-1] = scicos_link(xx=[[411.9],[411.9],[509]],yy=[[169.3],[271],[271]],ct=[10,-1],from=[8,2],to=[6,1]);
        diagram.objs[11-1] = split2;
        diagram.objs[12-1] = scicos_link(xx=[[482.5],[489.6],[489.6],[354],[354]],yy=[[169.3],[169.3],[338.3],[338.3],[244.7]],ct=[10,-1],from=[11,1],to=[1,1]);
        diagram.objs[13-1] = scicos_link(xx=[[482.4],[482.4],[509]],yy=[[169.3],[152],[152]],ct=[10,-1],from=[11,2],to=[7,1]);
        x = scicos_block();
        x.gui = "MCLOCK_f";
        x.graphics.sz = [3,2];
        x.graphics.gr_i = gr_i;
        x.model.sim = "csuper";
        x.model.evtout = [[1],[1]];
        x.model.blocktype = "h";
        x.model.rpar = diagram;
        x.graphics.peout = [[0],[0]];
    }
    MCLOCK_f.prototype.details = function MCLOCK_f() {
    }
    MCLOCK_f.prototype.get = function MCLOCK_f() {
    }
    MCLOCK_f.prototype.set = function MCLOCK_f() {
for (i=1;i<=length(arg1.model.rpar.objs);i+=1) {
        o = arg1.model.rpar.objs[i-1];
        if (typeof(o)=="Block"&&o.gui=="MFCLCK_f") {
        path = i;
break;
}
}
        newpar = list();
        spath = list("model","rpar","objs",path);
        xx = arg1[spath-1];
execstr("xxn="+xx.gui+"(\'set\',xx)");
        if (or(this.xxn!=xx)) {
        arg1[spath-1] = this.xxn;
        newpar[size(newpar)+1-1] = path;
}
        x = arg1;
        y = 0;
        typ = newpar;
    }
}
/* autogenerated from "macros/Events/MFCLCK_f.sci" */
function MFCLCK_f() {
    MFCLCK_f.prototype.define = function MFCLCK_f() {
        nn = 2;
        dt = 0.1;
        model = scicos_model();
        model.sim = "mfclck";
        model.evtin = 1;
        model.evtout = [[1],[1]];
        model.dstate = 0;
        model.rpar = dt;
        model.ipar = nn;
        model.blocktype = "d";
        model.firing = [-1,0];
        model.dep_ut = [false,false];
        exprs = [[string(dt)],[string(nn)]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    MFCLCK_f.prototype.details = function MFCLCK_f() {
    }
    MFCLCK_f.prototype.get = function MFCLCK_f() {
    }
    MFCLCK_f.prototype.set = function MFCLCK_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        [ok,dt,nn,exprs] = scicos_getvalue("Set Multifrequency clock parameters",[["basic period (1/f)"],["multiply by (n)"]],list("vec",1,"vec",1),exprs);
        if (ok) {
        model.ipar = nn;
        model.rpar = dt;
        hh = model.firing;
        hh[2-1] = 0;
        model.firing = hh;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
}
    }
}
/* autogenerated from "macros/Events/M_freq.sci" */
function M_freq() {
    M_freq.prototype.define = function M_freq() {
        model = scicos_model();
        model.sim = list("m_frequ",4);
        model.evtout = [[1],[1],[1]];
        model.evtin = 1;
        model.rpar = [];
        model.opar = list([[1,1,0],[1,1,1],[1,3,2]],1,0,0);
        model.blocktype = "d";
        model.firing = [0,-1,-1];
        model.dep_ut = [false,false];
        exprs = [[sci2exp([[1],[2]])],[sci2exp([[0],[0]])]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    M_freq.prototype.details = function M_freq() {
    }
    M_freq.prototype.get = function M_freq() {
    }
    M_freq.prototype.set = function M_freq() {
        x = arg1;
        graphics = arg1.graphics;
        model = arg1.model;
        exprs = graphics.exprs;
        while (true) {
        [ok,frequ,offset,exprs] = scicos_getvalue("Set block parameters",[["Sample time"],["Offset"]],list("vec",-1,"vec",-1),exprs);
        if (!ok) {
break;
}
        offset = offset.slice();
        frequ = frequ.slice();
        if ((size(frequ,"*"))!=(size(offset,"*"))) {
message("offset and frequency must have the same size");
        ok = false;
        } else if (or(frequ<0)) {
message("Frequency must be a positif number");
        ok = false;
        } else if (or(abs(offset)>frequ)) {
message("The |Offset| must be less than the Frequency");
        ok = false;
}
        if (ok) {
        [m,den,off,count,m1,fir,frequ,offset,ok] = mfrequ_clk(frequ,offset);
}
        if (ok) {
        model.opar = list(m,double(den),off,count);
        mn = (2^size(m1,"*"))-1;
        [model,graphics,ok] = set_io(model,graphics,list(),list(),1,ones(mn,1));
        if (mn>3) {
        graphics.sz = [40+(mn-3)*10,40];
        } else {
        graphics.sz = [50,40];
}
        model.firing = fir;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Events/VirtualCLK0.sci" */
function VirtualCLK0() {
    VirtualCLK0.prototype.define = function VirtualCLK0() {
        model = scicos_model();
        model.sim = "vrtclk0";
        model.evtin = 1;
        model.opar = list();
        model.ipar = [];
        model.blocktype = "d";
        model.firing = -1;
        model.dep_ut = [false,false];
        exprs = [];
        x = standard_define([2,2],model,exprs," ");
    }
    VirtualCLK0.prototype.details = function VirtualCLK0() {
    }
    VirtualCLK0.prototype.get = function VirtualCLK0() {
    }
    VirtualCLK0.prototype.set = function VirtualCLK0() {
        x = arg1;
    }
}
/* autogenerated from "macros/Events/freq_div.sci" */
function freq_div() {
    freq_div.prototype.define = function freq_div() {
        scs_m_1 = scicos_diagram();
        scs_m_1.objs[1-1] = Modulo_Count("define");
        scs_m_1.objs[2-1] = CLKINV_f("define");
        scs_m_1.objs[3-1] = CLKOUTV_f("define");
        scs_m_1.objs[4-1] = IFTHEL_f("define");
        scs_m_1.objs[5-1] = CLKSPLIT_f("define");
        scs_m_1.objs[6-1] = scicos_link();
        scs_m_1.objs[7-1] = scicos_link();
        scs_m_1.objs[8-1] = scicos_link();
        scs_m_1.objs[9-1] = scicos_link();
        scs_m_1.objs[10-1] = scicos_link();
        blk = scs_m_1.objs[1-1];
        graphics = blk.graphics;
        model = blk.model;
        graphics.orig = [0,-100];
        graphics.sz = [60,40];
        graphics.exprs = [["0"],["3"]];
        model.dstate = 3;
        model.ipar = 3;
        graphics.pout = 7;
        graphics.pein = 10;
        blk.graphics = graphics;
        blk.model = model;
        scs_m_1.objs[1-1] = blk;
        blk = scs_m_1.objs[2-1];
        graphics = blk.graphics;
        model = blk.model;
        graphics.orig = [120,0];
        graphics.sz = [20,20];
        graphics.exprs = ["1"];
        model.ipar = 1;
        graphics.peout = 6;
        blk.graphics = graphics;
        blk.model = model;
        scs_m_1.objs[2-1] = blk;
        blk = scs_m_1.objs[3-1];
        graphics = blk.graphics;
        model = blk.model;
        graphics.orig = [130,-160];
        graphics.sz = [20,20];
        graphics.exprs = ["1"];
        model.ipar = 1;
        graphics.pein = 8;
        blk.graphics = graphics;
        blk.model = model;
        scs_m_1.objs[3-1] = blk;
        blk = scs_m_1.objs[4-1];
        graphics = blk.graphics;
        model = blk.model;
        graphics.orig = [100,-100];
        graphics.sz = [60,40];
        graphics.exprs = [["1"],["0"]];
        model.ipar = 1;
        graphics.pin = 7;
        graphics.pein = 9;
        graphics.peout = [[0],[8]];
        blk.graphics = graphics;
        blk.model = model;
        scs_m_1.objs[4-1] = blk;
        blk = scs_m_1.objs[5-1];
        graphics = blk.graphics;
        model = blk.model;
        graphics.orig = [127,-33];
        graphics.sz = [7,7];
        graphics.pein = 6;
        graphics.peout = [[9],[10]];
        blk.graphics = graphics;
        blk.model = model;
        scs_m_1.objs[5-1] = blk;
        lnk = scs_m_1.objs[6-1];
        lnk.ct = [5,-1];
        lnk.from = [2,1,0];
        lnk.to = [5,1,1];
        scs_m_1.objs[6-1] = lnk;
        lnk = scs_m_1.objs[7-1];
        lnk.from = [1,1,0];
        lnk.to = [4,1,1];
        scs_m_1.objs[7-1] = lnk;
        lnk = scs_m_1.objs[8-1];
        lnk.ct = [5,-1];
        lnk.from = [4,2,0];
        lnk.to = [3,1,1];
        scs_m_1.objs[8-1] = lnk;
        lnk = scs_m_1.objs[9-1];
        lnk.ct = [5,-1];
        lnk.from = [5,1,0];
        lnk.to = [4,1,1];
        scs_m_1.objs[9-1] = lnk;
        lnk = scs_m_1.objs[10-1];
        lnk.xx = [0,30,1];
        lnk.yy = [0,-30,1];
        lnk.ct = [5,-1];
        lnk.from = [5,2,0];
        lnk.to = [1,1,1];
        scs_m_1.objs[10-1] = lnk;
blk={};
lnk={};
        model = scicos_model();
        model.sim = "csuper";
        model.evtin = 1;
        model.evtout = 1;
        model.rpar = scs_m_1;
        gr_i = [];
        x = standard_define([3,2],model,[],gr_i);
    }
    freq_div.prototype.details = function freq_div() {
    }
    freq_div.prototype.get = function freq_div() {
    }
    freq_div.prototype.set = function freq_div() {
for (i=1;i<=length(arg1.model.rpar.objs);i+=1) {
        o = arg1.model.rpar.objs[i-1];
        if (typeof(o)=="Block"&&o.gui=="Modulo_Count") {
        path = i;
break;
}
}
        newpar = list();
        y = 0;
        spath = list();
        spath[$+1-1] = "model";
        spath[$+1-1] = "rpar";
        spath[$+1-1] = "objs";
        spath[$+1-1] = path;
        xx = arg1[spath-1];
        xxn = xx;
        graphics = xx.graphics;
        exprs = graphics.exprs;
        model = xx.model;
        while (true) {
        [ok,%ph,%df,exprs] = scicos_getvalue("Set frequency division block parameters",[["Phase (0 to division factor -1)"],["Division factor"]],list("vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (ok) {
        if (%df<1) {
        %df = 1;
}
        %ph = abs(%ph);
        if (%ph>%df-1) {
        %ph = %df-1;
}
        graphics.exprs = exprs;
        model.ipar = %df;
        model.dstate = %ph;
        xxn.graphics = graphics;
        xxn.model = model;
break;
}
}
        if (diffobjs(xxn,xx)) {
        model = xx.model;
        model_n = xxn.model;
        if (!is_modelica_block(xx)) {
        modified = or(model.sim!=model_n.sim)||!isequal(model.state,model_n.state)||!isequal(model.dstate,model_n.dstate)||!isequal(model.rpar,model_n.rpar)||!isequal(model.ipar,model_n.ipar)||!isequal(model.label,model_n.label);
        if (or(model.in1!=model_n.in1)||or(model.out!=model_n.out)) {
        needcompile = 1;
}
        if (or(model.firing!=model_n.firing)) {
        needcompile = 2;
}
        if (model.sim=="input"||model.sim=="output") {
        if (model.ipar!=model_n.ipar) {
        needcompile = 4;
}
}
        if (or(model.blocktype!=model_n.blocktype)||or(model.dep_ut!=model_n.dep_ut)) {
        needcompile = 4;
}
        if ((model.nzcross!=model_n.nzcross)||(model.nmode!=model_n.nmode)) {
        needcompile = 4;
}
        if (prod(size(model_n.sim))>1) {
        if (model_n.sim[2-1]>1000) {
        if (model.sim[1-1]!=model_n.sim[1-1]) {
        needcompile = 4;
}
}
}
        } else {
        modified = or(model_n!=model);
        eq = model.equations;
        eqn = model_n.equations;
        if (or(eq.model!=eqn.model)||or(eq.inputs!=eqn.inputs)||or(eq.outputs!=eqn.outputs)) {
        needcompile = 4;
}
}
        arg1[spath-1] = xxn;
        newpar[size(newpar)+1-1] = 1;
        y = max(y,needcompile);
}
        x = arg1;
        typ = newpar;
    }
}
/* autogenerated from "macros/Hydraulics/Bache.sci" */
function Bache() {
    Bache.prototype.define = function Bache() {
        in1 = 2;
        out = 3;
        model = scicos_model();
        model.in1 = [-transpose([1:in1])];
        model.out = [-transpose([1:out])];
        Patm = 1.013e5;
        A = 1;
        ze1 = 40;
        ze2 = 0;
        zs1 = 40;
        zs2 = 0;
        z0 = 30;
        T0 = 290;
        p_rho = 0;
        model.rpar = [[Patm],[A],[ze1],[ze2],[zs1],[zs2],[z0],[T0],[p_rho]];
        model.sim = "Bache";
        model.blocktype = "c";
        model.dep_ut = [true,false];
        mo = modelica();
        mo.model = "Bache";
        mo.inputs = ["Ce1","Ce2"];
        mo.outputs = ["Cs1","Cs2","yNiveau"];
        mo.parameters = list([["Patm"],["A"],["ze1"],["ze2"],["zs1"],["zs2"],["z0"],["T0"],["p_rho"]],[[Patm],[A],[ze1],[ze2],[zs1],[zs2],[z0],[T0],[p_rho]]);
        model.equations = mo;
        model.in1 = ones(size(mo.inputs,"*"),1);
        model.out = ones(size(mo.outputs,"*"),1);
        exprs = [[string(Patm)],[string(A)],[string(ze1)],[string(ze2)],[string(zs1)],[string(zs2)],[string(z0)],[string(T0)],[string(p_rho)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,list(gr_i,0));
        x.graphics.in_implicit = [["I"],["I"]];
        x.graphics.out_implicit = [["I"],["I"],["E"]];
    }
    Bache.prototype.details = function Bache() {
    }
    Bache.prototype.get = function Bache() {
    }
    Bache.prototype.set = function Bache() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,Patm,A,ze1,ze2,zs1,zs2,z0,T0,p_rho,exprs] = scicos_getvalue("Parametres de la bache",[["Pression dans le ciel de la bache : Patm (Pa)"],["Section de la bache : A (m2)"],["Altitude du piquage d entrée 1: ze1 (m)"],["Altitude du piquage d entrée 2: ze2 (m)"],["Altitude du piquage de sortie 1: zs1 (m)"],["Altitude du piquage de sortie 2: zs2 (m)"],["Altitude initiale du fluide : z0 (m)"],["Température initiale du fluide : T0 (K)"],["Si >0, masse volumique imposée du fluide : p_rho (kg/m3)"]],list("vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1),exprs);
        if (!ok) {
break;
}
        model.rpar = [[Patm],[A],[ze1],[ze2],[zs1],[zs2],[z0],[T0],[p_rho]];
        model.equations.parameters[2-1] = list(Patm,A,ze1,ze2,zs1,zs2,z0,T0,p_rho);
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/Hydraulics/Flowmeter.sci" */
function Flowmeter() {
    Flowmeter.prototype.define = function Flowmeter() {
        ModelName = "Flowmeter";
        PrametersValue = 1;
        ParametersName = "Qini";
        model = scicos_model();
        Typein = [];
        Typeout = [];
        MI = [];
        MO = [];
        P = [[50,105,-1,90],[0,10,2,0],[101,10,-2,0]];
        PortName = [["Mesure"],["C1"],["C2"]];
for (i=1;i<=size(P,"r");i+=1) {
        if (P[i-1][3-1]==1) {
        Typein = [[Typein],["E"]];
        MI = [[MI],[PortName[i-1]]];
}
        if (P[i-1][3-1]==2) {
        Typein = [[Typein],["I"]];
        MI = [[MI],[PortName[i-1]]];
}
        if (P[i-1][3-1]==-1) {
        Typeout = [[Typeout],["E"]];
        MO = [[MO],[PortName[i-1]]];
}
        if (P[i-1][3-1]==-2) {
        Typeout = [[Typeout],["I"]];
        MO = [[MO],[PortName[i-1]]];
}
}
        model = scicos_model();
        mo = modelica();
        model.sim = ModelName;
        mo.inputs = MI;
        mo.outputs = MO;
        model.rpar = PrametersValue;
        mo.parameters = list(ParametersName,PrametersValue,zeros(ParametersName));
        exprs = "1";
        gr_i = [];
        model.blocktype = "c";
        model.dep_ut = [false,true];
        mo.model = ModelName;
        model.equations = mo;
        model.in1 = ones(size(MI,"*"),1);
        model.out = ones(size(MO,"*"),1);
        x = standard_define([2,2],model,exprs,list(gr_i,0));
        x.graphics.in_implicit = Typein;
        x.graphics.out_implicit = Typeout;
    }
    Flowmeter.prototype.details = function Flowmeter() {
    }
    Flowmeter.prototype.get = function Flowmeter() {
    }
    Flowmeter.prototype.set = function Flowmeter() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        x = arg1;
        exprs = x.graphics.exprs;
        while (false) {
        [ok,Qini,exprs] = scicos_getvalue([["Set Flowmeter block parameters:"],[""],["Qini: "]],"Qini",list("vec",1),exprs);
        if (!ok) {
break;
}
        x.model.equations.parameters[2-1] = list(Qini);
        x.graphics.exprs = exprs;
break;
}
    }
}
/* autogenerated from "macros/Hydraulics/PerteDP.sci" */
function PerteDP() {
    PerteDP.prototype.define = function PerteDP() {
        model = scicos_model();
        model.in1 = [1];
        model.out = [1];
        L = 10;
        D = 0.2;
        lambda = 0.03;
        z1 = 0;
        z2 = 0;
        p_rho = 0;
        model.rpar = [[L],[D],[lambda],[z1],[z2],[p_rho]];
        model.sim = "PerteDP";
        model.blocktype = "c";
        model.dep_ut = [true,false];
        mo = modelica();
        mo.model = "PerteDP";
        mo.inputs = "C1";
        mo.outputs = "C2";
        mo.parameters = list([["L"],["D"],["lambda"],["z1"],["z2"],["p_rho"]],[[L],[D],[lambda],[z1],[z2],[p_rho]]);
        model.equations = mo;
        model.in1 = ones(size(mo.inputs,"*"),1);
        model.out = ones(size(mo.outputs,"*"),1);
        exprs = [[string(L)],[string(D)],[string(lambda)],[string(z1)],[string(z2)],[string(p_rho)]];
        gr_i = [];
        x = standard_define([2,1],model,exprs,list(gr_i,0));
        x.graphics.in_implicit = ["I"];
        x.graphics.out_implicit = ["I"];
    }
    PerteDP.prototype.details = function PerteDP() {
    }
    PerteDP.prototype.get = function PerteDP() {
    }
    PerteDP.prototype.set = function PerteDP() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,L,D,lambda,z1,z2,p_rho,exprs] = scicos_getvalue("Parametres du tuyau",[["Longueur du tube : L (m)"],["Diamètre interne du tube : D (m)"],["Coefficient de perte de charge-frottement(S.U) : lambda"],["Altitude entrée tuyauterie : z1 (m)"],["Altitude sortie tuyauterie : z2 (m)"],["Si >0, masse volumique imposée fu fluide : p_rho (kg/m3)"]],list("vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1),exprs);
        if (!ok) {
break;
}
        model.rpar = [[L],[D],[lambda],[z1],[z2],[p_rho]];
        model.equations.parameters[2-1] = list(L,D,lambda,z1,z2,p_rho);
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/Hydraulics/PuitsP.sci" */
function PuitsP() {
    PuitsP.prototype.define = function PuitsP() {
        model = scicos_model();
        P0 = 100000;
        T0 = 290;
        H0 = 100000;
        option_temperature = 1;
        model.rpar = [[P0],[T0],[H0],[option_temperature]];
        model.sim = "Puits";
        model.blocktype = "c";
        model.dep_ut = [true,false];
        mo = modelica();
        mo.model = "Puits";
        mo.inputs = ["C"];
        mo.parameters = list([["P0"],["T0"],["H0"],["option_temperature"]],[[P0],[T0],[H0],[option_temperature]]);
        model.equations = mo;
        model.in1 = ones(size(mo.inputs,"*"),1);
        exprs = [[string(P0)],[string(T0)],[string(H0)],[string(option_temperature)]];
        gr_i = [];
        x = standard_define([2.5,2],model,exprs,list(gr_i,0));
        x.graphics.in_implicit = ["I"];
    }
    PuitsP.prototype.details = function PuitsP() {
    }
    PuitsP.prototype.get = function PuitsP() {
    }
    PuitsP.prototype.set = function PuitsP() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,P0,T0,H0,option_temperature,exprs] = scicos_getvalue("Paramètres du puits",[["Pression de la source : P0 (Pa)"],["Temperature de la source : T0 (K)"],["Enthalpie spécifique de la source : H0 (J/kg)"],["1:température fixée - 2:enthalpie fixée : option_temperature"]],list("vec",-1,"vec",-1,"vec",-1,"vec",-1),exprs);
        if (!ok) {
break;
}
        model.rpar = [[P0],[T0],[H0],[option_temperature]];
        model.equations.parameters[2-1] = list(P0,T0,H0,option_temperature);
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/Hydraulics/SourceP.sci" */
function SourceP() {
    SourceP.prototype.define = function SourceP() {
        model = scicos_model();
        P0 = 300000;
        T0 = 290;
        H0 = 100000;
        option_temperature = 1;
        model.rpar = [[P0],[T0],[H0],[option_temperature]];
        model.sim = "Source";
        model.blocktype = "c";
        model.dep_ut = [true,false];
        mo = modelica();
        mo.model = "Source";
        mo.inputs = [];
        mo.outputs = ["C"];
        mo.parameters = list([["P0"],["T0"],["H0"],["option_temperature"]],[[P0],[T0],[H0],[option_temperature]]);
        model.equations = mo;
        model.in1 = ones(size(mo.inputs,"*"),1);
        model.out = ones(size(mo.outputs,"*"),1);
        exprs = [[string(P0)],[string(T0)],[string(H0)],[string(option_temperature)]];
        gr_i = [];
        x = standard_define([2.5,2],model,exprs,list(gr_i,0));
        x.graphics.out_implicit = ["I"];
    }
    SourceP.prototype.details = function SourceP() {
    }
    SourceP.prototype.get = function SourceP() {
    }
    SourceP.prototype.set = function SourceP() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,P0,T0,H0,option_temperature,exprs] = scicos_getvalue("Paramètres du puits",[["Pression de la source : P0 (Pa)"],["Temperature de la source : T0 (K)"],["Enthalpie spécifique de la source : H0 (J/kg)"],["1:température fixée - 2:enthalpie fixée : option_temperature"]],list("vec",-1,"vec",-1,"vec",-1,"vec",-1),exprs);
        if (!ok) {
break;
}
        model.rpar = [[P0],[T0],[H0],[option_temperature]];
        model.equations.parameters[2-1] = list(P0,T0,H0,option_temperature);
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/Hydraulics/VanneReglante.sci" */
function VanneReglante() {
    VanneReglante.prototype.define = function VanneReglante() {
        model = scicos_model();
        model.in1 = [[1],[1]];
        model.out = [1];
        Cvmax = 8005.42;
        p_rho = 0;
        model.rpar = [[Cvmax],[p_rho]];
        model.sim = "VanneReglante";
        model.blocktype = "c";
        model.dep_ut = [true,false];
        mo = modelica();
        mo.model = "VanneReglante";
        mo.inputs = ["C1","Ouv"];
        mo.outputs = "C2";
        mo.parameters = list([["Cvmax"],["p_rho"]],[[Cvmax],[p_rho]]);
        model.equations = mo;
        model.in1 = ones(size(mo.inputs,"*"),1);
        model.out = ones(size(mo.outputs,"*"),1);
        exprs = [[string(Cvmax)],[string(p_rho)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,list(gr_i,0));
        x.graphics.in_implicit = [["I"],["E"]];
        x.graphics.out_implicit = ["I"];
    }
    VanneReglante.prototype.details = function VanneReglante() {
    }
    VanneReglante.prototype.get = function VanneReglante() {
    }
    VanneReglante.prototype.set = function VanneReglante() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,Cvmax,p_rho,exprs] = scicos_getvalue("Paramètres de la vanne reglante",[["Cvmax"],["p_rho"]],list("vec",-1,"vec",-1),exprs);
        if (!ok) {
break;
}
        model.rpar = [[Cvmax],[p_rho]];
        model.equations.parameters[2-1] = list(Cvmax,p_rho);
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/IntegerOp/BITCLEAR.sci" */
function BITCLEAR() {
    BITCLEAR.prototype.define = function BITCLEAR() {
        model = scicos_model();
        model.sim = list("bit_clear_32",4);
        model.in1 = 1;
        model.in2 = 1;
        model.out = 1;
        model.out2 = 1;
        model.intyp = 3;
        model.outtyp = 3;
        model.opar = list(int32(0));
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[sci2exp(3)],[sci2exp(0)]];
        gr_i = [];
        x = standard_define([4,2],model,exprs,gr_i);
    }
    BITCLEAR.prototype.details = function BITCLEAR() {
    }
    BITCLEAR.prototype.get = function BITCLEAR() {
    }
    BITCLEAR.prototype.set = function BITCLEAR() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,Datatype,bit,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"BITCLEAR")],[" "],[gettext("Clear a bit")],[" "]],[[msprintf(gettext("Data Type %s"),"(3:int32, 4:int16, 5:int8, ...)")],[gettext("Index of Bit (0 is least significant)")]],list("vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        in1 = [model.in1,model.in2];
        if (floor(bit)!=bit) {
block_parameter_error(msprintf(gettext("Wrong type for \'%s\' parameter: %5.1f."),gettext("Index of Bit"),bit),gettext("Must be integer."));
        ok = false;
        } else if ((Datatype==3)||(Datatype==6)) {
        if (bit>31||bit<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Index of Bit"),bit),msprintf(gettext("Must be in the interval %s."),"[0, 31]"));
        ok = false;
        } else {
        bit = uint32(bit);
        n = (2^32-1)-2^bit;
        n = uint32(n);
        model.sim = list("bit_clear_32",4);
}
        } else if ((Datatype==4)||(Datatype==7)) {
        if (bit>15||bit<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Index of Bit"),bit),msprintf(gettext("Must be in the interval %s."),"[0, 15]"));
        ok = false;
        } else {
        bit = uint16(bit);
        n = (2^16-1)-2^bit;
        n = uint16(n);
        model.sim = list("bit_clear_16",4);
}
        } else if ((Datatype==5)||(Datatype==8)) {
        if (bit>7||bit<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Index of Bit"),bit),msprintf(gettext("Must be in the interval %s."),"[0, 7]"));
        ok = false;
        } else {
        bit = uint8(bit);
        n = (2^8-1)-2^bit;
        n = uint8(n);
        model.sim = list("bit_clear_8",4);
}
        } else {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Data Type"),Datatype),msprintf(gettext("Must be in the interval %s."),"[3, 8]"));
        ok = false;
}
        if (ok) {
        it = Datatype;
        ot = Datatype;
        out = [1,1];
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
        if (ok) {
        graphics.exprs = exprs;
        model.opar = list(n);
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/IntegerOp/BITSET.sci" */
function BITSET() {
    BITSET.prototype.define = function BITSET() {
        model = scicos_model();
        model.sim = list("bit_set_32",4);
        model.in1 = 1;
        model.in2 = 1;
        model.out = 1;
        model.out2 = 1;
        model.intyp = 3;
        model.outtyp = 3;
        model.opar = list(uint32(0));
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[sci2exp(3)],[sci2exp(0)]];
        gr_i = [];
        x = standard_define([4,2],model,exprs,gr_i);
    }
    BITSET.prototype.details = function BITSET() {
    }
    BITSET.prototype.get = function BITSET() {
    }
    BITSET.prototype.set = function BITSET() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,Datatype,bit,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"BITSET")],[" "],[gettext("Set a bit")],[" "]],[[msprintf(gettext("Data Type %s"),"(3:int32, 4:int16, 5:int8, ...)")],[gettext("Index of Bit (0 is least significant)")]],list("vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        in1 = [model.in1,model.in2];
        if (floor(bit)!=bit) {
block_parameter_error(msprintf(gettext("Wrong type for \'%s\' parameter: %5.1f."),gettext("Index of Bit"),bit),gettext("Must be integer."));
        ok = false;
}
        if ((Datatype==3)||(Datatype==6)) {
        if (bit>31||bit<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Index of Bit"),bit),msprintf(gettext("Must be in the interval %s."),"[0, 31]"));
        ok = false;
}
        bit = uint32(bit);
        n = 2^bit;
        n = uint32(n);
        model.sim = list("bit_set_32",4);
        } else if ((Datatype==4)||(Datatype==7)) {
        if (bit>15||bit<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Index of Bit"),bit),msprintf(gettext("Must be in the interval %s."),"[0, 15]"));
        ok = false;
}
        bit = uint16(bit);
        n = 2^bit;
        n = uint16(n);
        model.sim = list("bit_set_16",4);
        } else if ((Datatype==5)||(Datatype==8)) {
        if (bit>7||bit<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Index of Bit"),bit),msprintf(gettext("Must be in the interval %s."),"[0, 7]"));
        ok = false;
}
        bit = uint8(bit);
        n = 2^bit;
        n = uint8(n);
        model.sim = list("bit_set_8",4);
        } else {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Data Type"),Datatype),msprintf(gettext("Must be in the interval %s."),"[3, 8]"));
        ok = false;
}
        if (ok) {
        it = Datatype;
        ot = Datatype;
        out = [1,1];
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
        if (ok) {
        graphics.exprs = exprs;
        model.opar = list(n);
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/IntegerOp/CONVERT.sci" */
function CONVERT() {
    CONVERT.prototype.define = function CONVERT() {
        sgn = 2;
        model = scicos_model();
        model.sim = list("convert",4);
        model.in1 = -1;
        model.out = -1;
        model.in2 = -2;
        model.out2 = -2;
        model.intyp = 1;
        model.outtyp = 3;
        model.rpar = [];
        model.ipar = sgn;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[sci2exp(1)],[sci2exp(3)],[sci2exp(0)]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    CONVERT.prototype.details = function CONVERT() {
    }
    CONVERT.prototype.get = function CONVERT() {
    }
    CONVERT.prototype.set = function CONVERT() {
        x = arg1;
        graphics = arg1.graphics;
        model = arg1.model;
        exprs = graphics.exprs;
        while (true) {
        [ok,it,ot,np,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"CONVERT")],[" "],[gettext("Type conversion")],[" "]],[[gettext("Input Type (1:double, 3:int32, 4:int16, 5:int8, ...)")],[gettext("Output Type (1:double, 3:int32, 4:int16, 5:int8, ...)")],[gettext("Do on Overflow (0:Nothing, 1:Saturate, 2:Error)")]],list("vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (it==2) {
        it = 1;
}
        if (ot==2) {
        ot = 1;
}
        if ((np!=0&&np!=1&&np!=2)) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Do on Overflow"),np),msprintf(gettext("Must be in the interval %s."),"[0, 2]"));
        ok = false;
        } else if ((it>8||it<1)) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Input Type"),it),msprintf(gettext("Must be in the interval %s."),"[1, 8]"));
        ok = false;
        } else if ((ot>8||ot<1)) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Output Type"),ot),msprintf(gettext("Must be in the interval %s."),"[1, 8]"));
        ok = false;
}
        model.sim = list("convert",4);
        if ((it==ot)) {
        model.ipar = 1;
        } else {
        if ((np==0)) {
        if ((it==1)) {
        if ((ot==3)) {
        model.ipar = 2;
        } else if ((ot==4)) {
        model.ipar = 3;
        } else if ((ot==5)) {
        model.ipar = 4;
        } else if ((ot==6)) {
        model.ipar = 5;
        } else if ((ot==7)) {
        model.ipar = 6;
        } else if ((ot==8)) {
        model.ipar = 7;
}
        } else if ((it==3)) {
        if ((ot==1)) {
        model.ipar = 8;
        } else if ((ot==4)) {
        model.ipar = 9;
        } else if ((ot==5)) {
        model.ipar = 10;
        } else if ((ot==6)) {
        model.ipar = 1;
        } else if ((ot==7)) {
        model.ipar = 11;
        } else if ((ot==8)) {
        model.ipar = 12;
}
        } else if ((it==4)) {
        if ((ot==1)) {
        model.ipar = 13;
        } else if ((ot==3)) {
        model.ipar = 14;
        } else if ((ot==5)) {
        model.ipar = 15;
        } else if ((ot==6)) {
        model.ipar = 16;
        } else if ((ot==7)) {
        model.ipar = 1;
        } else if ((ot==8)) {
        model.ipar = 17;
}
        } else if ((it==5)) {
        if ((ot==1)) {
        model.ipar = 18;
        } else if ((ot==3)) {
        model.ipar = 19;
        } else if ((ot==4)) {
        model.ipar = 20;
        } else if ((ot==6)) {
        model.ipar = 21;
        } else if ((ot==7)) {
        model.ipar = 22;
        } else if ((ot==8)) {
        model.ipar = 1;
}
        } else if ((it==6)) {
        if ((ot==1)) {
        model.ipar = 23;
        } else if ((ot==3)) {
        model.ipar = 1;
        } else if ((ot==4)) {
        model.ipar = 24;
        } else if ((ot==5)) {
        model.ipar = 25;
        } else if ((ot==7)) {
        model.ipar = 26;
        } else if ((ot==8)) {
        model.ipar = 27;
}
        } else if ((it==7)) {
        if ((ot==1)) {
        model.ipar = 28;
        } else if ((ot==3)) {
        model.ipar = 29;
        } else if ((ot==4)) {
        model.ipar = 1;
        } else if ((ot==5)) {
        model.ipar = 30;
        } else if ((ot==6)) {
        model.ipar = 31;
        } else if ((ot==8)) {
        model.ipar = 32;
}
        } else if ((it==8)) {
        if ((ot==1)) {
        model.ipar = 33;
        } else if ((ot==3)) {
        model.ipar = 34;
        } else if ((ot==4)) {
        model.ipar = 35;
        } else if ((ot==5)) {
        model.ipar = 1;
        } else if ((ot==6)) {
        model.ipar = 36;
        } else if ((ot==7)) {
        model.ipar = 37;
}
}
        } else if ((np==1)) {
        if ((it==1)) {
        if ((ot==3)) {
        model.ipar = 38;
        } else if ((ot==4)) {
        model.ipar = 39;
        } else if ((ot==5)) {
        model.ipar = 40;
        } else if ((ot==6)) {
        model.ipar = 41;
        } else if ((ot==7)) {
        model.ipar = 42;
        } else if ((ot==8)) {
        model.ipar = 43;
}
        } else if ((it==3)) {
        if ((ot==1)) {
        model.ipar = 8;
        } else if ((ot==4)) {
        model.ipar = 44;
        } else if ((ot==5)) {
        model.ipar = 45;
        } else if ((ot==6)) {
        model.ipar = 46;
        } else if ((ot==7)) {
        model.ipar = 47;
        } else if ((ot==8)) {
        model.ipar = 48;
}
        } else if ((it==4)) {
        if ((ot==1)) {
        model.ipar = 13;
        } else if ((ot==3)) {
        model.ipar = 14;
        } else if ((ot==5)) {
        model.ipar = 49;
        } else if ((ot==6)) {
        model.ipar = 50;
        } else if ((ot==7)) {
        model.ipar = 51;
        } else if ((ot==8)) {
        model.ipar = 52;
}
        } else if ((it==5)) {
        if ((ot==1)) {
        model.ipar = 18;
        } else if ((ot==3)) {
        model.ipar = 19;
        } else if ((ot==4)) {
        model.ipar = 20;
        } else if ((ot==6)) {
        model.ipar = 53;
        } else if ((ot==7)) {
        model.ipar = 54;
        } else if ((ot==8)) {
        model.ipar = 55;
}
        } else if ((it==6)) {
        if ((ot==1)) {
        model.ipar = 23;
        } else if ((ot==3)) {
        model.ipar = 56;
        } else if ((ot==4)) {
        model.ipar = 57;
        } else if ((ot==5)) {
        model.ipar = 58;
        } else if ((ot==7)) {
        model.ipar = 59;
        } else if ((ot==8)) {
        model.ipar = 60;
}
        } else if ((it==7)) {
        if ((ot==1)) {
        model.ipar = 28;
        } else if ((ot==3)) {
        model.ipar = 29;
        } else if ((ot==4)) {
        model.ipar = 61;
        } else if ((ot==5)) {
        model.ipar = 62;
        } else if ((ot==6)) {
        model.ipar = 31;
        } else if ((ot==8)) {
        model.ipar = 63;
}
        } else if ((it==8)) {
        if ((ot==1)) {
        model.ipar = 33;
        } else if ((ot==3)) {
        model.ipar = 34;
        } else if ((ot==4)) {
        model.ipar = 35;
        } else if ((ot==5)) {
        model.ipar = 64;
        } else if ((ot==6)) {
        model.ipar = 36;
        } else if ((ot==7)) {
        model.ipar = 37;
}
}
        } else if ((np==2)) {
        if ((it==1)) {
        if ((ot==3)) {
        model.ipar = 65;
        } else if ((ot==4)) {
        model.ipar = 66;
        } else if ((ot==5)) {
        model.ipar = 67;
        } else if ((ot==6)) {
        model.ipar = 68;
        } else if ((ot==7)) {
        model.ipar = 69;
        } else if ((ot==8)) {
        model.ipar = 70;
}
        } else if ((it==3)) {
        if ((ot==1)) {
        model.ipar = 8;
        } else if ((ot==4)) {
        model.ipar = 71;
        } else if ((ot==5)) {
        model.ipar = 72;
        } else if ((ot==6)) {
        model.ipar = 73;
        } else if ((ot==7)) {
        model.ipar = 74;
        } else if ((ot==8)) {
        model.ipar = 75;
}
        } else if ((it==4)) {
        if ((ot==1)) {
        model.ipar = 13;
        } else if ((ot==3)) {
        model.ipar = 14;
        } else if ((ot==5)) {
        model.ipar = 76;
        } else if ((ot==6)) {
        model.ipar = 77;
        } else if ((ot==7)) {
        model.ipar = 78;
        } else if ((ot==8)) {
        model.ipar = 79;
}
        } else if ((it==5)) {
        if ((ot==1)) {
        model.ipar = 18;
        } else if ((ot==3)) {
        model.ipar = 19;
        } else if ((ot==4)) {
        model.ipar = 20;
        } else if ((ot==6)) {
        model.ipar = 80;
        } else if ((ot==7)) {
        model.ipar = 81;
        } else if ((ot==8)) {
        model.ipar = 82;
}
        } else if ((it==6)) {
        if ((ot==1)) {
        model.ipar = 23;
        } else if ((ot==3)) {
        model.ipar = 83;
        } else if ((ot==4)) {
        model.ipar = 84;
        } else if ((ot==5)) {
        model.ipar = 85;
        } else if ((ot==7)) {
        model.ipar = 86;
        } else if ((ot==8)) {
        model.ipar = 87;
}
        } else if ((it==7)) {
        if ((ot==1)) {
        model.ipar = 28;
        } else if ((ot==3)) {
        model.ipar = 29;
        } else if ((ot==4)) {
        model.ipar = 88;
        } else if ((ot==5)) {
        model.ipar = 89;
        } else if ((ot==6)) {
        model.ipar = 31;
        } else if ((ot==8)) {
        model.ipar = 90;
}
        } else if ((it==8)) {
        if ((ot==1)) {
        model.ipar = 33;
        } else if ((ot==3)) {
        model.ipar = 34;
        } else if ((ot==4)) {
        model.ipar = 35;
        } else if ((ot==5)) {
        model.ipar = 91;
        } else if ((ot==6)) {
        model.ipar = 36;
        } else if ((ot==7)) {
        model.ipar = 37;
}
}
}
}
        in1 = [model.in1,model.in2];
        out = [model.out,model.out2];
        if (ok) {
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
        if (ok) {
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/IntegerOp/DFLIPFLOP.sci" */
function DFLIPFLOP() {
    DFLIPFLOP.prototype.define = function DFLIPFLOP() {
        scs_m = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["DFLIPFLOP"],tol=[0.0001,0.000001,1.000e-10,100001,0,0],tf=100000,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m.objs[1-1] = scicos_block(gui="CONST_m",graphics=scicos_graphics(orig=[109.62561,263.44465],sz=[[20],[20]],flip=true,theta=0,exprs="int8(0)",pin=[],pout=6,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim=list("cstblk4_m",4),in1=[],in2=[],intyp=1,out=1,out2=1,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(int8(0)),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[2-1] = scicos_block(gui="IFTHEL_f",graphics=scicos_graphics(orig=[239.98293,378.2166],sz=[60,60],flip=true,theta=0,exprs=[["1"],["1"]],pin=29,pout=[],pein=22,peout=[[16],[44]],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim=list("ifthel",-1),in1=1,in2=1,intyp=-1,out=[],out2=[],outtyp=1,evtin=1,evtout=[[1],[1]],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="l",firing=[-1,-1],dep_ut=[true,false],label="",nzcross=1,nmode=1,equations=list()),doc=list());
        scs_m.objs[3-1] = scicos_block(gui="LOGICAL_OP",graphics=scicos_graphics(orig=[152.88902,260.24498],sz=[60,40],flip=true,theta=0,exprs=[["2"],["1"],["5"],["0"]],pin=[[11],[39]],pout=5,pein=[],peout=[],gr_i=[],id="",in_implicit=[["E"],["E"]],out_implicit="E"),model=scicos_model(sim=list("logicalop_i8",4),in1=[[-1],[-1]],in2=[[-2],[-2]],intyp=[[5],[5]],out=-1,out2=-2,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[[1],[0]],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[4-1] = scicos_block(gui="SAMPHOLD_m",graphics=scicos_graphics(orig=[233.72156,260.24498],sz=[40,40],flip=true,theta=0,exprs="5",pin=5,pout=33,pein=42,peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("samphold4_m",4),in1=-1,in2=-2,intyp=5,out=-1,out2=-2,outtyp=5,evtin=1,evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="d",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[5-1] = scicos_link(xx=[[221.46044],[225.15013]],yy=[[280.24498],[280.24498]],id="drawlink",thick=[0,0],ct=[1,1],from=[3,1,0],to=[4,1,1]);
        scs_m.objs[6-1] = scicos_link(xx=[[138.19704],[140.34523]],yy=[[273.44465],[273.49157]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[38,1,1]);
        scs_m.objs[7-1] = scicos_block(gui="LOGICAL_OP",graphics=scicos_graphics(orig=[373.24106,309.46812],sz=[60,40],flip=true,theta=0,exprs=[["1"],["5"],["5"],["0"]],pin=36,pout=13,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("logicalop_i8",4),in1=-1,in2=-2,intyp=5,out=-1,out2=-2,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[[5],[0]],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[8-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[199.48466,398.2166],sz=[20,20],flip=true,theta=0,exprs="3",pin=[],pout=9,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=3,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[9-1] = scicos_link(xx=[[219.48466],[222.54128]],yy=[[408.2166],[408.2166]],id="drawlink",thick=[0,0],ct=[1,1],from=[8,1,0],to=[28,1,1]);
        scs_m.objs[10-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[104.31759,276.91165],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=11,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[11-1] = scicos_link(xx=[[124.31759],[144.31759]],yy=[[286.91165],[286.91165]],id="drawlink",thick=[0,0],ct=[1,1],from=[10,1,0],to=[3,1,1]);
        scs_m.objs[12-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[457.40928,320.20131],sz=[20,20],flip=true,theta=0,exprs="2",pin=13,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[13-1] = scicos_link(xx=[[441.81249],[457.40928]],yy=[[329.46812],[330.20131]],id="drawlink",thick=[0,0],ct=[1,1],from=[7,1,0],to=[12,1,1]);
        scs_m.objs[14-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[376.4669,270.83282],sz=[20,20],flip=true,theta=0,exprs="1",pin=37,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1 = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title="Untitled",tol=[0.0001,0.000001,1.000e-10,100001,0,0],tf=100000,context=[],void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m_1.objs[1-1] = scicos_block(gui="ANDLOG_f",graphics=scicos_graphics(orig=[194,133],sz=[60,60],flip=true,theta=0,exprs=[],pin=[],pout=9,pein=[[4],[11]],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="andlog",in1=[],in2=[],intyp=1,out=1,out2=[],outtyp=1,evtin=[[1],[1]],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[2-1] = scicos_block(gui="CLKIN_f",graphics=scicos_graphics(orig=[149,287],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=[],pein=[],peout=4,gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=1,state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="d",firing=-1,dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[3-1] = scicos_block(gui="CLKOUT_f",graphics=scicos_graphics(orig=[450,83],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=[],pein=8,peout=[],gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="output",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[4-1] = scicos_link(xx=[[169],[214],[214]],yy=[[297],[297],[198.71]],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,1],to=[1,1]);
        scs_m_1.objs[5-1] = scicos_block(gui="CLKIN_f",graphics=scicos_graphics(orig=[141,330],sz=[20,20],flip=true,theta=0,exprs="2",pin=[],pout=[],pein=[],peout=6,gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=1,state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="d",firing=-1,dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[6-1] = scicos_link(xx=[[161],[234],[234]],yy=[[340],[340],[275.78]],id="drawlink",thick=[0,0],ct=[5,-1],from=[5,1],to=[10,1]);
        scs_m_1.objs[7-1] = scicos_block(gui="IFTHEL_f",graphics=scicos_graphics(orig=[331,137],sz=[60,60],flip=true,theta=0,exprs=[["1"],["1"]],pin=9,pout=[],pein=12,peout=[[8],[0]],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim=list("ifthel",-1),in1=1,in2=1,intyp=-1,out=[],out2=[],outtyp=1,evtin=1,evtout=[[1],[1]],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="l",firing=[-1,-1],dep_ut=[true,false],label="",nzcross=1,nmode=1,equations=list()),doc=list());
        scs_m_1.objs[8-1] = scicos_link(xx=[[351],[351],[450]],yy=[[131.29],[93],[93]],id="drawlink",thick=[0,0],ct=[5,-1],from=[7,1],to=[3,1]);
        scs_m_1.objs[9-1] = scicos_link(xx=[[262.57],[322.43]],yy=[[163],[167]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1],to=[7,1]);
        scs_m_1.objs[10-1] = scicos_block(gui="CLKSPLIT_f",graphics=scicos_graphics(orig=[[234],[275.78348]],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=[],pout=[],pein=6,peout=[[11],[12]],gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="split",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=[[1],[1]],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="d",firing=[false,false,false],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[11-1] = scicos_link(xx=[[234],[234]],yy=[[275.78],[198.71]],id="drawlink",thick=[0,0],ct=[5,-1],from=[10,1],to=[1,2]);
        scs_m_1.objs[12-1] = scicos_link(xx=[[234],[361],[361]],yy=[[275.78],[275.78],[202.71]],id="drawlink",thick=[0,0],ct=[5,-1],from=[10,2],to=[7,1]);
        scs_m.objs[15-1] = scicos_block(gui="ANDBLK",graphics=scicos_graphics(orig=[233.73039,318.74407],sz=[40,40],flip=true,theta=0,exprs=[],pin=[],pout=[],pein=[[19],[16]],peout=17,gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="csuper",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[[1],[1]],evtout=1,state=[],dstate=[],odstate=list(),rpar=scs_m_1,ipar=[],opar=list(),blocktype="h",firing=false,dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[16-1] = scicos_link(xx=[[259.98293],[260.39705]],yy=[[372.50232],[364.45835]],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,1,0],to=[15,2,1]);
        scs_m.objs[17-1] = scicos_link(xx=[[253.73039],[253.72572]],yy=[[313.02978],[309.29537]],id="drawlink",thick=[0,0],ct=[5,-1],from=[15,1,0],to=[41,1,1]);
        scs_m_1 = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["EDGE_TRIGGER","./"],tol=[[0.0001],[0.000001],[1.000e-10],[100001],[0],[0],[0]],tf=30,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m_1.objs[1-1] = scicos_block(gui="EDGETRIGGER",graphics=scicos_graphics(orig=[288.58631,257.1131],sz=[60,40],flip=true,theta=0,exprs="1",pin=5,pout=3,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("edgetrig",4),in1=1,in2=[],intyp=1,out=1,out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=0,odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=1,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[2-1] = scicos_block(gui="IFTHEL_f",graphics=scicos_graphics(orig=[388.28869,247.1131],sz=[60,60],flip=true,theta=0,exprs=[["0"],["0"]],pin=3,pout=[],pein=[],peout=[[7],[0]],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim=list("ifthel",-1),in1=1,in2=[],intyp=1,out=[],out2=1,outtyp=[],evtin=[],evtout=[[1],[1]],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="l",firing=[-1,-1],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[3-1] = scicos_link(xx=[[357.15774],[362.99107],[379.71726]],yy=[[277.1131],[277.1131],[277.1131]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[2,1,1]);
        scs_m_1.objs[4-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[240.01488,267.1131],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=5,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=-1,out=-1,out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[5-1] = scicos_link(xx=[[260.01488],[280.01488]],yy=[[277.1131],[277.1131]],id="drawlink",thick=[0,0],ct=[1,1],from=[4,1,0],to=[1,1,1]);
        scs_m_1.objs[6-1] = scicos_block(gui="CLKOUTV_f",graphics=scicos_graphics(orig=[398.28869,181.39881],sz=[20,30],flip=true,theta=0,exprs="1",pin=[],pout=[],pein=7,peout=[],gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="output",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[7-1] = scicos_link(xx=[[408.28869],[408.28869]],yy=[[241.39881],[211.39881]],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,1,0],to=[6,1,1]);
        scs_m.objs[18-1] = scicos_block(gui="EDGE_TRIGGER",graphics=scicos_graphics(orig=[133.90637,385.342],sz=[60,40],flip=true,theta=0,exprs=[],pin=26,pout=[],pein=[],peout=19,gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="csuper",in1=-1,in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=1,state=[],dstate=[],odstate=list(),rpar=scs_m_1,ipar=[],opar=list(),blocktype="h",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[19-1] = scicos_link(xx=[[163.90637],[163.90637],[247.06372]],yy=[[379.62771],[364.45835],[364.45835]],id="drawlink",thick=[0,0],ct=[5,-1],from=[18,1,0],to=[15,1,1]);
        scs_m.objs[20-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[79.594811,395.47647],sz=[20,20],flip=true,theta=0,exprs="2",pin=[],pout=23,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1 = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["Extract_Activation","./"],tol=[[0.0001],[0.000001],[1.000e-10],[100001],[0],[0],[0]],tf=30,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m_1.objs[1-1] = scicos_block(gui="IFTHEL_f",graphics=scicos_graphics(orig=[150.65045,143.82208],sz=[60,60],flip=true,theta=0,exprs=[["0"],["0"]],pin=6,pout=[],pein=[],peout=[[3],[4]],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim=list("ifthel",-1),in1=1,in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=[[1],[1]],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="l",firing=[-1,-1],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[2-1] = scicos_block(gui="CLKSOMV_f",graphics=scicos_graphics(orig=[169.82143,96.146231],sz=[16.666667,16.666667],flip=true,theta=0,exprs=[],pin=[],pout=[],pein=[[3],[4],[0]],peout=8,gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="sum",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[[1],[1],[1]],evtout=1,state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="d",firing=-1,dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[3-1] = scicos_link(xx=[[170.65045],[170.65045],[150.04302],[150.04302],[169.82143]],yy=[[138.10779],[128.235],[128.235],[104.47956],[104.47956]],id="drawlink",thick=[0,0],ct=[5,-1],from=[1,1,0],to=[2,1,1]);
        scs_m_1.objs[4-1] = scicos_link(xx=[[190.65045],[190.65045],[178.15476]],yy=[[138.10779],[111.55729],[112.8129]],id="drawlink",thick=[0,0],ct=[5,-1],from=[1,2,0],to=[2,2,1]);
        scs_m_1.objs[5-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[102.07902,163.82208],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=6,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=-1,out=-1,out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[6-1] = scicos_link(xx=[[122.07902],[142.07902]],yy=[[173.82208],[173.82208]],id="drawlink",thick=[0,0],ct=[1,1],from=[5,1,0],to=[1,1,1]);
        scs_m_1.objs[7-1] = scicos_block(gui="CLKOUTV_f",graphics=scicos_graphics(orig=[168.15476,38.527183],sz=[20,30],flip=true,theta=0,exprs="1",pin=[],pout=[],pein=8,peout=[],gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="output",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[8-1] = scicos_link(xx=[[178.15476],[178.15476]],yy=[[98.527183],[68.527183]],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,1,0],to=[7,1,1]);
        scs_m.objs[21-1] = scicos_block(gui="Extract_Activation",graphics=scicos_graphics(orig=[239.82193,456.57677],sz=[60,40],flip=true,theta=0,exprs=[],pin=31,pout=[],pein=[],peout=22,gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="csuper",in1=-1,in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=1,state=[],dstate=[],odstate=list(),rpar=scs_m_1,ipar=[],opar=list(),blocktype="h",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[22-1] = scicos_link(xx=[[269.82193],[269.98293]],yy=[[450.86248],[443.93089]],id="drawlink",thick=[0,0],ct=[5,-1],from=[21,1,0],to=[2,1,1]);
        scs_m.objs[23-1] = scicos_link(xx=[[99.594811],[110.25582]],yy=[[405.47647],[405.42077]],id="drawlink",thick=[0,0],ct=[1,1],from=[20,1,0],to=[25,1,1]);
        scs_m.objs[24-1] = scicos_block(gui="SUM_f",graphics=scicos_graphics(orig=[200.5252,469.13173],sz=[16.666667,16.666667],flip=true,theta=0,exprs=[],pin=[[27],[0],[30]],pout=31,pein=[],peout=[],gr_i=[],id="",in_implicit=[["E"],["E"],["E"]],out_implicit="E"),model=scicos_model(sim=list("plusblk",2),in1=[[-1],[-1],[-1]],in2=[],intyp=1,out=-1,out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[25-1] = scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[[110.25582],[405.42077]],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=23,pout=[[26],[27]],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[["E"],["E"],["E"]]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[[-1],[-1],[-1]],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[26-1] = scicos_link(xx=[[110.25582],[114.33667],[125.33494]],yy=[[405.42077],[405.39945],[405.342]],id="drawlink",thick=[0,0],ct=[1,1],from=[25,1,0],to=[18,1,1]);
        scs_m.objs[27-1] = scicos_link(xx=[[110.25582],[110.25582],[208.85853]],yy=[[405.42077],[469.13173],[469.13173]],id="drawlink",thick=[0,0],ct=[1,1],from=[25,2,0],to=[24,1,1]);
        scs_m.objs[28-1] = scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[[222.54128],[408.2166]],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=9,pout=[[29],[30]],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[["E"],["E"],["E"]]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[[-1],[-1],[-1]],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[29-1] = scicos_link(xx=[[222.54128],[231.4115]],yy=[[408.2166],[408.2166]],id="drawlink",thick=[0,0],ct=[1,1],from=[28,1,0],to=[2,1,1]);
        scs_m.objs[30-1] = scicos_link(xx=[[222.54128],[222.54128],[208.85853],[208.85853]],yy=[[408.2166],[453.0015],[453.0015],[485.7984]],id="drawlink",thick=[0,0],ct=[1,1],from=[28,2,0],to=[24,3,1]);
        scs_m.objs[31-1] = scicos_link(xx=[[219.57282],[231.2505]],yy=[[477.46506],[476.57677]],id="drawlink",thick=[0,0],ct=[1,1],from=[24,1,0],to=[21,1,1]);
        scs_m.objs[32-1] = scicos_block(gui="SELECT_m",graphics=scicos_graphics(orig=[298.86371,253.57321],sz=[40,40],flip=true,theta=0,exprs=[["5"],["2"],["1"]],pin=[[33],[40]],pout=34,pein=[[43],[44]],peout=[],gr_i=[],id="",in_implicit=[["E"],["E"]],out_implicit="E"),model=scicos_model(sim=list("selector_m",4),in1=[[-1],[-1]],in2=[[-2],[-2]],intyp=[[5],[5]],out=-1,out2=-2,outtyp=5,evtin=[[1],[1]],evtout=[],state=[],dstate=1,odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[33-1] = scicos_link(xx=[[282.29299],[290.29229]],yy=[[280.24498],[280.23987]],id="drawlink",thick=[0,0],ct=[1,1],from=[4,1,0],to=[32,1,1]);
        scs_m.objs[34-1] = scicos_link(xx=[[347.43514],[357.57328],[357.57328]],yy=[[273.57321],[273.57321],[280.83282]],id="drawlink",thick=[0,0],ct=[1,1],from=[32,1,0],to=[35,1,1]);
        scs_m.objs[35-1] = scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[357.57328,280.83282],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=34,pout=[[36],[37]],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[["E"],["E"],["E"]]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[[-1],[-1],[-1]],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[36-1] = scicos_link(xx=[[357.57328],[357.57328],[364.66964]],yy=[[280.83282],[329.46812],[329.46812]],id="drawlink",thick=[0,0],ct=[1,1],from=[35,1,0],to=[7,1,1]);
        scs_m.objs[37-1] = scicos_link(xx=[[357.57328],[376.4669]],yy=[[280.83282],[280.83282]],id="drawlink",thick=[0,0],ct=[1,1],from=[35,2,0],to=[14,1,1]);
        scs_m.objs[38-1] = scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[[140.34523],[273.49157]],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=6,pout=[[39],[40]],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[["E"],["E"],["E"]]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[[-1],[-1],[-1]],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[39-1] = scicos_link(xx=[[140.34523],[144.31759]],yy=[[273.49157],[273.57832]],id="drawlink",thick=[0,0],ct=[1,1],from=[38,1,0],to=[3,2,1]);
        scs_m.objs[40-1] = scicos_link(xx=[[140.34523],[140.34523],[290.29229],[290.29229]],yy=[[273.49157],[247.70767],[247.70767],[266.90654]],id="drawlink",thick=[0,0],ct=[1,1],from=[38,2,0],to=[32,2,1]);
        scs_m.objs[41-1] = scicos_block(gui="CLKSPLIT_f",graphics=scicos_graphics(orig=[[253.72572],[309.29537]],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=[],pout=[],pein=17,peout=[[42],[43]],gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="split",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=[[1],[1]],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="d",firing=[false,false,false],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[42-1] = scicos_link(xx=[[253.72572],[253.72156]],yy=[[309.29537],[305.95927]],id="drawlink",thick=[0,0],ct=[5,-1],from=[41,1,0],to=[4,1,1]);
        scs_m.objs[43-1] = scicos_link(xx=[[253.72572],[312.19705],[312.19705]],yy=[[309.29537],[309.29537],[299.28749]],id="drawlink",thick=[0,0],ct=[5,-1],from=[41,2,0],to=[32,1,1]);
        scs_m.objs[44-1] = scicos_link(xx=[[279.98293],[279.98293],[325.53038],[325.53038]],yy=[[372.50232],[315.89455],[315.89455],[299.28749]],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,2,0],to=[32,2,1]);
        model = scicos_model();
        model.sim = "csuper";
        model.in1 = [[1],[1],[1]];
        model.in2 = [[1],[1],[1]];
        model.out = [[1],[1]];
        model.out2 = [[1],[1]];
        model.intyp = [5,1,1];
        model.outtyp = [5,5];
        model.blocktype = "h";
        model.firing = false;
        model.dep_ut = [true,false];
        model.rpar = scs_m;
        gr_i = [];
        x = standard_define([2,3],model,[],gr_i);
    }
    DFLIPFLOP.prototype.details = function DFLIPFLOP() {
    }
    DFLIPFLOP.prototype.get = function DFLIPFLOP() {
    }
    DFLIPFLOP.prototype.set = function DFLIPFLOP() {
        x = arg1;
    }
}
/* autogenerated from "macros/IntegerOp/DLATCH.sci" */
function DLATCH() {
    DLATCH.prototype.define = function DLATCH() {
        scs_m = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["DLATCH"],tol=[0.0001,0.000001,1.000e-10,100001,0,0],tf=100000,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m.objs[1-1] = scicos_block(gui="CONST_m",graphics=scicos_graphics(orig=[109.62561,263.44465],sz=[[20],[20]],flip=true,theta=0,exprs="int8(0)",pin=[],pout=7,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim=list("cstblk4_m",4),in1=[],in2=[],intyp=1,out=1,out2=1,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(int8(0)),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[2-1] = scicos_block(gui="IFTHEL_f",graphics=scicos_graphics(orig=[233.37693,320.30536],sz=[60,60],flip=true,theta=0,exprs=[["0"],["1"]],pin=13,pout=[],pein=[],peout=[[6],[0]],gr_i=list([["txt=[\'If in>0\';\' \';\' then    else\'];"],["xstringb(orig(1),orig(2),txt,sz(1),sz(2),\'fill\');"]],8),id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim=list("ifthel",-1),in1=1,in2=1,intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[[1],[1]],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="l",firing=[-1,-1],dep_ut=[true,false],label="",nzcross=1,nmode=1,equations=list()),doc=list());
        scs_m.objs[3-1] = scicos_block(gui="LOGICAL_OP",graphics=scicos_graphics(orig=[152.88902,260.24498],sz=[60,40],flip=true,theta=0,exprs=[["2"],["1"],["5"],["0"]],pin=[[15],[7]],pout=5,pein=[],peout=[],gr_i=list("xstringb(orig(1),orig(2),[\'Logical Op \';OPER],sz(1),sz(2),\'fill\');",8),id="",in_implicit=[["E"],["E"]],out_implicit="E"),model=scicos_model(sim=list("logicalop_i8",4),in1=[[-1],[-1]],in2=[[-2],[-2]],intyp=[[5],[5]],out=-1,out2=-2,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[[1],[0]],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[4-1] = scicos_block(gui="SAMPHOLD_m",graphics=scicos_graphics(orig=[233.72156,260.24498],sz=[40,40],flip=true,theta=0,exprs="5",pin=5,pout=9,pein=6,peout=[],gr_i=list("xstringb(orig(1),orig(2),\'S/H\',sz(1),sz(2),\'fill\')",8),id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("samphold4_m",4),in1=-1,in2=-2,intyp=5,out=-1,out2=-2,outtyp=5,evtin=1,evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="d",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[5-1] = scicos_link(xx=[[221.46044],[225.15013]],yy=[[280.24498],[280.24498]],id="drawlink",thick=[0,0],ct=[1,1],from=[3,1,0],to=[4,1,1]);
        scs_m.objs[6-1] = scicos_link(xx=[[253.37693],[253.72156]],yy=[[314.59108],[305.95927]],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,1,0],to=[4,1,1]);
        scs_m.objs[7-1] = scicos_link(xx=[[138.19704],[144.31759]],yy=[[273.44465],[273.57832]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[3,2,1]);
        scs_m.objs[8-1] = scicos_block(gui="LOGICAL_OP",graphics=scicos_graphics(orig=[317.46698,309.46812],sz=[60,40],flip=true,theta=0,exprs=[["1"],["5"],["5"],["0"]],pin=11,pout=17,pein=[],peout=[],gr_i=list("xstringb(orig(1),orig(2),[\'Logical Op \';OPER],sz(1),sz(2),\'fill\');",8),id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("logicalop_i8",4),in1=-1,in2=-2,intyp=5,out=-1,out2=-2,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[[5],[0]],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[9-1] = scicos_link(xx=[[282.29299],[305.09603],[305.09603]],yy=[[280.24498],[280.52797],[280.83282]],id="drawlink",thick=[0,0],ct=[1,1],from=[4,1,0],to=[10,1,1]);
        scs_m.objs[10-1] = scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[305.09603,280.83282],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=9,pout=[[11],[19]],pein=[],peout=[],gr_i=list([],8),id="",in_implicit="E",out_implicit=[["E"],["E"],["E"]]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[[-1],[-1],[-1]],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[11-1] = scicos_link(xx=[[305.09603],[305.09603],[308.89555]],yy=[[280.83282],[329.46812],[329.46812]],id="drawlink",thick=[0,0],ct=[1,1],from=[10,1,0],to=[8,1,1]);
        scs_m.objs[12-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[184.8055,340.30536],sz=[20,20],flip=true,theta=0,exprs="2",pin=[],pout=13,pein=[],peout=[],gr_i=list(" ",8),id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[13-1] = scicos_link(xx=[[204.8055],[224.8055]],yy=[[350.30536],[350.30536]],id="drawlink",thick=[0,0],ct=[1,1],from=[12,1,0],to=[2,1,1]);
        scs_m.objs[14-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[104.31759,276.91165],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=15,pein=[],peout=[],gr_i=list(" ",8),id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[15-1] = scicos_link(xx=[[124.31759],[144.31759]],yy=[[286.91165],[286.91165]],id="drawlink",thick=[0,0],ct=[1,1],from=[14,1,0],to=[3,1,1]);
        scs_m.objs[16-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[406.03841,319.46812],sz=[20,20],flip=true,theta=0,exprs="2",pin=17,pout=[],pein=[],peout=[],gr_i=list(" ",8),id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[17-1] = scicos_link(xx=[[386.03841],[406.03841]],yy=[[329.46812],[329.46812]],id="drawlink",thick=[0,0],ct=[1,1],from=[8,1,0],to=[16,1,1]);
        scs_m.objs[18-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[325.09603,270.83282],sz=[20,20],flip=true,theta=0,exprs="1",pin=19,pout=[],pein=[],peout=[],gr_i=list(" ",8),id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[19-1] = scicos_link(xx=[[305.09603],[325.09603]],yy=[[280.83282],[280.83282]],id="drawlink",thick=[0,0],ct=[1,1],from=[10,2,0],to=[18,1,1]);
        model = scicos_model();
        model.sim = "csuper";
        model.in1 = [[1],[1]];
        model.in2 = [[1],[1]];
        model.out = [[1],[1]];
        model.out2 = [[1],[1]];
        model.intyp = [5,-1];
        model.outtyp = [5,5];
        model.blocktype = "h";
        model.firing = false;
        model.dep_ut = [true,false];
        model.rpar = scs_m;
        gr_i = [];
        x = standard_define([2,3],model,[],gr_i);
    }
    DLATCH.prototype.details = function DLATCH() {
    }
    DLATCH.prototype.get = function DLATCH() {
    }
    DLATCH.prototype.set = function DLATCH() {
        x = arg1;
    }
}
/* autogenerated from "macros/IntegerOp/EXTRACTBITS.sci" */
function EXTRACTBITS() {
    EXTRACTBITS.prototype.define = function EXTRACTBITS() {
        numb = [];
        model = scicos_model();
        model.sim = list("extract_bit_32_UH0",4);
        model.in1 = 1;
        model.in2 = 1;
        model.out = 1;
        model.out2 = 1;
        model.intyp = 3;
        model.outtyp = 3;
        model.ipar = [0,numb];
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[sci2exp(3)],[sci2exp(1)],[sci2exp(0)],[sci2exp(0)]];
        gr_i = [];
        x = standard_define([4,2],model,exprs,gr_i);
    }
    EXTRACTBITS.prototype.details = function EXTRACTBITS() {
    }
    EXTRACTBITS.prototype.get = function EXTRACTBITS() {
    }
    EXTRACTBITS.prototype.set = function EXTRACTBITS() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,Datatype,rule,bit,scal,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"EXTRACTBITS")],[" "],[gettext("Bits Extraction")],[" "],[gettext("&nbsp;- Bits to Extract:")],[gettext("&nbsp;&nbsp;&nbsp;&nbsp;1 Upper Half")],[gettext("&nbsp;&nbsp;&nbsp;&nbsp;2 Lower Half")],[gettext("&nbsp;&nbsp;&nbsp;&nbsp;3 Range from MSB")],[gettext("&nbsp;&nbsp;&nbsp;&nbsp;4 Range to LSB")],[gettext("&nbsp;&nbsp;&nbsp;&nbsp;5 Range of Bits")],[gettext("&nbsp;- Number of Bits or Index of bit : Index 0 is LSB")],[gettext("&nbsp;&nbsp;&nbsp;&nbsp;If \'Bits to Extract\' is set to \'Range of bits\': [Start, End]")],[" "]],[[msprintf(gettext("Data Type %s"),"(3:int32, 4:int16, 5:int8, ...)")],[gettext("Bits to extract")],[gettext("Number of Bits or Index of Bit")],[gettext("Treat Bit Field as an Integer (0:No, 1:Yes)")]],list("vec",1,"vec",1,"vec",-1,"vec",1),exprs);
        if (!ok) {
break;
}
        bitstr = strcat(string(bit.slice())," ");
        if ((rule<1)||(rule>5)) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Bits to Extract"),rule),msprintf(gettext("Must be in the interval %s."),"[1, 5]"));
        ok = false;
        } else if (scal<0||scal>1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Treat Bit Field as an Integer"),scal),msprintf(gettext("Must be in the interval %s."),"[0, 1]"));
        ok = false;
        } else {
        in1 = [model.in1,model.in2];
        bit = int(bit);
        rule = int(rule);
        if ((rule==3)||(rule==4)) {
        if ((size(bit,"*")!=1)) {
block_parameter_error(msprintf(gettext("Wrong size for \'%s\' parameter: %s."),gettext("Number of Bits or Index of Bit"),bitstr),gettext("Must be a single value."));
        ok = false;
        } else {
        numb = bit;
}
        } else if ((rule==5)) {
        if ((size(bit,"*")!=2)) {
block_parameter_error(msprintf(gettext("Wrong size for \'%s\' parameter: %s."),gettext("Number of Bits or Index of Bit"),bitstr),gettext("Must have this form: [Start, End]."));
        ok = false;
        } else if (bit[1-1]>bit[2-1]) {
block_parameter_error(msprintf(gettext("Wrong values for \'%s\' parameter: %s."),gettext("Number of Bits or Index of Bit"),bitstr),msprintf(gettext("\'Start\' must be less than \'End\'.")));
        ok = false;
        } else {
        numb = bit[2-1]-bit[1-1];
}
        } else {
        bit = 0;
        numb = [];
}
}
        if (ok) {
        if ((Datatype==3||Datatype==6)) {
        if (or(bit.slice()>31)||or(bit.slice()<0)) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %s."),gettext("Number of Bits or Index of Bit"),bitstr),msprintf(gettext("Indexes must be in the interval %s."),"[0, 31]"));
        ok = false;
}
        switch (rule) {
        case 1:
        switch (scal) {
        case 0:
        model.sim = list("extract_bit_32_UH0",4);
        case 1:
        switch (Datatype) {
        case 3:
        model.sim = list("extract_bit_32_UH1",4);
        case 6:
        model.sim = list("extract_bit_u32_UH1",4);
}
}
        case 2:
        model.sim = list("extract_bit_32_LH",4);
        case 3:
        switch (scal) {
        case 0:
        model.sim = list("extract_bit_32_MSB0",4);
        case 1:
        switch (Datatype) {
        case 3:
        model.sim = list("extract_bit_32_MSB1",4);
        case 6:
        model.sim = list("extract_bit_u32_MSB1",4);
}
}
        case 4:
        model.sim = list("extract_bit_32_LSB",4);
        case 5:
        switch (scal) {
        case 0:
        model.sim = list("extract_bit_32_RB0",4);
        case 1:
        switch (Datatype) {
        case 3:
        model.sim = list("extract_bit_32_RB1",4);
        case 6:
        model.sim = list("extract_bit_u32_RB1",4);
}
}
}
        } else if ((Datatype==4||Datatype==7)) {
        if (or(bit.slice()>15)||or(bit.slice()<0)) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %s."),gettext("Number of Bits or Index of Bit"),bitstr),msprintf(gettext("Indexes must be in the interval %s."),"[0, 15]"));
        ok = false;
}
        switch (rule) {
        case 1:
        switch (scal) {
        case 0:
        model.sim = list("extract_bit_16_UH0",4);
        case 1:
        switch (Datatype) {
        case 4:
        model.sim = list("extract_bit_16_UH1",4);
        case 7:
        model.sim = list("extract_bit_u16_UH1",4);
}
}
        case 2:
        model.sim = list("extract_bit_16_LH",4);
        case 3:
        switch (scal) {
        case 0:
        model.sim = list("extract_bit_16_MSB0",4);
        case 1:
        switch (Datatype) {
        case 4:
        model.sim = list("extract_bit_16_MSB1",4);
        case 7:
        model.sim = list("extract_bit_u16_MSB1",4);
}
}
        case 4:
        model.sim = list("extract_bit_16_LSB",4);
        case 5:
        switch (scal) {
        case 0:
        model.sim = list("extract_bit_16_RB0",4);
        case 1:
        switch (Datatype) {
        case 4:
        model.sim = list("extract_bit_16_RB1",4);
        case 7:
        model.sim = list("extract_bit_u16_RB1",4);
}
}
}
        } else if ((Datatype==5||Datatype==8)) {
        if (or(bit.slice()>7)||or(bit.slice()<0)) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %s."),gettext("Number of Bits or Index of Bit"),bitstr),msprintf(gettext("Indexes must be in the interval %s."),"[0, 7]"));
        ok = false;
}
        switch (rule) {
        case 1:
        switch (scal) {
        case 0:
        model.sim = list("extract_bit_8_UH0",4);
        case 1:
        switch (Datatype) {
        case 5:
        model.sim = list("extract_bit_8_UH1",4);
        case 8:
        model.sim = list("extract_bit_u8_UH1",4);
}
}
        case 2:
        model.sim = list("extract_bit_8_LH",4);
        case 3:
        switch (scal) {
        case 0:
        model.sim = list("extract_bit_8_MSB0",4);
        case 1:
        switch (Datatype) {
        case 5:
        model.sim = list("extract_bit_8_MSB1",4);
        case 8:
        model.sim = list("extract_bit_u8_MSB1",4);
}
}
        case 4:
        model.sim = list("extract_bit_8_LSB",4);
        case 5:
        switch (scal) {
        case 0:
        model.sim = list("extract_bit_8_RB0",4);
        case 1:
        switch (Datatype) {
        case 5:
        model.sim = list("extract_bit_8_RB1",4);
        case 8:
        model.sim = list("extract_bit_u8_RB1",4);
}
}
}
        } else {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Data Type"),Datatype),msprintf(gettext("Must be in the interval %s."),"[3, 8]"));
        ok = false;
}
}
        if (ok) {
        it = Datatype;
        ot = Datatype;
        out = [1,1];
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
        if (ok) {
        graphics.exprs = exprs;
        model.ipar = [[int(bit.slice())],[int(numb.slice())]];
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/IntegerOp/INTMUL.sci" */
function INTMUL() {
    INTMUL.prototype.define = function INTMUL() {
        sgn = 0;
        model = scicos_model();
        model.sim = list("matmul_i32",4);
        model.in1 = [[-1],[-2]];
        model.out = -1;
        model.in2 = [[-2],[-3]];
        model.out2 = -3;
        model.intyp = [3,3];
        model.outtyp = 3;
        model.rpar = [];
        model.ipar = sgn;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[sci2exp(3)],[sci2exp(0)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    INTMUL.prototype.details = function INTMUL() {
    }
    INTMUL.prototype.get = function INTMUL() {
    }
    INTMUL.prototype.set = function INTMUL() {
        x = arg1;
        graphics = arg1.graphics;
        model = arg1.model;
        exprs = graphics.exprs;
        while (true) {
        [ok,Datatype,np,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"INTMUL")],[" "],[gettext("Integer matrix multiplication")],[" "]],[[msprintf(gettext("Data Type %s"),"(3:int32, 4:int16, 5:int8, ...)")],[gettext("Do on Overflow (0:Nothing, 1:Saturate, 2:Error)")]],list("vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        it = Datatype*ones(1,2);
        ot = Datatype;
        if ((np!=0&&np!=1&&np!=2)) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Do on Overflow"),np),msprintf(gettext("Must be in the interval %s."),"[0, 2]"));
        ok = false;
        } else if (Datatype==3) {
        if (np==0) {
        model.sim = list("matmul_i32n",4);
        } else if (np==1) {
        model.sim = list("matmul_i32s",4);
        } else {
        model.sim = list("matmul_i32e",4);
}
        } else if (Datatype==4) {
        if (np==0) {
        model.sim = list("matmul_i16n",4);
        } else if (np==1) {
        model.sim = list("matmul_i16s",4);
        } else {
        model.sim = list("matmul_i16e",4);
}
        } else if (Datatype==5) {
        if (np==0) {
        model.sim = list("matmul_i8n",4);
        } else if (np==1) {
        model.sim = list("matmul_i8s",4);
        } else {
        model.sim = list("matmul_i8e",4);
}
        } else if (Datatype==6) {
        if (np==0) {
        model.sim = list("matmul_ui32n",4);
        } else if (np==1) {
        model.sim = list("matmul_ui32s",4);
        } else {
        model.sim = list("matmul_ui32e",4);
}
        } else if (Datatype==7) {
        if (np==0) {
        model.sim = list("matmul_ui16n",4);
        } else if (np==1) {
        model.sim = list("matmul_ui16s",4);
        } else {
        model.sim = list("matmul_ui16e",4);
}
        } else if (Datatype==8) {
        if (np==0) {
        model.sim = list("matmul_ui8n",4);
        } else if (np==1) {
        model.sim = list("matmul_ui8s",4);
        } else {
        model.sim = list("matmul_ui8e",4);
}
        } else {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Data Type"),ot),msprintf(gettext("Must be in the interval %s."),"[3, 8]"));
        ok = false;
}
        in1 = [model.in1,model.in2];
        out = [model.out,model.out2];
        if (ok) {
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
        if (ok) {
        model.ipar = np;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/IntegerOp/JKFLIPFLOP.sci" */
function JKFLIPFLOP() {
    JKFLIPFLOP.prototype.define = function JKFLIPFLOP() {
        scs_m = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["JKFLIPFLOP"],tol=[[0.0001],[0.000001],[1.000e-10],[100001],[0],[0],[0]],tf=60,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m.objs[1-1] = scicos_block(gui="DOLLAR_m",graphics=scicos_graphics(orig=[299.96961,261.584],sz=[40,40],flip=false,theta=0,exprs=[["int8(0)"],["1"]],pin=7,pout=5,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("dollar4_m",4),in1=1,in2=1,intyp=5,out=1,out2=1,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(int8(0)),rpar=[],ipar=[],opar=list(),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1 = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["EDGE_TRIGGER","./"],tol=[[0.0001],[0.000001],[1.000e-10],[100001],[0],[0],[0]],tf=30,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m_1.objs[1-1] = scicos_block(gui="EDGETRIGGER",graphics=scicos_graphics(orig=[288.58631,257.1131],sz=[60,40],flip=true,theta=0,exprs="-1",pin=5,pout=3,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("edgetrig",4),in1=1,in2=[],intyp=1,out=1,out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=0,odstate=list(),rpar=[],ipar=-1,opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=1,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[2-1] = scicos_block(gui="IFTHEL_f",graphics=scicos_graphics(orig=[388.28869,247.1131],sz=[60,60],flip=true,theta=0,exprs=[["0"],["0"]],pin=3,pout=[],pein=[],peout=[[7],[0]],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim=list("ifthel",-1),in1=1,in2=[],intyp=1,out=[],out2=1,outtyp=[],evtin=[],evtout=[[1],[1]],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="l",firing=[-1,-1],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[3-1] = scicos_link(xx=[[357.15774],[362.99107],[379.71726]],yy=[[277.1131],[277.1131],[277.1131]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[2,1,1]);
        scs_m_1.objs[4-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[240.01488,267.1131],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=5,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[5-1] = scicos_link(xx=[[260.01488],[280.01488]],yy=[[277.1131],[277.1131]],id="drawlink",thick=[0,0],ct=[1,1],from=[4,1,0],to=[1,1,1]);
        scs_m_1.objs[6-1] = scicos_block(gui="CLKOUTV_f",graphics=scicos_graphics(orig=[398.28869,181.39881],sz=[20,30],flip=true,theta=0,exprs="1",pin=[],pout=[],pein=7,peout=[],gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="output",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[7-1] = scicos_link(xx=[[408.28869],[408.28869]],yy=[[241.39881],[211.39881]],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,1,0],to=[6,1,1]);
        scs_m.objs[2-1] = scicos_block(gui="EDGE_TRIGGER",graphics=scicos_graphics(orig=[292.52452,323.54888],sz=[60,40],flip=true,theta=0,exprs=[],pin=14,pout=[],pein=[],peout=8,gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="csuper",in1=-1,in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=1,state=[],dstate=[],odstate=list(),rpar=scs_m_1,ipar=[],opar=list(),blocktype="h",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[3-1] = scicos_block(gui="LOGIC",graphics=scicos_graphics(orig=[302.79613,202.52782],sz=[40,40],flip=true,theta=0,exprs=[["[0;1;1;1;0;0;1;0]"],["0"]],pin=[[5],[16],[18]],pout=4,pein=8,peout=[],gr_i=[],id="",in_implicit=[["E"],["E"],["E"]],out_implicit="E"),model=scicos_model(sim=list("logic",4),in1=[[1],[1],[1]],in2=[[1],[1],[1]],intyp=[[5],[5],[5]],out=1,out2=1,outtyp=5,evtin=1,evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(int8([[0],[1],[1],[1],[0],[0],[1],[0]])),blocktype="c",firing=false,dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[4-1] = scicos_link(xx=[[351.36756],[368.82793],[368.82793]],yy=[[222.52782],[222.52782],[223.06473]],id="drawlink",thick=[0,0],ct=[1,1],from=[3,1,0],to=[10,1,1]);
        scs_m.objs[5-1] = scicos_link(xx=[[291.39818],[274.18235],[274.18235],[294.2247]],yy=[[281.584],[281.584],[232.52782],[232.52782]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[3,1,1]);
        scs_m.objs[6-1] = scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[368.82793,243.45067],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=11,pout=[[7],[20]],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[["E"],["E"],["E"]]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[[-1],[-1],[-1]],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[7-1] = scicos_link(xx=[[368.82793],[368.82793],[345.68389]],yy=[[243.45067],[281.584],[281.584]],id="drawlink",thick=[0,0],ct=[1,1],from=[6,1,0],to=[1,1,1]);
        scs_m.objs[8-1] = scicos_link(xx=[[322.52452],[374.69743],[374.69743],[322.79613]],yy=[[317.8346],[317.8346],[248.24211],[248.24211]],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,1,0],to=[3,1,1]);
        scs_m.objs[9-1] = scicos_block(gui="LOGICAL_OP",graphics=scicos_graphics(orig=[377.63217,159.25363],sz=[60,40],flip=true,theta=0,exprs=[["1"],["5"],["5"],["0"]],pin=12,pout=22,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("logicalop_i8",4),in1=-1,in2=-2,intyp=5,out=-1,out2=-2,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[[5],[0]],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[10-1] = scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[[368.82793],[223.06473]],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=4,pout=[[11],[12]],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[["E"],["E"],["E"]]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[[-1],[-1],[-1]],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[11-1] = scicos_link(xx=[[368.82793],[368.82793]],yy=[[223.06473],[243.45067]],id="drawlink",thick=[0,0],ct=[1,1],from=[10,1,0],to=[6,1,1]);
        scs_m.objs[12-1] = scicos_link(xx=[[368.82793],[368.82793],[369.06074]],yy=[[223.06473],[177.7867],[179.25363]],id="drawlink",thick=[0,0],ct=[1,1],from=[10,2,0],to=[9,1,1]);
        scs_m.objs[13-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[243.95309,333.54888],sz=[20,20],flip=true,theta=0,exprs="2",pin=[],pout=14,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[14-1] = scicos_link(xx=[[263.95309],[283.95309]],yy=[[343.54888],[343.54888]],id="drawlink",thick=[0,0],ct=[1,1],from=[13,1,0],to=[2,1,1]);
        scs_m.objs[15-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[254.2247,212.52782],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=16,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[16-1] = scicos_link(xx=[[274.2247],[294.2247]],yy=[[222.52782],[222.52782]],id="drawlink",thick=[0,0],ct=[1,1],from=[15,1,0],to=[3,2,1]);
        scs_m.objs[17-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[254.2247,202.52782],sz=[20,20],flip=true,theta=0,exprs="3",pin=[],pout=18,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=3,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[18-1] = scicos_link(xx=[[274.2247],[294.2247]],yy=[[212.52782],[212.52782]],id="drawlink",thick=[0,0],ct=[1,1],from=[17,1,0],to=[3,3,1]);
        scs_m.objs[19-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[388.82793,233.45067],sz=[20,20],flip=true,theta=0,exprs="1",pin=20,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[20-1] = scicos_link(xx=[[368.82793],[388.82793]],yy=[[243.45067],[243.45067]],id="drawlink",thick=[0,0],ct=[1,1],from=[6,2,0],to=[19,1,1]);
        scs_m.objs[21-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[466.2036,169.25363],sz=[20,20],flip=true,theta=0,exprs="2",pin=22,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[22-1] = scicos_link(xx=[[446.2036],[466.2036]],yy=[[179.25363],[179.25363]],id="drawlink",thick=[0,0],ct=[1,1],from=[9,1,0],to=[21,1,1]);
        model = scicos_model();
        model.sim = "csuper";
        model.in1 = [[1],[1],[1]];
        model.in2 = [[1],[1],[1]];
        model.out = [[1],[1]];
        model.out2 = [[1],[1]];
        model.intyp = [5,1,5];
        model.outtyp = [5,5];
        model.blocktype = "h";
        model.firing = false;
        model.dep_ut = [true,false];
        model.rpar = scs_m;
        gr_i = [];
        x = standard_define([2,3],model,[],gr_i);
    }
    JKFLIPFLOP.prototype.details = function JKFLIPFLOP() {
    }
    JKFLIPFLOP.prototype.get = function JKFLIPFLOP() {
    }
    JKFLIPFLOP.prototype.set = function JKFLIPFLOP() {
for (i=1;i<=length(arg1.model.rpar.objs);i+=1) {
        o = arg1.model.rpar.objs[i-1];
        if (typeof(o)=="Block"&&o.gui=="DOLLAR_m") {
        path = i;
break;
}
}
        newpar = list();
        xx = arg1.model.rpar.objs[path-1];
        exprs = xx.graphics.exprs[1-1];
        model = xx.model;
        init_old = model.odstate[1-1];
        while (true) {
        [ok,init,exprs0] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"JKFLIPFLOP")],[" "],[gettext("JK flip-flop")],[" "],[gettext("The \'Initial Value\' must be 0 or 1 of type int8")],[gettext("&nbsp;- Negative values are considered as int8(0)")],[gettext("&nbsp;- Positive values are considered as int8(1)")],[" "]],gettext("Initial Value"),list("vec",1),exprs);
        if (!ok) {
break;
}
        if (init<=0) {
        init = int8(0);
        } else if (init>0) {
        init = int8(1);
}
        if (ok) {
        xx.graphics.exprs[1-1] = exprs0;
        model.odstate[1-1] = init;
        xx.model = model;
        arg1.model.rpar.objs[path-1] = xx;
break;
}
}
        needcompile = 0;
        if (init_old!=init) {
        newpar[size(newpar)+1-1] = 1;
        needcompile = 2;
}
        x = arg1;
        y = needcompile;
        typ = newpar;
    }
}
/* autogenerated from "macros/IntegerOp/LOGIC.sci" */
function LOGIC() {
    LOGIC.prototype.define = function LOGIC() {
        mat = [[0],[0],[0],[1]];
        model = scicos_model();
        model.sim = list("logic",4);
        model.in1 = [[1],[1]];
        model.in2 = [[1],[1]];
        model.out = 1;
        model.out2 = 1;
        model.evtin = 1;
        model.intyp = [5,5];
        model.outtyp = 5;
        model.opar = list(int8(mat));
        model.blocktype = "c";
        model.firing = false;
        model.dep_ut = [true,false];
        exprs = [[sci2exp(mat)],[sci2exp(0)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    LOGIC.prototype.details = function LOGIC() {
    }
    LOGIC.prototype.get = function LOGIC() {
    }
    LOGIC.prototype.set = function LOGIC() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,mat,herit,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"LOGIC")],[" "],[gettext("Combinatorial logic")],[" "],[gettext("&nbsp; Rows of the matrix are the output values")],[gettext("&nbsp; Number of rows must be a power of two.")],[gettext("&nbsp; Number of columns gives the number of outputs.")],[" "]],[[gettext("Truth Table (matrix of outputs)")],[gettext("Accepts Inherited Events (0:No, 1:Yes)")]],list("mat",[-1,-2],"vec",1),exprs);
        if (!ok) {
break;
}
        nout = size(mat,2);
        nin = (log(size(mat,1))/log(2));
        u1 = floor(nin);
        if ((u1!=nin)) {
block_parameter_error(msprintf(gettext("Wrong size for \'%s\' parameter: %d."),gettext("Truth Table"),size(mat,1)),gettext("Number of rows must be a power of two."));
        ok = false;
        } else if ((find(mat.slice()!=0&&mat.slice()!=1)!=[])) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter."),gettext("Truth Table")),msprintf(gettext("Elements must be in the interval %s."),"[0, 1]"));
        ok = false;
        } else if (herit<0||herit>1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Accepts Inherited Events"),herit),msprintf(gettext("Must be in the interval %s."),"[0, 1]"));
        ok = false;
}
        if (ok) {
        in1 = [ones(nin,1),ones(nin,1)];
        out = [ones(nout,1),ones(nout,1)];
        it = 5*ones(1,nin);
        ot = 5*ones(1,nout);
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),ones(1-herit,1),[]);
}
        if (ok) {
        graphics.exprs = exprs;
        mat = int8(mat);
        model.opar = list(mat);
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/IntegerOp/SHIFT.sci" */
function SHIFT() {
    SHIFT.prototype.define = function SHIFT() {
        sgn = [[0],[0]];
        OPER = 0;
        model = scicos_model();
        model.sim = list("shift_32_LA",4);
        model.in1 = -1;
        model.out = -1;
        model.in2 = -2;
        model.out2 = -2;
        model.intyp = 3;
        model.outtyp = 3;
        model.rpar = [];
        model.ipar = sgn;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[sci2exp(3)],[sci2exp(0)],[sci2exp(0)]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    SHIFT.prototype.details = function SHIFT() {
    }
    SHIFT.prototype.get = function SHIFT() {
    }
    SHIFT.prototype.set = function SHIFT() {
        x = arg1;
        graphics = arg1.graphics;
        model = arg1.model;
        exprs = graphics.exprs;
        while (true) {
        [ok,Datatype,nb,np,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"SHIFT")],[" "],[gettext("Shift/Rotates bits")]],[[msprintf(gettext("Data Type %s"),"(3:int32, 4:int16, 5:int8, ...)")],[gettext("Number of Bits to Shift Left (Negative number to shift right)")],[gettext("Shift Type (0:Arithmetic, 1:Circular)")]],list("vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if ((np!=0&&np!=1)) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Shift Type"),np),msprintf(gettext("Must be in the interval %s."),"[0, 1]"));
        ok = false;
}
        it = Datatype;
        ot = Datatype;
        if ((Datatype==3||Datatype==6)) {
        if (nb>0) {
        switch (np) {
        case 0:
        model.sim = list("shift_32_LA",4);
        case 1:
        model.sim = list("shift_32_LC",4);
}
        } else if (nb<0) {
        switch (np) {
        case 0:
        switch (Datatype) {
        case 3:
        model.sim = list("shift_32_RA",4);
        case 6:
        model.sim = list("shift_u32_RA",4);
}
        case 1:
        model.sim = list("shift_32_RC",4);
}
}
        } else if ((Datatype==4||Datatype==7)) {
        if (nb>0) {
        switch (np) {
        case 0:
        model.sim = list("shift_16_LA",4);
        case 1:
        model.sim = list("shift_16_LC",4);
}
        } else if (nb<0) {
        switch (np) {
        case 0:
        switch (Datatype) {
        case 4:
        model.sim = list("shift_16_RA",4);
        case 7:
        model.sim = list("shift_u16_RA",4);
}
        case 1:
        model.sim = list("shift_16_RC",4);
}
}
        } else if ((Datatype==5||Datatype==8)) {
        if (nb>0) {
        switch (np) {
        case 0:
        model.sim = list("shift_8_LA",4);
        case 1:
        model.sim = list("shift_8_LC",4);
}
        } else if (nb<0) {
        switch (np) {
        case 0:
        switch (Datatype) {
        case 5:
        model.sim = list("shift_8_RA",4);
        case 8:
        model.sim = list("shift_u8_RA",4);
}
        case 1:
        model.sim = list("shift_8_RC",4);
}
}
        } else {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Data Type"),Datatype),msprintf(gettext("Must be in the interval %s."),"[3, 8]"));
        ok = false;
}
        if (ok) {
        [model,graphics,ok] = set_io(model,graphics,list([-1,-2],it),list([-1,-2],ot),[],[]);
}
        if (ok) {
        model.ipar = nb;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/IntegerOp/SRFLIPFLOP.sci" */
function SRFLIPFLOP() {
    SRFLIPFLOP.prototype.define = function SRFLIPFLOP() {
        scs_m = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["SRFLIPFLOP"],tol=[[0.0001],[0.000001],[1.000e-10],[100001],[0],[0],[0]],tf=60,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m.objs[1-1] = scicos_block(gui="LOGIC",graphics=scicos_graphics(orig=[298.504,201.45067],sz=[40,40],flip=true,theta=0,exprs=[["[0 1;1 0;1 0;1 0;0 1;0 1;0 0;0 0]"],["1"]],pin=[[4],[10],[12]],pout=[[3],[8]],pein=[],peout=[],gr_i=[],id="",in_implicit=[["E"],["E"],["E"]],out_implicit=[["E"],["E"]]),model=scicos_model(sim=list("logic",4),in1=[[1],[1],[1]],in2=[[1],[1],[1]],intyp=[[5],[5],[5]],out=[[1],[1]],out2=[[1],[1]],outtyp=[[5],[5]],evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(int8([[0,1],[1,0],[1,0],[1,0],[0,1],[0,1],[0,0],[0,0]])),blocktype="c",firing=false,dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[2-1] = scicos_block(gui="DOLLAR_m",graphics=scicos_graphics(orig=[299.23733,254.25067],sz=[40,40],flip=false,theta=0,exprs=[["int8(0)"],["1"]],pin=6,pout=4,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("dollar4_m",4),in1=1,in2=1,intyp=5,out=1,out2=1,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(int8(0)),rpar=[],ipar=[],opar=list(),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[3-1] = scicos_link(xx=[[347.07543],[363.03733],[363.03733]],yy=[[228.11733],[228.11733],[248.584]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[5,1,1]);
        scs_m.objs[4-1] = scicos_link(xx=[[290.6659],[272.104],[272.104],[289.93257]],yy=[[274.25067],[274.25067],[231.45067],[231.45067]],id="drawlink",thick=[0,0],ct=[1,1],from=[2,1,0],to=[1,1,1]);
        scs_m.objs[5-1] = scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[363.03733,248.584],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=3,pout=[[6],[14]],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[["E"],["E"],["E"]]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[[-1],[-1],[-1]],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[6-1] = scicos_link(xx=[[363.03733],[363.03733],[344.95162]],yy=[[248.584],[274.25067],[274.25067]],id="drawlink",thick=[0,0],ct=[1,1],from=[5,1,0],to=[2,1,1]);
        scs_m.objs[7-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[367.07543,204.784],sz=[20,20],flip=true,theta=0,exprs="2",pin=8,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[8-1] = scicos_link(xx=[[347.07543],[367.07543]],yy=[[214.784],[214.784]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,2,0],to=[7,1,1]);
        scs_m.objs[9-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[249.93257,211.45067],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=10,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[10-1] = scicos_link(xx=[[269.93257],[289.93257]],yy=[[221.45067],[221.45067]],id="drawlink",thick=[0,0],ct=[1,1],from=[9,1,0],to=[1,2,1]);
        scs_m.objs[11-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[249.93257,201.45067],sz=[20,20],flip=true,theta=0,exprs="2",pin=[],pout=12,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[12-1] = scicos_link(xx=[[269.93257],[289.93257]],yy=[[211.45067],[211.45067]],id="drawlink",thick=[0,0],ct=[1,1],from=[11,1,0],to=[1,3,1]);
        scs_m.objs[13-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[383.03733,238.584],sz=[20,20],flip=true,theta=0,exprs="1",pin=14,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[14-1] = scicos_link(xx=[[363.03733],[383.03733]],yy=[[248.584],[248.584]],id="drawlink",thick=[0,0],ct=[1,1],from=[5,2,0],to=[13,1,1]);
        model = scicos_model();
        model.sim = "csuper";
        model.in1 = [[1],[1]];
        model.in2 = [[1],[1]];
        model.out = [[1],[1]];
        model.out2 = [[1],[1]];
        model.intyp = [5,5];
        model.outtyp = [5,5];
        model.blocktype = "h";
        model.firing = false;
        model.dep_ut = [true,false];
        model.rpar = scs_m;
        gr_i = [];
        x = standard_define([2,3],model,[],gr_i);
    }
    SRFLIPFLOP.prototype.details = function SRFLIPFLOP() {
    }
    SRFLIPFLOP.prototype.get = function SRFLIPFLOP() {
    }
    SRFLIPFLOP.prototype.set = function SRFLIPFLOP() {
for (i=1;i<=length(arg1.model.rpar.objs);i+=1) {
        o = arg1.model.rpar.objs[i-1];
        if (typeof(o)=="Block"&&o.gui=="DOLLAR_m") {
        path = i;
break;
}
}
        newpar = list();
        xx = arg1.model.rpar.objs[path-1];
        exprs = xx.graphics.exprs[1-1];
        model = xx.model;
        init_old = model.odstate[1-1];
        while (true) {
        [ok,init,exprs0] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"SRFLIPFLOP")],[" "],[gettext("SR flip-flop")],[" "],[gettext("The \'Initial Value\' must be 0 or 1 of type int8")],[gettext("&nbsp;- Negative values are considered as int8(0)")],[gettext("&nbsp;- Positive values are considered as int8(1)")],[" "]],gettext("Initial Value"),list("vec",1),exprs);
        if (!ok) {
break;
}
        if (init<=0) {
        init = int8(0);
        } else if (init>0) {
        init = int8(1);
}
        if (ok) {
        xx.graphics.exprs[1-1] = exprs0;
        model.odstate[1-1] = init;
        xx.model = model;
        arg1.model.rpar.objs[path-1] = xx;
break;
}
}
        needcompile = 0;
        if (init_old!=init) {
        newpar[size(newpar)+1-1] = path;
        needcompile = 2;
}
        x = arg1;
        y = needcompile;
        typ = newpar;
    }
}
/* autogenerated from "macros/Linear/BIGSOM_f.sci" */
function BIGSOM_f() {
    BIGSOM_f.prototype.define = function BIGSOM_f() {
        sgn = [[1],[1]];
        model = scicos_model();
        model.sim = list("sum",2);
        model.in1 = [[-1],[-1]];
        model.out = -1;
        model.rpar = sgn;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = sci2exp(sgn);
        gr_i = [];
        x = standard_define([2,3],model,exprs,gr_i);
    }
    BIGSOM_f.prototype.details = function BIGSOM_f() {
    }
    BIGSOM_f.prototype.get = function BIGSOM_f() {
    }
    BIGSOM_f.prototype.set = function BIGSOM_f() {
        x = arg1;
        graphics = arg1.graphics;
        model = arg1.model;
        exprs = graphics.exprs;
        while (true) {
        [ok,sgn,exprs] = scicos_getvalue("Set sum block parameters","Inputs ports signs/gain",list("vec",-1),exprs);
        if (!ok) {
break;
}
        in1 = -ones(size(sgn,"*"),1);
        [model,graphics,ok] = check_io(model,graphics,in1,-1,[],[]);
        if (ok) {
        model.rpar = sgn.slice();
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Linear/CLINDUMMY_f.sci" */
function CLINDUMMY_f() {
    CLINDUMMY_f.prototype.define = function CLINDUMMY_f() {
        x0 = 0;
        model = scicos_model();
        model.sim = list("cdummy",4);
        model.state = x0;
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [false,true];
        gr_i = [];
        x = standard_define([3,2],model,[],gr_i);
    }
    CLINDUMMY_f.prototype.details = function CLINDUMMY_f() {
    }
    CLINDUMMY_f.prototype.get = function CLINDUMMY_f() {
    }
    CLINDUMMY_f.prototype.set = function CLINDUMMY_f() {
        x = arg1;
    }
}
/* autogenerated from "macros/Linear/CLR.sci" */
function CLR() {
    CLR.prototype.define = function CLR() {
        x0 = 0;
        A = -1;
        B = 1;
        C = 1;
        D = 0;
        exprs = [["1"],["1+s"]];
        model = scicos_model();
        model.sim = list("csslti4",4);
        model.in1 = 1;
        model.out = 1;
        model.state = x0;
        model.rpar = [[A.slice()],[B.slice()],[C.slice()],[D.slice()]];
        model.blocktype = "c";
        model.dep_ut = [false,true];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    CLR.prototype.details = function CLR() {
    }
    CLR.prototype.get = function CLR() {
    }
    CLR.prototype.set = function CLR() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        x0 = model.state;
        rpar = model.rpar;
        ns = prod(size(x0));
        nin = 1;
        nout = 1;
        PREVAR_scicos_context = PREVAR_scicos_context;
        PREVAR_scicos_context.s = %s;
        while (true) {
        [ok,num,den,exprs] = scicos_getvalue("Set continuous SISO transfer parameters",[["Numerator (s)"],["Denominator (s)"]],list("pol",1,"pol",1),exprs);
        if (!ok) {
break;
}
        if (degree(num)>degree(den)) {
message("Transfer function must be proper or strictly proper.");
        ok = false;
}
        if (ok) {
        H = cont_frm(num,den);
        [A,B,C,D] = H.slice(2-1,5);
        graphics.exprs = exprs;
        [ns1,ns1] = size(A);
        rpar = [[matrix(A,ns1*ns1,1)],[matrix(B,ns1,1)],[matrix(C,ns1,1)],[D]];
        if (norm(D,1)!=0) {
        mmm = [true,true];
        } else {
        mmm = [false,true];
}
        if (or(model.dep_ut!=mmm)) {
        model.dep_ut = mmm;
}
        if (ns1<=ns) {
        x0 = x0.slice(1-1,ns1);
        } else {
        x0[ns1-1][1-1] = 0;
}
        model.state = x0;
        model.rpar = rpar;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Linear/CLR_f.sci" */
function CLR_f() {
    CLR_f.prototype.define = function CLR_f() {
        x0 = 0;
        A = -1;
        B = 1;
        C = 1;
        D = 0;
        exprs = [["1"],["1+s"]];
        model = scicos_model();
        model.sim = list("csslti",1);
        model.in1 = 1;
        model.out = 1;
        model.state = x0;
        model.rpar = [[A.slice()],[B.slice()],[C.slice()],[D.slice()]];
        model.blocktype = "c";
        model.dep_ut = [false,true];
        gr_i = [];
        x = standard_define([2.5,2.5],model,exprs,gr_i);
    }
    CLR_f.prototype.details = function CLR_f() {
    }
    CLR_f.prototype.get = function CLR_f() {
    }
    CLR_f.prototype.set = function CLR_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        x0 = model.state;
        rpar = model.rpar;
        ns = prod(size(x0));
        nin = 1;
        nout = 1;
        PREVAR_scicos_context = PREVAR_scicos_context;
        PREVAR_scicos_context.s = %s;
        while (true) {
        [ok,num,den,exprs] = scicos_getvalue("Set continuous SISO transfer parameters",[["Numerator (s)"],["Denominator (s)"]],list("pol",1,"pol",1),exprs);
        if (!ok) {
break;
}
        if (degree(num)>degree(den)) {
message("Transfer must be proper or strictly proper");
        ok = false;
}
        if (ok) {
        H = cont_frm(num,den);
        [A,B,C,D] = H.slice(2-1,5);
        graphics.exprs = exprs;
        [ns1,ns1] = size(A);
        rpar = [[matrix(A,ns1*ns1,1)],[matrix(B,ns1,1)],[matrix(C,ns1,1)],[D]];
        if (norm(D,1)!=0) {
        mmm = [true,true];
        } else {
        mmm = [false,true];
}
        if (or(model.dep_ut!=mmm)) {
        model.dep_ut = mmm;
}
        if (ns1<=ns) {
        x0 = x0.slice(1-1,ns1);
        } else {
        x0[ns1-1][1-1] = 0;
}
        model.state = x0;
        model.rpar = rpar;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Linear/CLSS.sci" */
function CLSS() {
    CLSS.prototype.define = function CLSS() {
        x0 = 0;
        A = -1;
        B = 1;
        C = 1;
        D = 0;
        in1 = 1;
        out = 1;
        model = scicos_model();
        model.sim = list("csslti4",4);
        model.in1 = in1;
        model.out = out;
        model.state = x0;
        model.rpar = [[A.slice()],[B.slice()],[C.slice()],[D.slice()]];
        model.blocktype = "c";
        model.dep_ut = [false,true];
        exprs = [[strcat(sci2exp(A))],[strcat(sci2exp(B))],[strcat(sci2exp(C))],[strcat(sci2exp(D))],[strcat(sci2exp(x0))]];
        gr_i = [];
        x = standard_define([4,2],model,exprs,gr_i);
    }
    CLSS.prototype.details = function CLSS() {
    }
    CLSS.prototype.get = function CLSS() {
    }
    CLSS.prototype.set = function CLSS() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        if (size(exprs,"*")==7) {
        exprs = exprs[[1:4,7]-1];
}
        model = arg1.model;
        while (true) {
        [ok,A,B,C,D,x0,exprs] = scicos_getvalue("Set continuous linear system parameters",[["A matrix"],["B matrix"],["C matrix"],["D matrix"],["Initial state"]],list("mat",[-1,-1],"mat",["size(%1,2)","-1"],"mat",["-1","size(%1,2)"],"mat",[-1,-1],"vec","size(%1,2)"),exprs);
        if (!ok) {
break;
}
        out = size(C,1);
        if (out==0) {
        out = [];
}
        in1 = size(B,2);
        if (in1==0) {
        in1 = [];
}
        [ms,ns] = size(A);
        okD = true;
        if (size(D,"*")!=size(C,1)*size(B,2)) {
        if (size(D,"*")==1) {
        D = D*ones(C*B);
        } else if (size(D,"*")==0) {
        D = zeros(C*B);
        } else {
        okD = false;
}
}
        if (ms!=ns||!okD) {
message(_("Matrix A is not square or D has wrong dimension"));
        } else {
        [model,graphics,ok] = check_io(model,graphics,in1,out,[],[]);
        if (ok) {
        graphics.exprs = exprs;
        rpar = [[A.slice()],[B.slice()],[C.slice()],[D.slice()]];
        if (D!=[]) {
        if (norm(D,1)!=0) {
        mmm = [true,true];
        } else {
        mmm = [false,true];
}
        if (or(model.dep_ut!=mmm)) {
        model.dep_ut = mmm;
}
        } else {
        model.dep_ut = [false,true];
}
        model.state = x0.slice();
        model.rpar = rpar;
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/Linear/CLSS_f.sci" */
function CLSS_f() {
    CLSS_f.prototype.define = function CLSS_f() {
        x0 = 0;
        A = -1;
        B = 1;
        C = 1;
        D = 0;
        in1 = 1;
        out = 1;
        model = scicos_model();
        model.sim = list("csslti",1);
        model.in1 = in1;
        model.out = out;
        model.state = x0;
        model.rpar = [[A.slice()],[B.slice()],[C.slice()],[D.slice()]];
        model.blocktype = "c";
        model.dep_ut = [false,true];
        exprs = [[strcat(sci2exp(A))],[strcat(sci2exp(B))],[strcat(sci2exp(C))],[strcat(sci2exp(D))],[strcat(sci2exp(x0))]];
        gr_i = [];
        x = standard_define([4,2],model,exprs,gr_i);
    }
    CLSS_f.prototype.details = function CLSS_f() {
    }
    CLSS_f.prototype.get = function CLSS_f() {
    }
    CLSS_f.prototype.set = function CLSS_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        if (size(exprs,"*")==7) {
        exprs = exprs[[1:4,7]-1];
}
        model = arg1.model;
        while (true) {
        [ok,A,B,C,D,x0,exprs] = scicos_getvalue("Set continuous linear system parameters",[["A matrix"],["B matrix"],["C matrix"],["D matrix"],["Initial state"]],list("mat",[-1,-1],"mat",["size(%1,2)","-1"],"mat",["-1","size(%1,2)"],"mat",[-1,-1],"vec","size(%1,2)"),exprs);
        if (!ok) {
break;
}
        out = size(C,1);
        if (out==0) {
        out = [];
}
        in1 = size(B,2);
        if (in1==0) {
        in1 = [];
}
        [ms,ns] = size(A);
        if (ms!=ns) {
message("A matrix must be square");
        } else {
        [model,graphics,ok] = check_io(model,graphics,in1,out,[],[]);
        if (ok) {
        graphics.exprs = exprs;
        rpar = [[A.slice()],[B.slice()],[C.slice()],[D.slice()]];
        if (D!=[]) {
        if (norm(D,1)!=0) {
        mmm = [true,true];
        } else {
        mmm = [false,true];
}
        if (or(model.dep_ut!=mmm)) {
        model.dep_ut = mmm;
}
        } else {
        model.dep_ut = [false,true];
}
        model.state = x0.slice();
        model.rpar = rpar;
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/Linear/DELAYV_f.sci" */
function DELAYV_f() {
    DELAYV_f.prototype.define = function DELAYV_f() {
        nin = 1;
        z0 = zeros(11,1);
        zz0 = z0.slice(1-1,$-1);
        T = 1;
        model = scicos_model();
        model.sim = list("delayv",1);
        model.in1 = [[nin],[1]];
        model.out = nin;
        model.evtin = 1;
        model.evtout = [[1],[1]];
        model.dstate = z0;
        model.rpar = T/(size(zz0,"*"));
        model.blocktype = "d";
        model.firing = [0,-1];
        model.dep_ut = [true,false];
        exprs = [[string(nin)],[strcat(string(z0.slice(1-1,$-1)),";")],[string(T)]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    DELAYV_f.prototype.details = function DELAYV_f() {
    }
    DELAYV_f.prototype.get = function DELAYV_f() {
    }
    DELAYV_f.prototype.set = function DELAYV_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        nin = model.in1[1-1];
        z0 = model.dstate;
        zz0 = z0.slice(1-1,$-1);
        told = z0[$-1];
        while (true) {
        [ok,nin,zz0,T,exprs] = scicos_getvalue("Set delay parameters",[["Number of inputs"],["Register initial condition"],["Max delay"]],list("vec",1,"vec",-1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (size(zz0,"*")<2) {
message("Register length must be at least 2");
        ok = false;
}
        if (T<=0) {
message("Delay must be positive");
        ok = false;
}
        if (ok) {
        [model,graphics,ok] = check_io(model,graphics,[[nin],[1]],nin,1,[[1],[1]]);
}
        if (ok) {
        graphics.exprs = exprs;
        model.dstate = [[zz0.slice()],[told]];
        model.rpar = T/(size(zz0,"*"));
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Linear/DELAY_f.sci" */
function DELAY_f() {
    DELAY_f.prototype.define = function DELAY_f() {
        evtdly = EVTDLY_f("define");
        evtdly.graphics.orig = [243,296];
        evtdly.graphics.sz = [40,40];
        evtdly.graphics.flip = true;
        evtdly.graphics.exprs = [["0.1"],["0"]];
        evtdly.graphics.pein = 10;
        evtdly.graphics.peout = 7;
        evtdly.model.rpar = 0.1;
        evtdly.model.firing = 0;
        register = REGISTER_f("define");
        register.graphics.orig = [238,195];
        register.graphics.sz = [50,50];
        register.graphics.flip = true;
        register.graphics.exprs = "0;0;0;0;0;0;0;0;0;0";
        register.graphics.pin = 6;
        register.graphics.pout = 5;
        register.graphics.pein = 9;
        input_port = IN_f("define");
        input_port.graphics.orig = [92,210];
        input_port.graphics.sz = [20,20];
        input_port.graphics.flip = true;
        input_port.graphics.exprs = [["1"],["1"]];
        input_port.graphics.pout = 6;
        input_port.model.ipar = 1;
        output_port = OUT_f("define");
        output_port.graphics.orig = [440,210];
        output_port.graphics.sz = [20,20];
        output_port.graphics.flip = true;
        output_port.graphics.exprs = [["1"],["1"]];
        output_port.graphics.pin = 5;
        output_port.model.ipar = 1;
        split = CLKSPLIT_f("define");
        split.graphics.orig = [[263],[271.2]];
        split.graphics.pein = 7;
        split.graphics.peout = [[9],[10]];
        diagram = scicos_diagram();
        diagram.objs[1-1] = input_port;
        diagram.objs[2-1] = output_port;
        diagram.objs[3-1] = register;
        diagram.objs[4-1] = evtdly;
        diagram.objs[5-1] = scicos_link(xx=[[296.6],[440]],yy=[[220],[220]],from=[3,1],to=[2,1]);
        diagram.objs[6-1] = scicos_link(xx=[[112],[229.4]],yy=[[220],[220]],from=[1,1],to=[3,1]);
        diagram.objs[7-1] = scicos_link(xx=[[263],[263]],yy=[[290.3],[271.2]],ct=[5,-1],from=[4,1],to=[8,1]);
        diagram.objs[8-1] = split;
        diagram.objs[9-1] = scicos_link(xx=[[263],[263]],yy=[[271.2],[250.7]],ct=[5,-1],from=[8,1],to=[3,1]);
        diagram.objs[10-1] = scicos_link(xx=[[263],[308.6],[308.6],[263],[263]],yy=[[271.2],[271.2],[367],[367],[341.7]],ct=[5,-1],from=[8,2],to=[4,1]);
        x = scicos_block();
        x.gui = "DELAY_f";
        x.graphics.sz = [2,2];
        x.graphics.gr_i = [];
        x.graphics.pin = 0;
        x.graphics.pout = 0;
        x.model.sim = "csuper";
        x.model.in1 = 1;
        x.model.out = 1;
        x.model.blocktype = "h";
        x.model.dep_ut = [false,false];
        x.model.rpar = diagram;
        x.graphics.in_implicit = ["E"];
        x.graphics.in_style = "";
        x.graphics.out_implicit = ["E"];
        x.graphics.out_style = "";
    }
    DELAY_f.prototype.details = function DELAY_f() {
    }
    DELAY_f.prototype.get = function DELAY_f() {
    }
    DELAY_f.prototype.set = function DELAY_f() {
        ppath = list(0,0);
for (i=1;i<=length(arg1.model.rpar.objs);i+=1) {
        o = arg1.model.rpar.objs[i-1];
        if (typeof(o)=="Block"&&o.gui=="REGISTER_f") {
        ppath[1-1] = i;
}
        if (typeof(o)=="Block"&&o.gui=="EVTDLY_f") {
        ppath[2-1] = i;
}
        if (and(ppath!=list(0,0))) {
break;
}
}
        x = arg1;
        newpar = list();
        register = x.model.rpar.objs[ppath[1-1]-1];
        evtdly = x.model.rpar.objs[ppath[2-1]-1];
        register_exprs = register.graphics.exprs;
        evtdly_exprs = evtdly.graphics.exprs;
        exprs = [[evtdly_exprs[1-1]],[register_exprs]];
        while (true) {
        [ok,dt,z0,exprs] = scicos_getvalue([["This block implements as a discretized delay"],["it is consist of a shift register and a clock"],["value of the delay is given by;","the discretization time step multiplied by the"],["number-1 of state of the register"]],[["Discretization time step"],["Register initial state"]],list("vec",1,"vec",-1),exprs);
        if (!ok) {
break;
}
        mess = [];
        if (prod(size(z0))<1) {
        mess = [[mess],["Register length must be at least 1"],[" "]];
        ok = false;
}
        if (dt<=0) {
        mess = [[mess],["Discretization time step must be positive"],[" "]];
        ok = false;
}
        if (!ok) {
message(mess);
        } else {
        evtdly.graphics.exprs[1-1] = exprs[1-1];
        if (evtdly.model.rpar!=dt) {
        evtdly.model.rpar = dt;
        newpar[$+1-1] = ppath[2-1];
}
        x.model.rpar.objs[ppath[2-1]-1] = evtdly;
        register.graphics.exprs = exprs[2-1];
        if (or(register.model.dstate!=z0.slice())) {
        register.model.dstate = z0.slice();
        newpar[$+1-1] = ppath[1-1];
}
        x.model.rpar.objs[ppath[1-1]-1] = register;
break;
}
}
        needcompile = 0;
        y = needcompile;
        typ = newpar;
    }
}
/* autogenerated from "macros/Linear/DERIV.sci" */
function DERIV() {
    DERIV.prototype.define = function DERIV() {
        model = scicos_model();
        model.sim = list("deriv",4);
        model.in1 = -1;
        model.out = -1;
        model.blocktype = "x";
        model.dep_ut = [true,false];
        exprs = [];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    DERIV.prototype.details = function DERIV() {
    }
    DERIV.prototype.get = function DERIV() {
    }
    DERIV.prototype.set = function DERIV() {
        x = arg1;
    }
}
/* autogenerated from "macros/Linear/DIFF_c.sci" */
function DIFF_c() {
    DIFF_c.prototype.define = function DIFF_c() {
        x0 = [[0],[0]];
        model = scicos_model();
        model.sim = list("diffblk_c",10004);
        model.in1 = 1;
        model.out = 1;
        model.state = x0;
        model.blocktype = "c";
        model.dep_ut = [false,true];
        exprs = [[strcat(sci2exp(x0[1-1]))],[strcat(sci2exp(x0[2-1]))]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    DIFF_c.prototype.details = function DIFF_c() {
    }
    DIFF_c.prototype.get = function DIFF_c() {
    }
    DIFF_c.prototype.set = function DIFF_c() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        ask_again = false;
        [ok,x0,xd0,exprs] = scicos_getvalue("Set continuous linear system parameters",[["Initial state"],["Initial Derivative"]],list("vec",-1,"vec",-1),exprs);
        if (!ok) {
break;
}
        x0 = x0.slice();
        N = size(x0,"*");
        xd0 = xd0.slice();
        Nxd = size(xd0,"*");
        if ((N!=Nxd)) {
message("Incompatible sizes: states and their derivatives should have the same size ");
        ask_again = true;
}
        if ((N<=0&&!ask_again)) {
x_message("number of states must be > 0 ");
        ask_again = true;
}
        if (!ask_again) {
        graphics.exprs = exprs;
        model.state = [[x0],[xd0]];
        model.out = [N];
        model.in1 = N;
        x.graphics = graphics;
        x.model = model;
break;
}
}
        x.model.firing = [];
    }
}
/* autogenerated from "macros/Linear/DLR.sci" */
function DLR() {
    DLR.prototype.define = function DLR() {
        x0 = 0;
        A = -1;
        B = 1;
        C = 1;
        D = 0;
        exprs = [["1"],["1+z"]];
        model = scicos_model();
        model.sim = list("dsslti4",4);
        model.in1 = 1;
        model.out = 1;
        model.evtin = 1;
        model.dstate = x0.slice();
        model.rpar = [[A.slice()],[B.slice()],[C.slice()],[D.slice()]];
        model.blocktype = "d";
        model.dep_ut = [false,false];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    DLR.prototype.details = function DLR() {
    }
    DLR.prototype.get = function DLR() {
    }
    DLR.prototype.set = function DLR() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        x0 = model.dstate;
        ns = prod(size(x0));
        PREVAR_scicos_context = PREVAR_scicos_context;
        PREVAR_scicos_context.z = %z;
        while (true) {
        [ok,num,den,exprs] = scicos_getvalue("Set discrete SISO transfer parameters",[["Numerator (z)"],["Denominator (z)"]],list("pol",1,"pol",1),exprs);
        if (!ok) {
break;
}
        if (degree(num)>degree(den)) {
message("Transfer function must be proper");
        ok = false;
}
        if (ok) {
        H = cont_frm(num,den);
        [A,B,C,D] = H.slice(2-1,5);
        graphics.exprs = exprs;
        [ns1,ns1] = size(A);
        if (ns1<=ns) {
        x0 = x0.slice(1-1,ns1);
        } else {
        x0[ns1-1][1-1] = 0;
}
        rpar = [[A.slice()],[B.slice()],[C.slice()],[D.slice()]];
        model.dstate = x0;
        model.rpar = rpar;
        if (norm(D,1)!=0) {
        mmm = [true,false];
        } else {
        mmm = [false,false];
}
        if (or(model.dep_ut!=mmm)) {
        model.dep_ut = mmm;
}
        x.graphics = graphics;
        x.model = model;
break;
}
}
        x.model.firing = [];
    }
}
/* autogenerated from "macros/Linear/DLR_f.sci" */
function DLR_f() {
    DLR_f.prototype.define = function DLR_f() {
        x0 = 0;
        A = -1;
        B = 1;
        C = 1;
        D = 0;
        exprs = [["1"],["1+z"]];
        model = scicos_model();
        model.sim = "dsslti";
        model.in1 = 1;
        model.out = 1;
        model.evtin = 1;
        model.dstate = x0.slice();
        model.rpar = [[A.slice()],[B.slice()],[C.slice()],[D.slice()]];
        model.blocktype = "d";
        model.dep_ut = [false,false];
        gr_i = [];
        x = standard_define([2.5,2.5],model,exprs,gr_i);
    }
    DLR_f.prototype.details = function DLR_f() {
    }
    DLR_f.prototype.get = function DLR_f() {
    }
    DLR_f.prototype.set = function DLR_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        x0 = model.dstate;
        ns = prod(size(x0));
        PREVAR_scicos_context = PREVAR_scicos_context;
        PREVAR_scicos_context.z = %z;
        while (true) {
        [ok,num,den,exprs] = scicos_getvalue("Set discrete SISO transfer parameters",[["Numerator (z)"],["Denominator (z)"]],list("pol",1,"pol",1),exprs);
        if (!ok) {
break;
}
        if (degree(num)>degree(den)) {
message("Transfer must be proper");
        ok = false;
}
        if (ok) {
        H = cont_frm(num,den);
        [A,B,C,D] = H.slice(2-1,5);
        graphics.exprs = exprs;
        [ns1,ns1] = size(A);
        if (ns1<=ns) {
        x0 = x0.slice(1-1,ns1);
        } else {
        x0[ns1-1][1-1] = 0;
}
        rpar = [[A.slice()],[B.slice()],[C.slice()],[D.slice()]];
        model.dstate = x0;
        model.rpar = rpar;
        if (norm(D,1)!=0) {
        mmm = [true,false];
        } else {
        mmm = [false,false];
}
        if (or(model.dep_ut!=mmm)) {
        model.dep_ut = mmm;
}
        x.graphics = graphics;
        x.model = model;
break;
}
}
        x.model.firing = [];
    }
}
/* autogenerated from "macros/Linear/DLSS.sci" */
function DLSS() {
    DLSS.prototype.define = function DLSS() {
        x0 = 0;
        A = -1;
        B = 1;
        C = 1;
        D = 0;
        model = scicos_model();
        model.sim = list("dsslti4",4);
        model.in1 = 1;
        model.out = 1;
        model.evtin = 1;
        model.dstate = x0.slice();
        model.rpar = [[A.slice()],[B.slice()],[C.slice()],[D.slice()]];
        model.blocktype = "d";
        model.dep_ut = [false,false];
        exprs = [[strcat(sci2exp(A))],[strcat(sci2exp(B))],[strcat(sci2exp(C))],[strcat(sci2exp(D))],[strcat(sci2exp(x0))]];
        gr_i = [];
        x = standard_define([4,2],model,exprs,gr_i);
    }
    DLSS.prototype.details = function DLSS() {
    }
    DLSS.prototype.get = function DLSS() {
    }
    DLSS.prototype.set = function DLSS() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        if (size(exprs,"*")==7) {
        exprs = exprs[[1:4,7]-1];
}
        model = arg1.model;
        while (true) {
        [ok,A,B,C,D,x0,exprs] = scicos_getvalue("Set discrete linear system parameters",[["A matrix"],["B matrix"],["C matrix"],["D matrix"],["Initial state"]],list("mat",[-1,-1],"mat",["size(%1,2)","-1"],"mat",["-1","size(%1,2)"],"mat",[-1,-1],"vec","size(%1,2)"),exprs);
        if (!ok) {
break;
}
        out = size(C,1);
        if (out==0) {
        out = [];
}
        in1 = size(B,2);
        if (in1==0) {
        in1 = [];
}
        [ms,ns] = size(A);
        okD = true;
        if (size(D,"*")!=size(C,1)*size(B,2)) {
        if (size(D,"*")==1) {
        D = D*ones(C*B);
        } else if (size(D,"*")==0) {
        D = zeros(C*B);
        } else {
        okD = false;
}
}
        if (ms!=ns||!okD) {
message(_("Matrix A is not square or D has wrong dimension"));
        } else {
        [model,graphics,ok] = check_io(model,graphics,in1,out,1,[]);
        if (ok) {
        graphics.exprs = exprs;
        rpar = [[A.slice()],[B.slice()],[C.slice()],[D.slice()]];
        if (D!=[]) {
        if (norm(D,1)!=0) {
        mmm = [true,false];
        } else {
        mmm = [false,false];
}
        if (or(model.dep_ut!=mmm)) {
        model.dep_ut = mmm;
}
        } else {
        model.dep_ut = [false,false];
}
        model.dstate = x0.slice();
        model.rpar = rpar;
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/Linear/DLSS_f.sci" */
function DLSS_f() {
    DLSS_f.prototype.define = function DLSS_f() {
        x0 = 0;
        A = -1;
        B = 1;
        C = 1;
        D = 0;
        model = scicos_model();
        model.sim = list("dsslti",1);
        model.in1 = 1;
        model.out = 1;
        model.evtin = 1;
        model.dstate = x0.slice();
        model.rpar = [[A.slice()],[B.slice()],[C.slice()],[D.slice()]];
        model.blocktype = "d";
        model.dep_ut = [false,false];
        exprs = [[strcat(sci2exp(A))],[strcat(sci2exp(B))],[strcat(sci2exp(C))],[strcat(sci2exp(D))],[strcat(sci2exp(x0))]];
        gr_i = [];
        x = standard_define([4,2],model,exprs,gr_i);
    }
    DLSS_f.prototype.details = function DLSS_f() {
    }
    DLSS_f.prototype.get = function DLSS_f() {
    }
    DLSS_f.prototype.set = function DLSS_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        if (size(exprs,"*")==7) {
        exprs = exprs[[1:4,7]-1];
}
        model = arg1.model;
        while (true) {
        [ok,A,B,C,D,x0,exprs] = scicos_getvalue("Set discrete linear system parameters",[["A matrix"],["B matrix"],["C matrix"],["D matrix"],["Initial state"]],list("mat",[-1,-1],"mat",["size(%1,2)","-1"],"mat",["-1","size(%1,2)"],"mat",[-1,-1],"vec","size(%1,2)"),exprs);
        if (!ok) {
break;
}
        out = size(C,1);
        if (out==0) {
        out = [];
}
        in1 = size(B,2);
        if (in1==0) {
        in1 = [];
}
        [ms,ns] = size(A);
        if (ms!=ns) {
message("A matrix must be square");
        } else {
        [model,graphics,ok] = check_io(model,graphics,in1,out,1,[]);
        if (ok) {
        graphics.exprs = exprs;
        rpar = [[A.slice()],[B.slice()],[C.slice()],[D.slice()]];
        if (D!=[]) {
        if (norm(D,1)!=0) {
        mmm = [true,false];
        } else {
        mmm = [false,false];
}
        if (or(model.dep_ut!=mmm)) {
        model.dep_ut = mmm;
}
        } else {
        model.dep_ut = [false,false];
}
        model.dstate = x0.slice();
        model.rpar = rpar;
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/Linear/DOLLAR.sci" */
function DOLLAR() {
    DOLLAR.prototype.define = function DOLLAR() {
        z = 0;
        inh = 0;
        in1 = 1;
        exprs = string([[z],[inh]]);
        model = scicos_model();
        model.sim = list("dollar4",4);
        model.in1 = in1;
        model.out = in1;
        model.evtin = 1-inh;
        model.dstate = z;
        model.blocktype = "d";
        model.dep_ut = [false,false];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    DOLLAR.prototype.details = function DOLLAR() {
    }
    DOLLAR.prototype.get = function DOLLAR() {
    }
    DOLLAR.prototype.set = function DOLLAR() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        if (size(exprs,"*")<2) {
        exprs[2-1] = "0";
}
        while (true) {
        [ok,a,inh,exprs] = scicos_getvalue("Set 1/z block parameters",[["initial condition"],["Inherit (no:0, yes:1)"]],list("mat",[-1,-2],"vec",-1),exprs);
        if (!ok) {
break;
}
        out = [size(a,1),size(a,2)];
        if (out==0) {
        out = [];
}
        in1 = out;
        model.sim = list("dollar4_m",4);
        model.odstate = list(a);
        model.dstate = [];
        if (this.type[(a)==1-1]) {
        if (isreal(a)) {
        it = 1;
        ot = 1;
        if ((size(a,1)==1||size(a,2)==1)) {
        model.sim = list("dollar4",4);
        model.dstate = a.slice();
        model.odstate = list();
}
        } else {
        it = 2;
        ot = 2;
}
        } else if ((typeof(a)=="int32")) {
        it = 3;
        ot = 3;
        } else if ((typeof(a)=="int16")) {
        it = 4;
        ot = 4;
        } else if ((typeof(a)=="int8")) {
        it = 5;
        ot = 5;
        } else if ((typeof(a)=="uint32")) {
        it = 6;
        ot = 6;
        } else if ((typeof(a)=="uint16")) {
        it = 7;
        ot = 7;
        } else if ((typeof(a)=="uint8")) {
        it = 8;
        ot = 8;
        } else {
message("type is not recognized");
        ok = false;
}
        if (ok) {
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),ones(1-inh,1),[]);
}
        if (ok) {
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Linear/DOLLAR_f.sci" */
function DOLLAR_f() {
    DOLLAR_f.prototype.define = function DOLLAR_f() {
        z = 0;
        inh = 0;
        in1 = 1;
        exprs = string([[z],[inh]]);
        model = scicos_model();
        model.sim = "dollar";
        model.in1 = in1;
        model.out = in1;
        model.evtin = 1-inh;
        model.dstate = z;
        model.blocktype = "d";
        model.dep_ut = [false,false];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    DOLLAR_f.prototype.details = function DOLLAR_f() {
    }
    DOLLAR_f.prototype.get = function DOLLAR_f() {
    }
    DOLLAR_f.prototype.set = function DOLLAR_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        if (size(exprs,"*")<2) {
        exprs[2-1] = "0";
}
        while (true) {
        [ok,a,inh,exprs] = scicos_getvalue("Set 1/z block parameters",[["initial condition"],["Inherit (no:0, yes:1)"]],list("vec",-1,"vec",-1),exprs);
        if (!ok) {
break;
}
        out = size(a,"*");
        if (out==0) {
        out = [];
}
        in1 = out;
        if (ok) {
        [model,graphics,ok] = check_io(model,graphics,-1,-1,ones(1-inh,1),[]);
}
        if (ok) {
        graphics.exprs = exprs;
        model.dstate = a;
        model.in1 = in1;
        model.out = out;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Linear/DOLLAR_m.sci" */
function DOLLAR_m() {
    DOLLAR_m.prototype.define = function DOLLAR_m() {
        z = 0;
        inh = 0;
        in1 = 1;
        exprs = string([[z],[inh]]);
        model = scicos_model();
        model.sim = list("dollar4",4);
        model.in1 = in1;
        model.out = in1;
        model.evtin = 1-inh;
        model.dstate = z;
        model.blocktype = "d";
        model.dep_ut = [false,false];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    DOLLAR_m.prototype.details = function DOLLAR_m() {
    }
    DOLLAR_m.prototype.get = function DOLLAR_m() {
    }
    DOLLAR_m.prototype.set = function DOLLAR_m() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        if (size(exprs,"*")<2) {
        exprs[2-1] = "0";
}
        while (true) {
        [ok,a,inh,exprs] = scicos_getvalue("Set 1/z block parameters",[["initial condition"],["Inherit (no:0, yes:1)"]],list("mat",[-1,-2],"vec",-1),exprs);
        if (!ok) {
break;
}
        out = [size(a,1),size(a,2)];
        if (out==0) {
        out = [];
}
        in1 = out;
        model.sim = list("dollar4_m",4);
        model.odstate = list(a);
        model.dstate = [];
        if ((this.type[a-1]==1)) {
        if (isreal(a)) {
        it = 1;
        ot = 1;
        if ((size(a,1)==1||size(a,2)==1)) {
        model.sim = list("dollar4",4);
        model.dstate = a.slice();
        model.odstate = list();
}
        } else {
        it = 2;
        ot = 2;
}
        } else if ((typeof(a)=="int32")) {
        it = 3;
        ot = 3;
        } else if ((typeof(a)=="int16")) {
        it = 4;
        ot = 4;
        } else if ((typeof(a)=="int8")) {
        it = 5;
        ot = 5;
        } else if ((typeof(a)=="uint32")) {
        it = 6;
        ot = 6;
        } else if ((typeof(a)=="uint16")) {
        it = 7;
        ot = 7;
        } else if ((typeof(a)=="uint8")) {
        it = 8;
        ot = 8;
        } else {
message("type is not recognized");
        ok = false;
}
        if (ok) {
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),ones(1-inh,1),[]);
}
        if (ok) {
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Linear/GAINBLK.sci" */
function GAINBLK() {
    GAINBLK.prototype.define = function GAINBLK() {
        gain = 1;
        in1 = -1;
        out = -1;
        in2 = -2;
        out2 = -2;
        model = scicos_model();
        model.sim = list("gainblk",4);
        model.in1 = in1;
        model.out = out;
        model.in2 = in2;
        model.out2 = out2;
        model.rpar = gain;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [strcat(sci2exp(gain))];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    GAINBLK.prototype.details = function GAINBLK() {
    }
    GAINBLK.prototype.get = function GAINBLK() {
    }
    GAINBLK.prototype.set = function GAINBLK() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        if (size(exprs,"*")==1) {
        exprs = [[exprs],[sci2exp(0)]];
}
        while (true) {
        [ok,gain,over,exprs] = scicos_getvalue("Set gain block parameters",[["Gain"],["Do On Overflow(0=Nothing 1=Saturate 2=Error)"]],list("mat",[-1,-1],"vec",1),exprs);
        if (!ok) {
break;
}
        if (gain==[]) {
message("Gain must have at least one element");
        } else {
        if (typeof(gain)=="constant") {
        if (isreal(gain)) {
        it = 1;
        ot = 1;
        model.sim = list("gainblk",4);
        model.rpar = gain.slice();
        model.opar = list();
        } else {
message("type is not supported");
        ok = false;
}
        } else {
        if ((over==0)) {
        if ((typeof(gain)=="int32")) {
        ot = 3;
        model.sim = list("gainblk_i32n",4);
        } else if ((typeof(gain)=="int16")) {
        ot = 4;
        model.sim = list("gainblk_i16n",4);
        } else if ((typeof(gain)=="int8")) {
        ot = 5;
        model.sim = list("gainblk_i8n",4);
        } else if ((typeof(gain)=="uint32")) {
        ot = 6;
        model.sim = list("gainblk_ui32n",4);
        } else if ((typeof(gain)=="uint16")) {
        ot = 7;
        model.sim = list("gainblk_ui16n",4);
        } else if ((typeof(gain)=="uint8")) {
        ot = 8;
        model.sim = list("gainblk_ui8n",4);
        } else {
message("type is not supported.");
        ok = false;
}
        } else if ((over==1)) {
        if ((typeof(gain)=="int32")) {
        ot = 3;
        model.sim = list("gainblk_i32s",4);
        } else if ((typeof(gain)=="int16")) {
        ot = 4;
        model.sim = list("gainblk_i16s",4);
        } else if ((typeof(gain)=="int8")) {
        ot = 5;
        model.sim = list("gainblk_i8s",4);
        } else if ((typeof(gain)=="uint32")) {
        ot = 6;
        model.sim = list("gainblk_ui32s",4);
        } else if ((typeof(gain)=="uint16")) {
        ot = 7;
        model.sim = list("gainblk_ui16s",4);
        } else if ((typeof(gain)=="uint8")) {
        ot = 8;
        model.sim = list("gainblk_ui8s",4);
        } else {
message("type is not supported.");
        ok = false;
}
        } else if ((over==2)) {
        if ((typeof(gain)=="int32")) {
        ot = 3;
        model.sim = list("gainblk_i32e",4);
        } else if ((typeof(gain)=="int16")) {
        ot = 4;
        model.sim = list("gainblk_i16e",4);
        } else if ((typeof(gain)=="int8")) {
        ot = 5;
        model.sim = list("gainblk_i8e",4);
        } else if ((typeof(gain)=="uint32")) {
        ot = 6;
        model.sim = list("gainblk_ui32e",4);
        } else if ((typeof(gain)=="uint16")) {
        ot = 7;
        model.sim = list("gainblk_ui16e",4);
        } else if ((typeof(gain)=="uint8")) {
        ot = 8;
        model.sim = list("gainblk_ui8e",4);
        } else {
message("type is not an integer.");
        ok = false;
}
        } else {
message("Do on Overflow must be 0,1,2");
        ok = false;
}
        model.rpar = [];
        model.opar = list(gain.slice());
}
        if (ok) {
        [out,in1] = size(gain);
        if (out*in1!=1) {
        [model,graphics,ok] = set_io(model,graphics,list([in1,-1],ot),list([out,-1],ot),[],[]);
        } else {
        [model,graphics,ok] = set_io(model,graphics,list([-1,-2],ot),list([-1,-2],ot),[],[]);
}
}
        if (ok) {
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/Linear/GAINBLK_f.sci" */
function GAINBLK_f() {
    GAINBLK_f.prototype.define = function GAINBLK_f() {
        gain = 1;
        in1 = 1;
        out = 1;
        model = scicos_model();
        model.sim = "gain";
        model.in1 = in1;
        model.out = out;
        model.rpar = gain;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [strcat(sci2exp(gain))];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    GAINBLK_f.prototype.details = function GAINBLK_f() {
    }
    GAINBLK_f.prototype.get = function GAINBLK_f() {
    }
    GAINBLK_f.prototype.set = function GAINBLK_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,gain,exprs] = scicos_getvalue("Set gain block parameters",["Gain"],list("mat",[-1,-1]),exprs[1-1]);
        if (!ok) {
break;
}
        if (gain==[]) {
message("Gain must have at least one element");
        } else {
        [out,in1] = size(gain);
        [model,graphics,ok] = check_io(model,graphics,in1,out,[],[]);
        if (ok) {
        graphics.exprs = exprs;
        model.rpar = gain.slice();
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/Linear/GAIN_f.sci" */
function GAIN_f() {
    GAIN_f.prototype.define = function GAIN_f() {
        gain = 1;
        in1 = 1;
        out = 1;
        model = scicos_model();
        model.sim = "gain";
        model.in1 = 1;
        model.out = 1;
        model.rpar = gain;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[strcat(sci2exp(gain))],[strcat(sci2exp(in1))],[strcat(sci2exp(out))]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    GAIN_f.prototype.details = function GAIN_f() {
    }
    GAIN_f.prototype.get = function GAIN_f() {
    }
    GAIN_f.prototype.set = function GAIN_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,gain,exprs] = scicos_getvalue("Set gain block parameters",["Gain"],list("mat",[-1,-1]),exprs[1-1]);
        if (!ok) {
break;
}
        if (gain==[]) {
message("Gain must have at least one element");
        } else {
        [out,in1] = size(gain);
        [model,graphics,ok] = check_io(model,graphics,in1,out,[],[]);
        if (ok) {
        graphics.exprs = exprs;
        model.rpar = gain.slice();
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/Linear/INTEGRAL.sci" */
function INTEGRAL() {
    INTEGRAL.prototype.define = function INTEGRAL() {
        maxp = 1;
        minp = -1;
        rpar = [];
        model = scicos_model();
        model.state = 0;
        model.sim = list("integral_func",4);
        model.in1 = 1;
        model.out = 1;
        model.rpar = rpar;
        model.blocktype = "c";
        model.dep_ut = [false,true];
        exprs = string([[0],[0],[0],[maxp],[minp]]);
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
        x.graphics.id = "1/s";
    }
    INTEGRAL.prototype.details = function INTEGRAL() {
    }
    INTEGRAL.prototype.get = function INTEGRAL() {
    }
    INTEGRAL.prototype.set = function INTEGRAL() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,x0,reinit,satur,maxp,lowp,exprs] = scicos_getvalue("Set Integral block parameters",[["Initial Condition"],["With re-intialization (1:yes, 0:no)"],["With saturation (1:yes, 0:no)"],["Upper limit"],["Lower limit"]],list("vec",-1,"vec",1,"vec",1,"vec",-1,"vec",-1),exprs);
        if (!ok) {
break;
}
        x0 = x0.slice();
        maxp = maxp.slice();
        lowp = lowp.slice();
        if (reinit!=0) {
        reinit = 1;
}
        if (satur!=0) {
        satur = 1;
        if (size(maxp,"*")==1) {
        maxp = maxp*ones(x0);
}
        if (size(lowp,"*")==1) {
        lowp = lowp*ones(x0);
}
        if ((size(x0,1)!=size(maxp,1)||size(x0,1)!=size(lowp,1))) {
message("x0 and Upper limit and Lower limit must have same size");
        ok = false;
        } else if (or(maxp<=lowp)) {
message("Upper limits must be > Lower limits");
        ok = false;
        } else if (or(x0>maxp)||or(x0<lowp)) {
message("Initial condition x0 should be inside the limits");
        ok = false;
        } else {
        rpar = [[maxp],[lowp]];
        model.nzcross = size(x0,1);
        model.nmode = size(x0,1);
}
        } else {
        rpar = [];
        model.nzcross = 0;
        model.nmode = 0;
}
        if (ok) {
        model.rpar = rpar;
        model.state = x0;
        [model,graphics,ok] = check_io(model,graphics,size(x0,1)*[[1],[ones(reinit,1)]],size(x0,1),ones(reinit,1),[]);
}
        if (ok) {
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Linear/INTEGRAL_f.sci" */
function INTEGRAL_f() {
    INTEGRAL_f.prototype.define = function INTEGRAL_f() {
        x0 = 0;
        model = scicos_model();
        model.sim = "integr";
        model.in1 = 1;
        model.out = 1;
        model.state = x0;
        model.blocktype = "c";
        model.dep_ut = [false,true];
        exprs = strcat(sci2exp(x0));
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    INTEGRAL_f.prototype.details = function INTEGRAL_f() {
    }
    INTEGRAL_f.prototype.get = function INTEGRAL_f() {
    }
    INTEGRAL_f.prototype.set = function INTEGRAL_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,x0,exprs] = scicos_getvalue("Set continuous linear system parameters","Initial state",list("vec",1),exprs);
        if (!ok) {
break;
}
        graphics.exprs = exprs;
        model.state = x0;
        x.graphics = graphics;
        x.model = model;
break;
}
        x.model.firing = [];
    }
}
/* autogenerated from "macros/Linear/INTEGRAL_m.sci" */
function INTEGRAL_m() {
    INTEGRAL_m.prototype.define = function INTEGRAL_m() {
        maxp = 1;
        minp = -1;
        rpar = [];
        model = scicos_model();
        model.state = 0;
        model.sim = list("integral_func",4);
        model.in1 = 1;
        model.out = 1;
        model.in2 = 1;
        model.out2 = 1;
        model.rpar = rpar;
        model.blocktype = "c";
        model.dep_ut = [false,true];
        exprs = string([[0],[0],[0],[maxp],[minp]]);
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    INTEGRAL_m.prototype.details = function INTEGRAL_m() {
    }
    INTEGRAL_m.prototype.get = function INTEGRAL_m() {
    }
    INTEGRAL_m.prototype.set = function INTEGRAL_m() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,x0,reinit,satur,maxp,lowp,exprs] = scicos_getvalue("Set Integral block parameters",[["Initial Condition"],["With re-intialization (1:yes, 0:no)"],["With saturation (1:yes, 0:no)"],["Upper limit"],["Lower limit"]],list("mat",[-1,-1],"vec",1,"vec",1,"mat",[-1,-1],"mat",[-1,-1]),exprs);
        if (!ok) {
break;
}
        if (isreal(x0)) {
        Datatype = 1;
        } else {
        Datatype = 2;
}
        if (reinit!=0) {
        reinit = 1;
}
        if (satur!=0) {
        satur = 1;
        if (Datatype==1) {
        if (size(maxp,"*")==1) {
        maxp = maxp*ones(x0);
}
        if (size(lowp,"*")==1) {
        lowp = lowp*ones(x0);
}
        if ((size(x0)!=size(maxp)||size(x0)!=size(lowp))) {
message("x0 and Upper limit and Lower limit must have same size");
        ok = false;
        } else if (or(maxp<=lowp)) {
message("Upper limits must be > Lower limits");
        ok = false;
        } else if (or(x0>maxp)||or(x0<lowp)) {
message("Initial condition x0 should be inside the limits");
        ok = false;
        } else {
        rpar = [[real(maxp.slice())],[real(lowp.slice())]];
        model.nzcross = size(x0,"*");
        model.nmode = size(x0,"*");
}
        } else if ((Datatype==2)) {
        if (size(maxp,"*")==1) {
        maxp = math.complex(maxp*ones(x0),(maxp*ones(x0)));
}
        if (size(lowp,"*")==1) {
        lowp = math.complex(lowp*ones(x0),(lowp*ones(x0)));
}
        if ((size(x0)!=size(maxp)||size(x0)!=size(lowp))) {
message("x0 and Upper limit and Lower limit must have same size");
        ok = false;
        } else if (or(real(maxp)<=real(lowp))||or(imag(maxp)<=imag(lowp))) {
message("Upper limits must be > Lower limits");
        ok = false;
        } else if (or(real(x0)>real(maxp))||or(real(x0)<real(lowp))||or(imag(x0)>imag(maxp))||or(imag(x0)<imag(lowp))) {
message("Initial condition x0 should be inside the limits");
        ok = false;
        } else {
        rpar = [[real(maxp.slice())],[real(lowp.slice())],[imag(maxp.slice())],[imag(lowp.slice())]];
        model.nzcross = 2*size(x0,"*");
        model.nmode = 2*size(x0,"*");
}
}
        } else {
        rpar = [];
        model.nzcross = 0;
        model.nmode = 0;
}
        if (ok) {
        model.rpar = rpar;
        if ((Datatype==1)) {
        model.state = real(x0.slice());
        model.sim = list("integral_func",4);
        it = [[1],[ones(reinit,1)]];
        ot = 1;
        } else if ((Datatype==2)) {
        model.state = [[real(x0.slice())],[imag(x0.slice())]];
        model.sim = list("integralz_func",4);
        it = [[2],[2*ones(reinit,1)]];
        ot = 2;
        } else {
message("Datatype is not supported");
        ok = false;
}
        if (ok) {
        in1 = [size(x0,1)*[[1],[ones(reinit,1)]],size(x0,2)*[[1],[ones(reinit,1)]]];
        out = size(x0);
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),ones(reinit,1),[]);
}
}
        if (ok) {
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Linear/PID.sci" */
function PID() {
    PID.prototype.define = function PID() {
        scs_m = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["PID"],tol=[0.0001,0.000001,1.000e-10,100001,0,0],tf=100000,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m.objs[1-1] = scicos_block(gui="INTEGRAL_m",graphics=scicos_graphics(orig=[318.304,183.11733],sz=[40,40],flip=true,theta=0,exprs=[["0"],["0"],["0"],["1"],["-1"]],pin=7,pout=9,pein=[],peout=[],gr_i=[],id="1/s",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("integral_func",4),in1=1,in2=1,intyp=1,out=1,out2=1,outtyp=1,evtin=[],evtout=[],state=0,dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[false,true],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[2-1] = scicos_block(gui="SUMMATION",graphics=scicos_graphics(orig=[387.97067,172.85067],sz=[40,60],flip=true,theta=0,exprs=[["1"],["[1;1;1]"]],pin=[[10],[9],[11]],pout=19,pein=[],peout=[],gr_i=[],id="",in_implicit=[["E"],["E"],["E"]],out_implicit="E"),model=scicos_model(sim=list("summation",4),in1=[[-1],[-1],[-1]],in2=[[-2],[-2],[-2]],intyp=[[1],[1],[1]],out=-1,out2=-2,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[[1],[1],[1]],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[3-1] = scicos_block(gui="GAINBLK",graphics=scicos_graphics(orig=[321.23733,235.91733],sz=[40,40],flip=true,theta=0,exprs="1",pin=17,pout=10,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("gainblk",4),in1=-1,in2=-2,intyp=1,out=-1,out2=-2,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=1,ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[4-1] = scicos_block(gui="DERIV",graphics=scicos_graphics(orig=[319.03733,135.45067],sz=[40,40],flip=true,theta=0,exprs=[],pin=8,pout=11,pein=[],peout=[],gr_i=[],id="s",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("deriv",4),in1=-1,in2=-2,intyp=1,out=-1,out2=-2,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="x",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[5-1] = scicos_block(gui="GAINBLK",graphics=scicos_graphics(orig=[255.23733,183.11733],sz=[40,40],flip=true,theta=0,exprs="1",pin=13,pout=7,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("gainblk",4),in1=-1,in2=-2,intyp=1,out=-1,out2=-2,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=1,ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[6-1] = scicos_block(gui="GAINBLK",graphics=scicos_graphics(orig=[255.23733,135.45067],sz=[40,40],flip=true,theta=0,exprs="1",pin=14,pout=8,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("gainblk",4),in1=-1,in2=-2,intyp=1,out=-1,out2=-2,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=1,ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[7-1] = scicos_link(xx=[[303.80876],[309.73257]],yy=[[203.11733],[203.11733]],id="drawlink",thick=[0,0],ct=[1,1],from=[5,1,0],to=[1,1,1]);
        scs_m.objs[8-1] = scicos_link(xx=[[303.80876],[310.4659]],yy=[[155.45067],[155.45067]],id="drawlink",thick=[0,0],ct=[1,1],from=[6,1,0],to=[4,1,1]);
        scs_m.objs[9-1] = scicos_link(xx=[[366.87543],[379.39924]],yy=[[203.11733],[202.85067]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[2,2,1]);
        scs_m.objs[10-1] = scicos_link(xx=[[369.80876],[379.39924],[379.39924]],yy=[[255.91733],[255.91733],[217.85067]],id="drawlink",thick=[0,0],ct=[1,1],from=[3,1,0],to=[2,1,1]);
        scs_m.objs[11-1] = scicos_link(xx=[[367.60876],[379.39924],[379.39924]],yy=[[155.45067],[155.45067],[187.85067]],id="drawlink",thick=[0,0],ct=[1,1],from=[4,1,0],to=[2,3,1]);
        scs_m.objs[12-1] = scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[[234.704],[203.11733]],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=16,pout=[[13],[14]],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[["E"],["E"],["E"]]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[[-1],[-1],[-1]],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[13-1] = scicos_link(xx=[[234.704],[246.6659]],yy=[[203.11733],[203.11733]],id="drawlink",thick=[0,0],ct=[1,1],from=[12,1,0],to=[5,1,1]);
        scs_m.objs[14-1] = scicos_link(xx=[[234.704],[234.704],[246.6659]],yy=[[203.11733],[155.45067],[155.45067]],id="drawlink",thick=[0,0],ct=[1,1],from=[12,2,0],to=[6,1,1]);
        scs_m.objs[15-1] = scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[[233.97067],[203.11733]],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=21,pout=[[16],[17]],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[["E"],["E"],["E"]]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[[-1],[-1],[-1]],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[16-1] = scicos_link(xx=[[233.97067],[234.704]],yy=[[203.11733],[203.11733]],id="drawlink",thick=[0,0],ct=[1,1],from=[15,1,0],to=[12,1,1]);
        scs_m.objs[17-1] = scicos_link(xx=[[233.97067],[233.97067],[312.6659]],yy=[[203.11733],[255.91733],[255.91733]],id="drawlink",thick=[0,0],ct=[1,1],from=[15,2,0],to=[3,1,1]);
        scs_m.objs[18-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[456.5421,192.85067],sz=[20,20],flip=true,theta=0,exprs="1",pin=19,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[19-1] = scicos_link(xx=[[436.5421],[456.5421]],yy=[[202.85067],[202.85067]],id="drawlink",thick=[0,0],ct=[1,1],from=[2,1,0],to=[18,1,1]);
        scs_m.objs[20-1] = scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[193.97067,193.11733],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=21,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m.objs[21-1] = scicos_link(xx=[[213.97067],[233.97067]],yy=[[203.11733],[203.11733]],id="drawlink",thick=[0,0],ct=[1,1],from=[20,1,0],to=[15,1,1]);
        model = scicos_model();
        model.sim = "csuper";
        model.in1 = -1;
        model.in2 = -2;
        model.out = -1;
        model.out2 = -2;
        model.intyp = 1;
        model.outtyp = 1;
        model.blocktype = "h";
        model.firing = false;
        model.dep_ut = [false,false];
        model.rpar = scs_m;
        gr_i = [];
        x = standard_define([2,2],model,[],gr_i);
    }
    PID.prototype.details = function PID() {
    }
    PID.prototype.get = function PID() {
    }
    PID.prototype.set = function PID() {
        ppath = list(0,0,0);
for (i=1;i<=length(arg1.model.rpar.objs);i+=1) {
        o = arg1.model.rpar.objs[i-1];
        if (typeof(o)=="Link") {
        from = arg1.model.rpar.objs[o.from[1-1]-1];
        to = arg1.model.rpar.objs[o.to[1-1]-1];
        if (from.gui=="GAINBLK") {
        switch (to.gui) {
        case "SUMMATION":
        ppath[1-1] = o.from[1-1];
        case "INTEGRAL_m":
        ppath[2-1] = o.from[1-1];
        case "DERIV":
        ppath[3-1] = o.from[1-1];
}
        } else if (to.gui=="GAINBLK") {
        switch (from.gui) {
        case "SUMMATION":
        ppath[1-1] = o.to[1-1];
        case "INTEGRAL_m":
        ppath[2-1] = o.to[1-1];
        case "DERIV":
        ppath[3-1] = o.to[1-1];
}
}
        if (and(ppath!=list(0,0,0))) {
break;
}
}
}
        newpar = list();
        xx1 = arg1.model.rpar.objs[ppath[1-1]-1];
        exprs[1-1] = xx1.graphics.exprs[1-1];
        p_old = xx1.model.rpar;
        xx2 = arg1.model.rpar.objs[ppath[2-1]-1];
        exprs[2-1] = xx2.graphics.exprs[1-1];
        i_old = xx2.model.rpar;
        xx3 = arg1.model.rpar.objs[ppath[3-1]-1];
        exprs[3-1] = xx3.graphics.exprs[1-1];
        d_old = xx3.model.rpar;
        y = 0;
        while (true) {
        [ok,p,i,d,exprs0] = scicos_getvalue("Set PID parameters",[["Proportional"],["Integral"],["Derivation"]],list("vec",-1,"vec",-1,"vec",-1),exprs);
        if (!ok) {
break;
}
        if (ok) {
        xx1.graphics.exprs = exprs0[1-1];
        xx1.model.rpar = p;
        xx2.graphics.exprs = exprs0[2-1];
        xx2.model.rpar = i;
        xx3.graphics.exprs = exprs0[3-1];
        xx3.model.rpar = d;
        arg1.model.rpar.objs[ppath[1-1]-1] = xx1;
        arg1.model.rpar.objs[ppath[2-1]-1] = xx2;
        arg1.model.rpar.objs[ppath[3-1]-1] = xx3;
break;
}
}
        needcompile = 0;
        if (!(p_old==p&&i_old==i&&d_old==d)) {
        newpar[size(newpar)+1-1] = ppath[1-1];
        newpar[size(newpar)+1-1] = ppath[2-1];
        newpar[size(newpar)+1-1] = ppath[3-1];
        needcompile = 2;
}
        x = arg1;
        y = max(y,needcompile);
        typ = newpar;
    }
}
/* autogenerated from "macros/Linear/REGISTER.sci" */
function REGISTER() {
    REGISTER.prototype.define = function REGISTER() {
        z0 = zeros(10,1);
        model = scicos_model();
        model.sim = list("delay4",4);
        model.in1 = 1;
        model.out = 1;
        model.evtin = 1;
        model.dstate = z0;
        model.blocktype = "d";
        model.dep_ut = [false,false];
        exprs = strcat(string(z0),";");
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    REGISTER.prototype.details = function REGISTER() {
    }
    REGISTER.prototype.get = function REGISTER() {
    }
    REGISTER.prototype.set = function REGISTER() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        if (size(exprs,1)==1) {
        exprs = [[exprs],[sci2exp(1)]];
}
        while (true) {
        [ok,z0,it,exprs] = scicos_getvalue("Set delay parameters",[["Register initial condition"],["Datatype (1=double 3=int32 ...)"]],list("vec",-1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (prod(size(z0))<1) {
message("Register length must be at least 1");
        ok = false;
}
        if (it==1) {
        model.sim = list("delay4",4);
        z0 = double(z0);
        model.dstate = z0;
        model.odstate = list();
        } else {
        if (it==3) {
        model.sim = list("delay4_i32",4);
        z0 = int32(z0);
        } else if (it==4) {
        model.sim = list("delay4_i16",4);
        z0 = int16(z0);
        } else if (it==5) {
        model.sim = list("delay4_i8",4);
        z0 = int8(z0);
        } else if (it==6) {
        model.sim = list("delay4_ui32",4);
        z0 = uint32(z0);
        } else if (it==7) {
        model.sim = list("delay4_ui16",4);
        z0 = uint16(z0);
        } else if (it==8) {
        model.sim = list("delay4_ui8",4);
        z0 = uint8(z0);
        } else {
message("Datatype is not supported");
        ok = false;
}
        model.odstate = list(z0);
        model.dstate = [];
}
        if (ok) {
        in1 = [1,1];
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(in1,it),1,[]);
}
        if (ok) {
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Linear/REGISTER_f.sci" */
function REGISTER_f() {
    REGISTER_f.prototype.define = function REGISTER_f() {
        z0 = zeros(10,1);
        model = scicos_model();
        model.sim = "delay";
        model.in1 = 1;
        model.out = 1;
        model.evtin = 1;
        model.dstate = z0;
        model.blocktype = "d";
        model.dep_ut = [false,false];
        exprs = strcat(string(z0),";");
        gr_i = [];
        x = standard_define([2.5,2.5],model,exprs,gr_i);
    }
    REGISTER_f.prototype.details = function REGISTER_f() {
    }
    REGISTER_f.prototype.get = function REGISTER_f() {
    }
    REGISTER_f.prototype.set = function REGISTER_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,z0,exprs] = scicos_getvalue("Set delay parameters","Register initial condition",list("vec",-1),exprs);
        if (!ok) {
break;
}
        if (prod(size(z0))<1) {
message("Register length must be at least 1");
        ok = false;
}
        if (ok) {
        graphics.exprs = exprs;
        model.dstate = z0;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Linear/SAMPHOLD.sci" */
function SAMPHOLD() {
    SAMPHOLD.prototype.define = function SAMPHOLD() {
        in1 = -1;
        model = scicos_model();
        model.sim = list("samphold4",4);
        model.in1 = -1;
        model.out = -1;
        model.evtin = 1;
        model.blocktype = "d";
        model.dep_ut = [true,false];
        gr_i = [];
        x = standard_define([2,2],model," ",gr_i);
    }
    SAMPHOLD.prototype.details = function SAMPHOLD() {
    }
    SAMPHOLD.prototype.get = function SAMPHOLD() {
    }
    SAMPHOLD.prototype.set = function SAMPHOLD() {
        x = arg1;
        x.model.firing = [];
    }
}
/* autogenerated from "macros/Linear/SAMPHOLD_m.sci" */
function SAMPHOLD_m() {
    SAMPHOLD_m.prototype.define = function SAMPHOLD_m() {
        model = scicos_model();
        model.sim = list("samphold4_m",4);
        model.in1 = -1;
        model.in2 = -2;
        model.intyp = 1;
        model.outtyp = 1;
        model.out = -1;
        model.out2 = -2;
        model.evtin = 1;
        model.blocktype = "d";
        model.dep_ut = [true,false];
        label = [sci2exp(1)];
        gr_i = [];
        x = standard_define([2,2],model,label,gr_i);
    }
    SAMPHOLD_m.prototype.details = function SAMPHOLD_m() {
    }
    SAMPHOLD_m.prototype.get = function SAMPHOLD_m() {
    }
    SAMPHOLD_m.prototype.set = function SAMPHOLD_m() {
        x = arg1;
        x.model.firing = [];
        graphics = arg1.graphics;
        label = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,it,exprs] = scicos_getvalue("Set parameters Block",["Datatype(1=real double 2=Complex 3=int32 ...)"],list("vec",1),label);
        if (!ok) {
break;
}
        if (((it<1)||(it>8))) {
message("Datatype is not supported");
        ok = false;
}
        if (ok) {
        in1 = [model.in1,model.in2];
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(in1,it),1,[]);
        if (ok) {
        graphics.exprs = exprs;
        arg1.graphics = graphics;
        arg1.model = model;
        x = arg1;
break;
}
}
}
    }
}
/* autogenerated from "macros/Linear/SAMPLEHOLD_f.sci" */
function SAMPLEHOLD_f() {
    SAMPLEHOLD_f.prototype.define = function SAMPLEHOLD_f() {
        in1 = -1;
        model = scicos_model();
        model.sim = "samphold";
        model.in1 = -1;
        model.out = -1;
        model.evtin = 1;
        model.blocktype = "d";
        model.dep_ut = [true,false];
        gr_i = [];
        x = standard_define([2,2],model," ",gr_i);
    }
    SAMPLEHOLD_f.prototype.details = function SAMPLEHOLD_f() {
    }
    SAMPLEHOLD_f.prototype.get = function SAMPLEHOLD_f() {
    }
    SAMPLEHOLD_f.prototype.set = function SAMPLEHOLD_f() {
        x = arg1;
        x.model.firing = [];
    }
}
/* autogenerated from "macros/Linear/SOM_f.sci" */
function SOM_f() {
    SOM_f.prototype.define = function SOM_f() {
        sgn = [[1],[1],[1]];
        model = scicos_model();
        model.sim = list("sum",2);
        model.in1 = [[-1],[-1],[-1]];
        model.out = -1;
        model.rpar = sgn;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[sci2exp(1)],[sci2exp(sgn)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    SOM_f.prototype.details = function SOM_f() {
    }
    SOM_f.prototype.get = function SOM_f() {
    }
    SOM_f.prototype.set = function SOM_f() {
        x = arg1;
        graphics = arg1.graphics;
        model = arg1.model;
        exprs = graphics.exprs;
        if (size(exprs,"*")==2) {
        exprs = exprs[2-1];
}
        if (size(exprs,"*")!=3) {
        exprs = string(model.rpar);
}
        if (graphics.flip) {
        labs = ["down","left","up"];
        } else {
        labs = ["down","right","up"];
}
        str = [["This sum block is obsolete","parameters cannot be modified. Please replace it with new sum block"],["and gain blocks in the linear palette"," ","Input ports are located at up, side and  down positions.","Current gains are:"]];
        str = [[str],[(part(labs.slice(),1,7)+exprs.slice())]];
message(str);
    }
}
/* autogenerated from "macros/Linear/SUMMATION.sci" */
function SUMMATION() {
    SUMMATION.prototype.define = function SUMMATION() {
        sgn = [[1],[-1]];
        model = scicos_model();
        model.sim = list("summation",4);
        model.in1 = [[-1],[-1]];
        model.out = -1;
        model.in2 = [[-2],[-2]];
        model.out2 = -2;
        model.ipar = sgn;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = sci2exp(sgn);
        gr_i = [];
        x = standard_define([2,3],model,exprs,gr_i);
    }
    SUMMATION.prototype.details = function SUMMATION() {
    }
    SUMMATION.prototype.get = function SUMMATION() {
    }
    SUMMATION.prototype.set = function SUMMATION() {
        x = arg1;
        graphics = arg1.graphics;
        model = arg1.model;
        exprs = graphics.exprs;
        if (size(exprs,1)==1) {
        exprs = [[sci2exp(1)],[exprs],[sci2exp(0)]];
        } else if (size(exprs,1)==2) {
        exprs = [[exprs],[sci2exp(0)]];
}
        while (true) {
        [ok,Datatype,sgn,satur,exprs] = scicos_getvalue("Set sum block parameters",[["Datatype (1=real double  2=complex 3=int32 ...)"],["Number of inputs or sign vector (of +1, -1)"],["Do on Overflow(0=Nothing 1=Saturate 2=Error)"]],list("vec",1,"vec",-1,"vec",1),exprs);
        if (!ok) {
break;
}
        sgn = sgn.slice();
        if ((satur!=0&&satur!=1&&satur!=2)) {
message("Do on overflow must be 0,1,2");
        ok = false;
}
        if (size(sgn,1)==1) {
        if (sgn<1) {
message("Number of inputs must be > 0");
        ok = false;
        } else if (sgn==1) {
        in1 = -1;
        in2 = -2;
        sgn = [];
        nout = 1;
        nout2 = 1;
        } else {
        in1 = -ones(sgn,1);
        in2 = 2*in1;
        sgn = ones(sgn,1);
        nout = -1;
        nout2 = -2;
}
        } else {
        if (!and(abs(sgn)==1)) {
message("Signs can only be +1 or -1");
        ok = false;
        } else {
        in1 = -ones(size(sgn,1),1);
        in2 = 2*in1;
        nout = -1;
        nout2 = -2;
}
}
        it = Datatype*ones(1,size(in1,1));
        ot = Datatype;
        if (Datatype==1) {
        model.sim = list("summation",4);
        } else if (Datatype==2) {
        model.sim = list("summation_z",4);
        } else if (((Datatype<1)||(Datatype>8))) {
message("Datatype is not supported");
        ok = false;
        } else {
        if (satur==0) {
        if (Datatype==3) {
        model.sim = list("summation_i32n",4);
        } else if (Datatype==4) {
        model.sim = list("summation_i16n",4);
        } else if (Datatype==5) {
        model.sim = list("summation_i8n",4);
        } else if (Datatype==6) {
        model.sim = list("summation_ui32n",4);
        } else if (Datatype==7) {
        model.sim = list("summation_ui16n",4);
        } else if (Datatype==8) {
        model.sim = list("summation_ui8n",4);
}
        } else if (satur==1) {
        if (Datatype==3) {
        model.sim = list("summation_i32s",4);
        } else if (Datatype==4) {
        model.sim = list("summation_i16s",4);
        } else if (Datatype==5) {
        model.sim = list("summation_i8s",4);
        } else if (Datatype==6) {
        model.sim = list("summation_ui32s",4);
        } else if (Datatype==7) {
        model.sim = list("summation_ui16s",4);
        } else if (Datatype==8) {
        model.sim = list("summation_ui8s",4);
}
        } else if (satur==2) {
        if (Datatype==3) {
        model.sim = list("summation_i32e",4);
        } else if (Datatype==4) {
        model.sim = list("summation_i16e",4);
        } else if (Datatype==5) {
        model.sim = list("summation_i8e",4);
        } else if (Datatype==6) {
        model.sim = list("summation_ui32e",4);
        } else if (Datatype==7) {
        model.sim = list("summation_ui16e",4);
        } else if (Datatype==8) {
        model.sim = list("summation_ui8e",4);
}
}
}
        if (ok) {
        [model,graphics,ok] = set_io(model,graphics,list([in1,in2],it),list([nout,nout2],ot),[],[]);
}
        if (ok) {
        model.rpar = satur;
        model.ipar = sgn;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Linear/SUM_f.sci" */
function SUM_f() {
    SUM_f.prototype.define = function SUM_f() {
        model = scicos_model();
        model.sim = list("plusblk",2);
        model.in1 = [[-1],[-1],[-1]];
        model.out = -1;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        gr_i = [];
        exprs = [];
        x = standard_define([1,1],model,exprs,gr_i);
    }
    SUM_f.prototype.details = function SUM_f() {
    }
    SUM_f.prototype.get = function SUM_f() {
    }
    SUM_f.prototype.set = function SUM_f() {
        x = arg1;
    }
}
/* autogenerated from "macros/Linear/TCLSS.sci" */
function TCLSS() {
    TCLSS.prototype.define = function TCLSS() {
        x0 = 0;
        A = 0;
        B = 1;
        C = 1;
        D = 0;
        in1 = 1;
        nx = size(x0,"*");
        out = 1;
        model = scicos_model();
        model.sim = list("tcslti4",4);
        model.in1 = [[in1],[nx]];
        model.out = out;
        model.evtin = 1;
        model.state = x0;
        model.rpar = [[A.slice()],[B.slice()],[C.slice()],[D.slice()]];
        model.blocktype = "c";
        model.dep_ut = [false,true];
        exprs = [[strcat(sci2exp(A))],[strcat(sci2exp(B))],[strcat(sci2exp(C))],[strcat(sci2exp(D))],[strcat(sci2exp(x0))]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    TCLSS.prototype.details = function TCLSS() {
    }
    TCLSS.prototype.get = function TCLSS() {
    }
    TCLSS.prototype.set = function TCLSS() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        if (size(exprs,"*")==7) {
        exprs = exprs[[1:4,7]-1];
}
        while (true) {
        [ok,A,B,C,D,x0,exprs] = scicos_getvalue("Set continuous linear system parameters",[["A matrix"],["B matrix"],["C matrix"],["D matrix"],["Initial state"]],list("mat",[-1,-1],"mat",["size(%1,2)","-1"],"mat",["-1","size(%1,2)"],"mat",[-1,-1],"vec","size(%1,2)"),exprs);
        if (!ok) {
break;
}
        out = size(C,1);
        if (out==0) {
        out = [];
}
        in1 = size(B,2);
        if (in1==0) {
        in1 = [];
}
        [ms,ns] = size(A);
        if (ms!=ns) {
message("A matrix must be square");
        } else {
        [model,graphics,ok] = check_io(model,graphics,[[in1],[ms]],out,1,[]);
        if (ok) {
        graphics.exprs = exprs;
        rpar = [[A.slice()],[B.slice()],[C.slice()],[D.slice()]];
        if (D!=[]) {
        if (norm(D,1)!=0) {
        mmm = [true,true];
        } else {
        mmm = [false,true];
}
        if (or(model.dep_ut!=mmm)) {
        model.dep_ut = mmm;
}
        } else {
        model.dep_ut = [false,true];
}
        model.state = x0.slice();
        model.rpar = rpar;
        if (D!=[]) {
        model.sim = list("tcslti4",4);
        } else {
        model.sim = list("tcsltj4",4);
}
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/Linear/TCLSS_f.sci" */
function TCLSS_f() {
    TCLSS_f.prototype.define = function TCLSS_f() {
        x0 = 0;
        A = 0;
        B = 1;
        C = 1;
        D = 0;
        in1 = 1;
        nx = size(x0,"*");
        out = 1;
        model = scicos_model();
        model.sim = list("tcslti",1);
        model.in1 = [[in1],[nx]];
        model.out = out;
        model.evtin = 1;
        model.state = x0;
        model.rpar = [[A.slice()],[B.slice()],[C.slice()],[D.slice()]];
        model.blocktype = "c";
        model.dep_ut = [false,true];
        exprs = [[strcat(sci2exp(A))],[strcat(sci2exp(B))],[strcat(sci2exp(C))],[strcat(sci2exp(D))],[strcat(sci2exp(x0))]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    TCLSS_f.prototype.details = function TCLSS_f() {
    }
    TCLSS_f.prototype.get = function TCLSS_f() {
    }
    TCLSS_f.prototype.set = function TCLSS_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        if (size(exprs,"*")==7) {
        exprs = exprs[[1:4,7]-1];
}
        while (true) {
        [ok,A,B,C,D,x0,exprs] = scicos_getvalue("Set continuous linear system parameters",[["A matrix"],["B matrix"],["C matrix"],["D matrix"],["Initial state"]],list("mat",[-1,-1],"mat",["size(%1,2)","-1"],"mat",["-1","size(%1,2)"],"mat",[-1,-1],"vec","size(%1,2)"),exprs);
        if (!ok) {
break;
}
        out = size(C,1);
        if (out==0) {
        out = [];
}
        in1 = size(B,2);
        if (in1==0) {
        in1 = [];
}
        [ms,ns] = size(A);
        if (ms!=ns) {
message("A matrix must be square");
        } else {
        [model,graphics,ok] = check_io(model,graphics,[[in1],[ms]],out,1,[]);
        if (ok) {
        graphics.exprs = exprs;
        rpar = [[A.slice()],[B.slice()],[C.slice()],[D.slice()]];
        if (D!=[]) {
        if (norm(D,1)!=0) {
        mmm = [true,true];
        } else {
        mmm = [false,true];
}
        if (or(model.dep_ut!=mmm)) {
        model.dep_ut = mmm;
}
        } else {
        model.dep_ut = [false,true];
}
        model.state = x0.slice();
        model.rpar = rpar;
        if (D!=[]) {
        model.sim = list("tcslti",1);
        } else {
        model.sim = list("tcsltj",1);
}
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/Linear/TIME_DELAY.sci" */
function TIME_DELAY() {
    TIME_DELAY.prototype.define = function TIME_DELAY() {
        nin = 1;
        T = 1;
        init = 0;
        N = 1024;
        model = scicos_model();
        model.sim = list("time_delay",4);
        model.in1 = [nin];
        model.out = nin;
        model.rpar = [T,init];
        model.ipar = N;
        model.blocktype = "x";
        model.dep_ut = [false,true];
        exprs = [[string(T)],[string(init)],[string(N)]];
        gr_i = [];
        x = standard_define([3.5,2],model,exprs,gr_i);
    }
    TIME_DELAY.prototype.details = function TIME_DELAY() {
    }
    TIME_DELAY.prototype.get = function TIME_DELAY() {
    }
    TIME_DELAY.prototype.set = function TIME_DELAY() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        nin = model.in1[1-1];
        while (true) {
        [ok,T,init,N,exprs] = scicos_getvalue("Set delay parameters",[["Delay"],["initial input"],["Buffer size"]],list("vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (N<2) {
message("Buffer must be larger than 2");
        ok = false;
}
        if (T<=0) {
message("Delay must be positive");
        ok = false;
}
        if (ok) {
        [model,graphics,ok] = check_io(model,graphics,[-1],-1,[],[]);
}
        if (ok) {
        graphics.exprs = exprs;
        model.rpar = [[T],[init]];
        model.ipar = N;
        model.dep_ut = [false,true];
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Linear/VARIABLE_DELAY.sci" */
function VARIABLE_DELAY() {
    VARIABLE_DELAY.prototype.define = function VARIABLE_DELAY() {
        nin = 1;
        T = 1;
        init = 0;
        N = 1024;
        model = scicos_model();
        model.sim = list("variable_delay",4);
        model.in1 = [[nin],[1]];
        model.out = nin;
        model.rpar = [T,init];
        model.ipar = N;
        model.blocktype = "d";
        model.dep_ut = [false,false];
        exprs = [[string(T)],[string(init)],[string(N)]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    VARIABLE_DELAY.prototype.details = function VARIABLE_DELAY() {
    }
    VARIABLE_DELAY.prototype.get = function VARIABLE_DELAY() {
    }
    VARIABLE_DELAY.prototype.set = function VARIABLE_DELAY() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        nin = model.in1[1-1];
        while (true) {
        [ok,T,init,N,exprs] = scicos_getvalue("Set delay parameters",[["Max delay"],["initial input"],["Buffer size"]],list("vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (N<2) {
message("Buffer must be larger than 2");
        ok = false;
}
        if (T<=0) {
message("Delay must be positive");
        ok = false;
}
        if (ok) {
        [model,graphics,ok] = check_io(model,graphics,[[-1],[1]],-1,[],[]);
}
        if (ok) {
        graphics.exprs = exprs;
        model.rpar = [[T],[init]];
        model.ipar = N;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/CUMSUM.sci" */
function CUMSUM() {
    CUMSUM.prototype.define = function CUMSUM() {
        model = scicos_model();
        function_name = "cumsum_m";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in1 = -1;
        model.in2 = -2;
        model.intyp = 1;
        model.out = -1;
        model.out2 = -2;
        model.outtyp = 1;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = [[sci2exp(1)],[sci2exp(0)]];
        gr_i = [];
        x = standard_define([3,2],model,label,gr_i);
    }
    CUMSUM.prototype.details = function CUMSUM() {
    }
    CUMSUM.prototype.get = function CUMSUM() {
    }
    CUMSUM.prototype.set = function CUMSUM() {
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        label = graphics.exprs;
        if (size(label,"*")==14) {
        label[9-1] = [];
}
        while (true) {
        [ok,typ,decomptyp,lab] = scicos_getvalue("Set CUMSUM block parameters",[["Datatype(1=real double  2=Complex)"],["Sum along (0=the first non singleton dimension  1=Rows  2=Columns)"]],list("vec",1,"vec",1),label);
        if (!ok) {
break;
}
        label = lab;
        if ((typ==1)) {
        if ((decomptyp==0)) {
        function_name = "cumsum_m";
        out = [-1,-2];
        } else if ((decomptyp==1)) {
        function_name = "cumsum_r";
        out = [-1,1];
        } else if ((decomptyp==2)) {
        function_name = "cumsum_c";
        out = [1,-2];
        } else {
message("decomposition type is not supported");
        ok = false;
}
        it = 1;
        ot = 1;
        } else if ((typ==2)) {
        if ((decomptyp==0)) {
        function_name = "cumsumz_m";
        } else if ((decomptyp==1)) {
        function_name = "cumsumz_r";
        } else if ((decomptyp==2)) {
        function_name = "cumsumz_c";
        } else {
message("decomposition type is not supported");
        ok = false;
}
        it = 2;
        ot = 2;
        } else {
message("Datatype is not supported");
        ok = false;
}
        in1 = [model.in1,model.in2];
        out = [model.out,model.out2];
        funtyp = 4;
        if (ok) {
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
        if (ok) {
        model.sim = list(function_name,funtyp);
        arg1.model = model;
        graphics.exprs = label;
        arg1.graphics = graphics;
        x = arg1;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/EXTRACT.sci" */
function EXTRACT() {
    EXTRACT.prototype.define = function EXTRACT() {
        model = scicos_model();
        function_name = "extract";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in1 = -1;
        model.in2 = -2;
        model.intyp = 1;
        model.out = 1;
        model.out2 = 1;
        model.outtyp = 1;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [1,1,1,1];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = [[sci2exp(1)],[sci2exp([1])],[sci2exp([1])]];
        gr_i = [];
        x = standard_define([3,2],model,label,gr_i);
    }
    EXTRACT.prototype.details = function EXTRACT() {
    }
    EXTRACT.prototype.get = function EXTRACT() {
    }
    EXTRACT.prototype.set = function EXTRACT() {
        x = arg1;
        graphics = arg1.graphics;
        label = graphics.exprs;
        model = arg1.model;
        if (size(label,"*")==14) {
        label[9-1] = [];
}
        while (true) {
        [ok,typ,a,b,exprs] = scicos_getvalue("Set EXTRACT Block",[["Datatype (1=real double  2=Complex)"],["Lines to extract"],["Columns to extract"]],list("vec",1,"mat",[1,-1],"mat",[1,-1]),label);
        a = a.slice();
        b = b.slice();
        if (!ok) {
break;
}
        if ((typ==1)) {
        function_name = "extract";
        ot = 1;
        it = 1;
        } else if ((typ==2)) {
        function_name = "extractz";
        ot = 2;
        it = 2;
        } else {
message("Datatype is not supported");
        ok = false;
}
        ma = size(a,1);
        mb = size(b,1);
        if ((ma==0||mb==0)) {
message("empty field");
        ok = false;
}
for (i=1;i<=ma;i+=1) {
        if ((a[i-1]<=0)) {
message("invalid index");
        ok = false;
}
}
for (j=1;j<=mb;j+=1) {
        if ((b[j-1]<=0)) {
message("invalid index");
        ok = false;
}
}
        model.ipar = [[a],[b],[ma],[mb]];
        in1 = [model.in1,model.in2];
        out = [ma,mb];
        funtyp = 4;
        if (ok) {
        label = exprs;
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
        model.sim = list(function_name,funtyp);
        graphics.exprs = label;
        arg1.graphics = graphics;
        arg1.model = model;
        x = arg1;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/EXTTRI.sci" */
function EXTTRI() {
    EXTTRI.prototype.define = function EXTTRI() {
        model = scicos_model();
        function_name = "extrilz";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in1 = -1;
        model.in2 = -2;
        model.intyp = 1;
        model.out = -1;
        model.out2 = -2;
        model.outtyp = 1;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = [[sci2exp(1)],[sci2exp(1)]];
        gr_i = [];
        x = standard_define([3,2],model,label,gr_i);
    }
    EXTTRI.prototype.details = function EXTTRI() {
    }
    EXTTRI.prototype.get = function EXTTRI() {
    }
    EXTTRI.prototype.set = function EXTTRI() {
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        label = graphics.exprs;
        if (size(label,"*")==14) {
        label[9-1] = [];
}
        while (true) {
        [ok,typ,decomptyp,lab] = scicos_getvalue("Set EXTTRI block parameters",[["Datatype(1=real double  2=Complex)"],["extraction type (1=lower  2=upper  3=diagonal)"]],list("vec",1,"vec",1),label);
        if (!ok) {
break;
}
        label = lab;
        if ((typ==1)) {
        if ((decomptyp==1)) {
        function_name = "exttril";
        } else if ((decomptyp==2)) {
        function_name = "exttriu";
        } else if ((decomptyp==3)) {
        function_name = "extdiag";
        } else {
message("decomposition type is not supported");
        ok = false;
}
        it = 1;
        ot = 1;
        } else if ((typ==2)) {
        if ((decomptyp==1)) {
        function_name = "exttrilz";
        } else if ((decomptyp==2)) {
        function_name = "exttriuz";
        } else if ((decomptyp==3)) {
        function_name = "extdiagz";
        } else {
message("decomposition type is not supported");
        ok = false;
}
        it = 2;
        ot = 2;
        } else {
message("Datatype is not supported");
        ok = false;
}
        in1 = [model.in1,model.in2];
        out = [model.out,model.out2];
        funtyp = 4;
        if (ok) {
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
        if (ok) {
        model.sim = list(function_name,funtyp);
        arg1.model = model;
        graphics.exprs = label;
        arg1.graphics = graphics;
        x = arg1;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/MATBKSL.sci" */
function MATBKSL() {
    MATBKSL.prototype.define = function MATBKSL() {
        model = scicos_model();
        function_name = "mat_bksl";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in1 = [[-1],[-1]];
        model.in2 = [[-2],[-3]];
        model.intyp = [1,1];
        model.out = -2;
        model.out2 = -3;
        model.outtyp = 1;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = [sci2exp(1)];
        gr_i = [];
        x = standard_define([2,2],model,label,gr_i);
    }
    MATBKSL.prototype.details = function MATBKSL() {
    }
    MATBKSL.prototype.get = function MATBKSL() {
    }
    MATBKSL.prototype.set = function MATBKSL() {
        x = arg1;
        graphics = arg1.graphics;
        label = graphics.exprs;
        model = arg1.model;
        if (size(label,"*")==14) {
        label[9-1] = [];
}
        while (true) {
        [ok,typ,exprs] = scicos_getvalue("Set MATBKSL Block",["Datatype (1=real double  2=Complex)"],list("vec",1),label);
        if (!ok) {
break;
}
        if ((typ==1)) {
        function_name = "mat_bksl";
        ot = 1;
        it = [1,1];
        } else if ((typ==2)) {
        function_name = "matz_bksl";
        ot = 2;
        it = [2,2];
        } else {
message("Datatype is not supported");
        ok = false;
}
        in1 = [model.in1,model.in2];
        out = [model.out,model.out2];
        funtyp = 4;
        if (ok) {
        label = exprs;
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
        model.sim = list(function_name,funtyp);
        graphics.exprs = label;
        arg1.graphics = graphics;
        arg1.model = model;
        x = arg1;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/MATCATH.sci" */
function MATCATH() {
    MATCATH.prototype.define = function MATCATH() {
        model = scicos_model();
        function_name = "mat_cath";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in1 = [[-1],[-1]];
        model.in2 = [[-2],[-3]];
        model.intyp = [1,1];
        model.out = -1;
        model.out2 = 0;
        model.outtyp = -1;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = [sci2exp(2)];
        gr_i = [];
        x = standard_define([2,3],model,label,gr_i);
    }
    MATCATH.prototype.details = function MATCATH() {
    }
    MATCATH.prototype.get = function MATCATH() {
    }
    MATCATH.prototype.set = function MATCATH() {
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        label = graphics.exprs;
        if (size(label,"*")>1) {
        label = "size(evstr("+label[2-1]+"),\'*\')";
}
        while (true) {
        [ok,nin,lab] = scicos_getvalue("Set MATCATH block parameters",["Number of input"],list("vec",1),label);
        if (!ok) {
break;
}
        label = lab;
        in1 = [-1*(ones(nin,1)),-(transpose([2:nin+1]))];
        out = [-1,0];
        it = -1*(ones(nin,1));
        ot = -1;
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
        if (ok) {
        funtyp = 4;
        model.sim = list("mat_cath",funtyp);
        graphics.exprs = label;
        arg1.graphics = graphics;
        arg1.model = model;
        x = arg1;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/MATCATV.sci" */
function MATCATV() {
    MATCATV.prototype.define = function MATCATV() {
        l1 = [[2],[2]];
        model = scicos_model();
        function_name = "mat_catv";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in2 = [[-1],[-1]];
        model.in1 = [[-2],[-3]];
        model.intyp = [-1,-1];
        model.out = 0;
        model.out2 = -1;
        model.outtyp = -1;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = [sci2exp(2)];
        gr_i = [];
        x = standard_define([2,3],model,label,gr_i);
    }
    MATCATV.prototype.details = function MATCATV() {
    }
    MATCATV.prototype.get = function MATCATV() {
    }
    MATCATV.prototype.set = function MATCATV() {
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        label = graphics.exprs;
        if (size(label,"*")>1) {
        label = "size(evstr("+label[2-1]+"),\'*\')";
}
        while (true) {
        [ok,nin,lab] = scicos_getvalue("Set MATCATV block parameters",["Number od inputs"],list("vec",1),label);
        if (!ok) {
break;
}
        label = lab;
        in1 = [-(transpose([2:nin+1])),-ones(nin,1)];
        it = -ones(nin,1);
        ot = -1;
        out = [0,-1];
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
        if (ok) {
        funtyp = 4;
        model.sim = list("mat_catv",funtyp);
        graphics.exprs = label;
        arg1.graphics = graphics;
        arg1.model = model;
        x = arg1;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/MATDET.sci" */
function MATDET() {
    MATDET.prototype.define = function MATDET() {
        model = scicos_model();
        function_name = "mat_det";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in1 = -1;
        model.in2 = -1;
        model.intyp = 1;
        model.out = 1;
        model.out2 = 1;
        model.outtyp = 1;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = [sci2exp(1)];
        gr_i = [];
        x = standard_define([2,2],model,label,gr_i);
    }
    MATDET.prototype.details = function MATDET() {
    }
    MATDET.prototype.get = function MATDET() {
    }
    MATDET.prototype.set = function MATDET() {
        x = arg1;
        graphics = arg1.graphics;
        label = graphics.exprs;
        model = arg1.model;
        if (size(label,"*")==14) {
        label[9-1] = [];
}
        while (true) {
        [ok,typ,exprs] = scicos_getvalue("Set MATDET Block",["Datatype(1=real double  2=Complex)"],list("vec",1),label);
        if (!ok) {
break;
}
        if ((typ==1)) {
        function_name = "mat_det";
        ot = 1;
        it = 1;
        } else if ((typ==2)) {
        function_name = "matz_det";
        ot = 2;
        it = 2;
        } else {
message("Datatype is not supported");
        ok = false;
}
        in1 = [model.in1,model.in2];
        out = [model.out,model.out2];
        funtyp = 4;
        if (ok) {
        label = exprs;
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
        model.sim = list(function_name,funtyp);
        graphics.exprs = label;
        arg1.graphics = graphics;
        arg1.model = model;
        x = arg1;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/MATDIAG.sci" */
function MATDIAG() {
    MATDIAG.prototype.define = function MATDIAG() {
        model = scicos_model();
        function_name = "mat_diag";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in1 = -1;
        model.in2 = 1;
        model.intyp = 1;
        model.out = -1;
        model.out2 = -1;
        model.outtyp = 1;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = [sci2exp(1)];
        gr_i = [];
        x = standard_define([2,2],model,label,gr_i);
    }
    MATDIAG.prototype.details = function MATDIAG() {
    }
    MATDIAG.prototype.get = function MATDIAG() {
    }
    MATDIAG.prototype.set = function MATDIAG() {
        x = arg1;
        graphics = arg1.graphics;
        label = graphics.exprs;
        model = arg1.model;
        if (size(label,"*")==14) {
        label[9-1] = [];
}
        while (true) {
        [ok,typ,exprs] = scicos_getvalue("Set MATDIAG Block",["Datatype (1=real double  2=Complex)"],list("vec",1),label);
        if (!ok) {
break;
}
        if ((typ==1)) {
        function_name = "mat_diag";
        ot = 1;
        it = 1;
        } else if ((typ==2)) {
        function_name = "matz_diag";
        ot = 2;
        it = 2;
        } else {
message("Datatype is not supported");
        ok = false;
}
        in1 = [model.in1,model.in2];
        out = [model.out,model.out2];
        funtyp = 4;
        if (ok) {
        label = exprs;
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
        model.sim = list(function_name,funtyp);
        graphics.exprs = label;
        arg1.graphics = graphics;
        arg1.model = model;
        x = arg1;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/MATDIV.sci" */
function MATDIV() {
    MATDIV.prototype.define = function MATDIV() {
        model = scicos_model();
        function_name = "mat_div";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in1 = [[-1],[-2]];
        model.in2 = [[-3],[-3]];
        model.intyp = [1,1];
        model.out = -1;
        model.out2 = -2;
        model.outtyp = 1;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = [sci2exp(1)];
        gr_i = [];
        x = standard_define([2,2],model,label,gr_i);
    }
    MATDIV.prototype.details = function MATDIV() {
    }
    MATDIV.prototype.get = function MATDIV() {
    }
    MATDIV.prototype.set = function MATDIV() {
        x = arg1;
        graphics = arg1.graphics;
        label = graphics.exprs;
        model = arg1.model;
        if (size(label,"*")==14) {
        label[9-1] = [];
}
        while (true) {
        [ok,typ,exprs] = scicos_getvalue("Set MATDIV Block",["Datatype(1=real double  2=Complex)"],list("vec",1),label);
        if (!ok) {
break;
}
        if ((typ==1)) {
        function_name = "mat_div";
        ot = 1;
        it = [1,1];
        } else if ((typ==2)) {
        function_name = "matz_div";
        ot = 2;
        it = [2,2];
        } else {
message("Datatype is not supported");
        ok = false;
}
        in1 = [model.in1,model.in2];
        out = [model.out,model.out2];
        funtyp = 4;
        if (ok) {
        label = exprs;
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
        model.sim = list(function_name,funtyp);
        graphics.exprs = label;
        arg1.graphics = graphics;
        arg1.model = model;
        x = arg1;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/MATEIG.sci" */
function MATEIG() {
    MATEIG.prototype.define = function MATEIG() {
        model = scicos_model();
        function_name = "mat_vps";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in1 = -1;
        model.in2 = -1;
        model.intyp = 1;
        model.out = -1;
        model.out2 = 1;
        model.outtyp = 2;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = [[sci2exp(1)],[sci2exp(1)]];
        gr_i = [];
        x = standard_define([2,2],model,label,gr_i);
    }
    MATEIG.prototype.details = function MATEIG() {
    }
    MATEIG.prototype.get = function MATEIG() {
    }
    MATEIG.prototype.set = function MATEIG() {
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        label = graphics.exprs;
        if (size(label,"*")==14) {
        label[9-1] = [];
}
        while (true) {
        [ok,typ,decomptyp,lab] = scicos_getvalue("Set MATEIG block parameters",[["Datatype(1=real double  2=Complex)"],["decomposition type (1=eig values  2=eig values+eig vectors"]],list("vec",1,"vec",1),label);
        if (!ok) {
break;
}
        label = lab;
        if ((typ==1)) {
        if ((decomptyp==1)) {
        function_name = "mat_vps";
        out = [-1,1];
        ot = 2;
        } else if ((decomptyp==2)) {
        function_name = "mat_vpv";
        out = [[-1,-1],[-1,-1]];
        ot = [2,2];
        } else {
message("decomposition type is not supported");
        ok = false;
}
        it = 1;
        } else if ((typ==2)) {
        if ((decomptyp==1)) {
        function_name = "matz_vps";
        out = [-1,1];
        ot = 2;
        } else if ((decomptyp==2)) {
        function_name = "matz_vpv";
        out = [[-1,-1],[-1,-1]];
        ot = [2,2];
        } else {
message("decomposition type is not supported");
        ok = false;
}
        it = 2;
        } else {
message("Datatype is not supported");
        ok = false;
}
        in1 = [-1,-1];
        funtyp = 4;
        if (ok) {
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
        if (ok) {
        model.sim = list(function_name,funtyp);
        arg1.model = model;
        graphics.exprs = label;
        arg1.graphics = graphics;
        x = arg1;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/MATEXPM.sci" */
function MATEXPM() {
    MATEXPM.prototype.define = function MATEXPM() {
        model = scicos_model();
        function_name = "mat_expm";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in1 = -1;
        model.in2 = -1;
        model.intyp = 1;
        model.out = -1;
        model.out2 = -1;
        model.outtyp = 1;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = [sci2exp(1)];
        gr_i = [];
        x = standard_define([2,2],model,label,gr_i);
    }
    MATEXPM.prototype.details = function MATEXPM() {
    }
    MATEXPM.prototype.get = function MATEXPM() {
    }
    MATEXPM.prototype.set = function MATEXPM() {
        x = arg1;
        graphics = arg1.graphics;
        label = graphics.exprs;
        model = arg1.model;
        if (size(label,"*")==14) {
        label[9-1] = [];
}
        while (true) {
        [ok,typ,exprs] = scicos_getvalue("Set EXPM Block",["Datatype(1=real double  2=Complex)"],list("vec",1),label);
        if (!ok) {
break;
}
        if ((typ==1)) {
        function_name = "mat_expm";
        ot = 1;
        it = 1;
        } else if ((typ==2)) {
        function_name = "matz_expm";
        ot = 2;
        it = 2;
        } else {
message("Datatype is not supported");
        ok = false;
}
        in1 = [model.in1,model.in2];
        out = [model.out,model.out2];
        funtyp = 4;
        if (ok) {
        label = exprs;
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
        model.sim = list(function_name,funtyp);
        graphics.exprs = label;
        arg1.graphics = graphics;
        arg1.model = model;
        x = arg1;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/MATINV.sci" */
function MATINV() {
    MATINV.prototype.define = function MATINV() {
        model = scicos_model();
        function_name = "mat_inv";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in1 = -1;
        model.in2 = -1;
        model.intyp = 1;
        model.out = -1;
        model.out2 = -1;
        model.outtyp = 1;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = [sci2exp(1)];
        gr_i = [];
        x = standard_define([2,2],model,label,gr_i);
    }
    MATINV.prototype.details = function MATINV() {
    }
    MATINV.prototype.get = function MATINV() {
    }
    MATINV.prototype.set = function MATINV() {
        x = arg1;
        graphics = arg1.graphics;
        label = graphics.exprs;
        model = arg1.model;
        if (size(label,"*")==14) {
        label[9-1] = [];
}
        while (true) {
        [ok,typ,exprs] = scicos_getvalue("Set MATINV Block",["Datatype(1=real double  2=Complex)"],list("vec",1),label);
        if (!ok) {
break;
}
        if ((typ==1)) {
        function_name = "mat_inv";
        ot = 1;
        it = 1;
        } else if ((typ==2)) {
        function_name = "matz_inv";
        ot = 2;
        it = 2;
        } else {
message("Datatype is not supported");
        ok = false;
}
        in1 = [model.in1,model.in2];
        out = [model.out,model.out2];
        funtyp = 4;
        if (ok) {
        label = exprs;
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
        model.sim = list(function_name,funtyp);
        graphics.exprs = label;
        arg1.graphics = graphics;
        arg1.model = model;
        x = arg1;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/MATLU.sci" */
function MATLU() {
    MATLU.prototype.define = function MATLU() {
        model = scicos_model();
        function_name = "mat_lu";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in1 = -1;
        model.in2 = -1;
        model.intyp = 1;
        model.out = [[-1],[-1]];
        model.out2 = [[-1],[-1]];
        model.outtyp = [1,1];
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = sci2exp(1);
        gr_i = [];
        x = standard_define([2,2],model,label,gr_i);
    }
    MATLU.prototype.details = function MATLU() {
    }
    MATLU.prototype.get = function MATLU() {
    }
    MATLU.prototype.set = function MATLU() {
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        label = graphics.exprs;
        if (size(label,"*")==14) {
        label[9-1] = [];
}
        while (true) {
        [ok,typ,lab] = scicos_getvalue("Set MATLU block parameters",["Datatype(1=real double  2=Complex)"],list("vec",1),label);
        if (!ok) {
break;
}
        if ((typ==1)) {
        function_name = "mat_lu";
        ot = [1,1];
        it = 1;
        } else if ((typ==2)) {
        function_name = "matz_lu";
        ot = [2,2];
        it = 2;
        } else {
message("Datatype is not supported");
        ok = false;
}
        if (ok) {
        [model,graphics,ok] = set_io(model,graphics,list([model.in1,model.in2],it),list([model.out,model.out2],ot),[],[]);
}
        if (ok) {
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        graphics.exprs = lab;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/MATMAGPHI.sci" */
function MATMAGPHI() {
    MATMAGPHI.prototype.define = function MATMAGPHI() {
        model = scicos_model();
        function_name = "matz_abs";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in1 = -1;
        model.in2 = -2;
        model.intyp = 2;
        model.out = [[-1],[-1]];
        model.out2 = [[-2],[-2]];
        model.outtyp = [1,1];
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = [sci2exp(1)];
        gr_i = [];
        x = standard_define([3,2],model,label,gr_i);
    }
    MATMAGPHI.prototype.details = function MATMAGPHI() {
    }
    MATMAGPHI.prototype.get = function MATMAGPHI() {
    }
    MATMAGPHI.prototype.set = function MATMAGPHI() {
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        label = graphics.exprs;
        if (size(label,"*")==14) {
        label[9-1] = [];
}
        while (true) {
        [ok,decomptyp,lab] = scicos_getvalue("Set MATMAGPHI block parameters",["decomposition type (1=Complex2MAG&PHI 2=MAG&PHI2Complex)"],list("vec",1),label);
        if (!ok) {
break;
}
        label = lab;
        if ((decomptyp==1)) {
        function_name = "matz_abs";
        in1 = [-1,-2];
        it = 2;
        out = [[-1,-2],[-1,-2]];
        ot = [1,1];
        } else if ((decomptyp==2)) {
        function_name = "matz_absc";
        in1 = [[-1,-2],[-1,-2]];
        it = [1,1];
        out = [-1,-2];
        ot = 2;
        } else {
message("decomposition type is not supported");
        ok = false;
}
        funtyp = 4;
        if (ok) {
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
        if (ok) {
        model.sim = list(function_name,funtyp);
        arg1.model = model;
        graphics.exprs = label;
        arg1.graphics = graphics;
        x = arg1;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/MATMUL.sci" */
function MATMUL() {
    MATMUL.prototype.define = function MATMUL() {
        model = scicos_model();
        model.sim = list("matmul_m",4);
        model.in1 = [[-1],[-2]];
        model.in2 = [[-2],[-3]];
        model.out = -1;
        model.out2 = -3;
        model.dep_ut = [true,false];
        model.ipar = 1;
        label = [sci2exp(model.ipar)];
        gr_i = [];
        x = standard_define([3,2],model,label,gr_i);
    }
    MATMUL.prototype.details = function MATMUL() {
    }
    MATMUL.prototype.get = function MATMUL() {
    }
    MATMUL.prototype.set = function MATMUL() {
        x = arg1;
        graphics = x.graphics;
        label = graphics.exprs;
        model = x.model;
        if (model.ipar==[]) {
        model.ipar = 1;
}
        if (size(label,"*")==1) {
        label[2-1] = sci2exp(1);
}
        if (size(label,"*")==2) {
        label[3-1] = sci2exp(1);
}
        while (true) {
        [ok,dtype,rule,np,exprs] = scicos_getvalue([["Set MATMUL parameter"],["For the Multipication rule:"],["    1= Matrix by Matrix"],["    2= Matrix by Matrix element wise "],["    3= Matrix by Scalar"],["In the third case the second input will be the scalar"]],[["Datatype(1=real double 2=Complex 3=int32 ...)"],["Multiplication rule"],["Do on Overflow(0=Nothing 1=Saturate 2=Error)"]],list("vec",1,"vec",1,"vec",1),label);
        if (!ok) {
break;
}
        rule = int(rule);
        if ((dtype<1||dtype>8)) {
message("type is not supported");
        ok = false;
}
        if ((rule<1||rule>3)) {
message("Multiplication rule must be only 1,2 or 3");
        ok = false;
}
        if ((dtype==1||dtype==2)) {
        np = 0;
}
        TABMIN = [[0],[0],[-(2^31)],[-(2^15)],[-(2^7)],[0],[0],[0]];
        TABMAX = [[0],[0],[(2^31)-1],[(2^15)-1],[(2^7)-1],[(2^32)-1],[(2^16)-1],[(2^8)-1]];
        if (rule==2) {
        if (np==0) {
        model.sim = list("matmul2_m",4);
        } else if (np==1) {
        model.sim = list("matmul2_s",4);
        } else {
        model.sim = list("matmul2_e",4);
}
        } else if (rule==3) {
        if (np==0) {
        model.sim = list("matbyscal",4);
        } else if (np==1) {
        model.sim = list("matbyscal_s",4);
        } else {
        model.sim = list("matbyscal_e",4);
}
        } else {
        if ((dtype==1)) {
        model.sim = list("matmul_m",4);
        } else if ((dtype==2)) {
        model.sim = list("matzmul_m",4);
        } else if (dtype==3) {
        if (np==0) {
        model.sim = list("matmul_i32n",4);
        } else if (np==1) {
        model.sim = list("matmul_i32s",4);
        } else {
        model.sim = list("matmul_i32e",4);
}
        } else if (dtype==4) {
        if (np==0) {
        model.sim = list("matmul_i16n",4);
        } else if (np==1) {
        model.sim = list("matmul_i16s",4);
        } else {
        model.sim = list("matmul_i16e",4);
}
        } else if (dtype==5) {
        if (np==0) {
        model.sim = list("matmul_i8n",4);
        } else if (np==1) {
        model.sim = list("matmul_i8s",4);
        } else {
        model.sim = list("matmul_i8e",4);
}
        } else if (dtype==6) {
        if (np==0) {
        model.sim = list("matmul_ui32n",4);
        } else if (np==1) {
        model.sim = list("matmul_ui32s",4);
        } else {
        model.sim = list("matmul_ui32e",4);
}
        } else if (dtype==7) {
        if (np==0) {
        model.sim = list("matmul_ui16n",4);
        } else if (np==1) {
        model.sim = list("matmul_ui16s",4);
        } else {
        model.sim = list("matmul_ui16e",4);
}
        } else if (dtype==8) {
        if (np==0) {
        model.sim = list("matmul_ui8n",4);
        } else if (np==1) {
        model.sim = list("matmul_ui8s",4);
        } else {
        model.sim = list("matmul_ui8e",4);
}
}
}
        kmin = TABMIN[dtype-1];
        kmax = TABMAX[dtype-1];
        it = dtype*ones(1,2);
        ot = dtype;
        if (rule==1) {
        in1 = [[-1,-2],[-2,-3]];
        out = [-1,-3];
        } else if (rule==2) {
        in1 = [[-1,-2],[-1,-2]];
        out = [-1,-2];
        } else {
        in1 = [[-1,-2],[1,1]];
        out = [-1,-2];
}
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
        if (ok) {
        label = exprs;
        model.ipar = rule;
        model.rpar = [[kmin],[kmax]];
        graphics.exprs = label;
        x.graphics = graphics;
        x.model = model;
        arg1 = x;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/MATPINV.sci" */
function MATPINV() {
    MATPINV.prototype.define = function MATPINV() {
        model = scicos_model();
        function_name = "mat_pinv";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in1 = -1;
        model.in2 = -2;
        model.intyp = 1;
        model.out = -2;
        model.out2 = -1;
        model.outtyp = 1;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = [sci2exp(1)];
        gr_i = [];
        x = standard_define([2,2],model,label,gr_i);
    }
    MATPINV.prototype.details = function MATPINV() {
    }
    MATPINV.prototype.get = function MATPINV() {
    }
    MATPINV.prototype.set = function MATPINV() {
        x = arg1;
        graphics = arg1.graphics;
        label = graphics.exprs;
        model = arg1.model;
        if (size(label,"*")==14) {
        label[9-1] = [];
}
        while (true) {
        [ok,typ,exprs] = scicos_getvalue("Set MATPINV Block",["Datatype(1=real double  2=Complex)"],list("vec",1),label);
        if (!ok) {
break;
}
        if ((typ==1)) {
        function_name = "mat_pinv";
        ot = 1;
        it = 1;
        } else if ((typ==2)) {
        function_name = "matz_pinv";
        ot = 2;
        it = 2;
        } else {
message("Datatype is not supported");
        ok = false;
}
        in1 = [model.in1,model.in2];
        out = [model.out,model.out2];
        funtyp = 4;
        if (ok) {
        label = exprs;
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
        model.sim = list(function_name,funtyp);
        graphics.exprs = label;
        arg1.graphics = graphics;
        arg1.model = model;
        x = arg1;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/MATRESH.sci" */
function MATRESH() {
    MATRESH.prototype.define = function MATRESH() {
        model = scicos_model();
        function_name = "mat_reshape";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in1 = -1;
        model.in2 = -2;
        model.intyp = 1;
        model.out = -1;
        model.out2 = -2;
        model.outtyp = 1;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = [[sci2exp(1)],[sci2exp([1,1])],[sci2exp([1,1])]];
        gr_i = [];
        x = standard_define([3,2],model,label,gr_i);
    }
    MATRESH.prototype.details = function MATRESH() {
    }
    MATRESH.prototype.get = function MATRESH() {
    }
    MATRESH.prototype.set = function MATRESH() {
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        label = graphics.exprs;
        if (size(label,"*")==14) {
        label[9-1] = [];
}
        while (true) {
        [ok,typ,l1,out,lab] = scicos_getvalue("Set MATRESH block parameters",[["Datatype(1=real double  2=Complex)","input size"],["output size desired"]],list("vec",-1,"vec",-1,"vec",-1),label);
        if (!ok) {
break;
}
        nout = size(out);
        nin = size(l1);
        if (nout==0) {
message("output must have at least one element");
        ok = false;
}
        if (nin==0) {
message("input must have at least one element");
        ok = false;
}
        if (ok) {
        if (((out[1-1]>(l1[1-1]*l1[2-1])))) {
message("the first dimension of the output is too big");
        ok = false;
}
        if (((out[2-1]>(l1[1-1]*l1[2-1])))) {
message("the second dimension of the output is too big");
        ok = false;
}
        if ((((out[2-1]*out[1-1])>(l1[1-1]*l1[2-1])))) {
message("the dimensions of the output are too big");
        ok = false;
}
}
        if ((typ==1)) {
        function_name = "mat_reshape";
        ot = 1;
        it = 1;
        } else if ((typ==2)) {
        function_name = "matz_reshape";
        ot = 2;
        it = 2;
        } else {
message("Datatype is not supported");
        ok = false;
}
        if (ok) {
        label = lab;
        [model,graphics,ok] = set_io(model,graphics,list(l1,it),list(out,ot),[],[]);
}
        if (ok) {
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        graphics.exprs = label;
        arg1.graphics = graphics;
        arg1.model = model;
        x = arg1;
break;
}
}
needcompile=resume(needcompile)
    }
}
/* autogenerated from "macros/MatrixOp/MATSING.sci" */
function MATSING() {
    MATSING.prototype.define = function MATSING() {
        model = scicos_model();
        function_name = "mat_sing";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in1 = -1;
        model.in2 = -2;
        model.intyp = 1;
        model.out = -1;
        model.out2 = 1;
        model.outtyp = 1;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = [[sci2exp(1)],[sci2exp(1)]];
        gr_i = [];
        x = standard_define([2,2],model,label,gr_i);
    }
    MATSING.prototype.details = function MATSING() {
    }
    MATSING.prototype.get = function MATSING() {
    }
    MATSING.prototype.set = function MATSING() {
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        label = graphics.exprs;
        if (size(label,"*")==14) {
        label[9-1] = [];
}
        while (true) {
        [ok,typ,decomptyp,lab] = scicos_getvalue("Set MATSVD block parameters",[["Datatype(1=real double  2=Complex)"],["decomposition type (1=singular values  2=sing values+matrix U & V)"]],list("vec",1,"vec",1),label);
        if (!ok) {
break;
}
        label = lab;
        if ((typ==1)) {
        if ((decomptyp==1)) {
        function_name = "mat_sing";
        in1 = [-1,-2];
        out = [-1,1];
        ot = 1;
        } else if ((decomptyp==2)) {
        function_name = "mat_svd";
        in1 = [-1,-2];
        out = [[-1,-1],[-1,-2],[-2,-2]];
        ot = [1,1,1];
        } else {
message("decomposition type is not supported");
        ok = false;
}
        it = 1;
        } else if ((typ==2)) {
        if ((decomptyp==1)) {
        function_name = "matz_sing";
        in1 = [-1,-2];
        out = [-1,1];
        ot = 1;
        } else if ((decomptyp==2)) {
        function_name = "matz_svd";
        in1 = [-1,-2];
        out = [[-1,-1],[-1,-2],[-2,-2]];
        ot = [2,1,2];
        } else {
message("decomposition type is not supported");
        ok = false;
}
        it = 2;
        } else {
message("Datatype is not supported");
        ok = false;
}
        funtyp = 4;
        if (ok) {
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
        if (ok) {
        model.sim = list(function_name,funtyp);
        arg1.model = model;
        graphics.exprs = label;
        arg1.graphics = graphics;
        x = arg1;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/MATSUM.sci" */
function MATSUM() {
    MATSUM.prototype.define = function MATSUM() {
        model = scicos_model();
        function_name = "mat_sum";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in1 = -1;
        model.in2 = -2;
        model.intyp = 1;
        model.out = 1;
        model.out2 = 1;
        model.outtyp = 1;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = [[sci2exp(1)],[sci2exp(0)]];
        gr_i = [];
        x = standard_define([3,2],model,label,gr_i);
    }
    MATSUM.prototype.details = function MATSUM() {
    }
    MATSUM.prototype.get = function MATSUM() {
    }
    MATSUM.prototype.set = function MATSUM() {
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        label = graphics.exprs;
        if (size(label,"*")==14) {
        label[9-1] = [];
}
        while (true) {
        [ok,typ,decomptyp,lab] = scicos_getvalue("Set MATSUM block parameters",[["Datatype(1=real double  2=Complex)"],["Sum along (0=all 1=lines  2=Columns)"]],list("vec",1,"vec",1),label);
        if (!ok) {
break;
}
        label = lab;
        if ((typ==1)) {
        if ((decomptyp==0)) {
        function_name = "mat_sum";
        out = [1,1];
        } else if ((decomptyp==2)) {
        function_name = "mat_suml";
        out = [-1,1];
        } else if ((decomptyp==1)) {
        function_name = "mat_sumc";
        out = [1,-2];
        } else {
message("decomposition type is not supported");
        ok = false;
}
        it = 1;
        ot = 1;
        } else if ((typ==2)) {
        if ((decomptyp==0)) {
        function_name = "matz_sum";
        out = [1,1];
        } else if ((decomptyp==2)) {
        function_name = "matz_suml";
        out = [-1,1];
        } else if ((decomptyp==1)) {
        function_name = "matz_sumc";
        out = [1,-2];
        } else {
message("decomposition type is not supported");
        ok = false;
}
        it = 2;
        ot = 2;
        } else {
message("Datatype is not supported");
        ok = false;
}
        in1 = [model.in1,model.in2];
        funtyp = 4;
        if (ok) {
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
        if (ok) {
        model.sim = list(function_name,funtyp);
        arg1.model = model;
        graphics.exprs = label;
        arg1.graphics = graphics;
        x = arg1;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/MATTRAN.sci" */
function MATTRAN() {
    MATTRAN.prototype.define = function MATTRAN() {
        model = scicos_model();
        model.sim = list("mattran_m",4);
        model.in1 = -1;
        model.in2 = -2;
        model.out = -2;
        model.out2 = -1;
        model.dep_ut = [true,false];
        label = [sci2exp(1)];
        gr_i = [];
        x = standard_define([3,2],model,label,gr_i);
    }
    MATTRAN.prototype.details = function MATTRAN() {
    }
    MATTRAN.prototype.get = function MATTRAN() {
    }
    MATTRAN.prototype.set = function MATTRAN() {
        x = arg1;
        graphics = arg1.graphics;
        label = graphics.exprs;
        model = arg1.model;
        if (size(label,"*")==1) {
        label[2-1] = sci2exp(1);
}
        while (true) {
        [ok,typ,rule,exprs] = scicos_getvalue("Set MATTRAN Block",[["Datatype(1=real double 2=Complex)"],["rule (1=.\' 2=\')"]],list("vec",1,"vec",1),label);
        if (!ok) {
break;
}
        if ((typ==1)) {
        function_name = "mattran_m";
        ot = 1;
        it = 1;
        } else if ((typ==2)) {
        if (rule==1) {
        function_name = "matztran_m";
        } else {
        function_name = "mathermit_m";
}
        ot = 2;
        it = 2;
        } else {
message("Datatype is not supported");
        ok = false;
}
        in1 = [model.in1,model.in2];
        out = [model.out,model.out2];
        funtyp = 4;
        if (ok) {
        label = exprs;
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
        model.sim = list(function_name,funtyp);
        graphics.exprs = label;
        arg1.graphics = graphics;
        arg1.model = model;
        x = arg1;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/MATZCONJ.sci" */
function MATZCONJ() {
    MATZCONJ.prototype.define = function MATZCONJ() {
        model = scicos_model();
        function_name = "matz_conj";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in1 = -1;
        model.in2 = -2;
        model.intyp = 2;
        model.out = -1;
        model.out2 = -2;
        model.outtyp = 2;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = [];
        gr_i = [];
        x = standard_define([2,2],model,label,gr_i);
    }
    MATZCONJ.prototype.details = function MATZCONJ() {
    }
    MATZCONJ.prototype.get = function MATZCONJ() {
    }
    MATZCONJ.prototype.set = function MATZCONJ() {
        x = arg1;
    }
}
/* autogenerated from "macros/MatrixOp/MATZREIM.sci" */
function MATZREIM() {
    MATZREIM.prototype.define = function MATZREIM() {
        model = scicos_model();
        function_name = "matz_reim";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in1 = -1;
        model.in2 = -2;
        model.intyp = 2;
        model.out = [[-1],[-1]];
        model.out2 = [[-2],[-2]];
        model.outtyp = [1,1];
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = sci2exp(1);
        gr_i = [];
        x = standard_define([3,2],model,label,gr_i);
    }
    MATZREIM.prototype.details = function MATZREIM() {
    }
    MATZREIM.prototype.get = function MATZREIM() {
    }
    MATZREIM.prototype.set = function MATZREIM() {
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        label = graphics.exprs;
        if (size(label,"*")==14) {
        label[9-1] = [];
}
        while (true) {
        [ok,decomptyp,lab] = scicos_getvalue("Set MATZREIM block parameters",["decomposition type (1=Complex2Real&Imag 2=Real&Imag2Complex)"],list("vec",1),label);
        if (!ok) {
break;
}
        label = lab;
        if ((decomptyp==1)) {
        function_name = "matz_reim";
        in1 = [-1,-2];
        it = 2;
        out = [[-1,-2],[-1,-2]];
        ot = [1,1];
        } else if ((decomptyp==2)) {
        function_name = "matz_reimc";
        in1 = [[-1,-2],[-1,-2]];
        it = [1,1];
        out = [-1,-2];
        ot = 2;
        } else {
message("decomposition type is not supported");
        ok = false;
}
        funtyp = 4;
        if (ok) {
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
        if (ok) {
        model.sim = list(function_name,funtyp);
        arg1.model = model;
        graphics.exprs = label;
        arg1.graphics = graphics;
        x = arg1;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/RICC.sci" */
function RICC() {
    RICC.prototype.define = function RICC() {
        model = scicos_model();
        function_name = "ricc_m";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in1 = [[-1],[-1],[-1]];
        model.in2 = [[-1],[-1],[-1]];
        model.intyp = [1,1,1];
        model.out = -1;
        model.out2 = -1;
        model.outtyp = 1;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [[1],[1]];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = [[sci2exp(1)],[sci2exp(1)]];
        gr_i = [];
        x = standard_define([2,2],model,label,gr_i);
    }
    RICC.prototype.details = function RICC() {
    }
    RICC.prototype.get = function RICC() {
    }
    RICC.prototype.set = function RICC() {
        x = arg1;
        graphics = arg1.graphics;
        label = graphics.exprs;
        model = arg1.model;
        if (size(label,"*")==14) {
        label[9-1] = [];
}
        while (true) {
        [ok,tpe,mod,exprs] = scicos_getvalue("Set RICC Block",[["Type (1=Cont  2=Disc)"],["Model(1=Schr  2=sign(cont) inv(disc))"]],list("vec",1,"vec",1),label);
        if (!ok) {
break;
}
        in1 = [model.in1,model.in2];
        out = [model.out,model.out2];
        it = [1,1,1];
        ot = 1;
        label = exprs;
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
        if (ok) {
        model.ipar = [[tpe],[mod]];
        graphics.exprs = label;
        arg1.graphics = graphics;
        arg1.model = model;
        x = arg1;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/ROOTCOEF.sci" */
function ROOTCOEF() {
    ROOTCOEF.prototype.define = function ROOTCOEF() {
        model = scicos_model();
        function_name = "root_coef";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in1 = -1;
        model.in2 = 1;
        model.intyp = 1;
        model.out = -2;
        model.out2 = 1;
        model.outtyp = 1;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = [[sci2exp(1)],[sci2exp(1)]];
        gr_i = [];
        x = standard_define([3,2],model,label,gr_i);
    }
    ROOTCOEF.prototype.details = function ROOTCOEF() {
    }
    ROOTCOEF.prototype.get = function ROOTCOEF() {
    }
    ROOTCOEF.prototype.set = function ROOTCOEF() {
        x = arg1;
        graphics = arg1.graphics;
        label = graphics.exprs;
        model = arg1.model;
        if (size(label,"*")==14) {
        label[9-1] = [];
}
        while (true) {
        [ok,typ,inp,exprs] = scicos_getvalue("Set ROOTCOEF Block",[["Datatype(1=real double  2=Complex)"],["input row size"]],list("vec",1,"vec",1),label);
        if (!ok) {
break;
}
        if ((typ==1)) {
        function_name = "root_coef";
        ot = 1;
        it = 1;
        } else if ((typ==2)) {
        function_name = "rootz_coef";
        ot = 2;
        it = 2;
        } else {
message("Datatype is not supported");
        ok = false;
}
        in1 = [inp,model.in2];
        out = [inp+1,model.out2];
        funtyp = 4;
        if (ok) {
        label = exprs;
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
        model.sim = list(function_name,funtyp);
        graphics.exprs = label;
        arg1.graphics = graphics;
        arg1.model = model;
        x = arg1;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/SQRT.sci" */
function SQRT() {
    SQRT.prototype.define = function SQRT() {
        model = scicos_model();
        model.sim = list("mat_sqrt",4);
        model.in1 = -1;
        model.in2 = -2;
        model.intyp = 1;
        model.outtyp = 1;
        model.out = -1;
        model.out2 = -2;
        model.dep_ut = [true,false];
        label = [sci2exp(1)];
        gr_i = [];
        x = standard_define([2,2],model,label,gr_i);
    }
    SQRT.prototype.details = function SQRT() {
    }
    SQRT.prototype.get = function SQRT() {
    }
    SQRT.prototype.set = function SQRT() {
        x = arg1;
        graphics = arg1.graphics;
        label = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,typ,exprs] = scicos_getvalue("Set SQRT Block",["Datatype(1=real double  2=Complex)"],list("vec",1),label);
        if (!ok) {
break;
}
        if ((typ==1)) {
        function_name = "mat_sqrt";
        } else if ((typ==2)) {
        function_name = "matz_sqrt";
        } else {
message("type is not supported");
        ok = false;
}
        it = typ;
        ot = typ;
        in1 = [model.in1,model.in2];
        out = [model.out,model.out2];
        funtyp = 4;
        if (ok) {
        label = exprs;
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
        model.sim = list(function_name,funtyp);
        graphics.exprs = label;
        arg1.graphics = graphics;
        arg1.model = model;
        x = arg1;
break;
}
}
    }
}
/* autogenerated from "macros/MatrixOp/SUBMAT.sci" */
function SUBMAT() {
    SUBMAT.prototype.define = function SUBMAT() {
        model = scicos_model();
        function_name = "submat";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in1 = -1;
        model.in2 = -2;
        model.intyp = 1;
        model.out = -1;
        model.out2 = -2;
        model.outtyp = 1;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [[1],[1],[1],[1]];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = [[sci2exp(1)],[sci2exp(1)],[sci2exp(1)],[sci2exp(1)],[sci2exp(1)]];
        gr_i = [];
        x = standard_define([2.5,2],model,label,gr_i);
    }
    SUBMAT.prototype.details = function SUBMAT() {
    }
    SUBMAT.prototype.get = function SUBMAT() {
    }
    SUBMAT.prototype.set = function SUBMAT() {
        x = arg1;
        graphics = arg1.graphics;
        label = graphics.exprs;
        model = arg1.model;
        if (size(label,"*")==5) {
        label[6-1] = sci2exp([1,1]);
}
        while (true) {
        [ok,typ,a,b,c,d,inp,exprs] = scicos_getvalue("Set SUBMAT Block",[["Datatype (1=real double  2=Complex)"],["Starting Row Index"],["Ending Row Index"],["Starting Column Index"],["Ending Column Index"],["Input Dimensions"]],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",2),label);
        if (!ok) {
break;
}
        if ((typ==1)) {
        function_name = "submat";
        ot = 1;
        it = 1;
        } else if ((typ==2)) {
        function_name = "submatz";
        ot = 2;
        it = 2;
        } else {
message("Datatype is not supported");
        ok = false;
}
        if ((a<=0)||(b<=0)||(c<=0)||(d<=0)) {
message("invalid index");
        ok = false;
}
        if (b<a) {
message("ending row must be greater than starting row");
        ok = false;
}
        if (d<c) {
message("ending column must be greater than starting column");
        ok = false;
}
        if (b>inp[1-1]) {
message("index of ending row is out of range");
        ok = false;
}
        if (d>inp[2-1]) {
message("index of ending column is out of range");
        ok = false;
}
        model.ipar = [[a],[b],[c],[d]];
        in1 = [inp[1-1],inp[2-1]];
        out = [(b-a)+1,(d-c)+1];
        funtyp = 4;
        label = exprs;
        if (ok) {
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
        model.sim = list(function_name,funtyp);
        graphics.exprs = label;
        arg1.graphics = graphics;
        arg1.model = model;
        x = arg1;
break;
}
}
    }
}
/* autogenerated from "macros/Misc/AUTOMAT.sci" */
function AUTOMAT() {
    AUTOMAT.prototype.define = function AUTOMAT() {
        NMode = 2;
        this.Minitial = 1;
        NX = 1;
        this.X0 = [0.0];
        this.XP = [[1],[1]];
        C1 = [2];
        C2 = [1];
        exprs = [[string(NMode)],[string(this.Minitial)],[string(NX)],[sci2exp(this.X0)],[sci2exp(this.XP)],[sci2exp(C1)],[sci2exp(C2)]];
        ipar = [[NMode],[this.Minitial],[NX],[this.XP],[C1],[C2]];
        rpar = [this.X0];
        model = scicos_model();
        model.sim = list("automat",10004);
        model.in1 = [[2*NX+1],[2*NX+1]];
        model.out = [[2],[2*NX]];
        model.state = ones(2*NX,1);
        model.nzcross = 1;
        model.blocktype = "c";
        model.evtout = 1;
        model.firing = -1;
        model.dep_ut = [false,true];
        model.ipar = ipar;
        model.rpar = rpar;
        gr_i = [];
        x = standard_define([4,2],model,exprs,gr_i);
    }
    AUTOMAT.prototype.details = function AUTOMAT() {
    }
    AUTOMAT.prototype.get = function AUTOMAT() {
    }
    AUTOMAT.prototype.set = function AUTOMAT() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        ipar = model.ipar;
        NMode = ipar[1-1];
        NX = ipar[3-1];
        while (true) {
        CX = "C1";
        MSG0 = "\'Jump from Mode ";
        MSG2 = ":[..;M_final(Guard=In(";
        MSG3 = ").i);..]\'";
        MSG = MSG0+"1"+MSG2+"1"+MSG3;
        VEC = "\'mat\',[-1,1]";
for (i=2;i<=NMode;i+=1) {
        CX = CX+","+"C"+string(i);
        MSG = MSG+";"+MSG0+string(i)+MSG2+string(i)+MSG3;
        VEC = VEC+","+"\'mat\',[-1,1]";
}
        GTV = "[ok,NMode,Minitial,NX,X0,XP,"+CX+",exprs]=scicos_getvalue(\'Set Finite state machine model\',            [\'Number (finite-state) Modes\';\'Initial Mode\';\'Number of continuous-time states\';\'Continuous-time states intial values\';\'Xproperties of continuous-time states in each Mode\';"+MSG+"],            list(\'vec\',1,\'vec\',1,\'vec\',1,\'mat\',[-1,-1],\'mat\',[-1,-1],"+VEC+"),exprs)";
execstr(GTV);
        if (!this.ok) {
break;
}
        NMode_old = size(exprs,"*")-5;
        ModifEncore = false;
        if ((NMode_old>NMode)) {
        exprs.slice(NMode+6-1,NMode_old+5) = [];
        ModifEncore = true;
}
        if ((NMode_old<NMode)) {
        exprs.slice(NMode_old+6-1,NMode+5) = exprs[NMode_old+4-1];
        ModifEncore = true;
}
        if ((NX!=size(this.X0,"*"))) {
messagebox("the size of intial continuous-time states should be NX="+string(NX),"modal","error");
        ModifEncore = true;
}
        [rXP,cXP] = size(this.XP);
        if (cXP!=NX) {
messagebox("Xproperty matrix is not valid: it should have NX="+string(NX)+" columns","modal","error");
        ModifEncore = true;
        } else if (((rXP!=NMode)&&(rXP>1))) {
messagebox("Xproperty matrix is not valid: it should have NMode="+string(NMode)+" or 1 row(s)","modal","error");
        ModifEncore = true;
        } else if ((rXP==1)) {
for (i=1;i<=NMode-1;i+=1) {
        this.XP = [[this.XP],[this.XP[1-1].slice()]];
}
}
        if ((NMode_old==NMode)&&(!ModifEncore)) {
        this.XP = matrix(transpose(this.XP),NMode*NX,1);
        ipar = [[NMode],[this.Minitial],[NX],[this.XP]];
        rpar = matrix(this.X0,NX,1);
        INP = ones(NMode,1);
        if (NX>0) {
        OUT = [[2],[2*NX]];
        } else {
        OUT = [2];
}
        MaxModes = 1;
        nzcross = 0;
for (i=1;i<=NMode;i+=1) {
        Ci = evstr(exprs[5+i-1]);
        ipar = [[ipar],[Ci]];
        INP[i-1][1-1] = 2*NX+length(Ci);
        if ((nzcross<length(Ci))) {
        nzcross = length(Ci);
}
        if ((MaxModes<max(Ci))) {
        MaxModes = max(Ci);
        imax = i;
}
}
        if (MaxModes>NMode) {
messagebox([["Number of Modes should be "+string(MaxModes)],["A destination Mode in Mode#"+string(imax)+"\'s targets is invalid!"]],"modal","error");
        ModifEncore = true;
}
        if (MaxModes<NMode) {
messagebox(["There is an unused Mode or the Number of Modes should be "+string(MaxModes)],"modal","error");
        ModifEncore = true;
}
}
        if (!ModifEncore) {
        [model,graphics,this.ok] = check_io(model,graphics,INP,OUT,[],[1]);
        if (!this.ok) {
break;
}
        model.nzcross = nzcross;
        model.state = ones(2*NX,1);
        graphics.gr_i[1-1][1-1] = "txt=[\'Automaton\';\'nM="+string(NMode)+",nX="+string(NX)+"\'];";
        graphics.exprs = exprs;
        x.graphics = graphics;
        model.ipar = ipar;
        model.rpar = rpar;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Misc/BACKLASH.sci" */
function BACKLASH() {
    BACKLASH.prototype.define = function BACKLASH() {
        exprs = [["0"],["1"],["1"]];
        model = scicos_model();
        model.sim = list("backlash",4);
        model.in1 = 1;
        model.out = 1;
        model.rpar = [[0],[1]];
        model.nzcross = 2;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    BACKLASH.prototype.details = function BACKLASH() {
    }
    BACKLASH.prototype.get = function BACKLASH() {
    }
    BACKLASH.prototype.set = function BACKLASH() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        rpar = model.rpar;
        while (true) {
        [ok,ini,gap,zcr,exprs] = scicos_getvalue("Set backlash parameters",[["initial output"],["gap"],["use zero-crossing (0:no, 1:yes)"]],list("vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (ok) {
        graphics.exprs = exprs;
        rpar[1-1] = ini;
        rpar[2-1] = gap;
        if (zcr!=0) {
        model.nzcross = 2;
        } else {
        model.nzcross = 0;
}
        model.rpar = rpar;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Misc/BOUNCE.sci" */
function BOUNCE() {
    BOUNCE.prototype.define = function BOUNCE() {
        n = 2;
        k = 1;
        ipar = [];
for (i=1;i<=n;i+=1) {
for (j=i+1;j<=n;j+=1) {
        ipar[k-1] = i;
        k = k+1;
        ipar[k-1] = j;
        k = k+1;
}
}
        walls = [[0],[5],[0],[5]];
        x = [[2],[2.5]];
        xd = [[0],[0]];
        y = [[3],[5]];
        yd = [[0],[0]];
        g = 9.81;
        C = 0;
        rpar1 = ones(n,1);
        rpar2 = rpar1;
        state = [x,xd,y,yd];
        state = transpose(state);
        model = scicos_model();
        model.sim = list("bounce_ball",4);
        model.in1 = [];
        model.out = [[n],[n]];
        model.state = state.slice();
        model.rpar = [[rpar1],[rpar2],[walls],[g],[C]];
        model.ipar = ipar;
        model.nzcross = n*(n-1)/2+4*n;
        model.blocktype = "c";
        model.dep_ut = [false,true];
        exprs = [[strcat(sci2exp(rpar1))],[strcat(sci2exp(rpar2))],[strcat(sci2exp(walls))],[strcat(sci2exp(x))],[strcat(sci2exp(xd))],[strcat(sci2exp(y))],[strcat(sci2exp(yd))]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    BOUNCE.prototype.details = function BOUNCE() {
    }
    BOUNCE.prototype.get = function BOUNCE() {
    }
    BOUNCE.prototype.set = function BOUNCE() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        if (size(exprs,"*")<9) {
        exprs[8-1] = "9.81";
        exprs[9-1] = "0";
}
        while (true) {
        [ok,rpar1,rpar2,walls,xt,xd,y,yd,g,C,exprs] = scicos_getvalue(["Set Bounce Block"],[["Mass"],["Radius"],["[xmin,xmax,ymin,ymax]"],["xpos"],["xdpos"],["ypos"],["ydpos"],["g (gravity)"],["C (aerodynamic coeff"]],list("vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        xt = xt.slice();
        y = y.slice();
        xd = xd.slice();
        yd = yd.slice();
        rpar1 = rpar1.slice();
        rpar2 = rpar2.slice();
        n = size(xt,"*");
        walls = walls.slice();
        if (walls[1-1]>walls[2-1]) {
        walls = walls[[2,1]-1];
}
        if (walls[3-1]>walls[3-1]) {
        walls = walls[[3,4]-1];
}
        if (n!=size(y,"*")||n!=size(rpar1,"*")||n!=size(rpar2,"*")||n!=size(xd,"*")||n!=size(yd,"*")) {
message("All vectors must have equal size");
        ok = false;
        } else if (!(min([[rpar1],[rpar2]])>0)) {
message("Mass and radius must be >0");
        ok = false;
}
        if (!ok) {
break;
}
        [model,graphics,ok] = check_io(model,graphics,[],[n,n],[],[]);
        if (ok) {
        k = 1;
        ipar = [];
for (i=1;i<=n;i+=1) {
for (j=i+1;j<=n;j+=1) {
        ipar[k-1] = i;
        k = k+1;
        ipar[k-1] = j;
        k = k+1;
}
}
        model.rpar = [[rpar1],[rpar2],[walls],[g],[C]];
        model.ipar = ipar;
        state = [xt,xd,y,yd];
        state = transpose(state);
        model.state = state.slice();
        model.nzcross = n*(n-1)/2+4*n;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Misc/BOUNCEXY.sci" */
function BOUNCEXY() {
    BOUNCEXY.prototype.define = function BOUNCEXY() {
        win = -1;
        imode = 1;
        clrs = [[1],[2]];
        siz = [[1],[1]];
        xmin = -5;
        xmax = 5;
        ymin = 0;
        ymax = 15;
        model = scicos_model();
        model.sim = list("bouncexy",4);
        model.in1 = [[-1],[-1]];
        model.in2 = [[1],[1]];
        model.intyp = [[1],[1]];
        model.evtin = 1;
        z = [];
for (i=1;i<=size(clrs,"*");i+=1) {
        z[6*(i-1)+1-1] = 0;
        z[6*(i-1)+2-1] = 0;
        z[6*(i-1)+3-1] = 2*siz[i-1];
        z[6*(i-1)+4-1] = 2*siz[i-1];
        z[6*(i-1)+5-1] = 0.000;
        z[6*(i-1)+6-1] = 64.0*360.000;
}
        model.dstate = z;
        model.rpar = [[xmin],[xmax],[ymin],[ymax]];
        model.ipar = [[win],[imode],[clrs.slice()]];
        model.blocktype = "d";
        model.firing = [];
        model.dep_ut = [false,false];
        exprs = [[strcat(sci2exp(clrs))],[strcat(sci2exp(siz))],[strcat(sci2exp(win))],[strcat(sci2exp(1))],[strcat(sci2exp(xmin))],[strcat(sci2exp(xmax))],[strcat(sci2exp(ymin))],[strcat(sci2exp(ymax))]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    BOUNCEXY.prototype.details = function BOUNCEXY() {
    }
    BOUNCEXY.prototype.get = function BOUNCEXY() {
    }
    BOUNCEXY.prototype.set = function BOUNCEXY() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        dstate = model.dstate;
        while (true) {
        [ok,clrs,siz,win,imode,xmin,xmax,ymin,ymax,exprs] = scicos_getvalue("Set Scope parameters",[["colors"],["radii"],["window number (-1 for automatic)"],["animation mode (0,1)"],["Xmin"],["Xmax"],["Ymin"],["Ymax"]],list("vec",-1,"vec",-1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        mess = [];
        if (size(clrs,"*")!=size(siz,"*")) {
        mess = [[mess],["colors and radii must have equal size (number of balls)"],[" "]];
        ok = false;
}
        if (win<-1) {
        mess = [[mess],["Window number cannot be inferior than -1"],[" "]];
        ok = false;
}
        if (ymin>=ymax) {
        mess = [[mess],["Ymax must be greater than Ymin"],[" "]];
        ok = false;
}
        if (xmin>=xmax) {
        mess = [[mess],["Xmax must be greater than Xmin"],[" "]];
        ok = false;
}
        if (!ok) {
message(mess);
        } else {
        rpar = [[xmin],[xmax],[ymin],[ymax]];
        ipar = [[win],[imode],[clrs.slice()]];
        z = [];
for (i=1;i<=size(clrs,"*");i+=1) {
        z[6*(i-1)+1-1] = 0;
        z[6*(i-1)+2-1] = 0;
        z[6*(i-1)+3-1] = 2*siz[i-1];
        z[6*(i-1)+4-1] = 2*siz[i-1];
        z[6*(i-1)+5-1] = 0.000;
        z[6*(i-1)+6-1] = 64.0*360.000;
}
        model.dstate = z;
        model.rpar = rpar;
        model.ipar = ipar;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Misc/BPLATFORM.sci" */
function BPLATFORM() {
    BPLATFORM.prototype.define = function BPLATFORM() {
        plen = 2;
        csiz = 2;
        phi = 0;
        xmin = -5;
        xmax = 5;
        ymin = 0;
        ymax = 15;
        model = scicos_model();
        model.sim = list("bplatform2",5);
        model.in1 = [[1],[1]];
        model.evtin = 1;
        model.dstate = 0;
        model.rpar = [[plen],[csiz],[phi],[xmin],[xmax],[ymin],[ymax]];
        model.blocktype = "d";
        model.dep_ut = [false,false];
        exprs = string(model.rpar);
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    BPLATFORM.prototype.details = function BPLATFORM() {
    }
    BPLATFORM.prototype.get = function BPLATFORM() {
    }
    BPLATFORM.prototype.set = function BPLATFORM() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        dstate = model.dstate;
        while (true) {
        [ok,plen,csiz,phi,xmin,xmax,ymin,ymax,exprs] = scicos_getvalue("Set Scope parameters",[["pendulum length"],["cart size (square side)"],["slope"],["Xmin"],["Xmax"],["Ymin"],["Ymax"]],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        mess = [];
        if (plen<=0||csiz<=0) {
        mess = [[mess],["Pendulum length and cart size must be positive."],[" "]];
        ok = false;
}
        if (ymin>=ymax) {
        mess = [[mess],["Ymax must be greater than Ymin"],[" "]];
        ok = false;
}
        if (xmin>=xmax) {
        mess = [[mess],["Xmax must be greater than Xmin"],[" "]];
        ok = false;
}
        if (!ok) {
message(mess);
        } else {
        rpar = [[plen],[csiz],[phi],[xmin],[xmax],[ymin],[ymax]];
        model.rpar = rpar;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Misc/CBLOCK.sci" */
function CBLOCK() {
    CBLOCK.prototype.define = function CBLOCK() {
        in1 = 1;
        out = 1;
        clkin = [];
        clkout = [];
        x0 = [];
        z0 = [];
        typ = "c";
        auto = [];
        rpar = [];
        ipar = [];
        funam = "toto";
        ng = 0;
        model = scicos_model();
        model.sim = list(" ",2004);
        model.in1 = in1;
        model.out = out;
        model.evtin = clkin;
        model.evtout = clkout;
        model.state = x0;
        model.dstate = z0;
        model.rpar = rpar;
        model.ipar = ipar;
        model.blocktype = typ;
        model.firing = auto;
        model.dep_ut = [true,false];
        model.nzcross = ng;
        label = list(transpose([funam,"n",sci2exp(in1),sci2exp(out),sci2exp(clkin),sci2exp(clkout),sci2exp(x0),sci2exp(0),sci2exp(z0),sci2exp(rpar),sci2exp(ipar),sci2exp(auto),"y","n"]),[]);
        gr_i = [];
        x = standard_define([4,2],model,label,gr_i);
    }
    CBLOCK.prototype.details = function CBLOCK() {
    }
    CBLOCK.prototype.get = function CBLOCK() {
    }
    CBLOCK.prototype.set = function CBLOCK() {
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        label = graphics.exprs;
        while (true) {
        [ok,function_name,impli,i,o,ci,co,xx,ng,z,rpar,ipar,auto0,depu,dept,lab] = scicos_getvalue("Set C-Block2 block parameters",[["simulation function"],["is block implicit? (y,n)"],["input ports sizes"],["output ports sizes"],["input event ports sizes"],["output events ports sizes"],["initial continuous state"],["number of zero crossing surfaces"],["initial discrete state"],["Real parameters vector"],["Integer parameters vector"],["initial firing vector (<0 for no firing)"],["direct feedthrough (y or n)"],["time dependence (y or n)"]],list("str",1,"str",1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",1,"vec",-1,"vec",-1,"vec",-1,"vec","sum(%6)","str",1,"str",1),label[1-1]);
        if (!ok) {
break;
}
        label[1-1] = lab;
        funam = stripblanks(function_name);
        xx = xx.slice();
        z = z.slice();
        rpar = rpar.slice();
        ipar = int(ipar.slice());
        nx = size(xx,1);
        nz = size(z,1);
        i = int(i.slice());
        o = int(o.slice());
        nout = size(o,1);
        ci = int(ci.slice());
        nevin = size(ci,1);
        co = int(co.slice());
        nevout = size(co,1);
        if (part(impli,1)=="y") {
        funtyp = 12004;
        } else {
        funtyp = 2004;
}
        if ([[ci],[co]]!=[]) {
        if (max([[ci],[co]])>1) {
message("vector event links not supported");
        ok = false;
}
}
        depu = stripblanks(depu);
        if (part(depu,1)=="y") {
        depu = true;
        } else {
        depu = false;
}
        dept = stripblanks(dept);
        if (part(dept,1)=="y") {
        dept = true;
        } else {
        dept = false;
}
        dep_ut = [depu,dept];
        if (funam==" ") {
break;
}
        if (model.sim[1-1]!=funam||sign(size(model.state,"*"))!=sign(nx)||sign(size(model.dstate,"*"))!=sign(nz)||model.nzcross!=ng||sign(size(model.evtout,"*"))!=sign(nevout)) {
        tt = [];
}
        tt = label[2-1];
        while (true) {
        [ok,tt,cancel] = CFORTR2(funam,tt);
        if (!ok) {
        if (cancel) {
break;
}
        } else {
        [model,graphics,ok] = check_io(model,graphics,i,o,ci,co);
        if (ok) {
        model.sim = list(funam,funtyp);
        model.in1 = i;
        model.out = o;
        model.evtin = ci;
        model.evtout = co;
        model.state = xx;
        model.dstate = z;
        model.rpar = rpar;
        model.ipar = ipar;
        model.firing = auto0;
        model.dep_ut = dep_ut;
        model.nzcross = ng;
        label[2-1] = tt;
        x.model = model;
        graphics.exprs = label;
        x.graphics = graphics;
break;
}
}
}
        if (ok||cancel) {
break;
}
}
    }
}
/* autogenerated from "macros/Misc/CBLOCK4.sci" */
function CBLOCK4() {
    CBLOCK4.prototype.define = function CBLOCK4() {
        funam = "toto";
        model = scicos_model();
        model.sim = list(" ",2004);
        model.in1 = 1;
        model.in2 = 1;
        model.intyp = 1;
        model.out = 1;
        model.out2 = 1;
        model.outtyp = 1;
        model.dep_ut = [true,false];
        label = list([[funam],["n"],[sci2exp([model.in1,model.in2])],[sci2exp(model.intyp)],[sci2exp([model.out,model.out2])],[sci2exp(model.outtyp)],[sci2exp(model.evtin)],[sci2exp(model.evtout)],[sci2exp(model.state)],[sci2exp(model.dstate)],[sci2exp(model.odstate)],[sci2exp(model.rpar)],[sci2exp(model.ipar)],[sci2exp(model.opar)],[sci2exp(model.nmode)],[sci2exp(model.nzcross)],[sci2exp(model.firing)],["y"],["n"]],[]);
        gr_i = [];
        x = standard_define([4,2],model,label,gr_i);
    }
    CBLOCK4.prototype.details = function CBLOCK4() {
    }
    CBLOCK4.prototype.get = function CBLOCK4() {
    }
    CBLOCK4.prototype.set = function CBLOCK4() {
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        label = graphics.exprs;
        while (true) {
        [ok,function_name,impli,in1,it,out,ot,ci,co,xx,z,oz,rpar,ipar,opar,nmode,nzcr,auto0,depu,dept,lab] = scicos_getvalue("Set C-Block4 block parameters",[["Simulation function"],["Is block implicit? (y,n)"],["Input ports sizes"],["Input ports type"],["Output port sizes"],["Output ports type"],["Input event ports sizes"],["Output events ports sizes"],["Initial continuous state"],["Initial discrete state"],["Initial object state"],["Real parameters vector"],["Integer parameters vector"],["Object parameters list"],["Number of modes"],["Number of zero crossings"],["Initial firing vector (<0 for no firing)"],["Direct feedthrough (y or n)"],["Time dependence (y or n)"]],list("str",1,"str",1,"mat",[-1,2],"vec",-1,"mat",[-1,2],"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"lis",-1,"vec",-1,"vec",-1,"lis",-1,"vec",1,"vec",1,"vec","sum(%8)","str",1,"str",1),label[1-1]);
        if (!ok) {
break;
}
        label[1-1] = lab;
        funam = stripblanks(function_name);
        xx = xx.slice();
        z = z.slice();
        rpar = rpar.slice();
        ipar = int(ipar.slice());
        nx = size(xx,1);
        nz = size(z,1);
        ci = int(ci.slice());
        nevin = size(ci,1);
        co = int(co.slice());
        nevout = size(co,1);
        if (part(impli,1)=="y") {
        funtyp = 12004;
        } else {
        funtyp = 2004;
}
        if ([[ci],[co]]!=[]) {
        if (max([[ci],[co]])>1) {
message("vector event links not supported");
        ok = false;
}
}
        if (ok) {
        depu = stripblanks(depu);
        if (part(depu,1)=="y") {
        depu = true;
        } else {
        depu = false;
}
        dept = stripblanks(dept);
        if (part(dept,1)=="y") {
        dept = true;
        } else {
        dept = false;
}
        dep_ut = [depu,dept];
        if (funam==" ") {
break;
}
        if (model.sim[1-1]!=funam||sign(size(model.state,"*"))!=sign(nx)||sign(size(model.dstate,"*"))!=sign(nz)||model.nzcross!=nzcr||sign(size(model.evtout,"*"))!=sign(nevout)) {
        tt = [];
}
        tt = label[2-1];
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),ci,co);
}
        if (ok) {
        while (true) {
        [ok,tt,cancel] = this.CC4[funam-1][tt-1];
        if (!ok) {
        if (cancel) {
break;
}
        } else {
        model.sim = list(funam,funtyp);
        model.state = xx;
        model.dstate = z;
        model.odstate = oz;
        model.rpar = rpar;
        model.ipar = ipar;
        model.opar = opar;
        model.firing = auto0;
        model.nzcross = nzcr;
        model.nmode = nmode;
        model.dep_ut = dep_ut;
        label[2-1] = tt;
        x.model = model;
        graphics.exprs = label;
        x.graphics = graphics;
break;
}
}
        if (ok||cancel) {
break;
}
}
}
    }
}
/* autogenerated from "macros/Misc/CONSTRAINT2_c.sci" */
function CONSTRAINT2_c() {
    CONSTRAINT2_c.prototype.define = function CONSTRAINT2_c() {
        x0 = [0];
        xd0 = [0];
        id = [0];
        model = scicos_model();
        model.sim = list("constraint_c",10004);
        model.in1 = 1;
        model.out = [[1],[1]];
        model.state = [[x0],[xd0]];
        model.ipar = id;
        model.blocktype = "c";
        model.dep_ut = [false,true];
        exprs = list(strcat(sci2exp(x0)),strcat(sci2exp(xd0)),strcat(sci2exp(id)));
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    CONSTRAINT2_c.prototype.details = function CONSTRAINT2_c() {
    }
    CONSTRAINT2_c.prototype.get = function CONSTRAINT2_c() {
    }
    CONSTRAINT2_c.prototype.set = function CONSTRAINT2_c() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        ask_again = false;
        [ok,x0,xd0,id,exprs] = scicos_getvalue("Set Constraint block parameters",[["Initial guess values of states x"],["Initial guess values of derivative x\'"],["Id(i)=1: if x\'(i) is present in the feedback, else Id(i)=0"]],list("vec",-1,"vec",-1,"vec",-1),exprs);
        if (!ok) {
break;
}
        x0 = x0.slice();
        N = size(x0,"*");
        xd0 = xd0.slice();
        Nxd = size(xd0,"*");
        id = id.slice();
        Nid = size(id,"*");
        if ((N!=Nxd)||(N!=Nid)) {
message("incompatible sizes, states, their derivatives, and ID should be the same size ");
        ask_again = true;
}
        if ((N<=0&&!ask_again)) {
x_message("number of states (constraints) must be > 0 ");
        ask_again = true;
}
        if ((!ask_again)) {
for (i=1;i<=N;i+=1) {
        if (!((id[i-1]==0)||(id[i-1]==1))) {
        ask_again = true;
x_message([["Id(i) must be either"],["0 when x\'(i) is not present in the feedback"],["1: when x\'(i) is present in the feedback"]]);
break;
}
        if ((id[i-1]==0)) {
        id[i-1] = -1;
}
}
}
        if (!ask_again) {
        graphics.exprs = exprs;
        model.state = [[x0],[xd0]];
        model.out = [[N],[N]];
        model.in1 = N;
        model.ipar = id;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Misc/CONSTRAINT_c.sci" */
function CONSTRAINT_c() {
    CONSTRAINT_c.prototype.define = function CONSTRAINT_c() {
        x0 = [[0],[0]];
        model = scicos_model();
        model.sim = list("constraint_c",10004);
        model.in1 = 1;
        model.out = 1;
        model.ipar = 0;
        model.state = x0;
        model.blocktype = "c";
        model.dep_ut = [false,true];
        exprs = "0";
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    CONSTRAINT_c.prototype.details = function CONSTRAINT_c() {
    }
    CONSTRAINT_c.prototype.get = function CONSTRAINT_c() {
    }
    CONSTRAINT_c.prototype.set = function CONSTRAINT_c() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,x0,exprs] = scicos_getvalue("Set solver block parameters","Initial guess values",list("vec",-1),exprs);
        if (!ok) {
break;
}
        x0 = x0.slice();
        N = size(x0,"*");
        if (N<=0) {
message("number of states (constraints) must be > 0 ");
        } else {
        [model,graphics,ok] = check_io(model,graphics,N,N,[],[]);
        if (ok) {
        graphics.exprs = exprs;
        model.state = [[x0],[zeros(N,1)]];
        model.out = N;
        model.in1 = N;
        model.ipar = -1*ones(N,1);
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/Misc/DEADBAND.sci" */
function DEADBAND() {
    DEADBAND.prototype.define = function DEADBAND() {
        minp = -.5;
        maxp = .5;
        rpar = [[maxp],[minp]];
        model = scicos_model();
        model.sim = list("deadband",4);
        model.in1 = 1;
        model.nzcross = 2;
        model.nmode = 1;
        model.out = 1;
        model.rpar = rpar;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[string(maxp)],[string(minp)],[string(model.nmode)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    DEADBAND.prototype.details = function DEADBAND() {
    }
    DEADBAND.prototype.get = function DEADBAND() {
    }
    DEADBAND.prototype.set = function DEADBAND() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,maxp,minp,zeroc,exprs] = scicos_getvalue("Set Deadband parameters",[["End of dead band"],["Start of dead band"],["zero crossing (0:no, 1:yes)"]],list("vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (maxp<=minp) {
message("Upper limit must be > Lower limit");
        } else {
        rpar = [[maxp],[minp]];
        model.rpar = rpar;
        if (zeroc!=0) {
        model.nzcross = 2;
        model.nmode = 1;
        } else {
        model.nzcross = 0;
        model.nmode = 0;
}
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Misc/DEBUG.sci" */
function DEBUG() {
    DEBUG.prototype.define = function DEBUG() {
        model = scicos_model();
        model.sim = list("%debug_scicos",99);
        model.blocktype = "d";
        exprs = list("","xcos_debug_gui(flag,block);");
        gr_i = [];
        x = standard_define([8,2],model,exprs,gr_i);
    }
    DEBUG.prototype.details = function DEBUG() {
    }
    DEBUG.prototype.get = function DEBUG() {
    }
    DEBUG.prototype.set = function DEBUG() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        textmp = exprs[2-1];
        ok = true;
        while (1==1) {
        [txt] = this.dialog[[["Enter scilab instructions for debugging."],[" Inputs are block and flag, output is block"]]-1][textmp-1];
        if (txt!=[]) {
        tt = ["block=debug_scicos(block,flag)"];
        if (execstr("deff(tt,txt)","errcatch")==0) {
        warnMode = warning("query");
warning("off");
save(this.TMPDIR+"/debug_scicos",this.debug_scicos);
warning(warnMode);
        exprs[2-1] = txt;
        if ((scicos_debug()!=2&&scicos_debug()!=3)) {
scicos_debug(2);
}
break;
        } else {
message([["Error in the instructions"],[lasterror()]]);
}
        } else {
        ok = false;
break;
}
}
        if (ok) {
        graphics.exprs = exprs;
        x.graphics = graphics;
}
    }
}
/* autogenerated from "macros/Misc/DEBUG_SCICOS.sci" */
function DEBUG_SCICOS() {
    DEBUG_SCICOS.prototype.define = function DEBUG_SCICOS() {
        x = DEBUG("define");
    }
    DEBUG_SCICOS.prototype.details = function DEBUG_SCICOS() {
    }
    DEBUG_SCICOS.prototype.get = function DEBUG_SCICOS() {
    }
    DEBUG_SCICOS.prototype.set = function DEBUG_SCICOS() {
        arg1.gui = "DEBUG";
        [x,y,typ] = DEBUG("set",arg1);
    }
}
/* autogenerated from "macros/Misc/DIFF_f.sci" */
function DIFF_f() {
    DIFF_f.prototype.define = function DIFF_f() {
        x0 = [[0],[0]];
        model = scicos_model();
        model.sim = list("diffblk",10001);
        model.in1 = 1;
        model.out = 1;
        model.state = x0;
        model.blocktype = "c";
        model.dep_ut = [false,true];
        exprs = [[strcat(sci2exp(x0[1-1]))],[strcat(sci2exp(x0[2-1]))]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    DIFF_f.prototype.details = function DIFF_f() {
    }
    DIFF_f.prototype.get = function DIFF_f() {
    }
    DIFF_f.prototype.set = function DIFF_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,x0,xd0,exprs] = scicos_getvalue("Set continuous linear system parameters",[["Initial state"],["Initial Derivative"]],list("vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        graphics.exprs = exprs;
        model.state = [[x0.slice()],[xd0.slice()]];
        x.graphics = graphics;
        x.model = model;
break;
}
        x.model.firing = [];
    }
}
/* autogenerated from "macros/Misc/DSUPER.sci" */
function DSUPER() {
    DSUPER.prototype.define = function DSUPER() {
    }
    DSUPER.prototype.details = function DSUPER() {
    }
    DSUPER.prototype.get = function DSUPER() {
    }
    DSUPER.prototype.set = function DSUPER() {
        y = this.needcompile;
        typ = list();
        graphics = arg1.graphics;
        if ((length(graphics.exprs)==0)) {
warnBlockByUID(arg1.model.label,gettext("Invalid masked block."));
        x = arg1;
return;
}
        exprs = graphics.exprs[1-1];
        exprs0 = graphics.exprs[2-1][1-1];
        btitre = graphics.exprs[2-1][2-1][1-1];
        bitems = graphics.exprs[2-1][2-1].slice(2-1,$);
        if (exprs0==[]) {
        x = arg1;
return;
}
        context = [arg1.model.rpar.props.context];
        [PREVAR_scicos_context,ierr] = script2var(context,PREVAR_scicos_context);
        if (ierr!=0) {
        x = arg1;
return;
}
        tt = "scicos_context."+exprs0[1-1];
for (i=2;i<=size(exprs0,1);i+=1) {
        tt = tt+",scicos_context."+exprs0[i-1];
}
        ss = graphics.exprs[2-1][3-1];
        scicos_context = PREVAR_scicos_context;
execstr("[ok,"+tt+",exprs]=scicos_getvalue(btitre,bitems,ss,exprs)");
        if (this.ok) {
        x = arg1;
        PREVAR_scicos_context = scicos_context;
        sblock = x.model.rpar;
        [sblock,%w,needcompile2,this.ok] = do_eval(sblock,list(),scicos_context);
        y = max(2,this.needcompile,needcompile2);
        x.graphics.exprs[1-1] = exprs;
        x.model.rpar = sblock;
        } else {
        x = arg1;
}
    }
}
/* autogenerated from "macros/Misc/EDGETRIGGER.sci" */
function EDGETRIGGER() {
    EDGETRIGGER.prototype.define = function EDGETRIGGER() {
        edge = 1;
        model = scicos_model();
        model.sim = list("edgetrig",4);
        model.in1 = 1;
        model.out = 1;
        model.dstate = 0;
        model.nzcross = 1;
        model.ipar = sign(edge);
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [string(edge)];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    EDGETRIGGER.prototype.details = function EDGETRIGGER() {
    }
    EDGETRIGGER.prototype.get = function EDGETRIGGER() {
    }
    EDGETRIGGER.prototype.set = function EDGETRIGGER() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,edge,exprs] = scicos_getvalue("Set edge trigger block parameters",["rising (1), falling (-1), both (0)"],list("vec",1),exprs);
        if (!ok) {
break;
}
        model.ipar = sign(edge);
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/Misc/EDGE_TRIGGER.sci" */
function EDGE_TRIGGER() {
    EDGE_TRIGGER.prototype.define = function EDGE_TRIGGER() {
        scs_m_1 = scicos_diagram();
        scs_m_1.objs[1-1] = this.EDGETRIGGER["define"-1];
        scs_m_1.objs[2-1] = IFTHEL_f("define");
        scs_m_1.objs[3-1] = IN_f("define");
        scs_m_1.objs[4-1] = CLKOUTV_f("define");
        scs_m_1.objs[5-1] = scicos_link();
        scs_m_1.objs[6-1] = scicos_link();
        scs_m_1.objs[7-1] = scicos_link();
        blk = scs_m_1.objs[1-1];
        graphics = blk.graphics;
        model = blk.model;
        graphics.orig = [60,0];
        graphics.sz = [60,40];
        graphics.exprs = "0";
        model.ipar = 0;
        graphics.pin = 5;
        graphics.pout = 6;
        blk.graphics = graphics;
        blk.model = model;
        scs_m_1.objs[1-1] = blk;
        blk = scs_m_1.objs[2-1];
        graphics = blk.graphics;
        model = blk.model;
        graphics.orig = [160,0];
        graphics.sz = [60,40];
        graphics.exprs = [["0"],["0"]];
        model.evtin = [];
        model.nzcross = 0;
        model.nmode = 0;
        graphics.pin = 6;
        graphics.peout = [[7],[0]];
        blk.graphics = graphics;
        blk.model = model;
        scs_m_1.objs[2-1] = blk;
        blk = scs_m_1.objs[3-1];
        graphics = blk.graphics;
        model = blk.model;
        graphics.orig = [0,10];
        graphics.sz = [20,20];
        graphics.exprs = ["1"];
        model.ipar = 1;
        graphics.pout = 5;
        blk.graphics = graphics;
        blk.model = model;
        scs_m_1.objs[3-1] = blk;
        blk = scs_m_1.objs[4-1];
        graphics = blk.graphics;
        model = blk.model;
        graphics.orig = [170,-60];
        graphics.sz = [20,20];
        graphics.exprs = ["1"];
        model.ipar = 1;
        graphics.pein = 7;
        blk.graphics = graphics;
        blk.model = model;
        scs_m_1.objs[4-1] = blk;
        lnk = scs_m_1.objs[5-1];
        lnk.from = [3,1,0];
        lnk.to = [1,1,1];
        scs_m_1.objs[5-1] = lnk;
        lnk = scs_m_1.objs[6-1];
        lnk.from = [1,1,0];
        lnk.to = [2,1,1];
        scs_m_1.objs[6-1] = lnk;
        lnk = scs_m_1.objs[7-1];
        lnk.ct = [5,-1];
        lnk.from = [2,1,0];
        lnk.to = [4,1,1];
        scs_m_1.objs[7-1] = lnk;
blk={};
lnk={};
        model = scicos_model();
        model.sim = "csuper";
        model.in1 = 1;
        model.evtout = 1;
        model.rpar = scs_m_1;
        gr_i = [];
        x = standard_define([3,2],model,[],gr_i);
    }
    EDGE_TRIGGER.prototype.details = function EDGE_TRIGGER() {
    }
    EDGE_TRIGGER.prototype.get = function EDGE_TRIGGER() {
    }
    EDGE_TRIGGER.prototype.set = function EDGE_TRIGGER() {
for (i=1;i<=length(arg1.model.rpar.objs);i+=1) {
        o = arg1.model.rpar.objs[i-1];
        if (typeof(o)=="Block"&&o.gui=="EDGETRIGGER") {
        ppath = list(i);
break;
}
}
        newpar = list();
        y = 0;
        for (path in ppath) {
        np = size(path,"*");
        spath = list();
for (k=1;k<=np;k+=1) {
        spath[$+1-1] = "model";
        spath[$+1-1] = "rpar";
        spath[$+1-1] = "objs";
        spath[$+1-1] = path[k-1];
}
        xx = arg1[spath-1];
execstr("xxn="+xx.gui+"(\'set\',xx)");
        if (diffobjs(this.xxn,xx)) {
        model = xx.model;
        model_n = this.xxn.model;
        if (!is_modelica_block(xx)) {
        modified = or(model.sim!=model_n.sim)||!isequal(model.state,model_n.state)||!isequal(model.dstate,model_n.dstate)||!isequal(model.rpar,model_n.rpar)||!isequal(model.ipar,model_n.ipar)||!isequal(model.label,model_n.label);
        if (or(model.in1!=model_n.in1)||or(model.out!=model_n.out)) {
        needcompile = 1;
}
        if (or(model.firing!=model_n.firing)) {
        needcompile = 2;
}
        if ((size(model.in1,"*")!=size(model_n.in1,"*"))||(size(model.out,"*")!=size(model_n.out,"*"))) {
        needcompile = 4;
}
        if (model.sim=="input"||model.sim=="output") {
        if (model.ipar!=model_n.ipar) {
        needcompile = 4;
}
}
        if (or(model.blocktype!=model_n.blocktype)||or(model.dep_ut!=model_n.dep_ut)) {
        needcompile = 4;
}
        if ((model.nzcross!=model_n.nzcross)||(model.nmode!=model_n.nmode)) {
        needcompile = 4;
}
        if (prod(size(model_n.sim))>1) {
        if (model_n.sim[2-1]>1000) {
        if (model.sim[1-1]!=model_n.sim[1-1]) {
        needcompile = 4;
}
}
}
        } else {
        modified = or(model_n!=model);
        eq = model.equations;
        eqn = model_n.equations;
        if (or(eq.model!=eqn.model)||or(eq.inputs!=eqn.inputs)||or(eq.outputs!=eqn.outputs)) {
        needcompile = 4;
}
}
        arg1[spath-1] = this.xxn;
        newpar[size(newpar)+1-1] = path;
        y = max(y,needcompile);
}
}
        x = arg1;
        typ = newpar;
    }
}
/* autogenerated from "macros/Misc/ENDBLK.sci" */
function ENDBLK() {
    ENDBLK.prototype.define = function ENDBLK() {
        scs_m_1 = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[-159.096,811.104,-121.216,617.984,1323,1008,331,284,630,480,0,7,1.4],Title="ENDBLK",tol=[0.0001,0.000001,1.000e-10,100001,0,0],tf=100000,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m_1.objs[1-1] = scicos_block(gui="END_c",graphics=scicos_graphics(orig=[272.104,249.11733],sz=[40,40],flip=true,theta=0,exprs="1.000E+08",pin=[],pout=[],pein=2,peout=2,gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim=list("scicosexit",4),in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=1,state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="d",firing=1.000e+08,dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[2-1] = scicos_link(xx=[[292.104],[292.104],[261.83733],[261.83733],[292.104],[292.104]],yy=[[243.40305],[234.45067],[234.45067],[305.584],[305.584],[294.83162]],id="drawlink",thick=[0,0],ct=[5,-1],from=[1,1,0],to=[1,1,1]);
        model = scicos_model(sim="csuper",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=scs_m_1,ipar=[],opar=list(),blocktype="h",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list());
        gr_i = [];
        x = standard_define([2,2],model,[],gr_i);
    }
    ENDBLK.prototype.details = function ENDBLK() {
    }
    ENDBLK.prototype.get = function ENDBLK() {
    }
    ENDBLK.prototype.set = function ENDBLK() {
for (i=1;i<=length(arg1.model.rpar.objs);i+=1) {
        o = arg1.model.rpar.objs[i-1];
        if (typeof(o)=="Block"&&o.gui=="END_c") {
        ppath = list(i);
break;
}
}
        newpar = list();
        y = 0;
        for (path in ppath) {
        np = size(path,"*");
        spath = list();
for (k=1;k<=np;k+=1) {
        spath[$+1-1] = "model";
        spath[$+1-1] = "rpar";
        spath[$+1-1] = "objs";
        spath[$+1-1] = path[k-1];
}
        xx = arg1[spath-1];
execstr("xxn="+xx.gui+"(\'set\',xx)");
        if (!this.isequalbitwise[this.xxn-1][xx-1]) {
        model = xx.model;
        model_n = this.xxn.model;
        if (!is_modelica_block(xx)) {
        modified = or(model.sim!=model_n.sim)||!isequal(model.state,model_n.state)||!isequal(model.dstate,model_n.dstate)||!isequal(model.odstate,model_n.odstate)||!isequal(model.rpar,model_n.rpar)||!isequal(model.ipar,model_n.ipar)||!isequal(model.opar,model_n.opar)||!isequal(model.label,model_n.label);
        if (or(model.in1!=model_n.in1)||or(model.out!=model_n.out)||or(model.in2!=model_n.in2)||or(model.out2!=model_n.out2)||or(model.outtyp!=model_n.outtyp)||or(model.intyp!=model_n.intyp)) {
        needcompile = 1;
}
        if (or(model.firing!=model_n.firing)) {
        needcompile = 2;
}
        if ((size(model.in1,"*")!=size(model_n.in1,"*"))||(size(model.out,"*")!=size(model_n.out,"*"))||(size(model.evtin,"*")!=size(model_n.evtin,"*"))) {
        needcompile = 4;
}
        if (model.sim=="input"||model.sim=="output") {
        if (model.ipar!=model_n.ipar) {
        needcompile = 4;
}
}
        if (or(model.blocktype!=model_n.blocktype)||or(model.dep_ut!=model_n.dep_ut)) {
        needcompile = 4;
}
        if ((model.nzcross!=model_n.nzcross)||(model.nmode!=model_n.nmode)) {
        needcompile = 4;
}
        if (prod(size(model_n.sim))>1) {
        if (model_n.sim[2-1]>1000) {
        if (model.sim[1-1]!=model_n.sim[1-1]) {
        needcompile = 4;
}
}
}
        } else {
        modified = or(model_n!=model);
        eq = model.equations;
        eqn = model_n.equations;
        if (or(eq.model!=eqn.model)||or(eq.inputs!=eqn.inputs)||or(eq.outputs!=eqn.outputs)) {
        needcompile = 4;
}
}
        arg1[spath-1] = this.xxn;
        newpar[size(newpar)+1-1] = path;
        y = max(y,needcompile);
}
}
        x = arg1;
        typ = newpar;
    }
}
/* autogenerated from "macros/Misc/Extract_Activation.sci" */
function Extract_Activation() {
    Extract_Activation.prototype.define = function Extract_Activation() {
        scs_m_1 = scicos_diagram();
        scs_m_1.objs[1-1] = IFTHEL_f("define");
        scs_m_1.objs[2-1] = CLKSOMV_f("define");
        scs_m_1.objs[3-1] = IN_f("define");
        scs_m_1.objs[4-1] = CLKOUTV_f("define");
        scs_m_1.objs[5-1] = scicos_link();
        scs_m_1.objs[6-1] = scicos_link();
        scs_m_1.objs[7-1] = scicos_link();
        scs_m_1.objs[8-1] = scicos_link();
        blk = scs_m_1.objs[1-1];
        graphics = blk.graphics;
        model = blk.model;
        graphics.orig = [80,0];
        graphics.sz = [60,40];
        graphics.exprs = [["0"],["0"]];
        model.evtin = [];
        model.nzcross = 0;
        model.nmode = 0;
        graphics.pin = 7;
        graphics.peout = [[5],[6]];
        blk.graphics = graphics;
        blk.model = model;
        scs_m_1.objs[1-1] = blk;
        blk = scs_m_1.objs[2-1];
        graphics = blk.graphics;
        model = blk.model;
        graphics.orig = [80,-80];
        graphics.sz = [80,40];
        graphics.pein = [[5],[6]];
        graphics.peout = 8;
        blk.graphics = graphics;
        blk.model = model;
        scs_m_1.objs[2-1] = blk;
        blk = scs_m_1.objs[3-1];
        graphics = blk.graphics;
        model = blk.model;
        graphics.orig = [0,10];
        graphics.sz = [20,20];
        graphics.exprs = ["1"];
        model.ipar = 1;
        graphics.pout = 7;
        blk.graphics = graphics;
        blk.model = model;
        scs_m_1.objs[3-1] = blk;
        blk = scs_m_1.objs[4-1];
        graphics = blk.graphics;
        model = blk.model;
        graphics.orig = [110,-140];
        graphics.sz = [20,20];
        graphics.exprs = ["1"];
        model.ipar = 1;
        graphics.pein = 8;
        blk.graphics = graphics;
        blk.model = model;
        scs_m_1.objs[4-1] = blk;
        lnk = scs_m_1.objs[5-1];
        lnk.ct = [5,-1];
        lnk.from = [1,1,0];
        lnk.to = [2,1,1];
        scs_m_1.objs[5-1] = lnk;
        lnk = scs_m_1.objs[6-1];
        lnk.ct = [5,-1];
        lnk.from = [1,2,0];
        lnk.to = [2,2,1];
        scs_m_1.objs[6-1] = lnk;
        lnk = scs_m_1.objs[7-1];
        lnk.from = [3,1,0];
        lnk.to = [1,1,1];
        scs_m_1.objs[7-1] = lnk;
        lnk = scs_m_1.objs[8-1];
        lnk.ct = [5,-1];
        lnk.from = [2,1,0];
        lnk.to = [4,1,1];
        scs_m_1.objs[8-1] = lnk;
blk={};
lnk={};
        model = scicos_model();
        model.sim = "csuper";
        model.in1 = 1;
        model.evtout = 1;
        model.rpar = scs_m_1;
        gr_i = [];
        x = standard_define([3,2],model,[],gr_i);
    }
    Extract_Activation.prototype.details = function Extract_Activation() {
    }
    Extract_Activation.prototype.get = function Extract_Activation() {
    }
    Extract_Activation.prototype.set = function Extract_Activation() {
        x = arg1;
    }
}
/* autogenerated from "macros/Misc/HYSTHERESIS.sci" */
function HYSTHERESIS() {
    HYSTHERESIS.prototype.define = function HYSTHERESIS() {
        in1 = 1;
        ipar = [0];
        nzz = 2;
        rpar = [[1],[0],[1],[0]];
        model = scicos_model();
        model.sim = list("hystheresis",4);
        model.in1 = in1;
        model.out = 1;
        model.rpar = rpar;
        model.nzcross = nzz;
        model.nmode = 1;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[string(rpar)],[string(sign(nzz))]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    HYSTHERESIS.prototype.details = function HYSTHERESIS() {
    }
    HYSTHERESIS.prototype.get = function HYSTHERESIS() {
    }
    HYSTHERESIS.prototype.set = function HYSTHERESIS() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,high_lim,low_lim,out_high,out_low,nzz,exprs] = scicos_getvalue("Set parameters",[["switch on at"],["switch off at"],["output when on"],["output when off"],["use zero crossing: yes (1), no (0)"]],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (low_lim>high_lim) {
message("switch on value must be larger than switch off value");
        } else {
        graphics.exprs = exprs;
        model.rpar = transpose([high_lim,low_lim,out_high,out_low]);
        if (nzz>0) {
        nzz = 2;
}
        model.nzcross = nzz;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Misc/IMPSPLIT_f.sci" */
function IMPSPLIT_f() {
    IMPSPLIT_f.prototype.define = function IMPSPLIT_f() {
        model = scicos_model();
        model.sim = "limpsplit";
        mo = modelica();
        mo.model = "limpsplit";
        mo.inputs = "n";
        mo.outputs = [["n"],["n"]];
        model.equations = mo;
        model.in1 = ones(size(mo.inputs,"*"),1);
        model.out = ones(size(mo.outputs,"*"),1);
        x = standard_define([1,1]/3,model,[],[]);
        x.graphics.in_implicit = ["I"];
        x.graphics.out_implicit = ["I","I"];
    }
    IMPSPLIT_f.prototype.details = function IMPSPLIT_f() {
    }
    IMPSPLIT_f.prototype.get = function IMPSPLIT_f() {
    }
    IMPSPLIT_f.prototype.set = function IMPSPLIT_f() {
        x = arg1;
    }
}
/* autogenerated from "macros/Misc/LOGICAL_OP.sci" */
function LOGICAL_OP() {
    LOGICAL_OP.prototype.define = function LOGICAL_OP() {
        in1 = [[-1],[-1]];
        ipar = [0];
        nin = 2;
        model = scicos_model();
        model.sim = list("logicalop",4);
        model.in1 = in1;
        model.out = -1;
        model.ipar = ipar;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[string(nin)],[string(ipar)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    LOGICAL_OP.prototype.details = function LOGICAL_OP() {
    }
    LOGICAL_OP.prototype.get = function LOGICAL_OP() {
    }
    LOGICAL_OP.prototype.set = function LOGICAL_OP() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        if (size(exprs,1)==2) {
        exprs = [[exprs],[sci2exp(1)],[sci2exp(0)]];
}
        while (true) {
        [ok,nin,rule,Datatype,tp,exprs] = scicos_getvalue("Set parameters",[["number of inputs"],["Operator: AND (0), OR (1), NAND (2), NOR (3), XOR (4), NOT (5)","Datatype (1=double 3=int32 ...)"],["Bitwise Rule(0=No 1=yes)"]],list("vec",1,"vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        nin = int(nin);
        rule = int(rule);
        tp = int(tp);
        if (nin<1) {
message("Number of inputs must be >=1 ");
        ok = false;
        } else if ((rule<0)||(rule>5)) {
message("Incorrect operator "+string(rule)+" ; must be 0 to 5.");
        ok = false;
        } else if ((rule==5)&&(nin>1)) {
message("Only one input allowed for NOT operation");
        nin = 1;
        } else if (((Datatype==1)&&(tp!=0))) {
message("Bitwise Rule is only activated when Data type is integer");
        ok = false;
}
        if (ok) {
        if ((tp!=0)) {
        tp = 1;
}
        if (Datatype==1) {
        model.sim = list("logicalop",4);
        model.ipar = [rule];
        } else {
        if (Datatype==3) {
        model.sim = list("logicalop_i32",4);
        } else if (Datatype==4) {
        model.sim = list("logicalop_i16",4);
        } else if (Datatype==5) {
        model.sim = list("logicalop_i8",4);
        } else if (Datatype==6) {
        model.sim = list("logicalop_ui32",4);
        } else if (Datatype==7) {
        model.sim = list("logicalop_ui16",4);
        } else if (Datatype==8) {
        model.sim = list("logicalop_ui8",4);
        } else {
message("Datatype is not supported");
        ok = false;
}
        model.ipar = [[rule],[tp]];
}
        if (ok) {
        it = Datatype*ones(nin,1);
        ot = Datatype;
        in1 = [-ones(nin,1),-2*ones(nin,1)];
        if ((rule!=5)&&(nin==1)) {
        out = [1,1];
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
        } else {
        out = [-1,-2];
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
}
        if (ok) {
        if (rule==0) {
        label = "AND";
        } else if (rule==1) {
        label = "OR";
        } else if (rule==2) {
        label = "NAND";
        } else if (rule==3) {
        label = "NOR";
        } else if (rule==4) {
        label = "XOR";
        } else if (rule==5) {
        label = "NOT";
}
        graphics.exprs = exprs;
        graphics.style = ["blockWithLabel;displayedLabel="+label];
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/Misc/MBLOCK.sci" */
function MBLOCK() {
    MBLOCK.prototype.define = function MBLOCK() {
        this.in1 = ["u1"];
        this.intype = ["I"];
        this.out = [["y1"],["y2"]];
        this.outtype = [["I"],["E"]];
        param = [["R"],["L"]];
        paramv = list(0.1,.0001);
        pprop = [[0],[0]];
        nameF = "generic";
        exprs = tlist(["MBLOCK","in","intype","out","outtype","param","paramv","pprop","nameF","funtxt"],sci2exp(this.in1.slice()),sci2exp(this.intype.slice()),sci2exp(this.out.slice()),sci2exp(this.outtype.slice()),sci2exp(param.slice()),list(string(0.1),string(.0001)),sci2exp(pprop.slice()),nameF,[]);
        model = scicos_model();
        model.blocktype = "c";
        model.dep_ut = [false,true];
        model.rpar = [];
for (i=1;i<=lstsize(paramv);i+=1) {
        model.rpar = [[model.rpar],[paramv[i-1].slice()]];
}
        mo = modelica();
        mo.model = nameF;
        mo.parameters = list(param,paramv);
        model.sim = list(mo.model,30004);
        mo.inputs = this.in1;
        mo.outputs = this.out;
        model.in1 = ones(size(mo.inputs,"r"),1);
        model.out = ones(size(mo.outputs,"r"),1);
        model.equations = mo;
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
        x.graphics.in_implicit = this.intype;
        x.graphics.out_implicit = this.outtype;
    }
    MBLOCK.prototype.details = function MBLOCK() {
    }
    MBLOCK.prototype.get = function MBLOCK() {
    }
    MBLOCK.prototype.set = function MBLOCK() {
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        if (this.type[exprs-1]==15) {
        paramv = list();
        pprop = [];
for (i=1;i<=size(model.rpar,"*");i+=1) {
        paramv[$+1-1] = string(model.rpar[i-1]);
        pprop[$+1-1] = 0;
}
        exprs = tlist(["MBLOCK","in","intype","out","outtype","param","paramv","pprop","nameF","funtxt"],exprs[1-1][1-1],exprs[1-1][2-1],exprs[1-1][3-1],exprs[1-1][4-1],exprs[1-1][5-1],paramv,sci2exp(pprop.slice()),exprs[1-1][7-1],exprs[2-1]);
}
        lab_1 = list(exprs.in1,exprs.intype,exprs.out,exprs.outtype,exprs.param,exprs.pprop,exprs.nameF);
        lab_2 = exprs.paramv;
        while (true) {
        [ok,Tin,Tintype,Tout,Touttype,Tparam,pprop,Tfunam,lab_1] = scicos_getvalue("Set Modelica generic block parameters",[["Input variables:       "],["Input variables types: "],["Output variables:      "],["Output variables types:"],["Parameters in Modelica:"],["Parameters properties: "],["Function name:         "]],list("str",-1,"str",-1,"str",-1,"str",-1,"str",-1,"vec",-1,"str",-1),lab_1);
        if (!ok) {
break;
}
        ierr = execstr("in=stripblanks(evstr(Tin));            intype=stripblanks(evstr(Tintype));            out=stripblanks(evstr(Tout));            outtype=stripblanks(evstr(Touttype));            param=stripblanks(evstr(Tparam));            funam=stripblanks(Tfunam)","errcatch");
        if (ierr!=0) {
messagebox("Error in evaluation of variables.","modal","error");
        ok = false;
}
        if (ok) {
for (i=1;i<=size(this.in1,"*");i+=1) {
        r = false;
        ierr = execstr("r=validvar(in(i))","errcatch");
        if (!r) {
        ok = false;
break;
}
}
        if (!ok) {
messagebox([["Invalid variable name for the input "+string(i)+"."],["\""+this.in1[i-1]+"\""],["Please choose another variable name."]],"modal","error");
}
}
        if (ok) {
for (i=1;i<=size(this.out,"*");i+=1) {
        r = false;
        ierr = execstr("r=validvar(out(i))","errcatch");
        if (!r) {
        ok = false;
break;
}
}
        if (!ok) {
messagebox([["Invalid variable name for the output "+string(i)+"."],["\""+this.out[i-1]+"\""],["Please choose another variable name."]],"modal","error");
}
}
        if (ok) {
        param = param.slice();
for (i=1;i<=size(param,"*");i+=1) {
        r = false;
        ierr = execstr("r=validvar(param(i))","errcatch");
        if (!r) {
        ok = false;
break;
}
}
        if (!ok) {
messagebox([["Invalid variable name for the parameter "+string(i)+"."],["\""+param[i-1]+"\""],["Please choose another variable name."]],"modal","error");
}
}
        if (ok) {
for (i=1;i<=size(this.intype,"*");i+=1) {
        if (this.intype[i-1]!="E"&&this.intype[i-1]!="I") {
messagebox("Input type should be \'E\' or \'I\'!","modal","error");
        ok = false;
break;
}
}
}
        if (ok) {
for (i=1;i<=size(this.outtype,"*");i+=1) {
        if (this.outtype[i-1]!="E"&&this.outtype[i-1]!="I") {
messagebox("Output type should be \'E\' or \'I\'!","modal","error");
        ok = false;
break;
}
}
}
        if (ok) {
        if (or(size(this.intype)!=size(this.in1))) {
messagebox("Input variables are not well defined!","modal","error");
        ok = false;
}
}
        if (ok) {
        if (or(size(this.outtype)!=size(this.out))) {
messagebox("Output variables are not well defined!","modal","error");
        ok = false;
}
}
        if (ok) {
        pprop = pprop.slice();
        if ((size(param,"*")!=size(pprop,"*"))) {
messagebox([["There is differences in"],["size of param and size "],["of param properties."]],"modal","error");
        ok = false;
}
}
        if (ok) {
        if (max(pprop)>2||min(pprop)<0) {
messagebox([["Parameters properties must be :"],["0 : for simple paramater,"],["1 : for initial state value,"],["2 : for a fixed initial state value."]],"modal","error");
        ok = false;
}
}
        if (ok) {
        if (this.funam=="") {
messagebox("The filename is not defined!","modal","error");
        ok = false;
}
}
        if (ok) {
        [dirF,nameF,extF] = fileparts(this.funam);
        if ((extF!=""&&extF!=".mo")||(dirF!=""&&extF!=".mo")) {
messagebox("Filename extention should be \'.mo \' !","modal","error");
        ok = false;
}
}
        if (ok) {
        intypex = find(this.intype=="I");
        outtypex = find(this.outtype=="I");
        [model,graphics,ok] = set_io(model,graphics,list([ones(this.in1),ones(this.in1)],ones(this.in1)),list([ones(this.out),ones(this.out)],ones(this.out)),[],[],intypex,outtypex);
}
        if (ok) {
        Tparam_lab = evstr(Tparam);
        Tparam_sz = size(Tparam_lab,"*");
        if (Tparam_sz>lstsize(lab_2)) {
for (i=1;i<=(Tparam_sz-lstsize(lab_2));i+=1) {
        lab_2[$+1-1] = "0";
}
        } else if (Tparam_sz<lstsize(lab_2)) {
        lab_2_tmp = list();
        if (Tparam_sz!=0) {
for (i=1;i<=(lstsize(lab_2)-Tparam_sz);i+=1) {
        lab_2_tmp[i-1] = lab_2[i-1];
}
}
        lab_2 = lab_2_tmp;
}
        if (Tparam_sz!=0) {
        lhs_txt = "";
        lab_txt = "";
        rhs_txt = "";
for (i=1;i<=Tparam_sz;i+=1) {
        lhs_txt = lhs_txt+"%v"+string(i)+",";
        if (pprop[i-1]==0) {
        lab_txt = lab_txt+"\'"+Tparam_lab[i-1]+"\';";
        } else if (pprop[i-1]==1) {
        lab_txt = lab_txt+"\'"+Tparam_lab[i-1]+" (state) \';";
        } else if (pprop[i-1]==2) {
        lab_txt = lab_txt+"\'"+Tparam_lab[i-1]+" (fixed state) \';";
}
        rhs_txt = rhs_txt+"\'vec\',-1,";
}
        lhs_txt = part(lhs_txt,1,length(lhs_txt)-1);
        lab_txt = part(lab_txt,1,length(lab_txt)-1);
        rhs_txt = part(rhs_txt,1,length(rhs_txt)-1);
        getvalue_txt = "[ok,"+lhs_txt+",lab_2]=scicos_getvalue(\'Set parameters values\',["+lab_txt+"],"+"list("+rhs_txt+"),lab_2)";
execstr(getvalue_txt);
        if (!ok) {
        lab_2 = exprs.paramv;
}
}
}
        if (ok) {
        paramv = list();
for (i=1;i<=Tparam_sz;i+=1) {
execstr("paramv("+string(i)+")=%v"+string(i));
}
}
        if (ok) {
        if (extF==".mo"&&fileinfo(this.funam)!=[]) {
        tt = mgetl(this.funam);
        } else {
        tt = exprs.funtxt;
        mo = model.equations;
        if (mo.model!=nameF) {
        tt = [];
}
}
        [ok,tt] = MODCOM(this.funam,tt,this.in1,this.out,param,paramv,pprop);
        if (!ok) {
break;
}
}
        if (ok) {
        mo = modelica();
        mo.model = nameF;
        mo.inputs = this.in1;
        mo.outputs = this.out;
        if (max(pprop)>0) {
        mo.parameters = list(transpose(param),paramv,transpose(pprop));
        } else {
        mo.parameters = list(transpose(param),paramv);
}
        model.equations = mo;
        model.rpar = [];
for (i=1;i<=lstsize(paramv);i+=1) {
        model.rpar = [[model.rpar],[paramv[i-1].slice()]];
}
        model.sim[1-1] = this.funam;
        exprs.in1 = lab_1[1-1];
        exprs.intype = lab_1[2-1];
        exprs.out = lab_1[3-1];
        exprs.outtype = lab_1[4-1];
        exprs.param = lab_1[5-1];
        exprs.paramv = list();
        if (Tparam_sz!=0) {
        if (this.type[lab_2-1]==15) {
for (i=1;i<=lstsize(lab_2);i+=1) {
        exprs.paramv[i-1] = lab_2[i-1];
}
        } else {
for (i=1;i<=size(lab_2,"*");i+=1) {
        exprs.paramv[i-1] = lab_2[i-1];
}
}
}
        exprs.pprop = lab_1[6-1];
        exprs.nameF = lab_1[7-1];
        exprs.funtxt = tt;
        x.model = model;
        graphics.gr_i[1-1][1-1] = "txt=[\'Modelica\';\' "+nameF+" \'];";
        graphics.in_implicit = this.intype;
        graphics.out_implicit = this.outtype;
        graphics.exprs = exprs;
        x.graphics = graphics;
break;
}
}
    }
}
/* autogenerated from "macros/Misc/MEMORY_f.sci" */
function MEMORY_f() {
    MEMORY_f.prototype.define = function MEMORY_f() {
        z = 0;
        in1 = 1;
        exprs = [[string(z)],[string(1)]];
        model = scicos_model();
        model.sim = "memo";
        model.in1 = in1;
        model.out = in1;
        model.evtin = 1;
        model.dstate = 0;
        model.rpar = z;
        model.blocktype = "m";
        model.dep_ut = [false,false];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    MEMORY_f.prototype.details = function MEMORY_f() {
    }
    MEMORY_f.prototype.get = function MEMORY_f() {
    }
    MEMORY_f.prototype.set = function MEMORY_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,a,inh,exprs] = scicos_getvalue("Set memory block parameters",[["initial condition"],["Inherit (1: no, 0: yes)"]],list("vec",-1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (inh==0) {
        inh = [];
        } else {
        inh = 1;
}
        [model,graphics,ok] = check_io(model,graphics,-1,-1,inh,[]);
        out = size(a,"*");
        if (out==0) {
        ok = false;
messagebox("Initial condition empty","modal","error");
}
        in1 = out;
        if (ok) {
        graphics.exprs = exprs;
        model.rpar = a;
        model.in1 = in1;
        model.out = out;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Misc/MPBLOCK.sci" */
function MPBLOCK() {
    MPBLOCK.prototype.define = function MPBLOCK() {
        this.in1 = ["u"];
        this.intype = ["I"];
        this.out = [["y1"],["y2"]];
        this.outtype = [["I"],["I"]];
        param = [];
        paramv = list();
        pprop = [];
        nameF = "myModel";
        exprs = tlist(["MPBLOCK","in","intype","out","outtype","param","paramv","pprop","nameF","funtxt"],sci2exp(this.in1.slice()),sci2exp(this.intype.slice()),sci2exp(this.out.slice()),sci2exp(this.outtype.slice()),sci2exp(param.slice()),list(string(0.1),string(.0001)),sci2exp(pprop.slice()),nameF,[]);
        model = scicos_model();
        model.blocktype = "c";
        model.dep_ut = [true,true];
        model.rpar = [];
for (i=1;i<=lstsize(paramv);i+=1) {
        model.rpar = [[model.rpar],[paramv[i-1].slice()]];
}
        mo = modelica();
        mo.model = nameF;
        mo.parameters = list(param,paramv);
        model.sim = list(mo.model,10004);
        mo.inputs = this.in1;
        mo.outputs = this.out;
        model.in1 = ones(size(mo.inputs,"r"),1);
        model.out = ones(size(mo.outputs,"r"),1);
        model.equations = mo;
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
        x.graphics.in_implicit = this.intype;
        x.graphics.out_implicit = this.outtype;
    }
    MPBLOCK.prototype.details = function MPBLOCK() {
    }
    MPBLOCK.prototype.get = function MPBLOCK() {
    }
    MPBLOCK.prototype.set = function MPBLOCK() {
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        if (this.type[exprs-1]==15) {
        paramv = list();
        pprop = [];
for (i=1;i<=size(model.rpar,"*");i+=1) {
        paramv[$+1-1] = string(model.rpar[i-1]);
        pprop[$+1-1] = 0;
}
        exprs = tlist(["MPBLOCK","in","intype","out","outtype","param","paramv","pprop","nameF","funtxt"],exprs[1-1][1-1],exprs[1-1][2-1],exprs[1-1][3-1],exprs[1-1][4-1],exprs[1-1][5-1],paramv,sci2exp(pprop.slice()),exprs[1-1][7-1],exprs[2-1]);
}
        lab_1 = list(exprs.in1,exprs.intype,exprs.out,exprs.outtype,exprs.param,exprs.pprop,exprs.nameF);
        lab_2 = exprs.paramv;
        while (true) {
        [ok,Tin,Tintype,Tout,Touttype,Tparam,pprop,Tfunam,lab_1] = getvalue("Set Modelica generic block parameters",[["Input variables:       "],["Input variables types: "],["Output variables:      "],["Output variables types:"],["Parameters in Modelica:"],["Parameters properties: "],["Model name in packages:"]],list("str",-1,"str",-1,"str",-1,"str",-1,"str",-1,"vec",-1,"str",-1),lab_1);
        if (!ok) {
break;
}
        ierr = execstr("in=stripblanks(evstr(Tin));            intype=stripblanks(evstr(Tintype));            out=stripblanks(evstr(Tout));            outtype=stripblanks(evstr(Touttype));            param=stripblanks(evstr(Tparam));            funam=stripblanks(Tfunam)","errcatch");
        if (ierr!=0) {
x_message("Error in evaluation of variables.");
        ok = false;
}
        if (ok) {
for (i=1;i<=size(this.in1,"*");i+=1) {
        r = false;
        ierr = execstr("r=validvar(in(i))","errcatch");
        if (!r) {
        ok = false;
break;
}
}
        if (!ok) {
x_message([["Invalid variable name for the input "+string(i)+"."],["\""+this.in1[i-1]+"\""],["Please choose another variable name."]]);
}
}
        if (ok) {
for (i=1;i<=size(this.out,"*");i+=1) {
        r = false;
        ierr = execstr("r=validvar(out(i))","errcatch");
        if (!r) {
        ok = false;
break;
}
}
        if (!ok) {
x_message([["Invalid variable name for the output "+string(i)+"."],["\""+this.out[i-1]+"\""],["Please choose another variable name."]]);
}
}
        if (ok) {
        param = param.slice();
for (i=1;i<=size(param,"*");i+=1) {
        r = false;
        ierr = execstr("r=validvar(param(i))","errcatch");
        if (!r) {
        ok = false;
break;
}
}
        if (!ok) {
x_message([["Invalid variable name for the parameter "+string(i)+"."],["\""+param[i-1]+"\""],["Please choose another variable name."]]);
}
}
        if (ok) {
for (i=1;i<=size(this.intype,"*");i+=1) {
        if (this.intype[i-1]!="E"&&this.intype[i-1]!="I") {
x_message("Input type should be \'E\' or \'I\'!");
        ok = false;
break;
}
}
}
        if (ok) {
for (i=1;i<=size(this.outtype,"*");i+=1) {
        if (this.outtype[i-1]!="E"&&this.outtype[i-1]!="I") {
x_message("Output type should be \'E\' or \'I\'!");
        ok = false;
break;
}
}
}
        if (ok) {
        if (or(size(this.intype)!=size(this.in1))) {
x_message("Input variables are not well defined!");
        ok = false;
}
}
        if (ok) {
        if (or(size(this.outtype)!=size(this.out))) {
x_message("Output variables are not well defined!");
        ok = false;
}
}
        if (ok) {
        pprop = pprop.slice();
        if ((size(param,"*")!=size(pprop,"*"))) {
x_message([["There is differences in"],["size of param and size "],["of param properties."]]);
        ok = false;
}
}
        if (ok) {
        if (max(pprop)>2||min(pprop)<0) {
x_message([["Parameters properties must be :"],["0 : if it is a paramaters"],["1 : if it is an initial value of state,"],["2 : it it is a fixed initial state value."]]);
        ok = false;
}
}
        if (ok) {
        if (this.funam=="") {
x_message("The model name is not defined!");
        ok = false;
}
}
        if (ok) {
        [dirF,nameF,extF] = fileparts(this.funam);
        if ((extF!="")||(dirF!="")) {
x_message("Invalid model name!");
        ok = false;
}
}
        if (ok) {
        intypex = find(this.intype=="I");
        outtypex = find(this.outtype=="I");
        [model,graphics,ok] = set_io(model,graphics,list([ones(this.in1),ones(this.in1)],ones(this.in1)),list([ones(this.out),ones(this.out)],ones(this.out)),[],[],intypex,outtypex);
}
        if (ok) {
        Tparam_lab = evstr(Tparam);
        Tparam_sz = size(Tparam_lab,"*");
        if (Tparam_sz>lstsize(lab_2)) {
for (i=1;i<=(Tparam_sz-lstsize(lab_2));i+=1) {
        lab_2[$+1-1] = "0";
}
        } else if (Tparam_sz<lstsize(lab_2)) {
        lab_2_tmp = list();
        if (Tparam_sz!=0) {
for (i=1;i<=Tparam_sz;i+=1) {
        ee = evstr(exprs.param);
for (j=1;j<=size(ee,"r");j+=1) {
        if (ee[j-1]==Tparam_lab[i-1]) {
        lab_2_tmp[i-1] = lab_2[j-1];
}
}
}
        lab_2 = lab_2_tmp;
}
}
        if (Tparam_sz!=0) {
        lhs_txt = "";
        lab_txt = "";
        rhs_txt = "";
for (i=1;i<=Tparam_sz;i+=1) {
        lhs_txt = lhs_txt+"%v"+string(i)+",";
        if (pprop[i-1]==0) {
        lab_txt = lab_txt+"\'"+Tparam_lab[i-1]+"\';";
        } else if (pprop[i-1]==1) {
        lab_txt = lab_txt+"\'"+Tparam_lab[i-1]+" (state) \';";
        } else if (pprop[i-1]==2) {
        lab_txt = lab_txt+"\'"+Tparam_lab[i-1]+" (fixed state) \';";
}
        rhs_txt = rhs_txt+"\'vec\',-1,";
}
        lhs_txt = part(lhs_txt,1,length(lhs_txt)-1);
        lab_txt = part(lab_txt,1,length(lab_txt)-1);
        rhs_txt = part(rhs_txt,1,length(rhs_txt)-1);
        getvalue_txt = "[ok,"+lhs_txt+",lab_2]=scicos_getvalue(\'Set parameters values\',["+lab_txt+"],"+"list("+rhs_txt+"),lab_2)";
execstr(getvalue_txt);
        if (!ok) {
        lab_2 = exprs.paramv;
}
}
}
        if (ok) {
        paramv = list();
for (i=1;i<=Tparam_sz;i+=1) {
execstr("paramv("+string(i)+")=%v"+string(i));
}
}
        if (ok) {
        mo = modelica();
        mo.model = nameF;
        mo.inputs = this.in1;
        mo.outputs = this.out;
        if (pprop!=[]) {
        if (max(pprop)>0) {
        mo.parameters = list(transpose(param),paramv,transpose(pprop));
        } else {
        mo.parameters = list(transpose(param),paramv);
}
}
        model.equations = mo;
        model.rpar = [];
for (i=1;i<=lstsize(paramv);i+=1) {
        model.rpar = [[model.rpar],[double(paramv[i-1].slice())]];
}
        model.sim[1-1] = this.funam;
        exprs.in1 = lab_1[1-1];
        exprs.intype = lab_1[2-1];
        exprs.out = lab_1[3-1];
        exprs.outtype = lab_1[4-1];
        exprs.param = lab_1[5-1];
        exprs.paramv = list();
        if (Tparam_sz!=0) {
        if (this.type[lab_2-1]==15) {
for (i=1;i<=lstsize(lab_2);i+=1) {
        exprs.paramv[i-1] = lab_2[i-1];
}
        } else {
for (i=1;i<=size(lab_2,"*");i+=1) {
        exprs.paramv[i-1] = lab_2[i-1];
}
}
}
        exprs.pprop = lab_1[6-1];
        exprs.nameF = lab_1[7-1];
        exprs.funtxt = "";
        x.model = model;
        graphics.gr_i[1-1][1-1] = "txt=[\' "+nameF+" \'];";
        graphics.in_implicit = this.intype;
        graphics.out_implicit = this.outtype;
        graphics.exprs = exprs;
        x.graphics = graphics;
break;
}
}
    }
}
/* autogenerated from "macros/Misc/PAL_f.sci" */
function PAL_f() {
    PAL_f.prototype.define = function PAL_f() {
        scs = scicos_diagram();
        scs.props.title = "Palette";
        model = scicos_model();
        model.sim = "palette";
        model.in1 = [];
        model.out = [];
        model.rpar = scs;
        model.blocktype = "h";
        model.dep_ut = [false,false];
        gr_i = [];
        x = standard_define([2,2],model,[],gr_i);
        x.graphics.id = scs.props.title[1-1];
    }
    PAL_f.prototype.details = function PAL_f() {
    }
    PAL_f.prototype.get = function PAL_f() {
    }
    PAL_f.prototype.set = function PAL_f() {
        [x,newparameters,needcompile,edited] = scicos(arg1.model.rpar);
        arg1.graphics.id = x.props.title[1-1];
        arg1.model.rpar = x;
        x = arg1;
        y = [];
        typ = [];
%exit=resume(false)
    }
}
/* autogenerated from "macros/Misc/PENDULUM_ANIM.sci" */
function PENDULUM_ANIM() {
    PENDULUM_ANIM.prototype.define = function PENDULUM_ANIM() {
        plen = 2;
        csiz = 2;
        phi = 0;
        xmin = -5;
        xmax = 5;
        ymin = -5;
        ymax = 5;
        model = scicos_model();
        model.sim = list("anim_pen",5);
        model.in1 = [[1],[1]];
        model.evtin = 1;
        model.dstate = 0;
        model.rpar = [[plen],[csiz],[phi],[xmin],[xmax],[ymin],[ymax]];
        model.blocktype = "d";
        model.dep_ut = [false,false];
        exprs = string(model.rpar);
        gr_i = [];
        x = standard_define([3,3],model,exprs,gr_i);
    }
    PENDULUM_ANIM.prototype.details = function PENDULUM_ANIM() {
    }
    PENDULUM_ANIM.prototype.get = function PENDULUM_ANIM() {
    }
    PENDULUM_ANIM.prototype.set = function PENDULUM_ANIM() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        dstate = model.dstate;
        while (true) {
        [ok,plen,csiz,phi,xmin,xmax,ymin,ymax,exprs] = scicos_getvalue("Set Scope parameters",[["pendulum length"],["cart size (square side)"],["slope"],["Xmin"],["Xmax"],["Ymin"],["Ymax"]],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        mess = [];
        if (plen<=0||csiz<=0) {
        mess = [[mess],["Pendulum length and cart size must be positive."],[" "]];
        ok = false;
}
        if (ymin>=ymax) {
        mess = [[mess],["Ymax must be greater than Ymin"],[" "]];
        ok = false;
}
        if (xmin>=xmax) {
        mess = [[mess],["Xmax must be greater than Xmin"],[" "]];
        ok = false;
}
        if (!ok) {
message(mess);
        } else {
        rpar = [[plen],[csiz],[phi],[xmin],[xmax],[ymin],[ymax]];
        model.rpar = rpar;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Misc/RATELIMITER.sci" */
function RATELIMITER() {
    RATELIMITER.prototype.define = function RATELIMITER() {
        minp = -1;
        maxp = 1;
        rpar = [[maxp],[minp]];
        model = scicos_model();
        model.sim = list("ratelimiter",4);
        model.in1 = 1;
        model.out = 1;
        model.rpar = rpar;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[string(maxp)],[string(minp)]];
        gr_i = [];
        x = standard_define([3.5,2],model,exprs,gr_i);
    }
    RATELIMITER.prototype.details = function RATELIMITER() {
    }
    RATELIMITER.prototype.get = function RATELIMITER() {
    }
    RATELIMITER.prototype.set = function RATELIMITER() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,maxp,minp,exprs] = scicos_getvalue("Set rate limiter parameters",[["max slope"],["min slope"]],list("vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (maxp<=minp||maxp<=0||minp>=0) {
message("We must have max_slope> 0 > min_slope.");
        } else {
        rpar = [[maxp],[minp]];
        model.rpar = rpar;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Misc/RELATIONALOP.sci" */
function RELATIONALOP() {
    RELATIONALOP.prototype.define = function RELATIONALOP() {
        ipar = [2];
        label = "&lt";
        model = scicos_model();
        model.sim = list("relationalop",4);
        model.in1 = [[1],[1]];
        model.out = 1;
        model.ipar = ipar;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[string(ipar)],[string(0)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
        x.graphics.style = ["fontSize=13;fontStyle=1;displayedLabel="+label];
    }
    RELATIONALOP.prototype.details = function RELATIONALOP() {
    }
    RELATIONALOP.prototype.get = function RELATIONALOP() {
    }
    RELATIONALOP.prototype.set = function RELATIONALOP() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        if (size(exprs,1)==2) {
        exprs = [[exprs],[sci2exp(1)]];
}
        while (true) {
        [ok,rule,zcr,Datatype,exprs] = scicos_getvalue("Set parameters",[["Operator: == (0), ~= (1), < (2), <= (3), > (4), >= (5)"],["Use zero crossing (no: 0), (yes: 1)","Datatype (1=double 3=int32 ...)"]],list("vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        rule = int(rule);
        if (zcr!=0) {
        zcr = 1;
}
        if ((rule<0)||(rule>5)) {
message("Incorrect operator "+string(rule)+" ; must be 0 to 5.");
        ok = false;
}
        if ((Datatype==1)) {
        model.sim = list("relational_op",4);
        } else if ((Datatype==3||Datatype==9)) {
        model.sim = list("relational_op_i32",4);
        } else if ((Datatype==4)) {
        model.sim = list("relational_op_i16",4);
        } else if ((Datatype==5)) {
        model.sim = list("relational_op_i8",4);
        } else if ((Datatype==6)) {
        model.sim = list("relational_op_ui32",4);
        } else if ((Datatype==7)) {
        model.sim = list("relational_op_ui16",4);
        } else if ((Datatype==8)) {
        model.sim = list("relational_op_ui8",4);
        } else {
message("Datatype is not supported");
        ok = false;
}
        if (ok) {
        it = Datatype*ones(1,2);
        ot = Datatype;
        in1 = [[-1,-2],[-1,-2]];
        out = [-1,-2];
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
        if (ok) {
        if (rule==0) {
        label = "==";
        } else if (rule==1) {
        label = "~=";
        } else if (rule==2) {
        label = "&#60;";
        } else if (rule==3) {
        label = "&#8804;";
        } else if (rule==4) {
        label = "&#62;";
        } else if (rule==5) {
        label = "&#8805;";
}
        graphics.exprs = exprs;
        graphics.style = ["fontSize=13;fontStyle=1;displayedLabel="+label];
        model.ipar = [rule];
        model.nzcross = zcr;
        model.nmode = zcr;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Misc/SPLIT_f.sci" */
function SPLIT_f() {
    SPLIT_f.prototype.define = function SPLIT_f() {
        model = scicos_model();
        model.sim = "lsplit";
        model.in1 = -1;
        model.out = [[-1],[-1],[-1]];
        model.blocktype = "c";
        model.dep_ut = [true,false];
        x = standard_define([1,1]/3,model,[],[]);
    }
    SPLIT_f.prototype.details = function SPLIT_f() {
    }
    SPLIT_f.prototype.get = function SPLIT_f() {
    }
    SPLIT_f.prototype.set = function SPLIT_f() {
        x = arg1;
    }
}
/* autogenerated from "macros/Misc/SUPER_f.sci" */
function SUPER_f() {
    SUPER_f.prototype.define = function SUPER_f() {
        scs = scicos_diagram();
        scs.props.title = "Super Block";
        in1 = IN_f("define");
        in1.graphics.orig = [40,40];
        in1.graphics.sz = [20,20];
        out = OUT_f("define");
        out.graphics.orig = [240,40];
        out.graphics.sz = [20,20];
        scs.objs[1-1] = in1;
        scs.objs[2-1] = out;
        model = scicos_model();
        model.sim = "super";
        model.in1 = 1;
        model.out = 1;
        model.rpar = scs;
        model.blocktype = "h";
        model.dep_ut = [false,false];
        gr_i = [];
        x = standard_define([2,2],model,[],gr_i);
    }
    SUPER_f.prototype.details = function SUPER_f() {
    }
    SUPER_f.prototype.get = function SUPER_f() {
    }
    SUPER_f.prototype.set = function SUPER_f() {
xcos(arg1.model.rpar);
    }
}
/* autogenerated from "macros/Misc/TEXT_f.sci" */
function TEXT_f() {
    TEXT_f.prototype.define = function TEXT_f() {
        font = 2;
        siz = 1;
        model = scicos_model();
        model.sim = "text";
        model.rpar = "Text";
        model.ipar = [[font],[siz]];
        exprs = [["Text"],[string(font)],[string(siz)]];
        graphics = scicos_graphics();
        graphics.orig = [0,0];
        graphics.sz = [2,1];
        graphics.exprs = exprs;
        x = mlist(["Text","graphics","model","void","gui"],graphics,model," ","TEXT_f");
    }
    TEXT_f.prototype.details = function TEXT_f() {
    }
    TEXT_f.prototype.get = function TEXT_f() {
    }
    TEXT_f.prototype.set = function TEXT_f() {
        x = arg1;
        graphics = arg1.graphics;
        orig = graphics.orig;
        exprs = graphics.exprs;
        model = arg1.model;
        if (size(exprs,"*")==1) {
        exprs = [[exprs],["3"],["1"]];
}
        while (true) {
        [ok,txt,font,siz,exprs] = scicos_getvalue("Set Text block parameters",[["Text"],["Font number"],["Font size"]],list("str",-1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (font<=0||font>6) {
message("Font number must be greater than 0 and less than 7");
        ok = false;
}
        if (siz<0) {
message("Font size must be positive");
        ok = false;
}
        if (ok) {
        graphics.exprs = exprs;
        gh_winpal = gca();
        default_font_style = gh_winpal.font_style;
        default_font_size = gh_winpal.font_size;
        default_font_color = gh_winpal.font_color;
        gh_winpal.font_style = font;
        gh_winpal.font_size = siz;
        r = xstringl(0,0,exprs[1-1],evstr(exprs[2-1]),evstr(exprs[3-1]));
        gh_winpal.font_style = default_font_style;
        gh_winpal.font_size = default_font_size;
        gh_winpal.font_color = default_font_color;
        sz = r.slice(3-1,4);
        graphics.sz = sz;
        x.graphics = graphics;
        ipar = [[font],[siz]];
        model.rpar = txt;
        model.ipar = ipar;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Misc/c_block.sci" */
function c_block() {
    c_block.prototype.define = function c_block() {
        in1 = 1;
        out = 1;
        clkin = [];
        clkout = [];
        x0 = [];
        z0 = [];
        typ = "c";
        auto = [];
        rpar = [];
        funam = "toto";
        model = scicos_model();
        model.sim = list(" ",2001);
        model.in1 = in1;
        model.out = out;
        model.evtin = clkin;
        model.evtout = clkout;
        model.state = x0;
        model.dstate = z0;
        model.rpar = rpar;
        model.ipar = 0;
        model.blocktype = typ;
        model.firing = auto;
        model.dep_ut = [true,false];
        label = list([[sci2exp(in1)],[sci2exp(out)],[strcat(sci2exp(rpar))],[funam]],list([]));
        gr_i = [];
        x = standard_define([3,2],model,label,gr_i);
    }
    c_block.prototype.details = function c_block() {
    }
    c_block.prototype.get = function c_block() {
    }
    c_block.prototype.set = function c_block() {
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        label = graphics.exprs;
        while (true) {
        [ok,i,o,rpar,funam,lab] = scicos_getvalue("Set C_block parameters",[["input ports sizes"],["output port sizes"],["System parameters vector"],["function name"]],list("vec",-1,"vec",-1,"vec",-1,"str",-1),label[1-1]);
        if (!ok) {
break;
}
        if (funam==" ") {
break;
}
        label[1-1] = lab;
        rpar = rpar.slice();
        i = int(i.slice());
        ni = size(i,1);
        o = int(o.slice());
        no = size(o,1);
        tt = label[2-1];
        if (model.sim[1-1]!=funam||size(model.in1,"*")!=size(i,"*")||size(model.out,"*")!=size(o,"*")) {
        tt = [];
}
        [ok,tt] = CFORTR(funam,tt,i,o);
        if (!ok) {
break;
}
        [model,graphics,ok] = check_io(model,graphics,i,o,[],[]);
        if (ok) {
        model.sim[1-1] = funam;
        model.rpar = rpar;
        label[2-1] = tt;
        x.model = model;
        graphics.exprs = label;
        x.graphics = graphics;
break;
}
}
    }
}
/* autogenerated from "macros/Misc/fortran_block.sci" */
function fortran_block() {
    fortran_block.prototype.define = function fortran_block() {
        model = scicos_model();
        model.sim = list(" ",1001);
        model.in1 = 1;
        model.out = 1;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = 0;
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        funam = "forty";
        label = list([[sci2exp(model.in1)],[sci2exp(model.out)],[strcat(sci2exp(model.rpar))],[funam]],list([]));
        gr_i = [];
        x = standard_define([4,2],model,label,gr_i);
    }
    fortran_block.prototype.details = function fortran_block() {
    }
    fortran_block.prototype.get = function fortran_block() {
    }
    fortran_block.prototype.set = function fortran_block() {
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        label = graphics.exprs;
        while (true) {
        [ok,i,o,rpar,funam,lab] = scicos_getvalue("Set fortran_block parameters",[["input ports sizes"],["output port sizes"],["System parameters vector"],["function name"]],list("vec",-1,"vec",-1,"vec",-1,"str",-1),label[1-1]);
        if (!ok) {
break;
}
        if (funam==" ") {
break;
}
        label[1-1] = lab;
        rpar = rpar.slice();
        i = int(i.slice());
        ni = size(i,1);
        o = int(o.slice());
        no = size(o,1);
        tt = label[2-1];
        if (model.sim[1-1]!=funam||size(model.in1,"*")!=size(i,"*")||size(model.out,"*")!=size(o,"*")) {
        tt = [];
}
        [ok,tt] = FORTR(funam,tt,i,o);
        if (!ok) {
break;
}
        [model,graphics,ok] = check_io(model,graphics,i,o,[],[]);
        if (ok) {
        model.sim[1-1] = funam;
        model.rpar = rpar;
        label[2-1] = tt;
        x.model = model;
        graphics.exprs = label;
        x.graphics = graphics;
break;
}
}
    }
}
/* autogenerated from "macros/Misc/func_block.sci" */
function func_block() {
    func_block.prototype.define = function func_block() {
        model = scicos_model();
        model.sim = " ";
        model.in1 = 1;
        model.out = 1;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = "v=sin(u);y=u*v";
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    func_block.prototype.details = function func_block() {
    }
    func_block.prototype.get = function func_block() {
    }
    func_block.prototype.set = function func_block() {
        model = arg1.model;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        x = arg1;
        model = x.model;
        [ok,mac,exprs] = this.genfunc[exprs-1];
        if (ok) {
        model.sim = mac;
        graphics.exprs = exprs;
        x.model = model;
        x.graphics = graphics;
}
    }
}
/* autogenerated from "macros/Misc/generic_block.sci" */
function generic_block() {
    generic_block.prototype.define = function generic_block() {
        model = scicos_model();
        function_name = "sinblk";
        funtyp = 1;
        model.sim = list(function_name,funtyp);
        model.in1 = 1;
        model.out = 1;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = [[function_name],[sci2exp(funtyp)],[sci2exp(model.in1)],[sci2exp(model.out)],[sci2exp(model.evtin)],[sci2exp(model.evtout)],[sci2exp(model.state)],[sci2exp(model.dstate)],[sci2exp(model.rpar)],[sci2exp(model.ipar)],[sci2exp(model.firing)],["y"],["n"]];
        gr_i = [];
        x = standard_define([2,2],model,label,gr_i);
    }
    generic_block.prototype.details = function generic_block() {
    }
    generic_block.prototype.get = function generic_block() {
    }
    generic_block.prototype.set = function generic_block() {
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        label = graphics.exprs;
        if (size(label,"*")==14) {
        label[9-1] = [];
}
        while (true) {
        [ok,function_name,funtyp,i,o,ci,co,xx,z,rpar,ipar,auto0,depu,dept,lab] = scicos_getvalue("Set GENERIC block parameters",[["simulation function"],["function type (0,1,2,..)"],["input ports sizes"],["output port sizes"],["input event ports sizes"],["output events ports sizes"],["initial continuous state"],["initial discrete state"],["Real parameters vector"],["Integer parameters vector"],["initial firing vector (<0 for no firing)"],["direct feedthrough (y or n)"],["time dependence (y or n)"]],list("str",1,"vec",1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec","sum(%6)","str",1,"str",1),label);
        if (!ok) {
break;
}
        label = lab;
        function_name = stripblanks(function_name);
        xx = xx.slice();
        z = z.slice();
        rpar = rpar.slice();
        ipar = int(ipar.slice());
        i = int(i.slice());
        o = int(o.slice());
        ci = int(ci.slice());
        co = int(co.slice());
        funtyp = int(funtyp);
        if (funtyp<0) {
message("function type cannot be negative");
        ok = false;
}
        if ([[ci],[co]]!=[]) {
        if (max([[ci],[co]])>1) {
message("vector event links not supported");
        ok = false;
}
}
        depu = stripblanks(depu);
        if (part(depu,1)=="y") {
        depu = true;
        } else {
        depu = false;
}
        dept = stripblanks(dept);
        if (part(dept,1)=="y") {
        dept = true;
        } else {
        dept = false;
}
        dep_ut = [depu,dept];
        if (ok) {
        [model,graphics,ok] = check_io(model,graphics,i,o,ci,co);
}
        if (ok) {
        if (funtyp==3) {
        needcompile = 4;
}
        model.sim = list(function_name,funtyp);
        model.state = xx;
        model.dstate = z;
        model.rpar = rpar;
        model.ipar = ipar;
        model.firing = auto0;
        model.dep_ut = dep_ut;
        arg1.model = model;
        graphics.exprs = label;
        arg1.graphics = graphics;
        x = arg1;
break;
}
}
needcompile=resume(needcompile)
    }
}
/* autogenerated from "macros/Misc/generic_block2.sci" */
function generic_block2() {
    generic_block2.prototype.define = function generic_block2() {
        model = scicos_model();
        function_name = "sinblk";
        funtyp = 1;
        model.sim = list(function_name,funtyp);
        model.in1 = 1;
        model.out = 1;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.rpar = [];
        model.ipar = [];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        label = [[function_name],[sci2exp(funtyp)],[sci2exp(model.in1)],[sci2exp(model.out)],[sci2exp(model.evtin)],[sci2exp(model.evtout)],[sci2exp(model.state)],[sci2exp(model.dstate)],[sci2exp(model.rpar)],[sci2exp(model.ipar)],[sci2exp(model.nmode)],[sci2exp(model.nzcross)],[sci2exp(model.firing)],["y"],["n"]];
        gr_i = [];
        x = standard_define([2,2],model,label,gr_i);
    }
    generic_block2.prototype.details = function generic_block2() {
    }
    generic_block2.prototype.get = function generic_block2() {
    }
    generic_block2.prototype.set = function generic_block2() {
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        label = graphics.exprs;
        if (size(label,"*")==14) {
        label[9-1] = [];
}
        while (true) {
        [ok,function_name,funtyp,i,o,ci,co,xx,z,rpar,ipar,nmode,nzcr,auto0,depu,dept,lab] = scicos_getvalue("Set GENERIC block parameters",[["simulation function"],["function type (0,1,2,..)"],["input ports sizes"],["output port sizes"],["input event ports sizes"],["output events ports sizes"],["initial continuous state"],["initial discrete state"],["Real parameters vector"],["Integer parameters vector"],["number of modes"],["number of zero_crossings"],["initial firing vector (<0 for no firing)"],["direct feedthrough (y or n)"],["time dependence (y or n)"]],list("str",1,"vec",1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",1,"vec",1,"vec","sum(%6)","str",1,"str",1),label);
        if (!ok) {
break;
}
        label = lab;
        function_name = stripblanks(function_name);
        xx = xx.slice();
        z = z.slice();
        rpar = rpar.slice();
        ipar = int(ipar.slice());
        i = int(i.slice());
        o = int(o.slice());
        ci = int(ci.slice());
        co = int(co.slice());
        funtyp = int(funtyp);
        if (funtyp<0) {
message("function type cannot be negative");
        ok = false;
}
        if ([[ci],[co]]!=[]) {
        if (max([[ci],[co]])>1) {
message("vector event links not supported");
        ok = false;
}
}
        depu = stripblanks(depu);
        if (part(depu,1)=="y") {
        depu = true;
        } else {
        depu = false;
}
        dept = stripblanks(dept);
        if (part(dept,1)=="y") {
        dept = true;
        } else {
        dept = false;
}
        dep_ut = [depu,dept];
        if (ok) {
        [model,graphics,ok] = check_io(model,graphics,i,o,ci,co);
}
        if (ok) {
        if (funtyp==3) {
        needcompile = 4;
}
        model.sim = list(function_name,funtyp);
        model.state = xx;
        model.dstate = z;
        model.rpar = rpar;
        model.ipar = ipar;
        model.firing = auto0;
        model.nzcross = nzcr;
        model.nmode = nmode;
        model.dep_ut = dep_ut;
        arg1.model = model;
        graphics.exprs = label;
        arg1.graphics = graphics;
        x = arg1;
break;
}
}
needcompile=resume(needcompile)
    }
}
/* autogenerated from "macros/Misc/generic_block3.sci" */
function generic_block3() {
    generic_block3.prototype.define = function generic_block3() {
        model = scicos_model();
        function_name = "sinblk";
        funtyp = 4;
        model.sim = list(function_name,funtyp);
        model.in1 = 1;
        model.in2 = 1;
        model.intyp = 1;
        model.out = 1;
        model.out2 = 1;
        model.outtyp = 1;
        model.dep_ut = [true,false];
        label = [[function_name],[sci2exp(funtyp)],[sci2exp([model.in1,model.in2])],[sci2exp(model.intyp)],[sci2exp([model.out,model.out2]),sci2exp(model.outtyp)],[sci2exp(model.evtin)],[sci2exp(model.evtout)],[sci2exp(model.state)],[sci2exp(model.dstate)],[sci2exp(model.odstate)],[sci2exp(model.rpar)],[sci2exp(model.ipar)],[sci2exp(model.opar)],[sci2exp(model.nmode)],[sci2exp(model.nzcross)],[sci2exp(model.firing)],["y"],["n"]];
        gr_i = [];
        x = standard_define([4,2],model,label,gr_i);
    }
    generic_block3.prototype.details = function generic_block3() {
    }
    generic_block3.prototype.get = function generic_block3() {
    }
    generic_block3.prototype.set = function generic_block3() {
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        label = graphics.exprs;
        if (size(label,"*")==14) {
        label[9-1] = [];
}
        while (true) {
        [ok,function_name,funtyp,in1,it,out,ot,ci,co,xx,z,oz,rpar,ipar,opar,nmode,nzcr,auto0,depu,dept,lab] = scicos_getvalue("Set GENERIC block parameters",[["Simulation function"],["Function type (0,1,2,..)"],["Input ports sizes"],["Input ports type"],["Output port sizes"],["Output ports type"],["Input event ports sizes"],["Output events ports sizes"],["Initial continuous state"],["Initial discrete state"],["Initial object state"],["Real parameters vector"],["Integer parameters vector"],["Object parameters list"],["Number of modes"],["Number of zero crossings"],["Initial firing vector (<0 for no firing)"],["Direct feedthrough (y or n)"],["Time dependence (y or n)"]],list("str",1,"vec",1,"mat",[-1,2],"vec",-1,"mat",[-1,2],"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"lis",-1,"vec",-1,"vec",-1,"lis",-1,"vec",1,"vec",1,"vec","sum(%8)","str",1,"str",1),label);
        if (!ok) {
break;
}
        label = lab;
        function_name = stripblanks(function_name);
        xx = xx.slice();
        z = z.slice();
        rpar = rpar.slice();
        ipar = int(ipar.slice());
        ci = int(ci.slice());
        co = int(co.slice());
        funtyp = funtyp;
        if (funtyp<0) {
message("function type cannot be negative");
        ok = false;
}
        if ([[ci],[co]]!=[]) {
        if (max([[ci],[co]])>1) {
message("vector event links not supported");
        ok = false;
}
}
        if (this.type[opar-1]!=15) {
message("object parameter must be a list");
        ok = false;
}
        if (this.type[oz-1]!=15) {
message("discrete object state must be a list");
        ok = false;
}
        depu = stripblanks(depu);
        if (part(depu,1)=="y") {
        depu = true;
        } else {
        depu = false;
}
        dept = stripblanks(dept);
        if (part(dept,1)=="y") {
        dept = true;
        } else {
        dept = false;
}
        dep_ut = [depu,dept];
        if (ok) {
        [model,graphics,ok] = set_io(model,graphics,list(in1,it),list(out,ot),ci,co);
}
        if (ok) {
        if (funtyp==3) {
        needcompile = 4;
}
        model.sim = list(function_name,funtyp);
        model.state = xx;
        model.dstate = z;
        model.odstate = oz;
        model.rpar = rpar;
        model.ipar = ipar;
        model.opar = opar;
        model.firing = auto0;
        model.nzcross = nzcr;
        model.nmode = nmode;
        model.dep_ut = dep_ut;
        arg1.model = model;
        graphics.exprs = label;
        arg1.graphics = graphics;
        x = arg1;
break;
}
}
needcompile=resume(needcompile)
    }
}
/* autogenerated from "macros/Misc/scifunc_block.sci" */
function scifunc_block() {
    scifunc_block.prototype.define = function scifunc_block() {
        in1 = 1;
        out = 1;
        clkin = [];
        clkout = [];
        x0 = [];
        z0 = [];
        typ = "c";
        auto = [];
        rpar = [];
        model = scicos_model();
        model.sim = list("scifunc",3);
        model.in1 = in1;
        model.out = out;
        model.evtin = clkin;
        model.evtout = clkout;
        model.state = x0;
        model.dstate = z0;
        model.rpar = rpar;
        model.ipar = 0;
        model.opar = list();
        model.blocktype = typ;
        model.firing = auto;
        model.dep_ut = [true,false];
        exprs = list([[sci2exp(in1)],[sci2exp(out)],[sci2exp(clkin)],[sci2exp(clkout)],[strcat(sci2exp(x0))],[strcat(sci2exp(z0))],[strcat(sci2exp(rpar))],[sci2exp(auto)]],list("y1=sin(u1)"," "," ","y1=sin(u1)"," "," "," "));
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    scifunc_block.prototype.details = function scifunc_block() {
    }
    scifunc_block.prototype.get = function scifunc_block() {
    }
    scifunc_block.prototype.set = function scifunc_block() {
        needcompile = 0;
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        if (size(exprs[1-1],"*")==8) {
        exprs[1-1][9-1] = "0";
}
        while (true) {
        [ok,i,o,ci,co,xx,z,rpar,auto0,deptime,lab] = scicos_getvalue([["Set scifunc_block parameters"],["only regular blocks supported"]],[["input ports sizes"],["output port sizes"],["input event ports sizes"],["output events ports sizes"],["initial continuous state"],["initial discrete state"],["System parameters vector"],["initial firing vector (<0 for no firing)"],["is block always active (0:no, 1:yes)"]],list("vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec","sum(%4)","vec",1),exprs[1-1]);
        if (!ok) {
break;
}
        exprs[1-1] = lab;
        xx = xx.slice();
        z = z.slice();
        rpar = rpar.slice();
        nrp = prod(size(rpar));
        i = int(i.slice());
        ni = size(i,1);
        o = int(o.slice());
        no = size(o,1);
        ci = int(ci.slice());
        nci = size(ci,1);
        co = int(co.slice());
        nco = size(co,1);
        [ok,tt,dep_ut] = genfunc1(exprs[2-1],i,o,nci,nco,size(xx,1),size(z,1),nrp,"c");
        dep_ut[2-1] = (1==deptime);
        if (!ok) {
break;
}
        [model,graphics,ok] = check_io(model,graphics,i,o,ci,co);
        if (ok) {
        auto = auto0;
        model.state = xx;
        model.dstate = z;
        model.rpar = rpar;
        if (model.ipar!=0) {
        model.opar = model.ipar;
        model.ipar = 0;
}
        if (or(model.opar!=tt)) {
        needcompile = 4;
}
        model.opar = tt;
        model.firing = auto;
        model.dep_ut = dep_ut;
        x.model = model;
        exprs[2-1] = tt;
        graphics.exprs = exprs;
        x.graphics = graphics;
break;
}
}
needcompile=resume(needcompile)
    }
}
/* autogenerated from "macros/Misc/scifunc_block_m.sci" */
function scifunc_block_m() {
    scifunc_block_m.prototype.define = function scifunc_block_m() {
        in1 = 1;
        out = 1;
        clkin = [];
        clkout = [];
        x0 = [];
        z0 = [];
        typ = "c";
        auto = [];
        rpar = [];
        it = 1;
        model = scicos_model();
        model.sim = list("scifunc",3);
        model.in1 = in1;
        model.in2 = in1;
        model.intyp = it;
        model.out = out;
        model.out2 = out;
        model.outtyp = it;
        model.evtin = clkin;
        model.evtout = clkout;
        model.state = x0;
        model.dstate = z0;
        model.rpar = rpar;
        model.ipar = 0;
        model.opar = list();
        model.blocktype = typ;
        model.firing = auto;
        model.dep_ut = [true,false];
        exprs = list([[sci2exp([in1,in1])],[sci2exp([out,out])],[sci2exp(clkin)],[sci2exp(clkout)],[strcat(sci2exp(x0))],[strcat(sci2exp(z0))],[strcat(sci2exp(rpar))],[sci2exp(auto)],[sci2exp(0)]],list("y1=sin(u1)"," "," ","y1=sin(u1)"," "," "," "));
        gr_i = [];
        x = standard_define([4,2],model,exprs,gr_i);
    }
    scifunc_block_m.prototype.details = function scifunc_block_m() {
    }
    scifunc_block_m.prototype.get = function scifunc_block_m() {
    }
    scifunc_block_m.prototype.set = function scifunc_block_m() {
        needcompile = 0;
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        while (true) {
        [ok,i,o,ci,co,xx,z,rpar,auto0,deptime,lab] = scicos_getvalue([["Set scifunc_block parameters"],["only regular blocks supported"]],[["input ports sizes"],["output port sizes"],["input event ports sizes"],["output events ports sizes"],["initial continuous state"],["initial discrete state"],["System parameters vector"],["initial firing vector (<0 for no firing)"],["is block always active (0:no, 1:yes)"]],list("mat",[-1,2],"mat",[-2,2],"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",1),exprs[1-1]);
        if (!ok) {
break;
}
        exprs[1-1] = lab;
        xx = xx.slice();
        z = z.slice();
        rpar = rpar.slice();
        it = ones(1,size(i,1));
        ot = ones(1,size(o,1));
        nrp = prod(size(rpar));
        ni = size(i,1);
        no = size(o,1);
        ci = int(ci.slice());
        nci = size(ci,1);
        co = int(co.slice());
        nco = size(co,1);
        [ok,tt,dep_ut] = genfunc2(exprs[2-1],i,o,nci,nco,size(xx,1),size(z,1),nrp,"c");
        dep_ut[2-1] = (1==deptime);
        if (!ok) {
break;
}
        [model,graphics,ok] = set_io(model,graphics,list(i,it),list(o,ot),ci,co);
        if (ok) {
        auto = auto0;
        model.state = xx;
        model.dstate = z;
        model.rpar = rpar;
        if (model.ipar!=0) {
        model.opar = model.ipar;
        model.ipar = 0;
}
        if (or(model.opar!=tt)) {
        needcompile = 4;
}
        model.opar = tt;
        model.firing = auto;
        model.dep_ut = dep_ut;
        x.model = model;
        exprs[2-1] = tt;
        graphics.exprs = exprs;
        x.graphics = graphics;
break;
}
}
needcompile=resume(needcompile)
    }
}
/* autogenerated from "macros/NonLinear/ABSBLK_f.sci" */
function ABSBLK_f() {
    ABSBLK_f.prototype.define = function ABSBLK_f() {
        model = scicos_model();
        model.sim = list("absblk",1);
        model.in1 = -1;
        model.out = -1;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        gr_i = [];
        x = standard_define([2,2],model,[],gr_i);
    }
    ABSBLK_f.prototype.details = function ABSBLK_f() {
    }
    ABSBLK_f.prototype.get = function ABSBLK_f() {
    }
    ABSBLK_f.prototype.set = function ABSBLK_f() {
        x = arg1;
    }
}
/* autogenerated from "macros/NonLinear/ABS_VALUE.sci" */
function ABS_VALUE() {
    ABS_VALUE.prototype.define = function ABS_VALUE() {
        nu = -1;
        model = scicos_model();
        model.sim = list("absolute_value",4);
        model.in1 = nu;
        model.out = nu;
        model.nzcross = nu;
        model.nmode = nu;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [string([1])];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    ABS_VALUE.prototype.details = function ABS_VALUE() {
    }
    ABS_VALUE.prototype.get = function ABS_VALUE() {
    }
    ABS_VALUE.prototype.set = function ABS_VALUE() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,zcr,exprs] = scicos_getvalue("Set block parameters",["use zero_crossing (1: yes) (0:no)"],list("vec",1),exprs);
        if (!ok) {
break;
}
        graphics.exprs = exprs;
        if (ok) {
        if (zcr!=0) {
        model.nmode = -1;
        model.nzcross = -1;
        } else {
        model.nmode = 0;
        model.nzcross = 0;
}
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/NonLinear/COSBLK_f.sci" */
function COSBLK_f() {
    COSBLK_f.prototype.define = function COSBLK_f() {
        in1 = 1;
        model = scicos_model();
        model.sim = "cosblk";
        model.in1 = -1;
        model.out = -1;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        gr_i = [];
        x = standard_define([2,2],model,[],gr_i);
    }
    COSBLK_f.prototype.details = function COSBLK_f() {
    }
    COSBLK_f.prototype.get = function COSBLK_f() {
    }
    COSBLK_f.prototype.set = function COSBLK_f() {
        x = arg1;
    }
}
/* autogenerated from "macros/NonLinear/DLRADAPT_f.sci" */
function DLRADAPT_f() {
    DLRADAPT_f.prototype.define = function DLRADAPT_f() {
        p = [[0],[1]];
        rn = [];
        rd = [[math.complex(0.2,0.8),math.complex(0.2,-0.8)],[math.complex(0.3,0.7),math.complex(0.3,-0.7)]];
        g = [[1],[1]];
        last_u = [];
        last_y = [[0],[0]];
        model = scicos_model();
        model.sim = "dlradp";
        model.in1 = [[1],[1]];
        model.out = 1;
        model.evtin = 1;
        model.dstate = [[last_u],[last_y]];
        model.rpar = [[p.slice()],[real(rn.slice())],[imag(rn.slice())],[real(rd.slice())],[imag(rd.slice())],[g.slice()]];
        model.ipar = [[0],[2],[2]];
        model.blocktype = "d";
        model.firing = [];
        model.dep_ut = [true,false];
        exprs = [[sci2exp(p)],[sci2exp(rn)],[sci2exp(rd,0)],[sci2exp(g)],[sci2exp(last_u)],[sci2exp(last_y)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    DLRADAPT_f.prototype.details = function DLRADAPT_f() {
    }
    DLRADAPT_f.prototype.get = function DLRADAPT_f() {
    }
    DLRADAPT_f.prototype.set = function DLRADAPT_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,p,rn,rd,g,last_u,last_y,exprs] = scicos_getvalue("Set block parameters",[["Vector of p mesh points"],["Numerator roots (one line for each mesh)"],["Denominator roots (one line for each mesh)"],["Vector of gain at mesh points"],["past inputs (Num degree values)"],["past outputs (Den degree values)"]],list("vec",-1,"mat",[-1,-1],"mat",["size(%1,\'*\')","-1"],"vec","size(%1,\'*\')","vec","size(%2,2)","vec","size(%3,2)"),exprs);
        if (!ok) {
break;
}
        m = size(rn,2);
        [npt,n] = size(rd);
        if (m>=n) {
message("Transfer must be strictly proper");
        } else if (size(rn,1)!=0&&size(rn,1)!=size(p,"*")) {
message("Numerator roots matrix row size\'s is incorrect");
        } else {
        rpar = [[p.slice()],[real(rn.slice())],[imag(rn.slice())],[real(rd.slice())],[imag(rd.slice())],[g.slice()]];
        ipar = [[m],[n],[npt]];
        model.dstate = [[last_u.slice()],[last_y.slice()]];
        model.rpar = rpar;
        model.ipar = ipar;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/NonLinear/EXPBLK_f.sci" */
function EXPBLK_f() {
    EXPBLK_f.prototype.define = function EXPBLK_f() {
        in1 = 1;
        a = math.E;
        model = scicos_model();
        model.sim = "expblk";
        model.in1 = -1;
        model.out = -1;
        model.rpar = a;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = ["%e"];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    EXPBLK_f.prototype.details = function EXPBLK_f() {
    }
    EXPBLK_f.prototype.get = function EXPBLK_f() {
    }
    EXPBLK_f.prototype.set = function EXPBLK_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        if (size(exprs,"*")==2) {
        exprs = exprs[2-1];
}
        while (true) {
        [ok,a,exprs] = scicos_getvalue("Set a^u  block parameters","a (>0)",list("vec",1),exprs);
        if (!ok) {
break;
}
        if (or(a<=0)) {
message("a^u : a must be positive");
        } else {
        graphics.exprs = exprs;
        model.rpar = a;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/NonLinear/EXPBLK_m.sci" */
function EXPBLK_m() {
    EXPBLK_m.prototype.define = function EXPBLK_m() {
        in1 = 1;
        a = math.E;
        model = scicos_model();
        model.sim = list("expblk_m",4);
        model.in1 = -1;
        model.in2 = -2;
        model.out = -1;
        model.out2 = -2;
        model.intyp = 1;
        model.outtyp = 1;
        model.rpar = a;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = ["%e"];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    EXPBLK_m.prototype.details = function EXPBLK_m() {
    }
    EXPBLK_m.prototype.get = function EXPBLK_m() {
    }
    EXPBLK_m.prototype.set = function EXPBLK_m() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        if (size(exprs,"*")==2) {
        exprs = exprs[2-1];
}
        while (true) {
        [ok,a,exprs] = scicos_getvalue("Set a^u  block parameters","a (>0)",list("vec",1),exprs);
        if (!ok) {
break;
}
        if (or(a<=0)) {
message("a^u : a must be positive");
        } else {
        graphics.exprs = exprs;
        model.rpar = a;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/NonLinear/FSV_f.sci" */
function FSV_f() {
    FSV_f.prototype.define = function FSV_f() {
        in1 = 1;
        model = scicos_model();
        model.sim = list("fsv",1);
        model.in1 = in1;
        model.out = in1;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = " ";
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    FSV_f.prototype.details = function FSV_f() {
    }
    FSV_f.prototype.get = function FSV_f() {
    }
    FSV_f.prototype.set = function FSV_f() {
        x = arg1;
    }
}
/* autogenerated from "macros/NonLinear/INTRP2BLK_f.sci" */
function INTRP2BLK_f() {
    INTRP2BLK_f.prototype.define = function INTRP2BLK_f() {
        a = [[0],[1]];
        b = [[0],[1]];
        c = [[0,1],[1,2]];
        model = scicos_model();
        model.sim = list("intrp2",1);
        model.in1 = [[1],[1]];
        model.out = 1;
        model.rpar = [[a],[b],[c.slice()]];
        model.ipar = [[2],[2]];
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[strcat(sci2exp(a))],[strcat(sci2exp(b))],[strcat(sci2exp(c,0))]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    INTRP2BLK_f.prototype.details = function INTRP2BLK_f() {
    }
    INTRP2BLK_f.prototype.get = function INTRP2BLK_f() {
    }
    INTRP2BLK_f.prototype.set = function INTRP2BLK_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,a,b,c,exprs] = scicos_getvalue("Set Interpolation block parameters",[["X coord."],["Y coord."],["Z values"]],list("vec",-1,"vec",-1,"mat",[-1,-1]),exprs);
        if (!ok) {
break;
}
        if (size(a,"*")!=size(c,"c")||size(b,"*")!=size(c,"r")) {
message("incompatible dimension");
        } else if (min(a.slice(2-1,$)-a.slice(1-1,$-1))<=0||min(b.slice(2-1,$)-b.slice(1-1,$-1))<=0) {
message("X and Y must be strictly increasing");
        } else {
        if (ok) {
        graphics.exprs = exprs;
        model.rpar = [[a.slice()],[b.slice()],[c.slice()]];
        model.ipar = [[size(a,"*")],[size(b,"*")]];
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/NonLinear/INTRPLBLK_f.sci" */
function INTRPLBLK_f() {
    INTRPLBLK_f.prototype.define = function INTRPLBLK_f() {
        a = [[0],[1]];
        b = [[0],[1]];
        model = scicos_model();
        model.sim = "intrpl";
        model.in1 = 1;
        model.out = 1;
        model.rpar = [[a],[b]];
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[strcat(sci2exp(a))],[strcat(sci2exp(b))]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    INTRPLBLK_f.prototype.details = function INTRPLBLK_f() {
    }
    INTRPLBLK_f.prototype.get = function INTRPLBLK_f() {
    }
    INTRPLBLK_f.prototype.set = function INTRPLBLK_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,a,b,exprs] = scicos_getvalue("Set Interpolation block parameters",[["X coord."],["Y coord."]],list("vec",-1,"vec",-1),exprs);
        if (!ok) {
break;
}
        if (size(a,"*")!=size(b,"*")) {
message("X and Y must have the same size");
        } else if (min(a.slice(2-1,$)-a.slice(1-1,$-1))<=0) {
message("X must be strictly increasing");
        } else {
        if (ok) {
        graphics.exprs = exprs;
        model.rpar = [[a.slice()],[b.slice()]];
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/NonLinear/INVBLK.sci" */
function INVBLK() {
    INVBLK.prototype.define = function INVBLK() {
        in1 = -1;
        model = scicos_model();
        model.sim = list("invblk4",4);
        model.in1 = in1;
        model.out = in1;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = " ";
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    INVBLK.prototype.details = function INVBLK() {
    }
    INVBLK.prototype.get = function INVBLK() {
    }
    INVBLK.prototype.set = function INVBLK() {
        x = arg1;
    }
}
/* autogenerated from "macros/NonLinear/INVBLK_f.sci" */
function INVBLK_f() {
    INVBLK_f.prototype.define = function INVBLK_f() {
        in1 = -1;
        model = scicos_model();
        model.sim = "invblk";
        model.in1 = in1;
        model.out = in1;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = " ";
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    INVBLK_f.prototype.details = function INVBLK_f() {
    }
    INVBLK_f.prototype.get = function INVBLK_f() {
    }
    INVBLK_f.prototype.set = function INVBLK_f() {
        x = arg1;
    }
}
/* autogenerated from "macros/NonLinear/LOGBLK_f.sci" */
function LOGBLK_f() {
    LOGBLK_f.prototype.define = function LOGBLK_f() {
        in1 = 1;
        a = math.E;
        model = scicos_model();
        model.sim = "logblk";
        model.in1 = -1;
        model.out = -1;
        model.rpar = a;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = "%e";
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    LOGBLK_f.prototype.details = function LOGBLK_f() {
    }
    LOGBLK_f.prototype.get = function LOGBLK_f() {
    }
    LOGBLK_f.prototype.set = function LOGBLK_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        if (size(exprs,"*")==2) {
        exprs = exprs[2-1];
}
        while (true) {
        [ok,a,exprs] = scicos_getvalue("Set log block parameters","Basis (>1)",list("vec",1),exprs);
        if (!ok) {
break;
}
        if (a<=1) {
message("Basis must be larger than 1");
        } else {
        if (ok) {
        graphics.exprs = exprs;
        model.rpar = a;
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/NonLinear/LOOKUP2D.sci" */
function LOOKUP2D() {
    LOOKUP2D.prototype.define = function LOOKUP2D() {
        model = scicos_model();
        xx = [1:4];
        yy = [1:3];
        zz = [[4,5,6],[16,19,20],[10,18,23],[6,3,-1]];
        Method = 1;
        Graf = "n";
        Nx = length(xx);
        Ny = length(yy);
        model.sim = list("lookup2d",4);
        model.in1 = [[1],[1]];
        model.out = 1;
        model.rpar = [[xx.slice()],[yy.slice()],[zz.slice()]];
        model.ipar = [[Nx],[Ny],[Method]];
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = list(strcat(sci2exp(xx)),strcat(sci2exp(yy)),strcat(sci2exp(zz)),sci2exp(Method),Graf);
        gr_i = [];
        x = standard_define([2.5,2],model,exprs,gr_i);
    }
    LOOKUP2D.prototype.details = function LOOKUP2D() {
    }
    LOOKUP2D.prototype.get = function LOOKUP2D() {
    }
    LOOKUP2D.prototype.set = function LOOKUP2D() {
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        ok = false;
        SaveExit = false;
        while (true) {
        Ask_again = false;
        [ok,xx,yy,zz,Method,graf,exprs] = scicos_getvalue("2D Lookup table parameters",[["Row index input values"],["Column index input values"],["Table data"],["Lookup method(1..5)"],["Launch graphic window(y/n)?"]],list("vec",-1,"vec",-1,"mat",[-1,-1],"vec",1,"str",1),exprs);
        if (!ok) {
break;
}
        mtd = int(Method);
        if (mtd<1) {
        mtd = 1;
}
        if (mtd>6) {
        mtd = 6;
}
        if (graf!="y"&&graf!="Y") {
        graf = "n";
}
        exprs[5-1] = "n";
        exprs[4-1] = sci2exp(mtd);
        METHOD = getmethod(mtd);
        if (!Ask_again) {
        xx = xx.slice();
        yy = yy.slice();
        [nx,mx] = size(xx);
        [ny,my] = size(yy);
        [nz,mz] = size(zz);
        if (((nx<=1)||(ny<=1))) {
x_message("input row/column data size should be greater than one");
        Ask_again = true;
}
        if (!((nx==nz)&&(ny==mz))) {
x_message("incompatible size of x and y");
        Ask_again = true;
}
        [ok] = test_increasing(xx);
        if ((!ok)) {
x_message("Row input values must be monotonically increasing");
        Ask_again = true;
}
        [ok] = test_increasing(yy);
        if ((!ok)) {
x_message("Column input values must be monotonically increasing");
        Ask_again = true;
}
}
        if (!Ask_again) {
        if ((graf=="Y"||graf=="y")) {
        gh = gcf();
        curwin = gh.figure_id;
        save_curwin = curwin;
        gh2 = scf();
        curwin = max(winsid())+1;
plot3d(xx,yy,zz,35,45,"X@Y@Z",[5,2,4]);
        curwin = save_curwin;
        gh.figure_id = curwin;
}
        model.rpar = [[xx.slice()],[yy.slice()],[zz.slice()]];
        model.ipar = [[nx],[ny],[mtd]];
        graphics.exprs = exprs;
        x.model = model;
        x.graphics = graphics;
break;
}
}
    }
}
/* autogenerated from "macros/NonLinear/LOOKUP_f.sci" */
function LOOKUP_f() {
    LOOKUP_f.prototype.define = function LOOKUP_f() {
        model = scicos_model();
        model.sim = "lookup";
        model.in1 = 1;
        model.out = 1;
        model.rpar = [[-2],[-1],[1],[2],[-1],[1],[-1],[1]];
        model.blocktype = "c";
        model.dep_ut = [true,false];
        gr_i = [];
        x = standard_define([2,2],model,[],gr_i);
    }
    LOOKUP_f.prototype.details = function LOOKUP_f() {
    }
    LOOKUP_f.prototype.get = function LOOKUP_f() {
    }
    LOOKUP_f.prototype.set = function LOOKUP_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        rpar = model.rpar;
        n = size(rpar,"*")/2;
        xx = rpar.slice(1-1,n);
        yy = rpar.slice(n+1-1,2*n);
        while (true) {
[ln,fun]=where()
        if (!or(fun=="do_eval")) {
        [xx,yy,ok,gc] = edit_curv(xx,yy,"axy");
        } else {
        ok = true;
}
        if (!ok) {
break;
}
        n = size(xx,"*");
        if (or(xx.slice(2-1,n)-xx.slice(1-1,n-1)<=0)) {
message("You have not defined a function");
        ok = false;
}
        if (ok) {
        model.rpar = [[xx.slice()],[yy.slice()]];
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/NonLinear/MAXMIN.sci" */
function MAXMIN() {
    MAXMIN.prototype.define = function MAXMIN() {
        model = scicos_model();
        model.sim = list("minmax",4);
        model.out = 1;
        model.in1 = -1;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        model.ipar = 0;
        exprs = [string(transpose([2,1,1]))];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
        x.graphics.style = "MAXMIN;displayedLabel=MAX";
    }
    MAXMIN.prototype.details = function MAXMIN() {
    }
    MAXMIN.prototype.get = function MAXMIN() {
    }
    MAXMIN.prototype.set = function MAXMIN() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,mm,nin,zcr,exprs] = scicos_getvalue("Set Max/Min block parameters",[["Min (1) or Max (2) "],["Number of input vectors (1 or 2)"],["zero-crossing (1: yes, 0;no)"]],list("vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (zcr!=0) {
        zcr = -1;
}
        if (mm!=1) {
        mm = 2;
}
        if (nin!=1&&nin!=2) {
message("Wrong number of inputs, only 1 and 2 allowed");
        ok = false;
}
        if (ok) {
        if (nin==1) {
        [model,graphics,ok] = check_io(model,graphics,-1,1,[],[]);
        } else {
        [model,graphics,ok] = check_io(model,graphics,[-1,-1],-1,[],[]);
}
}
        if (ok) {
        model.nzcross = zcr;
        if (nin==1) {
        model.nmode = abs(zcr);
        } else {
        model.nmode = zcr;
}
        model.ipar = mm;
        if (mm==1) {
        label = "MIN";
        } else {
        label = "MAX";
}
        graphics.style = "MAXMIN;displayedLabel="+label;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/NonLinear/MAX_f.sci" */
function MAX_f() {
    MAX_f.prototype.define = function MAX_f() {
        in1 = -1;
        model = scicos_model();
        model.sim = "maxblk";
        model.in1 = in1;
        model.out = 1;
        model.dstate = [[0],[0]];
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = " ";
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    MAX_f.prototype.details = function MAX_f() {
    }
    MAX_f.prototype.get = function MAX_f() {
    }
    MAX_f.prototype.set = function MAX_f() {
        x = arg1;
    }
}
/* autogenerated from "macros/NonLinear/MIN_f.sci" */
function MIN_f() {
    MIN_f.prototype.define = function MIN_f() {
        in1 = -1;
        model = scicos_model();
        model.sim = "minblk";
        model.in1 = in1;
        model.out = 1;
        model.dstate = [[0],[0]];
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = sci2exp(in1);
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    MIN_f.prototype.details = function MIN_f() {
    }
    MIN_f.prototype.get = function MIN_f() {
    }
    MIN_f.prototype.set = function MIN_f() {
        x = arg1;
    }
}
/* autogenerated from "macros/NonLinear/POWBLK_f.sci" */
function POWBLK_f() {
    POWBLK_f.prototype.define = function POWBLK_f() {
        in1 = 1;
        a = 1.5;
        model = scicos_model();
        model.sim = "powblk";
        model.in1 = -1;
        model.out = -1;
        model.rpar = a;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = string(a);
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    POWBLK_f.prototype.details = function POWBLK_f() {
    }
    POWBLK_f.prototype.get = function POWBLK_f() {
    }
    POWBLK_f.prototype.set = function POWBLK_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        if (size(exprs,"*")==2) {
        exprs = exprs[2-1];
}
        while (true) {
        [ok,a,exprs] = scicos_getvalue("Set u^a block parameters","to the power of",list("vec",1),exprs);
        if (!ok) {
break;
}
        graphics.exprs = exprs;
        if (a==int(a)) {
        model.ipar = a;
        model.rpar = [];
        } else {
        model.rpar = a;
        model.ipar = [];
}
        model.firing = [];
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/NonLinear/PRODUCT.sci" */
function PRODUCT() {
    PRODUCT.prototype.define = function PRODUCT() {
        sgn = [[1],[-1]];
        model = scicos_model();
        model.sim = list("product",4);
        model.in1 = [[-1],[-1]];
        model.out = -1;
        model.ipar = sgn;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = sci2exp(sgn);
        gr_i = [];
        x = standard_define([2,3],model,exprs,gr_i);
    }
    PRODUCT.prototype.details = function PRODUCT() {
    }
    PRODUCT.prototype.get = function PRODUCT() {
    }
    PRODUCT.prototype.set = function PRODUCT() {
        x = arg1;
        graphics = arg1.graphics;
        model = arg1.model;
        exprs = graphics.exprs;
        while (true) {
        [ok,sgn,exprs] = scicos_getvalue([["         Set multiplication block parameters"],["(multiplication is set with + 1, division with -1)"],[""]],"Number of inputs or sign vector",list("vec",-1),exprs);
        if (!ok) {
break;
}
        sgn = sgn.slice();
        if (size(sgn,1)==1) {
        if (sgn<1) {
message("Number of inputs must be > 0");
        ok = false;
        } else if (sgn==1) {
        in1 = -1;
        sgn = [];
        nout = 1;
        } else {
        in1 = -ones(sgn,1);
        sgn = ones(sgn,1);
        nout = -1;
}
        } else {
        if (!and(abs(sgn)==1)) {
message("Signs can only be +1 or -1");
        ok = false;
        } else {
        in1 = -ones(size(sgn,1),1);
        nout = -1;
}
}
        if (ok) {
        [model,graphics,ok] = check_io(model,graphics,in1,nout,[],[]);
}
        if (ok) {
        model.ipar = sgn;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/NonLinear/PROD_f.sci" */
function PROD_f() {
    PROD_f.prototype.define = function PROD_f() {
        model = scicos_model();
        model.sim = list("prod",2);
        model.in1 = [[-1],[-1]];
        model.out = -1;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        x = standard_define([1,1],model,[],[]);
    }
    PROD_f.prototype.details = function PROD_f() {
    }
    PROD_f.prototype.get = function PROD_f() {
    }
    PROD_f.prototype.set = function PROD_f() {
        x = arg1;
    }
}
/* autogenerated from "macros/NonLinear/QUANT_f.sci" */
function QUANT_f() {
    QUANT_f.prototype.define = function QUANT_f() {
        pas = 0.1;
        meth = 1;
        model = scicos_model();
        model.sim = "qzrnd";
        model.in1 = -1;
        model.out = -1;
        model.rpar = pas;
        model.ipar = meth;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[string(pas)],[string(meth)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    QUANT_f.prototype.details = function QUANT_f() {
    }
    QUANT_f.prototype.get = function QUANT_f() {
    }
    QUANT_f.prototype.set = function QUANT_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,pas,meth,exprs] = scicos_getvalue("Set parameters",[["Step"],["Quantization Type (1-4)"]],list("vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (meth<1||meth>4) {
message("Quantization Type must be from 1 to 4");
        } else {
        rpar = pas;
        model.rpar = rpar;
        model.ipar = meth;
        switch (meth) {
        case 1:
        model.sim = "qzrnd";
        case 2:
        model.sim = "qztrn";
        case 3:
        model.sim = "qzflr";
        case 4:
        model.sim = "qzcel";
}
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/NonLinear/SATURATION.sci" */
function SATURATION() {
    SATURATION.prototype.define = function SATURATION() {
        minp = -1;
        maxp = 1;
        rpar = [[maxp],[minp]];
        model = scicos_model();
        model.sim = list("satur",4);
        model.in1 = 1;
        model.nzcross = 2;
        model.nmode = 1;
        model.out = 1;
        model.rpar = rpar;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[string(maxp)],[string(minp)],[string(model.nmode)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    SATURATION.prototype.details = function SATURATION() {
    }
    SATURATION.prototype.get = function SATURATION() {
    }
    SATURATION.prototype.set = function SATURATION() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,maxp,minp,zeroc,exprs] = scicos_getvalue("Set Saturation parameters",[["Upper limit"],["Lower limit"],["zero crossing (0:no, 1:yes)"]],list("vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (maxp<=minp) {
message("Upper limit must be > Lower limit");
        } else {
        rpar = [[maxp],[minp]];
        model.rpar = rpar;
        if (zeroc!=0) {
        model.nzcross = 2;
        model.nmode = 1;
        } else {
        model.nzcross = 0;
        model.nmode = 0;
}
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/NonLinear/SAT_f.sci" */
function SAT_f() {
    SAT_f.prototype.define = function SAT_f() {
        minp = -1;
        maxp = 1;
        slope = 1;
        rpar = [[minp],[maxp],[slope]];
        model = scicos_model();
        model.sim = list("lusat",1);
        model.in1 = 1;
        model.nzcross = 2;
        model.out = 1;
        model.rpar = [[minp],[maxp],[slope]];
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[string(minp)],[string(maxp)],[string(slope)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    SAT_f.prototype.details = function SAT_f() {
    }
    SAT_f.prototype.get = function SAT_f() {
    }
    SAT_f.prototype.set = function SAT_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,minp,maxp,pente,exprs] = scicos_getvalue("Set Saturation parameters",[["Min"],["Max"],["Slope"]],list("vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (maxp<=0) {
message("Max must be strictly positive");
        } else if (pente<=0) {
message("Slope must be strictly positive");
        } else {
        rpar = [[minp/pente],[maxp/pente],[pente]];
        model.rpar = rpar;
        model.firing = [];
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/NonLinear/SIGNUM.sci" */
function SIGNUM() {
    SIGNUM.prototype.define = function SIGNUM() {
        nu = -1;
        model = scicos_model();
        model.sim = list("signum",4);
        model.in1 = nu;
        model.out = nu;
        model.nzcross = nu;
        model.nmode = nu;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [string([1])];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    SIGNUM.prototype.details = function SIGNUM() {
    }
    SIGNUM.prototype.get = function SIGNUM() {
    }
    SIGNUM.prototype.set = function SIGNUM() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,zcr,exprs] = scicos_getvalue("Set block parameters",["use zero_crossing (1: yes) (0:no)"],list("vec",1),exprs);
        if (!ok) {
break;
}
        graphics.exprs = exprs;
        if (ok) {
        if (zcr!=0) {
        model.nmode = -1;
        model.nzcross = -1;
        } else {
        model.nmode = 0;
        model.nzcross = 0;
}
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/NonLinear/SINBLK_f.sci" */
function SINBLK_f() {
    SINBLK_f.prototype.define = function SINBLK_f() {
        model = scicos_model();
        model.sim = "sinblk";
        model.in1 = -1;
        model.out = -1;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = " ";
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    SINBLK_f.prototype.details = function SINBLK_f() {
    }
    SINBLK_f.prototype.get = function SINBLK_f() {
    }
    SINBLK_f.prototype.set = function SINBLK_f() {
        x = arg1;
    }
}
/* autogenerated from "macros/NonLinear/TANBLK_f.sci" */
function TANBLK_f() {
    TANBLK_f.prototype.define = function TANBLK_f() {
        in1 = -1;
        model = scicos_model();
        model.sim = "tanblk";
        model.in1 = in1;
        model.out = in1;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = sci2exp(in1);
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    TANBLK_f.prototype.details = function TANBLK_f() {
    }
    TANBLK_f.prototype.get = function TANBLK_f() {
    }
    TANBLK_f.prototype.set = function TANBLK_f() {
        x = arg1;
        x.model.firing = [];
    }
}
/* autogenerated from "macros/NonLinear/TrigFun.sci" */
function TrigFun() {
    TrigFun.prototype.define = function TrigFun() {
        model = scicos_model();
        model.sim = list("sin_blk",4);
        model.in1 = -1;
        model.out = -1;
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = "sin";
        gr_i = [];
        x = standard_define([4,2],model,exprs,gr_i);
    }
    TrigFun.prototype.details = function TrigFun() {
    }
    TrigFun.prototype.get = function TrigFun() {
    }
    TrigFun.prototype.set = function TrigFun() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        PREVAR_FF = [["sin"],["cos"],["tan"],["asin"],["acos"],["atan"],["sinh"],["cosh"],["tanh"],["asinh"],["acosh"],["atanh"]];
        PREVAR_GG = [["Choose among "+strcat(PREVAR_FF.slice(1-1,4),", ")],[strcat(PREVAR_FF.slice(5-1,$),", ")]];
        while (true) {
        [ok,fun,exprs] = scicos_getvalue(PREVAR_GG,"Function",list("str",1),exprs);
        if (!ok) {
break;
}
        if (find(PREVAR_FF==fun)==[]) {
message("Sorry but "+fun+" is not in the list!");
        } else {
        graphics.exprs = exprs;
execstr("model.sim=list(\'"+fun+"_blk\',4)");
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/PDE/PDE.sci" */
function PDE() {
    PDE.prototype.define = function PDE() {
        model = scicos_model();
        model.state = zeros(10,1);
        model.sim = list("PDE",0);
        model.in1 = [[1],[1],[1],[1],[1]];
        model.out = [[10],[0]];
        model.blocktype = "c";
        model.dep_ut = [false,true];
        params_pde = tlist([["paramspde"],["a"],["b"],["txt_exp"],["check_op1"],["a1"],["b1"],["check_op2"],["a2"],["b2"],["check_op3"],["a3"],["b3"],["check_op4"],["a4"],["b4"],["check_op5"],["a5"],["b5"],["check_op6"],["a6"],["b6"],["check_op7"],["a7"],["b7"],["discr_cst"],["discr_non_cst"],["signe"],["rad_automatique"],["rad_manuel"],["methode"],["ord1"],["ord2"],["ord3"],["degre"],["nnode"],["txt_pas"],["CI"],["dCI"],["CLa"],["CLa_exp"],["CLb"],["CLb_exp"],["points"]],"","","","0","","IN_EDP1(t)","0","","IN_EDP2(t)","0","","IN_EDP3(t)","0","","IN_EDP4(t)","0","","IN_EDP5(t)","0","","IN_EDP6(t)","0","","IN_EDP7(t)","0","0","0","0","0","0","","","","","","","","","0","IN_CL1(t)","0","IN_CL2(t)","");
        label = list(params_pde,[],"");
        gr_i = [];
        x = standard_define([3,3],model,label,gr_i);
    }
    PDE.prototype.details = function PDE() {
    }
    PDE.prototype.get = function PDE() {
    }
    PDE.prototype.set = function PDE() {
        x = arg1;
        graphics = arg1.graphics;
        label = graphics.exprs;
        model = arg1.model;
        params_pde = label[1-1];
        while (true) {
[ln,fun]=where()
        if (!or(fun=="do_eval")) {
        [ok,a_domaine,b_domaine,discr,signe,choix,type_meth,degre,Nbr_maillage,CI,CI1,CLa_type,CLa_exp,CLb_type,CLb_exp,oper,a1,b1,a2,b2,a3,b3,a4,b4,a5,b5,a6,b6,a7,b7,k,mesures,params_pde] = IHM_EDP(params_pde);
        if (ok) {
return;
}
        } else {
        if (exists("%scicos_context")) {
        [ok,a_domaine,b_domaine,discr,signe,choix,type_meth,degre,Nbr_maillage,CI,CI1,CLa_type,CLa_exp,CLb_type,CLb_exp,oper,a1,b1,a2,b2,a3,b3,a4,b4,a5,b5,a6,b6,a7,b7,k,mesures,params_pde] = setvalue_IHM_EDP(params_pde);
}
}
        okk = false;
        rdnom = "PDE";
        ok1 = true;
        while (true) {
        [okk,rdnom,lab] = scicos_getvalue("PLEASE, GIVE US THE BLOCK\'s NAME. ","New block\'s name :",list("str",1),label[3-1]);
        if (okk==false) {
        ok1 = false;
return;
}
        label[3-1] = lab;
        rdnom = stripblanks(rdnom);
        if (rdnom==emptystr()) {
        ok1 = false;
x_message("sorry C file name not defined");
}
        if (ok1) {
break;
}
}
        if ((choix==0)) {
        ind4 = strindex(a4,"x");
        ind1 = strindex(a1,"x");
        ind2 = strindex(a2,"x");
        if ((ind4!=[]||ind1!=[]||ind2!=[])) {
        if ((signe==1)) {
        delta = 1;
        } else if ((signe==2)) {
        delta = -1;
        } else if ((signe==0)) {
        delta = 0;
        } else {
x_message([["le discriminant n\'est pas constant,"],["Vous devez choisir son signe dans l\'IHM"]]);
return;
}
        } else {
        delta = evstr(a4)^2-4*evstr(a1)*evstr(a2);
}
        if ((delta==[])) {
        delta = 0;
}
        type_meth = this.arbre_decision[delta-1];
}
        [flag_type,rdnom,DF_type,tt] = translate(CI,CI1,CLa_type,CLa_exp,CLb_type,CLb_exp,oper,type_meth,degre,a_domaine,b_domaine,Nbr_maillage,a1,b1,a2,b2,a3,b3,a4,b4,a5,b5,a6,b6,a7,b7,rdnom,mesures);
        Nbr = Nbr_maillage;
        if (((CLa_type==1)&&(DF_type==0||DF_type==1))||((CLb_type==1)&&(DF_type==0||DF_type==2))) {
        Nbr = Nbr+1;
}
        if ((mesures==[])) {
        out = Nbr_maillage;
        } else {
        out = [[Nbr_maillage],[size(mesures,"*")]];
}
        if ((flag_type==1)) {
        model.sim = list(rdnom,2004);
        if ((find(oper==1)!=[])) {
        model.state = zeros(2*Nbr_maillage,1);
        } else {
        model.state = zeros(Nbr_maillage,1);
}
        } else if ((flag_type==2)) {
        model.sim = list(rdnom,12004);
        if ((find(oper==1)!=[])) {
        if ((type_meth==3&&(find(oper==2)!=[]||find(oper==4)!=[]))) {
        model.state = zeros(6*Nbr_maillage,1);
        } else if ((type_meth==1)) {
        model.state = zeros(4*Nbr,1);
        } else {
        model.state = zeros(4*Nbr_maillage,1);
}
        } else {
        if ((type_meth==3&&(find(oper==2)!=[]||find(oper==4)!=[]))) {
        model.state = zeros(4*Nbr_maillage,1);
        } else if ((type_meth==1)) {
        model.state = zeros(2*Nbr,1);
        } else {
        model.state = zeros(2*Nbr_maillage,1);
}
}
}
        [ok1] = CFORTREDP(rdnom,tt);
        if (!ok1) {
break;
}
        if (!ok) {
        [model,graphics,ok] = check_io(model,graphics,ones(k,1),out.slice(),[],[]);
}
        label[1-1] = params_pde;
        label[2-1] = tt;
        graphics.exprs = label;
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/Sinks/AFFICH_m.sci" */
function AFFICH_m() {
    AFFICH_m.prototype.define = function AFFICH_m() {
        font = 1;
        fontsize = 1;
        colr = 1;
        nt = 5;
        nd = 1;
        in1 = [1,1];
        model = scicos_model();
        model.sim = list("affich2",4);
        model.in1 = in1[1-1][1-1];
        model.in2 = in1[1-1][2-1];
        model.evtin = 1;
        model.dstate = [[-1],[0],[0],[1],[1],[0],[zeros(in1[1-1][1-1]*in1[1-1][2-1],1)]];
        model.ipar = [[font],[fontsize],[colr],[1000],[nt],[nd],[in1[1-1][1-1]]];
        model.blocktype = "c";
        model.firing = [];
        model.dep_ut = [true,false];
        model.label = "";
        exprs = [[sci2exp([model.in1,model.in2])],[string(font)],[string(fontsize)],[string(colr)],[string(nt)],[string(nd)],[string(0)]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    AFFICH_m.prototype.details = function AFFICH_m() {
    }
    AFFICH_m.prototype.get = function AFFICH_m() {
    }
    AFFICH_m.prototype.set = function AFFICH_m() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,in1,font,fontsize,colr,nt,nd,herit,exprs] = scicos_getvalue("Set  parameters",[["Input Size","Font number"],["Font size"],["Color"],["Total number of digits"],["Number of rational part digits"],["Block inherits (1) or not (0)"]],list("mat",[1,2],"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        mess = [];
        if (font<=0) {
        mess = [[mess],["Font number must be positive"],[" "]];
        ok = false;
}
        if (fontsize<=0) {
        mess = [[mess],["Font size must be positive"],[" "]];
        ok = false;
}
        if (nt<=3) {
        mess = [[mess],["Total number of digits must be greater than 3"],[" "]];
        ok = false;
}
        if (nd<0) {
        mess = [[mess],["Number of rational part digits must be ","greater or equal 0"],[" "]];
        ok = false;
}
        if (!ok) {
message([["Some specified values are inconsistent:"],[" "],[mess]]);
}
        if (!or(herit==[0,1])) {
        mess = [[mess],["Accept inherited values are 0 and 1"],[" "]];
        ok = false;
}
        if (!ok) {
message([["Some specified values are inconsistent:"],[" "],[mess]]);
}
        if (ok) {
        [model,graphics,ok] = set_io(model,graphics,list(in1,1),list(),ones(1-herit,1),[]);
}
        if (ok) {
        model.ipar = [[font],[fontsize],[colr],[nt],[nd],[in1[1-1][1-1]]];
        model.dstate = [[-1],[0],[0],[1],[1],[0],[zeros(in1[1-1][1-1]*in1[1-1][2-1],1)]];
        model.evtin = ones(1-herit,1);
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sinks/BARXY.sci" */
function BARXY() {
    BARXY.prototype.define = function BARXY() {
        model = scicos_model();
        xmin = -15;
        xmax = 15;
        ymin = -15;
        ymax = 15;
        model.sim = list("BARXY_sim",5);
        model.blocktype = "d";
        model.dep_ut = [true,false];
        model.in1 = [[-1],[-1]];
        model.intyp = [1];
        model.out = [];
        model.evtin = [1];
        model.rpar = [[xmin],[xmax],[ymin],[ymax]];
        model.ipar = 1;
        x = standard_define([2,2],model,[],[]);
        x.graphics.in_implicit = ["E","E"];
        x.graphics.out_implicit = [];
        x.graphics.exprs = [["-15"],["15"],["-15"],["15"],["1"]];
    }
    BARXY.prototype.details = function BARXY() {
    }
    BARXY.prototype.get = function BARXY() {
    }
    BARXY.prototype.set = function BARXY() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,xmin,xmax,ymin,ymax,thickness,exprs] = scicos_getvalue("Set Scope parameters",[["Xmin"],["Xmax"],["Ymin"],["Ymax"],["Segs Thickness"]],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        mess = [];
        if (ymin>=ymax) {
        mess = [[mess],["Ymax must be greater than Ymin"],[" "]];
        ok = false;
}
        if (xmin>=xmax) {
        mess = [[mess],["Xmax must be greater than Xmin"],[" "]];
        ok = false;
}
        if (thickness<=0) {
        mess = [[mess],["Thickness must be strictly positive."]];
        ok = false;
}
        if (!ok) {
message(mess);
        } else {
        model.rpar = [[xmin],[xmax],[ymin],[ymax]];
        model.ipar = thickness;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sinks/CANIMXY.sci" */
function CANIMXY() {
    CANIMXY.prototype.define = function CANIMXY() {
        win = -1;
        clrs = -4;
        N = 2;
        siz = 1;
        wpos = [[-1],[-1]];
        wdim = [[-1],[-1]];
        xmin = -15;
        xmax = 15;
        ymin = -15;
        ymax = +15;
        nbr_curves = 1;
        model = scicos_model();
        model.sim = list("canimxy",4);
        model.in1 = [[1],[1]];
        model.in2 = [[1],[1]];
        model.intyp = [[1],[1]];
        model.evtin = 1;
        model.rpar = [[xmin],[xmax],[ymin],[ymax]];
        model.ipar = [[win],[1],[N],[clrs],[siz],[0],[wpos.slice()],[wdim.slice()],[nbr_curves]];
        model.blocktype = "d";
        model.firing = [];
        model.dep_ut = [false,false];
        exprs = [[string(nbr_curves)],[string(clrs)],[string(siz)],[string(win)],["[]"],["[]"],[string(xmin)],[string(xmax)],[string(ymin)],[string(ymax)],[string(N)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    CANIMXY.prototype.details = function CANIMXY() {
    }
    CANIMXY.prototype.get = function CANIMXY() {
    }
    CANIMXY.prototype.set = function CANIMXY() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,nbr_curves,clrs,siz,win,wpos,wdim,xmin,xmax,ymin,ymax,N,exprs] = scicos_getvalue("Set Scope parameters",[["Number of Curves"],["color (>0) or mark (<0)"],["line or mark size"],["Output window number (-1 for automatic)"],["Output window position"],["Output window sizes"],["Xmin"],["Xmax"],["Ymin"],["Ymax"],["Buffer size"]],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",-1,"vec",-1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        mess = [];
        if (size(wpos,"*")!=0&&size(wpos,"*")!=2) {
        mess = [[mess],["Window position must be [] or a 2 vector"],[" "]];
        ok = false;
}
        if (size(wdim,"*")!=0&&size(wdim,"*")!=2) {
        mess = [[mess],["Window dim must be [] or a 2 vector"],[" "]];
        ok = false;
}
        if (win<-1) {
        mess = [[mess],["Window number cannot be inferior than -1"],[" "]];
        ok = false;
}
        if (nbr_curves<=0) {
        mess = [[mess],["Number of curves cannot be negative or null"],[" "]];
        ok = false;
}
        if (N<1) {
        mess = [[mess],["Buffer size must be at least 1"],[" "]];
        ok = false;
}
        if (N==1&&clrs>0) {
        mess = [[mess],["Buffer size must be at least 2"],[" "]];
        ok = false;
}
        if (ymin>=ymax) {
        mess = [[mess],["Ymax must be greater than Ymin"],[" "]];
        ok = false;
}
        if (xmin>=xmax) {
        mess = [[mess],["Xmax must be greater than Xmin"],[" "]];
        ok = false;
}
        if (!ok) {
message(mess);
        } else {
        in1 = nbr_curves*ones(2,1);
        in2 = ones(2,1);
        [model,graphics,ok] = set_io(model,graphics,list([in1,in2],ones(2,1)),list(),ones(1,1),[]);
        if (wpos==[]) {
        wpos = [[-1],[-1]];
}
        if (wdim==[]) {
        wdim = [[-1],[-1]];
}
        rpar = [[xmin],[xmax],[ymin],[ymax]];
        ipar = [[win],[1],[N],[clrs],[siz],[0],[wpos.slice()],[wdim.slice()],[nbr_curves]];
        model.rpar = rpar;
        model.ipar = ipar;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sinks/CANIMXY3D.sci" */
function CANIMXY3D() {
    CANIMXY3D.prototype.define = function CANIMXY3D() {
        win = -1;
        N = 2;
        clrs = [[1],[2],[3],[4],[5],[6],[7],[13]];
        siz = [[1],[1],[1],[1],[1],[1],[1],[1]];
        wpos = [[-1],[-1]];
        wdim = [[-1],[-1]];
        param3ds = [[50],[280]];
        vec_x = [[-15],[15]];
        vec_y = [[-15],[15]];
        vec_z = [[-15],[15]];
        nbr_curves = 1;
        model = scicos_model();
        model.sim = list("canimxy3d",4);
        model.in1 = [[1],[1],[1]];
        model.evtin = 1;
        model.in2 = [[1],[1],[1]];
        model.intyp = [[1],[1],[1]];
        model.rpar = [[vec_x.slice()],[vec_y.slice()],[vec_z.slice()],[param3ds.slice()]];
        model.ipar = [[win],[8],[N],[clrs.slice()],[siz.slice()],[8],[wpos.slice()],[wdim.slice()],[nbr_curves]];
        model.blocktype = "d";
        model.firing = [];
        model.dep_ut = [false,false];
        exprs = [[string(nbr_curves)],[strcat(string(clrs)," ")],[strcat(string(siz)," ")],[string(win)],["[]"],["[]"],[strcat(string(vec_x)," ")],[strcat(string(vec_y)," ")],[strcat(string(vec_z)," ")],[strcat(string(param3ds)," ")],[string(N)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    CANIMXY3D.prototype.details = function CANIMXY3D() {
    }
    CANIMXY3D.prototype.get = function CANIMXY3D() {
    }
    CANIMXY3D.prototype.set = function CANIMXY3D() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,nbr_curves,clrs,siz,win,wpos,wdim,vec_x,vec_y,vec_z,param3ds,N,exprs] = scicos_getvalue("Set Scope parameters",[["Number of curves"],["color (>0) or mark (<0)"],["line or mark size"],["Output window number (-1 for automatic)"],["Output window position"],["Output window sizes"],["Xmin and Xmax"],["Ymin and Ymax"],["Zmin and Zmax"],["Alpha and Theta"],["Buffer size"]],list("vec",1,"vec",-1,"vec",-1,"vec",1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",1),exprs);
        if (!ok) {
break;
}
        mess = [];
        if (size(wpos,"*")!=0&&size(wpos,"*")!=2) {
        mess = [[mess],["Window position must be [] or a 2 vector"],[" "]];
        ok = false;
}
        if (size(wdim,"*")!=0&&size(wdim,"*")!=2) {
        mess = [[mess],["Window dim must be [] or a 2 vector"],[" "]];
        ok = false;
}
        if (win<-1) {
        mess = [[mess],["Window number cannot be inferior than -1"],[" "]];
        ok = false;
}
        if (size(clrs,"*")!=size(siz,"*")) {
        mess = [[mess],["Colors and Size must have same size"],[" "]];
        ok = false;
}
        if (nbr_curves<=0) {
        mess = [[mess],["Number of curves cannot be negative or null"],[" "]];
        ok = false;
}
        if (size(clrs,"*")<nbr_curves) {
        mess = [[mess],["You must have at least same size for clrs and the number of curves"],[" "]];
        ok = false;
}
        if (N<1) {
        mess = [[mess],["Buffer size must be at least 1"],[" "]];
        ok = false;
}
        if (N<2) {
for (i=1;i<=nbr_curves;i+=1) {
        if (clrs[i-1]>0) {
        mess = [[mess],["Buffer size must be at least 2 or Change a color (must be <0)"],[" "]];
        ok = false;
}
}
}
        if (vec_y[1-1]>=vec_y[2-1]) {
        mess = [[mess],["Ymax must be higher than Ymin"],[" "]];
        ok = false;
}
        if (vec_x[1-1]>=vec_x[2-1]) {
        mess = [[mess],["Xmax must be higher than Xmin"],[" "]];
        ok = false;
}
        if (vec_z[1-1]>=vec_z[2-1]) {
        mess = [[mess],["Zmax must be higher than Zmin"],[" "]];
        ok = false;
}
        if (!ok) {
message(mess);
        } else {
        in1 = nbr_curves*ones(3,1);
        in2 = ones(3,1);
        [model,graphics,ok] = set_io(model,graphics,list([in1,in2],ones(3,1)),list(),ones(1,1),[]);
        if (wpos==[]) {
        wpos = [[-1],[-1]];
}
        if (wdim==[]) {
        wdim = [[-1],[-1]];
}
        rpar = [[vec_x.slice()],[vec_y.slice()],[vec_z.slice()],[param3ds.slice()]];
        size_siz = size(siz,"*");
        ipar = [[win],[size_siz],[N],[clrs.slice()],[siz.slice()],[1],[wpos.slice()],[wdim.slice()],[nbr_curves]];
        model.rpar = rpar;
        model.ipar = ipar;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sinks/CEVENTSCOPE.sci" */
function CEVENTSCOPE() {
    CEVENTSCOPE.prototype.define = function CEVENTSCOPE() {
        nclock = 1;
        win = -1;
        clrs = [[1],[3],[5],[7],[9],[11],[13],[15]];
        wdim = [[600],[400]];
        wpos = [[-1],[-1]];
        per = 30;
        model = scicos_model();
        model.sim = list("cevscpe",4);
        model.evtin = 1;
        model.rpar = per;
        model.ipar = [[win],[1],[clrs[nclock-1]],[wpos.slice()],[wdim.slice()]];
        model.blocktype = "d";
        model.dep_ut = [false,false];
        exprs = [[sci2exp(nclock)],[strcat(sci2exp(clrs[nclock-1])," ")],[string(win)],[sci2exp([])],[sci2exp(wdim)],[string(per)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    CEVENTSCOPE.prototype.details = function CEVENTSCOPE() {
    }
    CEVENTSCOPE.prototype.get = function CEVENTSCOPE() {
    }
    CEVENTSCOPE.prototype.set = function CEVENTSCOPE() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,nclock,clrs,win,wpos,wdim,per,exprs] = scicos_getvalue("Set Scope parameters",[["Number of event inputs"],["colors c (>0) or mark (<0)"],["Output window number (-1 for automatic)"],["Output window position"],["Output window sizes"],["Refresh period"]],list("vec",1,"vec",-1,"vec",1,"vec",-1,"vec",-1,"vec",1),exprs);
        nclock = int(nclock);
        clrs = int(clrs);
        win = int(win);
        if (!ok) {
break;
}
        mess = [];
        if (size(wpos,"*")!=0&&size(wpos,"*")!=2) {
        mess = [[mess],["Window position must be [] or a 2 vector"],[" "]];
        ok = false;
}
        if (size(wdim,"*")!=0&&size(wdim,"*")!=2) {
        mess = [[mess],["Window dim must be [] or a 2 vector"],[" "]];
        ok = false;
}
        if (nclock<=0) {
        mess = [[mess],["Block must have at least one input event"],[" "]];
        ok = false;
}
        if (size(clrs,"*")!=nclock) {
        mess = [[mess],["Inputs color c size must be equal to Number of inputs"],[" "]];
        ok = false;
}
        if (win<-1) {
        mess = [[mess],["Window number cannot be inferior than -1"],[" "]];
        ok = false;
}
        if (per<=0) {
        mess = [[mess],["Refresh period must be positive"],[" "]];
        ok = false;
}
        if (ok) {
        [model,graphics,ok] = set_io(model,graphics,list(),list(),ones(nclock,1),[]);
        } else {
message([["Some specified values are inconsistent:"],[" "],[mess]]);
}
        if (ok) {
        if (wpos==[]) {
        wpos = [[-1],[-1]];
}
        if (wdim==[]) {
        wdim = [[-1],[-1]];
}
        rpar = per;
        ipar = [[win],[1],[clrs.slice()],[wpos.slice()],[wdim.slice()]];
        model.rpar = rpar;
        model.ipar = ipar;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sinks/CFSCOPE.sci" */
function CFSCOPE() {
    CFSCOPE.prototype.define = function CFSCOPE() {
        win = -1;
        wdim = [[600],[400]];
        wpos = [[-1],[-1]];
        clrs = [[1],[3],[5],[7],[9],[11],[13],[15]];
        N = 2;
        ymin = -15;
        ymax = +15;
        per = 30;
        model = scicos_model();
        model.sim = list("cfscope",4);
        model.evtin = 1;
        model.rpar = [[0],[ymin],[ymax],[per]];
        model.ipar = [[win],[1],[N],[clrs],[wpos],[wdim],[1],[1]];
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[strcat(string(clrs)," ")],[string(win)],[sci2exp([])],[sci2exp(wdim)],[string(ymin)],[string(ymax)],[string(per)],[string(N)],[string([1])]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    CFSCOPE.prototype.details = function CFSCOPE() {
    }
    CFSCOPE.prototype.get = function CFSCOPE() {
    }
    CFSCOPE.prototype.set = function CFSCOPE() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,clrs,win,wpos,wdim,ymin,ymax,per,N,wu,exprs] = scicos_getvalue("Set Scope parameters",[["Color (>0) or mark (<0) vector (8 entries)"],["Output window number (-1 for automatic)"],["Output window position"],["Output window sizes"],["Ymin"],["Ymax"],["Refresh period"],["Buffer size","Links to view"]],list("vec",8,"vec",1,"vec",-1,"vec",-1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",-1),exprs);
        if (!ok) {
break;
}
        mess = [];
        if (size(wpos,"*")!=0&&size(wpos,"*")!=2) {
        mess = [[mess],["Window position must be [] or a 2 vector"],[" "]];
        ok = false;
}
        if (size(wdim,"*")!=0&&size(wdim,"*")!=2) {
        mess = [[mess],["Window dim must be [] or a 2 vector"],[" "]];
        ok = false;
}
        if (win<-1) {
        mess = [[mess],["Window number cannot be inferior than -1"],[" "]];
        ok = false;
}
        if (per<=0) {
        mess = [[mess],["Refresh period must be positive"],[" "]];
        ok = false;
}
        if (N<2) {
        mess = [[mess],["Buffer size must be at least 2"],[" "]];
        ok = false;
}
        if (ymin>=ymax) {
        mess = [[mess],["Ymax must be greater than Ymin"],[" "]];
        ok = false;
}
        if (wu<0) {
        mess = [[mess],["Link to view must be positive"],[" "]];
        ok = false;
}
        if (!ok) {
message([["Some specified values are inconsistent:"],[" "],[mess]]);
}
        if (ok) {
        if (wpos==[]) {
        wpos = [[-1],[-1]];
}
        if (wdim==[]) {
        wdim = [[-1],[-1]];
}
        rpar = [[0],[ymin],[ymax],[per]];
        if (size(clrs,"*")>8) {
        clrs = clrs.slice(1-1,8);
}
        if (size(clrs,"*")<8) {
        clrs[8-1] = 0;
}
        ipar = [[win],[1],[N],[clrs.slice()],[wpos.slice()],[wdim.slice()],[size(wu,"*")],[wu.slice()]];
        model.rpar = rpar;
        model.ipar = ipar;
        model.firing = [];
        model.dep_ut = [true,false];
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sinks/CLKOUTV_f.sci" */
function CLKOUTV_f() {
    CLKOUTV_f.prototype.define = function CLKOUTV_f() {
        prt = 1;
        model = scicos_model();
        model.sim = "output";
        model.evtin = 1;
        model.ipar = prt;
        model.blocktype = "d";
        model.firing = [];
        model.dep_ut = [false,false];
        exprs = string(prt);
        x = standard_define([1,1],model,exprs," ");
    }
    CLKOUTV_f.prototype.details = function CLKOUTV_f() {
    }
    CLKOUTV_f.prototype.get = function CLKOUTV_f() {
    }
    CLKOUTV_f.prototype.set = function CLKOUTV_f() {
        x = arg1;
        graphics = arg1.graphics;
        model = arg1.model;
        exprs = graphics.exprs;
        while (true) {
        [ok,prt,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"CLKOUTV_f")],[" "],[gettext("Event output port")]],gettext("Port number"),list("vec",1),exprs);
        if (!ok) {
break;
}
        prt = int(prt);
        if (prt<=0) {
block_parameter_error(msprintf(gettext("Wrong value for \'Port Number\' parameter: %d."),prt),gettext("Strictly positive integer expected."));
        } else {
        model.ipar = prt;
        model.evtin = 1;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sinks/CLKOUT_f.sci" */
function CLKOUT_f() {
    CLKOUT_f.prototype.define = function CLKOUT_f() {
        prt = 1;
        model = scicos_model();
        model.sim = "output";
        model.evtin = 1;
        model.ipar = prt;
        model.blocktype = "d";
        model.firing = [];
        model.dep_ut = [false,false];
        exprs = string(prt);
        x = standard_define([1,1],model,exprs," ");
    }
    CLKOUT_f.prototype.details = function CLKOUT_f() {
    }
    CLKOUT_f.prototype.get = function CLKOUT_f() {
    }
    CLKOUT_f.prototype.set = function CLKOUT_f() {
        x = arg1;
        graphics = arg1.graphics;
        model = arg1.model;
        exprs = graphics.exprs;
        exprs = exprs[1-1];
        while (true) {
        [ok,prt,exprs] = scicos_getvalue("Set Event Output block parameters","Port number",list("vec",1),exprs);
        if (!ok) {
break;
}
        prt = int(prt);
        if (prt<=0) {
message("Port number must be a positive integer");
        } else {
        model.ipar = prt;
        model.evtin = 1;
        model.firing = [];
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sinks/CMAT3D.sci" */
function CMAT3D() {
    CMAT3D.prototype.define = function CMAT3D() {
        cmin = 0;
        cmax = 100;
        colormap = this.jetcolormap[25-1];
        size_c = 25;
        x = -1;
        y = -1;
        size_x = 1;
        size_y = 1;
        model = scicos_model();
        model.sim = list("cmat3d",4);
        model.in1 = -1;
        model.in2 = -2;
        model.intyp = 1;
        model.evtin = 1;
        model.ipar = [[cmin],[cmax],[size_c],[size_x],[size_y]];
        model.rpar = [[colormap.slice()],[x],[y]];
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[strcat(string(x)," ")],[strcat(string(y)," ")],[string("jetcolormap(25)")],[string(cmin)],[string(cmax)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    CMAT3D.prototype.details = function CMAT3D() {
    }
    CMAT3D.prototype.get = function CMAT3D() {
    }
    CMAT3D.prototype.set = function CMAT3D() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,vec_x,vec_y,colormap,cmin,cmax,exprs] = scicos_getvalue("Set Scope parameters",[["Bounds Vector X (-1 for standard)"],["Bounds Vector Y (-1 for standard)"],["ColorMap"],["Zmin"],["Zmax"]],list("vec",-1,"vec",-1,"vec",-1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        mess = [];
        if (size(vec_x,"*")!=size(vec_y,"*")) {
        mess = [[mess],["Vector X and Vector Y must have the same size"],[" "]];
        ok = false;
}
        if (cmax<=cmin) {
        mess = [[mess],["Error with minimum and maximum value"],[" "]];
        ok = false;
}
        if (!ok) {
message([["Some specified values are inconsistent:"],[" "],[mess]]);
}
        if (ok) {
        size_x = size(vec_x,"*");
        size_c = size(colormap.slice(),1);
        ipar = [[cmin],[cmax],[size_c],[size_x]];
        rpar = [[colormap.slice()],[vec_x.slice()],[vec_y.slice()]];
        model.ipar = ipar;
        model.rpar = rpar;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sinks/CMATVIEW.sci" */
function CMATVIEW() {
    CMATVIEW.prototype.define = function CMATVIEW() {
        cmin = 0;
        cmax = 100;
        size_c = 25;
        colormap = this.jetcolormap[size_c-1];
        alpha_c = 0.24;
        beta_c = 1;
        model = scicos_model();
        model.sim = list("cmatview",4);
        model.in1 = -1;
        model.in2 = -2;
        model.intyp = 1;
        model.evtin = 1;
        model.ipar = [[cmin],[cmax],[size_c]];
        model.rpar = [[alpha_c],[beta_c],[colormap.slice()]];
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[string("jetcolormap(25)")],[string(cmin)],[string(cmax)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    CMATVIEW.prototype.details = function CMATVIEW() {
    }
    CMATVIEW.prototype.get = function CMATVIEW() {
    }
    CMATVIEW.prototype.set = function CMATVIEW() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,colormap,cmin,cmax,exprs] = scicos_getvalue("Set Scope parameters",[["ColorMap"],["Minimum level range"],["Maximum level range"]],list("vec",-1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        mess = [];
        if (cmax<=cmin) {
        mess = [[mess],["Error with minimum and maximum value"],[" "]];
        ok = false;
}
        if (!ok) {
message([["Some specified values are inconsistent:"],[" "],[mess]]);
}
        if (ok) {
        size_c = size(colormap.slice(),1);
        sol = inv([[cmin,1],[cmax,1]])*[[1],[size_c/3]];
        alpha_c = sol[1-1];
        beta_c = sol[2-1];
        ipar = [[cmin],[cmax],[size_c]];
        rpar = [[alpha_c],[beta_c],[colormap.slice()]];
        model.ipar = ipar;
        model.rpar = rpar;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sinks/CMSCOPE.sci" */
function CMSCOPE() {
    CMSCOPE.prototype.define = function CMSCOPE() {
        win = -1;
        in1 = [[1],[1]];
        wdim = [[-1],[-1]];
        wpos = [[-1],[-1]];
        clrs = [[1],[3],[5],[7],[9],[11],[13],[15]];
        N = 20;
        ymin = [[-1],[-5]];
        ymax = [[1],[5]];
        per = [[30],[30]];
        yy = [[transpose(ymin.slice())],[transpose(ymax.slice())]];
        period = transpose(per.slice());
        model = scicos_model();
        model.sim = list("cmscope",4);
        model.in1 = in1;
        model.in2 = [[1],[1]];
        model.intyp = [[1],[1]];
        model.evtin = 1;
        model.rpar = [[0],[period.slice()],[yy.slice()]];
        model.ipar = [[win],[size(in1,"*")],[N],[wpos.slice()],[wdim.slice()],[in1.slice()],[clrs.slice(1-1,sum(in1))]];
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[strcat(string(in1)," ")],[strcat(string(clrs)," ")],[string(win)],[sci2exp([])],[sci2exp([])],[strcat(string(ymin)," ")],[strcat(string(ymax)," ")],[strcat(string(per)," ")],[string(N)],[string(0)],[emptystr()]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    CMSCOPE.prototype.details = function CMSCOPE() {
    }
    CMSCOPE.prototype.get = function CMSCOPE() {
    }
    CMSCOPE.prototype.set = function CMSCOPE() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,in1,clrs,win,wpos,wdim,ymin,ymax,per,N,heritance,nom,exprs] = scicos_getvalue("Set Scope parameters",[["Input ports sizes"],["Drawing colors (>0) or mark (<0)"],["Output window number (-1 for automatic)"],["Output window position"],["Output window sizes"],["Ymin vector"],["Ymax vector"],["Refresh period"],["Buffer size"],["Accept herited events 0/1","Name of Scope (label&Id)"]],list("vec",-1,"vec",-1,"vec",1,"vec",-1,"vec",-1,"vec","size(%1,\'*\')","vec","size(%1,\'*\')","vec","size(%1,\'*\')","vec",1,"vec",1,"str",1),exprs);
        if (!ok) {
break;
}
        mess = [];
        if (size(in1,"*")<=0) {
        mess = [[mess],["Block must have at least one input port"],[" "]];
        ok = false;
}
        if (min(in1)<=0) {
        mess = [[mess],["Port sizes must be positive"],[" "]];
        ok = false;
}
        if (size(clrs,"*")<sum(in1)) {
        mess = [[mess],["Not enough colors defined (at least "+string(sum(in1))+")"],[" "]];
        ok = false;
}
        if (size(wpos,"*")!=0&&size(wpos,"*")!=2) {
        mess = [[mess],["Window position must be [] or a 2 vector"],[" "]];
        ok = false;
}
        if (size(wdim,"*")!=0&&size(wdim,"*")!=2) {
        mess = [[mess],["Window dim must be [] or a 2 vector"],[" "]];
        ok = false;
}
        if (win<-1) {
        mess = [[mess],["Window number can\'t be  < -1"],[" "]];
        ok = false;
}
        if (size(per,"*")!=size(ymin,"*")) {
        mess = [[mess],["Size of Refresh Period must equal size of Ymin/Ymax vector"],[" "]];
        ok = false;
}
for (i=1;i<=size(per,"*");i+=1) {
        if ((per[i-1]<=0)) {
        mess = [[mess],["Refresh Period must be positive"],[" "]];
        ok = false;
}
}
        if (N<2) {
        mess = [[mess],["Buffer size must be at least 2"],[" "]];
        ok = false;
}
        if (or(ymin>=ymax)) {
        mess = [[mess],["Ymax must be greater than Ymin"],[" "]];
        ok = false;
}
        if (!or(heritance==[0,1])) {
        mess = [[mess],["Accept herited events must be 0 or 1"],[" "]];
        ok = false;
}
        if (!ok) {
message([["Some specified values are inconsistent:"],[" "],[mess]]);
}
        if (ok) {
        in1 = in1.slice();
        a = size(in1,1);
        in2 = ones(a,1);
        [model,graphics,ok] = set_io(model,graphics,list([in1,in2],ones(a,1)),list(),ones(1-heritance,1),[]);
}
        if (ok) {
        if (wpos==[]) {
        wpos = [[-1],[-1]];
}
        if (wdim==[]) {
        wdim = [[-1],[-1]];
}
        if (ok) {
        period = transpose(per.slice());
        yy = [[transpose(ymin.slice())],[transpose(ymax.slice())]];
        rpar = [[0],[period.slice()],[yy.slice()]];
        clrs = clrs.slice(1-1,sum(in1));
        ipar = [[win],[size(in1,"*")],[N],[wpos.slice()],[wdim.slice()],[in1.slice()],[clrs.slice()],[heritance]];
        model.evtin = ones(1-heritance,1);
        model.dstate = [];
        model.rpar = rpar;
        model.ipar = ipar;
        model.label = nom;
        graphics.id = nom;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/Sinks/CSCOPE.sci" */
function CSCOPE() {
    CSCOPE.prototype.define = function CSCOPE() {
        win = -1;
        wdim = [[600],[400]];
        wpos = [[-1],[-1]];
        clrs = [[1],[3],[5],[7],[9],[11],[13],[15]];
        N = 20;
        ymin = -15;
        ymax = +15;
        per = 30;
        model = scicos_model();
        model.sim = list("cscope",4);
        model.in1 = -1;
        model.in2 = 1;
        model.evtin = 1;
        model.rpar = [[0],[ymin],[ymax],[per]];
        model.ipar = [[win],[1],[N],[clrs],[wpos],[wdim]];
        model.blocktype = "c";
        model.dep_ut = [true,false];
        exprs = [[strcat(string(clrs)," ")],[string(win)],[sci2exp([])],[sci2exp(wdim)],[string(ymin)],[string(ymax)],[string(per)],[string(N)],[transpose(string(0))],[emptystr()]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    CSCOPE.prototype.details = function CSCOPE() {
    }
    CSCOPE.prototype.get = function CSCOPE() {
    }
    CSCOPE.prototype.set = function CSCOPE() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,clrs,win,wpos,wdim,ymin,ymax,per,N,heritance,nom,exprs] = scicos_getvalue("Set Scope parameters",[["Color (>0) or mark (<0) vector (8 entries)"],["Output window number (-1 for automatic)"],["Output window position"],["Output window sizes"],["Ymin"],["Ymax"],["Refresh period"],["Buffer size","Accept herited events 0/1","Name of Scope (label&Id)"]],list("vec",8,"vec",1,"vec",-1,"vec",-1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"str",1),exprs);
        if (!ok) {
break;
}
        mess = [];
        if (size(wpos,"*")!=0&&size(wpos,"*")!=2) {
        mess = [[mess],["Window position must be [] or a 2 vector"],[" "]];
        ok = false;
}
        if (size(wdim,"*")!=0&&size(wdim,"*")!=2) {
        mess = [[mess],["Window dim must be [] or a 2 vector"],[" "]];
        ok = false;
}
        if (win<-1) {
        mess = [[mess],["Window number can\'t be  < -1"],[" "]];
        ok = false;
}
        if (per<=0) {
        mess = [[mess],["Refresh period must be positive"],[" "]];
        ok = false;
}
        if (N<2) {
        mess = [[mess],["Buffer size must be at least 2"],[" "]];
        ok = false;
}
        if (ymin>=ymax) {
        mess = [[mess],["Ymax must be greater than Ymin"],[" "]];
        ok = false;
}
        if (!or(heritance==[0,1])) {
        mess = [[mess],["Accept herited events must be 0 or 1"],[" "]];
        ok = false;
}
        if (!ok) {
message([["Some specified values are inconsistent:"],[" "],[mess]]);
}
        if (ok) {
        [model,graphics,ok] = set_io(model,graphics,list([-1,1],1),list(),ones(1-heritance,1),[]);
}
        if (ok) {
        if (wpos==[]) {
        wpos = [[-1],[-1]];
}
        if (wdim==[]) {
        wdim = [[-1],[-1]];
}
        rpar = [[0],[ymin],[ymax],[per]];
        ipar = [[win],[1],[N],[clrs.slice()],[wpos.slice()],[wdim.slice()]];
        model.rpar = rpar;
        model.ipar = ipar;
        model.evtin = ones(1-heritance,1);
        model.label = nom;
        graphics.id = nom;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sinks/CSCOPXY.sci" */
function CSCOPXY() {
    CSCOPXY.prototype.define = function CSCOPXY() {
        win = -1;
        clrs = 4;
        siz = 1;
        wdim = [[600],[400]];
        wpos = [[-1],[-1]];
        N = 2;
        xmin = -15;
        xmax = 15;
        ymin = -15;
        ymax = +15;
        nbr_curves = 1;
        model = scicos_model();
        model.sim = list("cscopxy",4);
        model.in1 = [[1],[1]];
        model.in2 = [[1],[1]];
        model.intyp = [[1],[1]];
        model.evtin = 1;
        model.rpar = [[xmin],[xmax],[ymin],[ymax]];
        model.ipar = [[win],[1],[N],[clrs],[siz],[1],[wpos.slice()],[wdim.slice()],[nbr_curves]];
        model.blocktype = "d";
        model.dep_ut = [false,false];
        exprs = [[string(nbr_curves)],[sci2exp(clrs)],[sci2exp(siz)],[string(win)],[sci2exp([])],[sci2exp(wdim)],[string(xmin)],[string(xmax)],[string(ymin)],[string(ymax)],[string(N)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    CSCOPXY.prototype.details = function CSCOPXY() {
    }
    CSCOPXY.prototype.get = function CSCOPXY() {
    }
    CSCOPXY.prototype.set = function CSCOPXY() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,nbr_curves,clrs,siz,win,wpos,wdim,xmin,xmax,ymin,ymax,N,exprs] = scicos_getvalue("Set Scope parameters",[["Number of Curves"],["color (>0) or mark (<0)"],["line or mark size"],["Output window number (-1 for automatic)"],["Output window position"],["Output window sizes"],["Xmin"],["Xmax"],["Ymin"],["Ymax"],["Buffer size"]],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",-1,"vec",-1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        mess = [];
        if (size(wpos,"*")!=0&&size(wpos,"*")!=2) {
        mess = [[mess],["Window position must be [] or a 2 vector"],[" "]];
        ok = false;
}
        if (size(wdim,"*")!=0&&size(wdim,"*")!=2) {
        mess = [[mess],["Window dim must be [] or a 2 vector"],[" "]];
        ok = false;
}
        if (nbr_curves<=0) {
        mess = [[mess],["Number of Curves cannot be negative or null"],[" "]];
        ok = false;
}
        if (win<-1) {
        mess = [[mess],["Window number cannot be inferior than -1"],[" "]];
        ok = false;
}
        if (N<1) {
        mess = [[mess],["Buffer size must be at least 1"],[" "]];
        ok = false;
}
        if (N==1&&clrs>0) {
        mess = [[mess],["Buffer size must be at least 2"],[" "]];
        ok = false;
}
        if (ymin>=ymax) {
        mess = [[mess],["Ymax must be greater than Ymin"],[" "]];
        ok = false;
}
        if (xmin>=xmax) {
        mess = [[mess],["Xmax must be greater than Xmin"],[" "]];
        ok = false;
}
        if (!ok) {
message(mess);
        } else {
        in1 = nbr_curves*ones(2,1);
        in2 = ones(2,1);
        [model,graphics,ok] = set_io(model,graphics,list([in1,in2],ones(2,1)),list(),ones(1,1),[]);
        if (wpos==[]) {
        wpos = [[-1],[-1]];
}
        if (wdim==[]) {
        wdim = [[-1],[-1]];
}
        rpar = [[xmin],[xmax],[ymin],[ymax]];
        ipar = [[win],[1],[N],[clrs],[siz],[1],[wpos.slice()],[wdim.slice()],[nbr_curves]];
        model.rpar = rpar;
        model.ipar = ipar;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sinks/CSCOPXY3D.sci" */
function CSCOPXY3D() {
    CSCOPXY3D.prototype.define = function CSCOPXY3D() {
        win = -1;
        clrs = [[1],[2],[3],[4],[5],[6],[7],[13]];
        siz = [[1],[1],[1],[1],[1],[1],[1],[1]];
        wdim = [[600],[400]];
        wpos = [[-1],[-1]];
        N = 2;
        param3ds = [[50],[280]];
        vec_x = [[-15],[15]];
        vec_y = [[-15],[15]];
        vec_z = [[-15],[15]];
        nbr_curves = 1;
        model = scicos_model();
        model.sim = list("cscopxy3d",4);
        model.in1 = [[1],[1],[1]];
        model.in2 = [[1],[1],[1]];
        model.intyp = [[1],[1],[1]];
        model.evtin = 1;
        model.rpar = [[vec_x.slice()],[vec_y.slice()],[vec_z.slice()],[param3ds.slice()]];
        model.ipar = [[win],[8],[N],[clrs.slice()],[siz.slice()],[8],[wpos.slice()],[wdim.slice()],[nbr_curves]];
        model.blocktype = "d";
        model.dep_ut = [false,false];
        exprs = [[string(nbr_curves)],[strcat(string(clrs)," ")],[strcat(string(siz)," ")],[string(win)],[sci2exp([])],[sci2exp(wdim)],[strcat(string(vec_x)," ")],[strcat(string(vec_y)," ")],[strcat(string(vec_z)," ")],[strcat(string(param3ds)," ")],[string(N)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    CSCOPXY3D.prototype.details = function CSCOPXY3D() {
    }
    CSCOPXY3D.prototype.get = function CSCOPXY3D() {
    }
    CSCOPXY3D.prototype.set = function CSCOPXY3D() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,nbr_curves,clrs,siz,win,wpos,wdim,vec_x,vec_y,vec_z,param3ds,N,exprs] = scicos_getvalue("Set Scope parameters",[["Number of curves"],["color (>0) or mark (<0)"],["Line or Mark Size"],["Output window number (-1 for automatic)"],["Output window position"],["Output window sizes"],["Xmin and Xmax"],["Ymin and Ymax"],["Zmin and Zmax"],["Alpha and Theta"],["Buffer size"]],list("vec",1,"vec",-1,"vec",-1,"vec",1,"vec",-1,"vec",-1,"vec",2,"vec",2,"vec",2,"vec",2,"vec",1),exprs);
        if (!ok) {
break;
}
        mess = [];
        if (size(wpos,"*")!=0&&size(wpos,"*")!=2) {
        mess = [[mess],["Window position must be [] or a 2 vector"],[" "]];
        ok = false;
}
        if (size(wdim,"*")!=0&&size(wdim,"*")!=2) {
        mess = [[mess],["Window dim must be [] or a 2 vector"],[" "]];
        ok = false;
}
        if (size(clrs,"*")!=size(siz,"*")) {
        mess = [[mess],["Colors and Size must have same size"],[" "]];
        ok = false;
}
        if (nbr_curves<=0) {
        mess = [[mess],["Number of curves cannot be negative or null"],[" "]];
        ok = false;
}
        if (win<-1) {
        mess = [[mess],["Window number cannot be inferior than -1"],[" "]];
        ok = false;
}
        if (N<1) {
        mess = [[mess],["Buffer size must be at least 1"],[" "]];
        ok = false;
}
        if (N<2) {
for (i=1;i<=size(clrs,"*");i+=1) {
        if (clrs[i-1]>0) {
        mess = [[mess],["Buffer size must be at least 2 or Change a color (must be >0)"],[" "]];
        ok = false;
}
}
}
        if (vec_y[1-1]>=vec_y[2-1]) {
        mess = [[mess],["Ymax must be higher than Ymin"],[" "]];
        ok = false;
}
        if (vec_x[1-1]>=vec_x[2-1]) {
        mess = [[mess],["Xmax must be higher than Xmin"],[" "]];
        ok = false;
}
        if (vec_z[1-1]>=vec_z[2-1]) {
        mess = [[mess],["Zmax must be higher than Zmin"],[" "]];
        ok = false;
}
        if (ok) {
        in1 = nbr_curves*ones(3,1);
        in2 = ones(3,1);
        [model,graphics,ok] = set_io(model,graphics,list([in1,in2],ones(3,1)),list(),ones(1,1),[]);
        if (wpos==[]) {
        wpos = [[-1],[-1]];
}
        if (wdim==[]) {
        wdim = [[-1],[-1]];
}
        rpar = [[vec_x.slice()],[vec_y.slice()],[vec_z.slice()],[param3ds.slice()]];
        size_siz = size(siz,"*");
        ipar = [[win],[size_siz],[N],[clrs.slice()],[siz.slice()],[1],[wpos.slice()],[wdim.slice()],[nbr_curves]];
        model.rpar = rpar;
        model.ipar = ipar;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
        } else {
message(mess);
}
}
    }
}
/* autogenerated from "macros/Sinks/OUTIMPL_f.sci" */
function OUTIMPL_f() {
    OUTIMPL_f.prototype.define = function OUTIMPL_f() {
        model = scicos_model();
        model.in1 = [-1];
        model.in2 = [1];
        prt = 1;
        model.sim = "outimpl";
        model.ipar = [1];
        model.blocktype = "c";
        model.dep_ut = [false,false];
        mo = modelica();
        mo.model = "PORT";
        mo.inputs = "n";
        model.equations = mo;
        exprs = "1";
        gr_i = [];
        x = standard_define([1,1],model,exprs,gr_i);
        x.graphics.in_implicit = ["I"];
    }
    OUTIMPL_f.prototype.details = function OUTIMPL_f() {
    }
    OUTIMPL_f.prototype.get = function OUTIMPL_f() {
    }
    OUTIMPL_f.prototype.set = function OUTIMPL_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        if (size(exprs,"*")==2) {
        exprs = exprs[1-1];
}
        while (true) {
        [ok,prt,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"OUTIMPL_f")],[" "],[gettext("Implicit output port")]],gettext("Port number"),list("vec",1),exprs);
        if (!ok) {
break;
}
        prt = int(prt);
        if (prt<=0) {
block_parameter_error(msprintf(gettext("Wrong value for \'Port Number\' parameter: %d."),prt),gettext("Strictly positive integer expected."));
        } else {
        if (model.ipar!=prt) {
        needcompile = 4;
        y = needcompile;
}
        model.ipar = prt;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sinks/OUT_f.sci" */
function OUT_f() {
    OUT_f.prototype.define = function OUT_f() {
        n = -1;
        prt = 1;
        model = scicos_model();
        model.sim = "output";
        model.in1 = -1;
        model.in2 = -2;
        model.intyp = -1;
        model.ipar = prt;
        model.blocktype = "c";
        model.dep_ut = [false,false];
        exprs = string(prt);
        gr_i = [];
        x = standard_define([1,1],model,exprs,gr_i);
    }
    OUT_f.prototype.details = function OUT_f() {
    }
    OUT_f.prototype.get = function OUT_f() {
    }
    OUT_f.prototype.set = function OUT_f() {
        x = arg1;
        graphics = arg1.graphics;
        model = arg1.model;
        exprs = graphics.exprs;
        if (size(exprs,"*")==2) {
        exprs = exprs[1-1];
}
        while (true) {
        [ok,prt,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"OUT_f")],[" "],[gettext("Regular output port")]],gettext("Port number"),list("vec",1),exprs);
        if (!ok) {
break;
}
        prt = int(prt);
        if (prt<=0) {
block_parameter_error(msprintf(gettext("Wrong value for \'Port Number\' parameter: %d."),prt),gettext("Strictly positive integer expected."));
        } else {
        model.ipar = prt;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sinks/TOWS_c.sci" */
function TOWS_c() {
    TOWS_c.prototype.define = function TOWS_c() {
        nu = -1;
        nz = 128;
        varnam = "A";
        herit = 0;
        model = scicos_model();
        model.sim = list("tows_c",4);
        model.in1 = [nu];
        model.in2 = -2;
        model.intyp = -1;
        model.out = [];
        model.evtin = [1];
        model.evtout = [];
        model.rpar = [];
        model.ipar = [[nz],[length(varnam)],[transpose(this.ascii[varnam-1])]];
        model.blocktype = "d";
        model.firing = [];
        model.dep_ut = [false,false];
        gr_i = [];
        exprs = [[string(nz)],[string(varnam)],[string(herit)]];
        x = standard_define([4,2],model,exprs,gr_i);
    }
    TOWS_c.prototype.details = function TOWS_c() {
    }
    TOWS_c.prototype.get = function TOWS_c() {
    }
    TOWS_c.prototype.set = function TOWS_c() {
        x = arg1;
        graphics = arg1.graphics;
        model = arg1.model;
        exprs = graphics.exprs;
        while (true) {
        [ok,nz,varnam,herit,exprs] = scicos_getvalue("Set Xcos buffer block",[["Size of buffer"],["Scilab variable name"],["Inherit (no:0, yes:1)"]],list("vec",1,"str",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if ((nz<=0)) {
message("Size of buffer must be positive");
        ok = false;
}
        r = false;
        ierr = execstr("r = validvar(varnam)","errcatch");
        if (!r||ierr!=0||length(varnam)>19) {
message([["Invalid variable name."],["Please choose another variable name."]]);
        ok = false;
}
execstr("if type("+varnam+") <> 17 | or(fieldnames("+varnam+") <> [\"values\"; \"time\"]) then"+" message([\"Protected variable name.\"; \"Please choose another variable name.\"]);"+" ok = %f;"+" end","errcatch");
        if (ok) {
        [model,graphics,ok] = set_io(model,graphics,list([-1,-2],-1),list(),ones(1-herit,1),[]);
        if (herit==1) {
        model.blocktype = "x";
        } else {
        model.blocktype = "d";
}
        model.ipar = [[nz],[length(varnam)],[transpose(this.ascii[varnam-1])]];
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sinks/TRASH_f.sci" */
function TRASH_f() {
    TRASH_f.prototype.define = function TRASH_f() {
        in1 = -1;
        model = scicos_model();
        model.sim = "trash";
        model.in1 = in1;
        model.evtin = 1;
        model.blocktype = "d";
        model.dep_ut = [false,false];
        exprs = " ";
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    TRASH_f.prototype.details = function TRASH_f() {
    }
    TRASH_f.prototype.get = function TRASH_f() {
    }
    TRASH_f.prototype.set = function TRASH_f() {
        x = arg1;
    }
}
/* autogenerated from "macros/Sinks/WFILE_f.sci" */
function WFILE_f() {
    WFILE_f.prototype.define = function WFILE_f() {
        in1 = 1;
        nin = sum(in1);
        frmt = "(7(e10.3,1x))";
        fname = "foo";
        lunit = 0;
        N = 2;
        model = scicos_model();
        model.sim = "writef";
        model.in1 = in1;
        model.evtin = 1;
        model.dstate = [[-1],[lunit],[zeros((nin+1)*N,1)]];
        model.ipar = [[length(fname)],[length(frmt)],[0],[N],[this._str2code[fname-1]],[this._str2code[frmt-1]]];
        model.blocktype = "d";
        model.dep_ut = [true,false];
        exprs = [[sci2exp(in1)],[fname],[frmt],[string(N)]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    WFILE_f.prototype.details = function WFILE_f() {
    }
    WFILE_f.prototype.get = function WFILE_f() {
    }
    WFILE_f.prototype.set = function WFILE_f() {
warnobsolete("WRITEC_f","6.0.0");
        warnMessage = msprintf(_("Feature %s is obsolete."),"WFILE_f");
        warnAdvise = msprintf(_("Please use %s instead."),"WRITEC_f");
        warnXcosMessage = msprintf("%s %s",warnMessage,warnAdvise);
warnBlockByUID(arg1.model.label,warnXcosMessage);
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        dstate = model.dstate;
        lunit = dstate[2-1];
        fname = exprs[2-1];
        frmt = exprs[3-1];
        while (true) {
        [ok,in1,fname1,frmt1,N,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"WFILE_f")],[" "],[gettext("Write to output file")],[" "],[gettext("Write is done on:")],[gettext("&nbsp; - A binary file if no format given")],[gettext("&nbsp; - A formatted text file if a  format (Fortran type) is given")]],[[gettext("Input Size")],[gettext("Output File Name")],[gettext("Output Format")],[gettext("Buffer Size")]],list("vec",1,"str",1,"str",1,"vec",1),exprs);
        if (!ok) {
break;
}
        in1 = int(in1);
        nin = in1;
        fname1 = pathconvert(stripblanks(fname1),false,true);
        frmt1 = stripblanks(frmt1);
        if (lunit>0&&min(length(frmt),1)!=min(length(frmt1),1)) {
block_parameter_error(gettext("Simulation running !!! You cannot switch<br />between formatted and unformatted when running"),gettext("End current simulation first."));
        ok = false;
        } else if (lunit>0&&fname1!=fname) {
block_parameter_error(gettext("You cannot modify \'Output File Name\' when running."),gettext("End current simulation first."));
        ok = false;
        } else if (fname1=="") {
block_parameter_error(gettext("Wrong value for \'Output File Name\' parameter"),gettext("You must provide a filename."));
        ok = false;
        } else if (fileparts(fname1)!="") {
        [pa,fn,ex] = fileparts(fname1);
        if (!this.isdir[pa-1]) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter."),gettext("Output File Name")),msprintf(gettext("Directory \'%s\' does not exist"),pa));
        ok = false;
}
        } else if (frmt1!=""&&(part(frmt1,1)!="("||part(frmt1,length(frmt1))!=")")) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %s."),gettext("Input Format"),frmt1),gettext("You must enclose the format\'s string between parentheses."));
        ok = false;
        } else if (N<2) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Buffer Size"),N),gettext("Must be greater than 1."));
        ok = false;
        } else if (in1<=0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Input Size"),in1),gettext("Strictly positive integer expected."));
        ok = false;
}
        if (ok) {
        ipar = [[length(fname1)],[length(frmt1)],[0],[N],[this._str2code[fname1-1]],[this._str2code[frmt1-1]]];
        if (prod(size(dstate))!=(nin+1)*N+2) {
        dstate = [[-1],[lunit],[zeros((nin+1)*N,1)]];
}
        model.in1 = nin;
        model.dstate = dstate;
        model.ipar = ipar;
        model.dep_ut = [true,false];
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sinks/WRITEAU_f.sci" */
function WRITEAU_f() {
    WRITEAU_f.prototype.define = function WRITEAU_f() {
        in1 = 1;
        nin = sum(in1);
        frmt = "uc ";
        fname = "/dev/audio";
        swap = 0;
        lunit = 0;
        N = 2;
        model = scicos_model();
        model.sim = list("writeau",2);
        model.in1 = in1;
        model.evtin = 1;
        model.dstate = [[-1],[lunit],[zeros((nin+1)*N,1)]];
        model.ipar = [[length(fname)],[this._str2code[frmt-1]],[N],[swap],[this._str2code[fname-1]]];
        model.blocktype = "d";
        model.dep_ut = [true,false];
        exprs = [string(N),string(swap)];
        gr_i = [];
        x = standard_define([4,2],model,exprs,gr_i);
    }
    WRITEAU_f.prototype.details = function WRITEAU_f() {
    }
    WRITEAU_f.prototype.get = function WRITEAU_f() {
    }
    WRITEAU_f.prototype.set = function WRITEAU_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        ipar = model.ipar;
        dstate = model.dstate;
        lunit = dstate[2-1];
        while (true) {
        [ok,N,swap,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"WRITEAU_f")],[" "],[gettext("Write \'.au\' sound file on audio device")]],[[gettext("Buffer Size")],[gettext("Swap Mode (0:No, 1:Yes)")]],list("vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        nin = 1;
        fname1 = "/dev/audio";
        frmt1 = "uc ";
        if (this.alreadyran&&(N!=ipar[5-1])) {
block_parameter_error(msprintf(gettext("You cannot modify \'%s\' when running."),gettext("Buffer Size")),gettext("End current simulation first"));
        ok = false;
        } else if (N<1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Buffer Size"),N),gettext("Strictly positive integer expected."));
        ok = false;
}
        if (swap!=0&&swap!=1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Swap Mode"),swap),msprintf(gettext("Must be in the interval %s."),"[0, 1]"));
        ok = false;
}
        if (ok) {
        ipar = [[length(fname1)],[this._str2code[frmt1-1]],[N],[swap],[this._str2code[fname1-1]]];
        if (prod(size(dstate))!=(nin+1)*N+2) {
        dstate = [[-1],[lunit],[zeros((nin+1)*N,1)]];
}
        model.in1 = 1;
        model.dstate = dstate;
        model.ipar = ipar;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sinks/WRITEC_f.sci" */
function WRITEC_f() {
    WRITEC_f.prototype.define = function WRITEC_f() {
        in1 = 1;
        nin = sum(in1);
        frmt = "c  ";
        fname = "foo";
        swap = 0;
        lunit = 0;
        N = 2;
        model = scicos_model();
        model.sim = list("writec",2);
        model.in1 = in1;
        model.evtin = 1;
        model.dstate = [[-1],[lunit],[zeros((nin+1)*N,1)]];
        model.ipar = [[length(fname)],[this._str2code[frmt-1]],[N],[swap],[this._str2code[fname-1]]];
        model.blocktype = "d";
        model.dep_ut = [true,false];
        exprs = [[sci2exp(in1)],[fname],[frmt],[string(N),string(swap)]];
        gr_i = [];
        x = standard_define([4,2],model,exprs,gr_i);
    }
    WRITEC_f.prototype.details = function WRITEC_f() {
    }
    WRITEC_f.prototype.get = function WRITEC_f() {
    }
    WRITEC_f.prototype.set = function WRITEC_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        ipar = model.ipar;
        dstate = model.dstate;
        lunit = dstate[2-1];
        fname = exprs[2-1];
        frmt = exprs[3-1];
        while (true) {
        [ok,in1,fname1,frmt1,N,swap,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"WRITEC_f")],[" "],[gettext("Write to C binary file")]],[[gettext("Input Size")],[gettext("Output File Name")],[gettext("Output Format")],[gettext("Buffer Size")],[gettext("Swap Mode (0:No, 1:Yes)")]],list("vec",1,"str",1,"str",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        in1 = int(in1);
        nin = in1;
        fname1 = pathconvert(stripblanks(fname1),false,true);
        frmt1 = stripblanks(frmt1);
        fmts = ["s","l","d","f","c","us","ul","uc","ull","uls","ubl","ubs","dl","fl","ll","sl","db","fb","lb","sb"];
        if (and(frmt1!=fmts)) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %s."),gettext("Input Format"),frmt1),gettext("Valid formats are: "+strcat(fmts,", ")));
        ok = false;
        } else if (this.alreadyran&&fname1!=fname) {
block_parameter_error(msprintf(gettext("You cannot modify \'%s\' when running"),gettext("Input Format")),gettext("End current simulation first."));
        ok = false;
        } else if (this.alreadyran&&N!=ipar[5-1]) {
block_parameter_error(msprintf(gettext("You cannot modify \'Buffer Size\' when running."),gettext("Buffer Size")),gettext("End current simulation first"));
        ok = false;
        } else if (fname1=="") {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter."),gettext("Output File Name")),gettext("You must provide a filename."));
        } else if (fileparts(fname1)!="") {
        [pa,fn,ex] = fileparts(fname1);
        if (!this.isdir[pa-1]) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter."),gettext("Output File Name")),msprintf(gettext("Directory \'%s\' does not exist"),pa));
        ok = false;
}
        } else if (N<1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Buffer Size"),N),gettext("Strictly positive integer expected."));
        ok = false;
        } else if (in1<=0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Input Size"),in1),gettext("Strictly positive integer expected."));
        ok = false;
        } else if (swap!=0&&swap!=1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Swap Mode"),swap),msprintf(gettext("Must be in the interval %s."),"[0, 1]"));
        ok = false;
}
        frmt1 = part(frmt1,1,3);
        if (ok) {
        ipar = [[length(fname1)],[this._str2code[frmt1-1]],[N],[swap],[this._str2code[fname1-1]]];
        if (prod(size(dstate))!=(nin+1)*N+2) {
        dstate = [[-1],[lunit],[zeros((nin+1)*N,1)]];
}
        model.in1 = nin;
        model.dstate = dstate;
        model.ipar = ipar;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sources/CLKINV_f.sci" */
function CLKINV_f() {
    CLKINV_f.prototype.define = function CLKINV_f() {
        prt = 1;
        model = scicos_model();
        model.sim = "input";
        model.evtout = 1;
        model.ipar = prt;
        model.blocktype = "d";
        model.firing = -1;
        model.dep_ut = [false,false];
        exprs = string(prt);
        gr_i = [];
        x = standard_define([1,1],model,exprs,gr_i);
    }
    CLKINV_f.prototype.details = function CLKINV_f() {
    }
    CLKINV_f.prototype.get = function CLKINV_f() {
    }
    CLKINV_f.prototype.set = function CLKINV_f() {
        x = arg1;
        graphics = arg1.graphics;
        model = arg1.model;
        exprs = graphics.exprs;
        exprs = exprs[1-1];
        while (true) {
        [ok,prt,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"CLKINV_f")],[" "],[gettext("Event input port")],[" "]],"Port Number",list("vec",1),exprs);
        prt = int(prt);
        if (!ok) {
break;
}
        if (prt<=0) {
block_parameter_error(msprintf(gettext("Wrong values for \'Port Number\' parameter: %d."),prt),gettext("Strictly positive integer expected."));
        } else {
        model.ipar = prt;
        model.evtout = 1;
        model.firing = -1;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sources/CLKIN_f.sci" */
function CLKIN_f() {
    CLKIN_f.prototype.define = function CLKIN_f() {
        prt = 1;
        model = scicos_model();
        model.sim = "input";
        model.evtout = 1;
        model.ipar = prt;
        model.blocktype = "d";
        model.firing = -1;
        model.dep_ut = [false,false];
        exprs = string(prt);
        x = standard_define([1,1],model,exprs," ");
    }
    CLKIN_f.prototype.details = function CLKIN_f() {
    }
    CLKIN_f.prototype.get = function CLKIN_f() {
    }
    CLKIN_f.prototype.set = function CLKIN_f() {
        x = arg1;
        graphics = arg1.graphics;
        model = arg1.model;
        exprs = graphics.exprs;
        exprs = exprs[1-1];
        while (true) {
        [ok,prt,exprs] = scicos_getvalue("Set Event Input block parameters","Port number",list("vec",1),exprs);
        prt = int(prt);
        if (!ok) {
break;
}
        if (prt<=0) {
message("Port number must be a positive integer");
        } else {
        model.ipar = prt;
        model.evtout = 1;
        model.firing = -1;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sources/CLOCK_c.sci" */
function CLOCK_c() {
    CLOCK_c.prototype.define = function CLOCK_c() {
        evtdly = this.EVTDLY_c["define"-1];
        evtdly.graphics.orig = [320,232];
        evtdly.graphics.sz = [40,40];
        evtdly.graphics.flip = true;
        evtdly.graphics.exprs = [["0.1"],["0.1"]];
        evtdly.graphics.pein = 6;
        evtdly.graphics.peout = 3;
        evtdly.model.rpar = [[0.1],[0.1]];
        evtdly.model.firing = 0.1;
        output_port = CLKOUT_f("define");
        output_port.graphics.orig = [399,162];
        output_port.graphics.sz = [20,20];
        output_port.graphics.flip = true;
        output_port.graphics.exprs = "1";
        output_port.graphics.pein = 5;
        output_port.model.ipar = 1;
        split = CLKSPLIT_f("define");
        split.graphics.orig = [[380.71066],[172]];
        split.graphics.pein = 3;
        split.graphics.peout = [[5],[6]];
        gr_i = [];
        diagram = scicos_diagram();
        diagram.objs[1-1] = output_port;
        diagram.objs[2-1] = evtdly;
        diagram.objs[3-1] = scicos_link(xx=[[340],[340],[380.71]],yy=[[226.29],[172],[172]],ct=[5,-1],from=[2,1],to=[4,1]);
        diagram.objs[4-1] = split;
        diagram.objs[5-1] = scicos_link(xx=[[380.71],[399]],yy=[[172],[172]],ct=[5,-1],from=[4,1],to=[1,1]);
        diagram.objs[6-1] = scicos_link(xx=[[380.71],[380.71],[340],[340]],yy=[[172],[302],[302],[277.71]],ct=[5,-1],from=[4,2],to=[2,1]);
        x = scicos_block();
        x.gui = "CLOCK_c";
        x.graphics.sz = [2,2];
        x.graphics.gr_i = gr_i;
        x.graphics.peout = 0;
        x.model.sim = "csuper";
        x.model.evtout = 1;
        x.model.blocktype = "h";
        x.model.firing = false;
        x.model.dep_ut = [false,false];
        x.model.rpar = diagram;
    }
    CLOCK_c.prototype.details = function CLOCK_c() {
    }
    CLOCK_c.prototype.get = function CLOCK_c() {
    }
    CLOCK_c.prototype.set = function CLOCK_c() {
for (i=1;i<=length(arg1.model.rpar.objs);i+=1) {
        o = arg1.model.rpar.objs[i-1];
        if (typeof(o)=="Block"&&o.gui=="EVTDLY_c") {
        path = i;
break;
}
}
        newpar = list();
        xx = arg1.model.rpar.objs[path-1];
        exprs = xx.graphics.exprs;
        model = xx.model;
        t0_old = model.firing;
        dt_old = model.rpar[1-1];
        model_n = model;
        while (true) {
        [ok,dt,t0,exprs0] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"CLOCK_c")],[" "],[gettext("Event clock generator")],[" "],[gettext("&nbsp; Do not start if \'Initialisation Time\' is negative")],[" "]],[[gettext("Period")],[gettext("Initialisation Time")]],list("vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (dt<=0) {
block_parameter_error(msprintf(gettext("Wrong values for \'%s\' parameter: %5.1e."),gettext("Period"),dt),gettext("Strictly positive number expected."));
        ok = false;
}
        if (ok) {
        xx.graphics.exprs = exprs0;
        model.rpar = [[dt],[t0]];
        model.firing = t0;
        xx.model = model;
        arg1.model.rpar.objs[path-1] = xx;
break;
}
}
        if (!and([t0_old,dt_old]==[t0,dt])) {
        newpar[size(newpar)+1-1] = path;
}
        if (t0_old!=t0) {
        needcompile = 2;
        } else {
        needcompile = 0;
}
        x = arg1;
        y = needcompile;
        typ = newpar;
    }
}
/* autogenerated from "macros/Sources/CLOCK_f.sci" */
function CLOCK_f() {
    CLOCK_f.prototype.define = function CLOCK_f() {
        evtdly = EVTDLY_f("define");
        evtdly.graphics.orig = [320,232];
        evtdly.graphics.sz = [40,40];
        evtdly.graphics.flip = true;
        evtdly.graphics.exprs = [["0.1"],["0.1"]];
        evtdly.graphics.pein = 6;
        evtdly.graphics.peout = 3;
        evtdly.model.rpar = 0.1;
        evtdly.model.firing = 0.1;
        output_port = CLKOUT_f("define");
        output_port.graphics.orig = [399,162];
        output_port.graphics.sz = [20,20];
        output_port.graphics.flip = true;
        output_port.graphics.exprs = "1";
        output_port.graphics.pein = 5;
        output_port.model.ipar = 1;
        split = CLKSPLIT_f("define");
        split.graphics.orig = [[380.71066],[172]];
        split.graphics.pein = 3;
        split.graphics.peout = [[5],[6]];
        gr_i = [];
        diagram = scicos_diagram();
        diagram.objs[1-1] = output_port;
        diagram.objs[2-1] = evtdly;
        diagram.objs[3-1] = scicos_link(xx=[[340],[340],[380.71]],yy=[[226.29],[172],[172]],ct=[5,-1],from=[2,1],to=[4,1]);
        diagram.objs[4-1] = split;
        diagram.objs[5-1] = scicos_link(xx=[[380.71],[399]],yy=[[172],[172]],ct=[5,-1],from=[4,1],to=[1,1]);
        diagram.objs[6-1] = scicos_link(xx=[[380.71],[380.71],[340],[340]],yy=[[172],[302],[302],[277.71]],ct=[5,-1],from=[4,2],to=[2,1]);
        x = scicos_block();
        x.gui = "CLOCK_f";
        x.graphics.sz = [2,2];
        x.graphics.gr_i = gr_i;
        x.graphics.peout = 0;
        x.model.sim = "csuper";
        x.model.evtout = 1;
        x.model.blocktype = "h";
        x.model.firing = false;
        x.model.dep_ut = [false,false];
        x.model.rpar = diagram;
    }
    CLOCK_f.prototype.details = function CLOCK_f() {
    }
    CLOCK_f.prototype.get = function CLOCK_f() {
    }
    CLOCK_f.prototype.set = function CLOCK_f() {
for (i=1;i<=length(arg1.model.rpar.objs);i+=1) {
        o = arg1.model.rpar.objs[i-1];
        if (typeof(o)=="Block"&&o.gui=="EVTDLY_f") {
        path = i;
break;
}
}
        newpar = list();
        xx = arg1.model.rpar.objs[path-1];
        exprs = xx.graphics.exprs;
        model = xx.model;
        t0_old = model.firing;
        dt_old = model.rpar;
        model_n = model;
        while (true) {
        [ok,dt,t0,exprs0] = scicos_getvalue("Set Clock  block parameters",[["Period"],["Init time"]],list("vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (dt<=0) {
message("period must be positive");
        ok = false;
}
        if (ok) {
        xx.graphics.exprs = exprs0;
        model.rpar = dt;
        model.firing = t0;
        xx.model = model;
        arg1.model.rpar.objs[path-1] = xx;
break;
}
}
        if (!and([t0_old,dt_old]==[t0,dt])||!and(exprs0==exprs)) {
        newpar[size(newpar)+1-1] = path;
}
        if (t0_old!=t0) {
        needcompile = 2;
        } else {
        needcompile = 0;
}
        x = arg1;
        y = needcompile;
        typ = newpar;
    }
}
/* autogenerated from "macros/Sources/CONST.sci" */
function CONST() {
    CONST.prototype.define = function CONST() {
        C = 1;
        model = scicos_model();
        model.sim = list("cstblk4",4);
        model.in1 = [];
        model.out = 1;
        model.rpar = C;
        model.blocktype = "d";
        model.dep_ut = [false,false];
        exprs = strcat(sci2exp(C));
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    CONST.prototype.details = function CONST() {
    }
    CONST.prototype.get = function CONST() {
    }
    CONST.prototype.set = function CONST() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,C,exprs] = scicos_getvalue(["Set Contant Block"],"Constant",list("vec",-1),exprs);
        if (!ok) {
break;
}
        sz = size(C);
        nout = size(C,"*");
        if (nout==0) {
message("C must have at least one element");
        } else if (and(sz>1)) {
message("C matrix is not supported, use CONST_m instead");
        } else {
        model.rpar = C.slice();
        model.out = nout;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sources/CONST_f.sci" */
function CONST_f() {
    CONST_f.prototype.define = function CONST_f() {
        C = 1;
        model = scicos_model();
        model.sim = list("cstblk",1);
        model.in1 = [];
        model.out = 1;
        model.rpar = C;
        model.blocktype = "d";
        model.dep_ut = [false,false];
        exprs = strcat(sci2exp(C));
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    CONST_f.prototype.details = function CONST_f() {
    }
    CONST_f.prototype.get = function CONST_f() {
    }
    CONST_f.prototype.set = function CONST_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,C,exprs] = scicos_getvalue(["Set Contant Block"],"Constant",list("vec",-1),exprs);
        if (!ok) {
break;
}
        nout = size(C,"*");
        if (nout==0) {
message("C must have at least one element");
        } else {
        model.rpar = C.slice();
        model.out = nout;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sources/CONST_m.sci" */
function CONST_m() {
    CONST_m.prototype.define = function CONST_m() {
        C = [1];
        model = scicos_model();
        model.sim = list("cstblk4",4);
        model.in1 = [];
        model.out = size(C,1);
        model.in2 = [];
        model.out2 = size(C,2);
        model.rpar = C;
        model.opar = list();
        model.blocktype = "d";
        model.dep_ut = [false,false];
        exprs = sci2exp(C);
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    CONST_m.prototype.details = function CONST_m() {
    }
    CONST_m.prototype.get = function CONST_m() {
    }
    CONST_m.prototype.set = function CONST_m() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,C,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"CONST_m")],[" "],[gettext("Constant value generator")],[" "]],gettext("Constant Value"),list("vec",-1),exprs);
        if (!ok) {
break;
}
        nout = size(C);
        if (find(nout==0)!=[]) {
block_parameter_error(msprintf(gettext("Wrong size for \'%s\' parameter"),gettext("Constant Value")),gettext("Constant value must have at least one element."));
        } else {
        model.sim = list("cstblk4_m",4);
        model.opar = list(C);
        if ((this.type[C-1]==1)) {
        if (isreal(C)) {
        ot = 1;
        } else {
        ot = 2;
}
        } else if ((typeof(C)=="int32")) {
        ot = 3;
        } else if ((typeof(C)=="int16")) {
        ot = 4;
        } else if ((typeof(C)=="int8")) {
        ot = 5;
        } else if ((typeof(C)=="uint32")) {
        ot = 6;
        } else if ((typeof(C)=="uint16")) {
        ot = 7;
        } else if ((typeof(C)=="uint8")) {
        ot = 8;
        } else {
block_parameter_error(msprintf(gettext("Wrong type for \'%s\' parameter"),gettext("Constant Value")),gettext("Value type must be a numeric type (double, complex, int, int8, ...)."));
        ok = false;
}
        if (ok) {
        model.rpar = [];
        [model,graphics,ok] = set_io(model,graphics,list(),list(nout,ot),[],[]);
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/Sources/CURV_f.sci" */
function CURV_f() {
    CURV_f.prototype.define = function CURV_f() {
        xx = [[0],[1],[2]];
        yy = [[-5],[5],[0]];
        rect = [0,-5,2,5];
        axisdata = [[2],[10],[2],[10]];
        ipar = [[size(xx,1)],[axisdata.slice()]];
        rpar = [[xx],[yy],[rect.slice()]];
        model = scicos_model();
        model.sim = "intplt";
        model.in1 = [];
        model.out = 1;
        model.rpar = [[xx],[yy],[rect.slice()]];
        model.ipar = [[size(xx,1)],[axisdata.slice()]];
        model.blocktype = "c";
        model.dep_ut = [false,true];
        gr_i = [];
        x = standard_define([2,2],model,[],gr_i);
    }
    CURV_f.prototype.details = function CURV_f() {
    }
    CURV_f.prototype.get = function CURV_f() {
    }
    CURV_f.prototype.set = function CURV_f() {
        x = arg1;
        model = arg1.model;
        graphics = arg1.graphics;
        rpar = model.rpar;
        ipar = model.ipar;
        n = ipar[1-1];
        xx = rpar.slice(1-1,n);
        yy = rpar.slice(n+1-1,2*n);
        gc = list(rpar.slice(2*n+1-1,2*n+4),ipar.slice(2-1,5));
        while (true) {
[ln,fun]=where()
        if (!or(fun=="do_eval")) {
        [xx,yy,ok,gc] = edit_curv(xx,yy,"axy",[" "," "," "],gc);
        } else {
        ok = true;
}
        if (!ok) {
break;
}
        n = size(xx,"*");
        if (or(xx.slice(2-1,n)-xx.slice(1-1,n-1)<0)) {
message("You have not defined a function");
        ok = false;
}
        if (ok) {
        model.sim = "intplt";
        model.firing = [];
        rect = gc[1-1];
        model.rpar = [[xx.slice()],[yy.slice()],[rect.slice()]];
        axisdata = gc[2-1];
        model.ipar = [[size(xx,"*")],[axisdata.slice()]];
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sources/Counter.sci" */
function Counter() {
    Counter.prototype.define = function Counter() {
        minim = 0;
        maxim = 2;
        rule = 1;
        model = scicos_model();
        model.sim = list("counter",4);
        model.evtin = 1;
        model.out = 1;
        model.out2 = 1;
        model.dstate = 0;
        model.ipar = [[rule],[maxim],[minim]];
        model.blocktype = "c";
        model.dep_ut = [false,false];
        exprs = [[string(minim)],[string(maxim)],[string(rule)]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    Counter.prototype.details = function Counter() {
    }
    Counter.prototype.get = function Counter() {
    }
    Counter.prototype.set = function Counter() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,minim,maxim,rule,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"Counter")],[" "],[gettext("Integer counter generator")],[" "]],[[gettext("Minimum")],[gettext("Maximum")],[gettext("Rule (1:Increment, 2:Decrement)")]],list("vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        maxim = int(maxim);
        minim = int(minim);
        if (maxim<minim) {
block_parameter_error(msprintf(gettext("Wrong values for \'Maximum\' and \'Minimum\' parameters: %d &lt; %d"),minim,maxim),msprintf(gettext("\'Minimum\' must be less than \'Maximum\'.")));
        } else if ((rule!=1&&rule!=2)) {
block_parameter_error(msprintf(gettext("Wrong value for \'Rule\' parameter: %d"),rule),msprintf(gettext("Must be in the interval %s."),"[1,2]"));
        } else {
        graphics.exprs = exprs;
        model.dstate = 0;
        model.ipar = [[rule],[maxim],[minim]];
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sources/FROMWSB.sci" */
function FROMWSB() {
    FROMWSB.prototype.define = function FROMWSB() {
        scs_m_1 = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[-159.096,811.104,-121.216,617.984,1323,1008,331,284,630,480,1426,231,1.4],Title="FROMWSB",tol=[0.0001,0.000001,1.000e-10,100001,0,0],tf=100000,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m_1.objs[1-1] = scicos_block(gui="FROMWS_c",graphics=scicos_graphics(orig=[260.37067,261.584],sz=[70,40],flip=true,theta=0,exprs=[["V"],["1"],["1"],["0"]],pin=[],pout=4,pein=2,peout=2,gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim=list("fromws_c",4),in1=[],in2=[],intyp=1,out=-1,out2=-2,outtyp=-1,evtin=1,evtout=1,state=[],dstate=[],odstate=list(),rpar=[],ipar=[[1],[-31],[1],[1],[0]],opar=list(),blocktype="d",firing=0,dep_ut=[false,true],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[2-1] = scicos_link(xx=[[295.37067],[295.37067],[233.23733],[233.23733],[295.37067],[295.37067]],yy=[[255.86971],[223.45067],[223.45067],[337.85067],[337.85067],[307.29829]],id="drawlink",thick=[0,0],ct=[5,-1],from=[1,1,0],to=[1,1,1]);
        scs_m_1.objs[3-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[358.9421,271.584],sz=[20,20],flip=true,theta=0,exprs="1",pin=4,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=-2,intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[4-1] = scicos_link(xx=[[338.9421],[358.9421]],yy=[[281.584],[281.584]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[3,1,1]);
        model = scicos_model(sim="csuper",in1=[],in2=[],intyp=1,out=-1,out2=-2,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=scs_m_1,ipar=[],opar=list(),blocktype="h",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list());
        gr_i = [];
        x = standard_define([5,2],model,[],gr_i);
    }
    FROMWSB.prototype.details = function FROMWSB() {
    }
    FROMWSB.prototype.get = function FROMWSB() {
    }
    FROMWSB.prototype.set = function FROMWSB() {
for (i=1;i<=length(arg1.model.rpar.objs);i+=1) {
        o = arg1.model.rpar.objs[i-1];
        if (typeof(o)=="Block"&&o.gui=="FROMWS_c") {
        ppath = list(i);
break;
}
}
        newpar = list();
        y = 0;
        for (path in ppath) {
        np = size(path,"*");
        spath = list();
for (k=1;k<=np;k+=1) {
        spath[$+1-1] = "model";
        spath[$+1-1] = "rpar";
        spath[$+1-1] = "objs";
        spath[$+1-1] = path[k-1];
}
        xx = arg1[spath-1];
execstr("xxn="+xx.gui+"(\'set\',xx)");
        if (!this.isequalbitwise[this.xxn-1][xx-1]) {
        model = xx.model;
        model_n = this.xxn.model;
        if (!is_modelica_block(xx)) {
        modified = or(model.sim!=model_n.sim)||!isequal(model.state,model_n.state)||!isequal(model.dstate,model_n.dstate)||!isequal(model.odstate,model_n.odstate)||!isequal(model.rpar,model_n.rpar)||!isequal(model.ipar,model_n.ipar)||!isequal(model.opar,model_n.opar)||!isequal(model.label,model_n.label);
        if (or(model.in1!=model_n.in1)||or(model.out!=model_n.out)||or(model.in2!=model_n.in2)||or(model.out2!=model_n.out2)||or(model.outtyp!=model_n.outtyp)||or(model.intyp!=model_n.intyp)) {
        needcompile = 1;
}
        if (or(model.firing!=model_n.firing)) {
        needcompile = 2;
}
        if ((size(model.in1,"*")!=size(model_n.in1,"*"))||(size(model.out,"*")!=size(model_n.out,"*"))) {
        needcompile = 4;
}
        if (model.sim=="input"||model.sim=="output") {
        if (model.ipar!=model_n.ipar) {
        needcompile = 4;
}
}
        if (or(model.blocktype!=model_n.blocktype)||or(model.dep_ut!=model_n.dep_ut)) {
        needcompile = 4;
}
        if ((model.nzcross!=model_n.nzcross)||(model.nmode!=model_n.nmode)) {
        needcompile = 4;
}
        if (prod(size(model_n.sim))>1) {
        if (model_n.sim[2-1]>1000) {
        if (model.sim[1-1]!=model_n.sim[1-1]) {
        needcompile = 4;
}
}
}
        } else {
        modified = or(model_n!=model);
        eq = model.equations;
        eqn = model_n.equations;
        if (or(eq.model!=eqn.model)||or(eq.inputs!=eqn.inputs)||or(eq.outputs!=eqn.outputs)) {
        needcompile = 4;
}
}
        arg1[spath-1] = this.xxn;
        newpar[size(newpar)+1-1] = path;
        y = max(y,needcompile);
}
}
        x = arg1;
        typ = newpar;
    }
}
/* autogenerated from "macros/Sources/FROMWS_c.sci" */
function FROMWS_c() {
    FROMWS_c.prototype.define = function FROMWS_c() {
        varnam = "V";
        Method = 1;
        ZC = 1;
        OutEnd = 0;
        model = scicos_model();
        model.sim = list("fromws_c",4);
        model.out = -1;
        model.out2 = -2;
        model.outtyp = -1;
        model.ipar = [[length(varnam)],[this._str2code[varnam-1]],[Method],[ZC],[OutEnd]];
        model.evtin = [1];
        model.evtout = [1];
        model.firing = [0];
        model.blocktype = "d";
        model.dep_ut = [false,true];
        gr_i = [];
        exprs = [[string(varnam)],[string(Method)],[string(ZC)],[string(OutEnd)]];
        x = standard_define([3.5,2],model,exprs,gr_i);
    }
    FROMWS_c.prototype.details = function FROMWS_c() {
    }
    FROMWS_c.prototype.get = function FROMWS_c() {
    }
    FROMWS_c.prototype.set = function FROMWS_c() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,varnam,Method,ZC,OutEnd,exprs] = scicos_getvalue("Set From_Workspace block parameters",[["Variable name"],["Interpolation Method"],["Enable zero crossing(0:No, 1:Yes)?"],["Output at end(0:Zero, 1:Hold, 2:Repeat)"]],list("str",1,"vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (!(Method==0||Method==1||Method==2||Method==3)) {
message("Interpolation method should be chosen in [0,1,2,3]");
        ok = false;
}
        if (!(ZC==0||ZC==1)) {
message("Zero crossing should be either 0 or 1");
        ok = false;
}
        if (!(OutEnd==0||OutEnd==1||OutEnd==2)) {
message("Output at end option should be either 0 or 1");
        ok = false;
}
        r = false;
        ierr = execstr("r=validvar(varnam)","errcatch");
        if (!r) {
message([["Invalid variable name."],["Please choose another variable name."]]);
        ok = false;
}
        if (ok) {
        model.ipar = [[length(varnam)],[this._str2code[varnam-1]],[Method],[ZC],[OutEnd]];
        [model,graphics,ok] = set_io(model,graphics,list(),list([-1,-2],-1),1,1);
        if (ok) {
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/Sources/GENSIN_f.sci" */
function GENSIN_f() {
    GENSIN_f.prototype.define = function GENSIN_f() {
        rpar = [[1],[1],[0]];
        model = scicos_model();
        model.sim = "gensin";
        model.in1 = [];
        model.out = 1;
        model.out2 = 1;
        model.outtyp = 1;
        model.rpar = [[1],[1],[0]];
        model.blocktype = "c";
        model.dep_ut = [false,true];
        exprs = [[string(rpar[1-1])],[string(rpar[2-1])],[string(rpar[3-1])]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    GENSIN_f.prototype.details = function GENSIN_f() {
    }
    GENSIN_f.prototype.get = function GENSIN_f() {
    }
    GENSIN_f.prototype.set = function GENSIN_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,M,F,P,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"GENSIN_f")],[" "],[gettext("Sine wave generator")],[" "]],[[gettext("Magnitude")],[gettext("Frequency (rad/s)")],[gettext("Phase (rad)")]],list("vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (F<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'Frequency\' parameter: %e."),F),gettext("Strictly positive integer expected."));
        ok = false;
}
        if (ok) {
        [model,graphics,ok] = check_io(model,graphics,[],1,[],[]);
        model.rpar = [[M],[F],[P]];
        model.out2 = 1;
        model.outtyp = 1;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sources/GENSQR_f.sci" */
function GENSQR_f() {
    GENSQR_f.prototype.define = function GENSQR_f() {
        Amplitude = 1;
        model = scicos_model();
        model.sim = "gensqr";
        model.out = 1;
        model.out2 = 1;
        model.outtyp = 1;
        model.evtin = 1;
        model.dstate = Amplitude;
        model.blocktype = "d";
        model.dep_ut = [false,false];
        exprs = string(Amplitude);
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    GENSQR_f.prototype.details = function GENSQR_f() {
    }
    GENSQR_f.prototype.get = function GENSQR_f() {
    }
    GENSQR_f.prototype.set = function GENSQR_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        if (size(exprs,"*")==2) {
        exprs = exprs[2-1];
}
        while (true) {
        [ok,Amplitude,exprs] = scicos_getvalue(["Set Square generator block parameters"],["Amplitude"],list("vec",1),exprs);
        if (!ok) {
break;
}
        graphics.exprs = exprs;
        model.dstate = Amplitude;
        model.out2 = 1;
        model.outtyp = 1;
        x.graphics = graphics;
        x.model = model;
break;
}
    }
}
/* autogenerated from "macros/Sources/GEN_SQR.sci" */
function GEN_SQR() {
    GEN_SQR.prototype.define = function GEN_SQR() {
        scs_m_1 = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[-176.97473,421.18646,173.61587,524.41503,827,480,0,15,827,480,755,614,1.4],Title="SuperBlock",tol=[0.0001,0.000001,1.000e-10,100001,0,0],tf=100000,context=[["if typeof(Amin)<>typeof(Amax) then error(\'Minimum value and Maximum value must have the same type\');end"],["if and(rule<>[1;2]) then error(\'Initial Value must be 1 (for Min) or 2 (for Max)\');end"],["if Amin>Amax then error(\'Maximum value must be greater than the Minimum Value\');end"],["P=%pi/F"],[""]],void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m_1.objs[1-1] = scicos_block(gui="Counter",graphics=scicos_graphics(orig=[18.229901,339.5057],sz=[60,40],flip=true,theta=0,exprs=[["1"],["2"],["rule"]],pin=[],pout=8,pein=16,peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim=list("counter",4),in1=[],in2=[],intyp=1,out=1,out2=1,outtyp=1,evtin=1,evtout=[],state=[],dstate=0,odstate=list(),rpar=[],ipar=[[1],[2],[1]],opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[2-1] = scicos_block(gui="CONST_m",graphics=scicos_graphics(orig=[38.096074,293.82198],sz=[40,40],flip=true,theta=0,exprs="Amin",pin=[],pout=5,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim=list("cstblk4_m",4),in1=[],in2=[],intyp=1,out=1,out2=1,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(-1),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[3-1] = scicos_block(gui="CONST_m",graphics=scicos_graphics(orig=[37.378886,245.02389],sz=[40,40],flip=true,theta=0,exprs="Amax",pin=[],pout=6,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim=list("cstblk4_m",4),in1=[],in2=[],intyp=1,out=1,out2=1,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(1),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[4-1] = scicos_block(gui="SELECT_m",graphics=scicos_graphics(orig=[116.26954,269.42294],sz=[40,40],flip=true,theta=0,exprs=[["-1"],["2"],["1"]],pin=[[5],[6]],pout=14,pein=[[9],[10]],peout=[],gr_i=[],id="",in_implicit=[["E"],["E"]],out_implicit="E"),model=scicos_model(sim=list("selector_m",4),in1=[[-1],[-1]],in2=[[-2],[-2]],intyp=[[-1],[-1]],out=-1,out2=-2,outtyp=-1,evtin=[[1],[1]],evtout=[],state=[],dstate=1,odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[5-1] = scicos_link(xx=[[86.667502],[107.69811],[107.69811]],yy=[[313.82198],[313.82198],[296.0896]],id="drawlink",thick=[0,0],ct=[1,1],from=[2,1,0],to=[4,1,1]);
        scs_m_1.objs[6-1] = scicos_link(xx=[[85.950315],[107.69811],[107.69811]],yy=[[265.02389],[265.02389],[282.75627]],id="drawlink",thick=[0,0],ct=[1,1],from=[3,1,0],to=[4,2,1]);
        scs_m_1.objs[7-1] = scicos_block(gui="ESELECT_f",graphics=scicos_graphics(orig=[106.9461,339.7496],sz=[60,40],flip=true,theta=0,exprs=[["2"],["0"],["0"]],pin=8,pout=[],pein=[],peout=[[9],[10]],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim=list("eselect",-2),in1=1,in2=1,intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[[1],[1]],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="l",firing=[[-1],[-1]],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[8-1] = scicos_link(xx=[[86.80133],[98.374671]],yy=[[359.5057],[359.7496]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[7,1,1]);
        scs_m_1.objs[9-1] = scicos_link(xx=[[126.9461],[129.60287]],yy=[[334.03532],[315.13722]],id="drawlink",thick=[0,0],ct=[5,-1],from=[7,1,0],to=[4,1,1]);
        scs_m_1.objs[10-1] = scicos_link(xx=[[146.9461],[142.93621]],yy=[[334.03532],[315.13722]],id="drawlink",thick=[0,0],ct=[5,-1],from=[7,2,0],to=[4,2,1]);
        scs_m_1.objs[11-1] = mlist("Deleted");
        scs_m_1.objs[12-1] = mlist("Deleted");
        scs_m_1.objs[13-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[184.40238,278.75198],sz=[20,20],flip=true,theta=0,exprs="1",pin=14,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=-2,intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[14-1] = scicos_link(xx=[[164.84097],[184.40238]],yy=[[289.42294],[288.75198]],id="drawlink",thick=[0,0],ct=[1,1],from=[4,1,0],to=[13,1,1]);
        scs_m_1.objs[15-1] = scicos_block(gui="SampleCLK",graphics=scicos_graphics(orig=[18.313686,403.57431],sz=[60,40],flip=true,theta=0,exprs=[["F/2"],["0"]],pin=[],pout=[],pein=[],peout=16,gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="sampleclk",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=1,state=[],dstate=[],odstate=list(),rpar=[[1/2],[0]],ipar=[],opar=list(),blocktype="d",firing=-1,dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[16-1] = scicos_link(xx=[[48.313686],[48.229901]],yy=[[403.57431],[385.21998]],id="drawlink",thick=[0,0],ct=[5,-1],from=[15,1,0],to=[1,1,1]);
        model = scicos_model();
        model.sim = "csuper";
        model.in1 = [];
        model.in2 = [];
        model.intyp = 1;
        model.out = -1;
        model.out2 = -2;
        model.outtyp = -1;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.odstate = list();
        model.rpar = scs_m_1;
        model.ipar = 1;
        model.opar = list();
        model.blocktype = "h";
        model.firing = [];
        model.dep_ut = [false,false];
        model.label = "";
        model.nzcross = 0;
        model.nmode = 0;
        model.equations = list();
        Amin = -1;
        Amax = 1;
        rule = 1;
        F = 1;
        exprs = [sci2exp(Amin),sci2exp(Amax),sci2exp(rule),sci2exp(F)];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    GEN_SQR.prototype.details = function GEN_SQR() {
    }
    GEN_SQR.prototype.get = function GEN_SQR() {
    }
    GEN_SQR.prototype.set = function GEN_SQR() {
        y = this.needcompile;
        arg1.model.ipar = 1;
        typ = list();
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        Btitre = "Set GEN_SQR parameters";
        Exprs0 = [["Amin"],["Amax"],["rule"],["F"]];
        Bitems = [["Minimum Value"],["Maximum Value"],["Initial Value( 1= Minimum Value 2= Maximum Value)"],["Period (sec)"]];
        Ss = list("mat",[-1,-1],"mat",[-1,-1],"pol",-1,"pol",-1);
        scicos_context = struct();
        x = arg1;
        ok = false;
        while (!ok) {
        [ok,scicos_context.Amin,scicos_context.Amax,scicos_context.rule,scicos_context.F,exprs] = scicos_getvalue(Btitre,Bitems,Ss,exprs);
        if (!ok) {
return;
}
        PREVAR_scicos_context = scicos_context;
        sblock = x.model.rpar;
        [PREVAR_scicos_context,ierr] = script2var(sblock.props.context,PREVAR_scicos_context);
        if (ierr==0) {
        [sblock,%w,needcompile2,ok] = do_eval(sblock,list());
        if (ok) {
        y = max(2,this.needcompile,needcompile2);
        x.graphics.exprs = exprs;
        x.model.rpar = sblock;
break;
}
        } else {
message(lasterror());
        ok = false;
}
}
    }
}
/* autogenerated from "macros/Sources/Ground_g.sci" */
function Ground_g() {
    Ground_g.prototype.define = function Ground_g() {
        C = [0];
        model = scicos_model();
        model.sim = list("cstblk4_m",4);
        model.in1 = [];
        model.out = 1;
        model.in2 = [];
        model.out2 = 1;
        model.outtyp = -1;
        model.rpar = [];
        model.opar = list(C);
        model.blocktype = "d";
        model.dep_ut = [false,false];
        exprs = [];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    Ground_g.prototype.details = function Ground_g() {
    }
    Ground_g.prototype.get = function Ground_g() {
    }
    Ground_g.prototype.set = function Ground_g() {
        x = arg1;
    }
}
/* autogenerated from "macros/Sources/INIMPL_f.sci" */
function INIMPL_f() {
    INIMPL_f.prototype.define = function INIMPL_f() {
        model = scicos_model();
        model.sim = "inimpl";
        model.out = [-1];
        model.out2 = [1];
        model.ipar = [1];
        model.dep_ut = [false,false];
        model.blocktype = "c";
        mo = modelica();
        mo.model = "PORT";
        mo.outputs = "n";
        model.equations = mo;
        prt = 1;
        exprs = "1";
        gr_i = [];
        x = standard_define([1,1],model,exprs,gr_i);
        x.graphics.out_implicit = ["I"];
    }
    INIMPL_f.prototype.details = function INIMPL_f() {
    }
    INIMPL_f.prototype.get = function INIMPL_f() {
    }
    INIMPL_f.prototype.set = function INIMPL_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        if (size(exprs,"*")==2) {
        exprs = exprs[1-1];
}
        while (true) {
        [ok,prt,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"INIMPL_f")],[" "],[gettext("Implicit input port")],[" "]],"Port Number",list("vec",1),exprs);
        if (!ok) {
break;
}
        prt = int(prt);
        if (prt<=0) {
block_parameter_error(msprintf(gettext("Wrong value for \'Port Number\' parameter: %d."),prt),gettext("Strictly positive integer expected."));
        } else {
        if (model.ipar!=prt) {
        needcompile = 4;
        y = needcompile;
}
        model.ipar = prt;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sources/IN_f.sci" */
function IN_f() {
    IN_f.prototype.define = function IN_f() {
        prt = 1;
        model = scicos_model();
        model.sim = "input";
        model.out = -1;
        model.out2 = -2;
        model.outtyp = -1;
        model.ipar = prt;
        model.blocktype = "c";
        model.dep_ut = [false,false];
        exprs = sci2exp(prt);
        gr_i = [];
        x = standard_define([1,1],model,exprs,gr_i);
    }
    IN_f.prototype.details = function IN_f() {
    }
    IN_f.prototype.get = function IN_f() {
    }
    IN_f.prototype.set = function IN_f() {
        x = arg1;
        graphics = arg1.graphics;
        model = arg1.model;
        exprs = graphics.exprs;
        if (size(exprs,"*")==2) {
        exprs = exprs[1-1];
}
        if (size(exprs,"*")==1) {
        exprs = [[exprs[1-1]],["[-1 -2]"],["-1"]];
}
        while (true) {
        [ok,prt,otsz,ot,exprs] = getvalue(_("Set Input block parameters"),[[_("Port number")],[_("Outport size ([-1 -2] for inherit)")],[_("Outport Type (-1 for inherit)")]],list("vec",1,"vec",-1,"vec",1),exprs);
        if (!ok) {
break;
}
        prt = int(prt);
        if (prt<=0) {
message(_("Port number must be a positive integer"));
        } else if (!isequal(size(otsz,"*"),2)) {
message(_("Outport Size must be a 2 elements vector"));
        } else if (((ot<1||ot>9)&&(ot!=-1))) {
message(_("Outport type must be a number between 1 and 9, or -1 for inheritance."));
        } else {
        if (model.ipar!=prt) {
        needcompile = 4;
        y = needcompile;
}
        model.ipar = prt;
        model.firing = [];
        model.out = otsz[1-1];
        model.out2 = otsz[2-1];
        model.outtyp = ot;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sources/Modulo_Count.sci" */
function Modulo_Count() {
    Modulo_Count.prototype.define = function Modulo_Count() {
        ini_c = 0;
        base = 3;
        model = scicos_model();
        model.sim = list("modulo_count",4);
        model.evtin = 1;
        model.out = 1;
        model.dstate = ini_c;
        model.ipar = base;
        model.blocktype = "c";
        model.dep_ut = [false,false];
        exprs = [[string(ini_c)],[string(base)]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    Modulo_Count.prototype.details = function Modulo_Count() {
    }
    Modulo_Count.prototype.get = function Modulo_Count() {
    }
    Modulo_Count.prototype.set = function Modulo_Count() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,ini_c,base,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"Modulo_Count")],[" "],[gettext("Modulo counter (0 to N counter)")],[" "]],[[gettext("Initial State (zero or positive number)")],[gettext("Upper Limit (positive number)")]],list("vec",1,"vec",1),exprs);
        ini_c = int(ini_c);
        base = int(base);
        if (!ok) {
break;
}
        if (ini_c<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'Initial State\' parameter: %d."),ini_c),gettext("Null or positive integer expected."));
        } else if (base<=0) {
block_parameter_error(msprintf(gettext("Wrong values for \'Upper Limit\' parameter: %d."),base),gettext("Strictly positive integer expected."));
        } else {
        graphics.exprs = exprs;
        model.ipar = base;
        model.dstate = ini_c;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sources/PULSE_SC.sci" */
function PULSE_SC() {
    PULSE_SC.prototype.define = function PULSE_SC() {
        scs_m_1 = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[-162.7581,435.54369,67.607292,416.67644,827,479,0,15,827,480,715,167,1.4],Title=["SuperBlock","/home/fady/Scicos_examples/"],tol=[[0.0001],[0.000001],[1.000e-10],[100001],[0],[0],[0]],tf=10,context=[["E2=E+W/100*F"],["if (W<0 | W>100) then error(\'Width must be between 0 and 100\');end"],["if (E2 >= F) then error (\'Offset must be lower than (frequency*(1-Width/100))\'); end"]],void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m_1.objs[1-1] = scicos_block(gui="CONST_m",graphics=scicos_graphics(orig=[30.801202,158.91733],sz=[40,40],flip=true,theta=0,exprs="A",pin=[],pout=5,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim=list("cstblk4_m",4),in1=[],in2=[],intyp=1,out=1,out2=1,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(1),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[2-1] = scicos_block(gui="Ground_g",graphics=scicos_graphics(orig=[31.534535,215.384],sz=[40,40],flip=true,theta=0,exprs=[],pin=[],pout=4,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim=list("cstblk4_m",4),in1=[],in2=[],intyp=1,out=1,out2=1,outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(0),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[3-1] = scicos_block(gui="SELECT_m",graphics=scicos_graphics(orig=[106.00652,186.09381],sz=[40,40],flip=true,theta=0,exprs=[["-1"],["2"],["1"]],pin=[[4],[5]],pout=11,pein=[[9],[8]],peout=[],gr_i=[],id="",in_implicit=[["E"],["E"]],out_implicit="E"),model=scicos_model(sim=list("selector_m",4),in1=[[-1],[-1]],in2=[[-2],[-2]],intyp=[[-1],[-1]],out=-1,out2=-2,outtyp=-1,evtin=[[1],[1]],evtout=[],state=[],dstate=1,odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[4-1] = scicos_link(xx=[[80.105964],[97.43509],[97.43509]],yy=[[235.384],[235.384],[212.76048]],id="drawlink",thick=[0,0],ct=[1,1],from=[2,1,0],to=[3,1,1]);
        scs_m_1.objs[5-1] = scicos_link(xx=[[79.372631],[97.43509],[97.43509]],yy=[[178.91733],[178.91733],[199.42714]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[3,2,1]);
        scs_m_1.objs[6-1] = scicos_block(gui="SampleCLK",graphics=scicos_graphics(orig=[82.349744,274.21741],sz=[60,40],flip=true,theta=0,exprs=[["F"],["E2"]],pin=[],pout=[],pein=[],peout=9,gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="sampleclk",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=1,state=[],dstate=[],odstate=list(),rpar=[[1],[0.4]],ipar=[],opar=list(),blocktype="d",firing=-1,dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[7-1] = scicos_block(gui="SampleCLK",graphics=scicos_graphics(orig=[160.48879,274.21741],sz=[60,40],flip=true,theta=0,exprs=[["F"],["E"]],pin=[],pout=[],pein=[],peout=8,gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="sampleclk",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=1,state=[],dstate=[],odstate=list(),rpar=[[1],[0.1]],ipar=[],opar=list(),blocktype="d",firing=-1,dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[8-1] = scicos_link(xx=[[190.48879],[190.48879],[132.67318],[132.67318]],yy=[[274.21741],[240.99048],[240.99048],[231.80809]],id="drawlink",thick=[0,0],ct=[5,-1],from=[7,1,0],to=[3,2,1]);
        scs_m_1.objs[9-1] = scicos_link(xx=[[112.34974],[112.34974],[119.33985],[119.33985]],yy=[[274.21741],[248.21372],[248.21372],[231.80809]],id="drawlink",thick=[0,0],ct=[5,-1],from=[6,1,0],to=[3,1,1]);
        scs_m_1.objs[10-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[174.57795,196.09381],sz=[20,20],flip=true,theta=0,exprs="1",pin=11,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=-2,intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[11-1] = scicos_link(xx=[[154.57795],[174.57795]],yy=[[206.09381],[206.09381]],id="drawlink",thick=[0,0],ct=[1,1],from=[3,1,0],to=[10,1,1]);
        model = scicos_model();
        model.sim = "csuper";
        model.in1 = [];
        model.in2 = [];
        model.intyp = 1;
        model.out = -1;
        model.out2 = -2;
        model.outtyp = -1;
        model.evtin = [];
        model.evtout = [];
        model.state = [];
        model.dstate = [];
        model.odstate = list();
        model.rpar = scs_m_1;
        model.ipar = 1;
        model.opar = list();
        model.blocktype = "h";
        model.firing = [];
        model.dep_ut = [false,false];
        model.label = "";
        model.nzcross = 0;
        model.nmode = 0;
        model.equations = list();
        E = 0.1;
        W = 30;
        F = 1;
        A = 1;
        exprs = [sci2exp(E),sci2exp(W),sci2exp(F),sci2exp(A)];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    PULSE_SC.prototype.details = function PULSE_SC() {
    }
    PULSE_SC.prototype.get = function PULSE_SC() {
    }
    PULSE_SC.prototype.set = function PULSE_SC() {
        y = this.needcompile;
        arg1.model.ipar = 1;
        typ = list();
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        Btitre = "Set Pulse Generator parameters";
        Exprs0 = [["E"],["W"],["F"],["A"]];
        Bitems = [["Phase delay (secs):"],["Pulse Width (% of period):"],["Period (secs):"],["Amplitude:"]];
        Ss = list("pol",-1,"pol",-1,"pol",-1,"mat",[-1,-1]);
        scicos_context = struct();
        x = arg1;
        ok = false;
        while (!ok) {
        [ok,scicos_context.E,scicos_context.W,scicos_context.F,scicos_context.A,exprs] = scicos_getvalue(Btitre,Bitems,Ss,exprs);
        if (!ok) {
return;
}
        PREVAR_scicos_context = scicos_context;
        sblock = x.model.rpar;
        [PREVAR_scicos_context,ierr] = script2var(sblock.props.context,PREVAR_scicos_context);
        if (ierr==0) {
        [sblock,%w,needcompile2,ok] = do_eval(sblock,list());
        if (ok) {
        y = max(2,this.needcompile,needcompile2);
        x.graphics.exprs = exprs;
        x.model.rpar = sblock;
break;
}
        } else {
        if ((lasterror()!=[])) {
messagebox(lasterror());
}
        ok = false;
}
}
    }
}
/* autogenerated from "macros/Sources/RAMP.sci" */
function RAMP() {
    RAMP.prototype.define = function RAMP() {
        slope = 0;
        iout = 0;
        stt = 0;
        rpar = [[slope],[stt],[iout]];
        model = scicos_model();
        model.sim = list("ramp",4);
        model.in1 = [];
        model.out = 1;
        model.rpar = rpar;
        model.blocktype = "c";
        model.nmode = 1;
        model.nzcross = 1;
        model.dep_ut = [false,true];
        exprs = [string(rpar)];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    RAMP.prototype.details = function RAMP() {
    }
    RAMP.prototype.get = function RAMP() {
    }
    RAMP.prototype.set = function RAMP() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,slope,stt,iout,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"RAMP")],[" "],[gettext("Ramp function")],[" "]],[[gettext("Slope")],[gettext("Start Time")],[gettext("Initial Value")]],list("vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (stt<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'Start Time\' parameter: %e."),stt),gettext("Null or positive integer expected."));
        } else {
        model.rpar = [[slope],[stt],[iout]];
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sources/RAND_f.sci" */
function RAND_f() {
    RAND_f.prototype.define = function RAND_f() {
        a = 0;
        b = 1;
        dt = 0;
        out = 1;
        flag = 0;
        model = scicos_model();
        model.sim = "rndblk";
        model.out = out;
        model.evtin = 1;
        model.dstate = [[int(rand()*(10^7-1))],[0*a.slice()]];
        model.rpar = [[a.slice()],[b.slice()]];
        model.ipar = flag;
        model.blocktype = "d";
        model.dep_ut = [false,false];
        exprs = [[string(flag)],[sci2exp(a.slice())],[sci2exp(b.slice())],[string(model.dstate[1-1])]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    RAND_f.prototype.details = function RAND_f() {
    }
    RAND_f.prototype.get = function RAND_f() {
    }
    RAND_f.prototype.set = function RAND_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        if (size(exprs,"*")==5) {
        exprs = exprs.slice(1-1,3);
}
        if (size(exprs,"*")==3) {
        exprs = [[exprs],[string(model.dstate[1-1])]];
}
        while (true) {
        [ok,flag,a,b,seed_c,exprs] = scicos_getvalue([["Set Random generator block parameters"],["flag = 0 : Uniform distribution A is min and A+B max"],["flag = 1 : Normal distribution A is mean and B deviation"],[" "],["A and B must be vector with equal sizes"],["seed is the seed of random number generator (integer<2**31)"]],[["flag"],["A"],["B"],["seed"]],list("vec",1,"vec",-1,"vec","size(%2,\'*\')","vec",1),exprs);
        if (!ok) {
break;
}
        if (flag!=0&&flag!=1) {
message("flag must be equal to 1 or 0");
        } else {
        nout = size(a,"*");
        graphics.exprs = exprs;
        model.out = nout;
        model.ipar = flag;
        model.rpar = [[a.slice()],[b.slice()]];
        model.dstate = [[seed_c],[0*a.slice()]];
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sources/RAND_m.sci" */
function RAND_m() {
    RAND_m.prototype.define = function RAND_m() {
        a = 0;
        b = 1;
        dt = 0;
        flag = 0;
        function_name = "rndblk_m";
        funtyp = 4;
        model = scicos_model();
        model.sim = list(function_name,funtyp);
        model.in1 = [];
        model.in2 = [];
        model.intyp = [];
        model.out = 1;
        model.out2 = 1;
        model.outtyp = 1;
        model.evtin = 1;
        model.evtout = [];
        model.state = [];
        model.dstate = [[int(rand()*(10^7-1))],[0*a.slice()]];
        model.rpar = [a.slice(),b.slice()];
        model.ipar = flag;
        model.blocktype = "d";
        model.firing = [];
        model.dep_ut = [false,false];
        exprs = [[sci2exp(1)],[string(flag)],[sci2exp([a])],[sci2exp([b])],[sci2exp([model.dstate[1-1],int(rand()*(10^7-1))])]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    RAND_m.prototype.details = function RAND_m() {
    }
    RAND_m.prototype.get = function RAND_m() {
    }
    RAND_m.prototype.set = function RAND_m() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        if (size(exprs,"*")==14) {
        exprs[9-1] = [];
}
        while (true) {
        [ok,typ,flag,a,b,seed_c,exprs] = scicos_getvalue([["Set Random generator block parameters"],["flag = 0 : Uniform distribution A is min and A+B max"],["flag = 1 : Normal distribution A is mean and B deviation"],[" "],["A and B must be matrix with equal sizes"]],[["Datatype(1=real double  2=complex)"],["flag"],["A"],["B"],["SEED"]],list("vec",1,"vec",1,"mat",[-1,-2],"mat","[-1 -2]","mat",[1,2]),exprs);
        if (!ok) {
break;
}
        if (flag!=0&&flag!=1) {
message("flag must be equal to 1 or 0");
        } else {
        out = size(a);
        if (typ==1) {
        function_name = "rndblk_m";
        model.rpar = [[real(a.slice())],[real(b.slice())]];
        model.dstate = [[seed_c[1-1]],[0*real(a.slice())]];
        ot = 1;
        } else if (typ==2) {
        function_name = "rndblkz_m";
        ot = 2;
        model.rpar = [[real(a.slice())],[imag(a.slice())],[real(b.slice())],[imag(b.slice())]];
        model.dstate = [[seed_c.slice()],[0*[[real(a.slice())],[imag(a.slice())]]]];
        } else {
message("Datatype is not supported");
        ok = false;
}
        if (ok) {
        [model,graphics,ok] = set_io(model,graphics,list([],[]),list(out,ot),1,[]);
        if (ok) {
        model.sim = list(function_name,4);
        graphics.exprs = exprs;
        model.ipar = flag;
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
}
    }
}
/* autogenerated from "macros/Sources/READAU_f.sci" */
function READAU_f() {
    READAU_f.prototype.define = function READAU_f() {
        frmt = "uc ";
        fname = "test.au";
        lunit = 0;
        N = 20;
        M = 1;
        tmask = [];
        swap = 0;
        offset = 1;
        outmask = 1;
        ievt = 0;
        nout = size(outmask,"*");
        model = scicos_model();
        model.sim = list("readau",2);
        model.out = nout;
        model.evtin = 1;
        model.dstate = [[1],[1],[lunit],[zeros(N*M,1)]];
        model.ipar = [[length(fname)],[this._str2code[frmt-1]],[ievt],[N],[M],[swap],[offset],[this._str2code[fname-1]],[tmask],[outmask]];
        model.blocktype = "d";
        model.dep_ut = [false,false];
        exprs = [[fname],[string(N)],[string(swap)]];
        gr_i = [];
        x = standard_define([5,2],model,exprs,gr_i);
    }
    READAU_f.prototype.details = function READAU_f() {
    }
    READAU_f.prototype.get = function READAU_f() {
    }
    READAU_f.prototype.set = function READAU_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        out = model.out;
        dstate = model.dstate;
        ipar = model.ipar;
        imask = 9+ipar[1-1];
        tmask = ipar[imask-1];
        lunit = dstate[3-1];
        fname = exprs[1-1];
        while (true) {
        [ok,fname1,N,swap,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"READAU_f")],[" "],[gettext("(Read Audio File)")],[" "],[gettext("Read is done on a binary \'.au\' file")]],[[gettext("Input File Name")],[gettext("Buffer size")],[gettext("Swap Mode (0:No, 1:Yes)")]],list("str",1,"vec",1,"vec",1),exprs);
        tmask1 = [];
        outmask = 1;
        frmt1 = "uc";
        M = 1;
        offset = 1;
        if (!ok) {
break;
}
        fname1 = stripblanks(fname1);
        frmt1 = stripblanks(frmt1);
        if (this.alreadyran&&fname1!=fname) {
block_parameter_error(gettext("Simulation running !!! You cannot modify Input file name"),gettext("End current simulation first."));
        } else if (fname1=="") {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter."),gettext("Input File Name")),gettext("You must provide a filename."));
        } else if (N<1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Buffer size"),N),msprintf(gettext("Must be greater than %d."),1));
        } else if (this.alreadyran&&(N!=ipar[6-1])) {
block_parameter_error(msprintf(gettext("You cannot modify \'%s\' when running."),gettext("Buffer Size")),gettext("End current simulation first."));
        } else if (swap!=0&&swap!=1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Swap Mode"),swap),msprintf(gettext("Must be in the interval %s."),"[0, 1]"));
        } else {
        [model,graphics,ok] = check_io(model,graphics,[],1,1,[]);
        frmt1 = part(frmt1,1,3);
        if (ok) {
        ipar = [[length(fname1)],[this._str2code[frmt1-1]],[0],[N],[M],[swap],[offset,this._str2code[fname1-1]],[tmask1,outmask.slice()]];
        if (prod(size(dstate))!=(N*M)+3) {
        dstate = [[-1],[-1],[lunit],[zeros(N*M,1)]];
}
        model.dstate = dstate;
        model.ipar = ipar;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/Sources/READC_f.sci" */
function READC_f() {
    READC_f.prototype.define = function READC_f() {
        frmt = "d  ";
        fname = "foo";
        lunit = 0;
        N = 20;
        M = 1;
        rpar = [];
        tmask = 0;
        swap = 0;
        offset = 1;
        outmask = 1;
        ievt = 0;
        nout = size(outmask,"*");
        ipar = [[length(fname)],[this._str2code[frmt-1]],[ievt],[N],[M],[swap],[offset],[this._str2code[fname-1]],[tmask],[outmask]];
        model = scicos_model();
        model.sim = list("readc",2);
        model.out = nout;
        model.evtin = 1;
        model.evtout = [];
        model.dstate = [[1],[1],[lunit],[zeros(N*M,1)]];
        model.ipar = [[length(fname)],[this._str2code[frmt-1]],[ievt],[N],[M],[swap],[offset],[this._str2code[fname-1]],[tmask],[outmask]];
        model.blocktype = "d";
        model.firing = -1;
        model.dep_ut = [false,false];
        exprs = [["[]"],[sci2exp(outmask)],[fname],[frmt],[string(M)],[string(N)],[string(offset)],[string(swap)]];
        gr_i = [];
        x = standard_define([4,2],model,exprs,gr_i);
    }
    READC_f.prototype.details = function READC_f() {
    }
    READC_f.prototype.get = function READC_f() {
    }
    READC_f.prototype.set = function READC_f() {
        x = arg1;
        model = x.model;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        out = model.out;
        dstate = model.dstate;
        ipar = model.ipar;
        imask = 9+ipar[1-1];
        tmask = ipar[imask-1];
        lunit = dstate[3-1];
        fname = exprs[3-1];
        frmt = exprs[4-1];
        while (true) {
        [ok,tmask1,outmask,fname1,frmt1,M,N,offset,swap,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"READC_f")],[" "],[gettext("Read from C binary file")]],[[gettext("Time Record Selection")],[gettext("Outputs Record Selection")],[gettext("Input File Name")],[gettext("Input Format")],[gettext("Record Size")],[gettext("Buffer Size")],[gettext("Initial Record Index")],[gettext("Swap Mode (0:No, 1:Yes)")]],list("vec",-1,"vec",-1,"str",1,"str",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        fname1 = pathconvert(stripblanks(fname1),false,true);
        frmt1 = stripblanks(frmt1);
        fmts = ["s","l","d","f","c","us","ul","uc","ull","uls","ubl","ubs","dl","fl","ll","sl","db","fb","lb","sb"];
        nout = size(outmask,"*");
        if (prod(size(tmask1))>1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter."),gettext("Time Record Selection")),gettext("Must be a scalar or an empty matrix."));
        } else if (and(frmt1!=fmts)) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %s."),gettext("Input Format"),frmt1),gettext("Valid formats are: "+strcat(fmts,", ")));
        } else if (this.alreadyran&&fname1!=fname) {
block_parameter_error(msprintf(gettext("You cannot modify \'%s\' when running"),gettext("Input File Name")),gettext("End current simulation first."));
        } else if (N!=ipar[6-1]&&this.alreadyran) {
block_parameter_error(msprintf(gettext("You cannot modify \'%s\' when running."),gettext("Buffer Size")),gettext("End current simulation first"));
        } else if (this.alreadyran&&size(tmask1)!=size(tmask)) {
block_parameter_error(msprintf(gettext("You cannot modify \'%s\' when running."),gettext("Time Record Selection")),gettext("End current simulation first."));
        } else if (fname1=="") {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter."),gettext("Input File Name")),gettext("You must provide a file name."));
        } else if (M<1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Record Size"),M),gettext("Strictly positive integer expected."));
        } else if (tmask1!=[]&&(tmask1<1||tmask1>M)) {
block_parameter_error(msprintf(gettext("Wrong value for  \'%s\' parameter: %d."),gettext("Time Record Selection"),tmask1),msprintf(gettext("Must be in the interval %s."),gettext("[1, Record Size = ")+string(M)+"]"));
        } else if (nout==0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Outputs Record Selection"),nout),gettext("Strictly positive integer expected."));
        } else if (nout>M) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Outputs Record Selection"),nout),msprintf(gettext("Must be in the interval %s."),gettext("[1, Record Size = ")+string(M)+"]"));
        } else if (max(outmask)>M||min(outmask)<1) {
block_parameter_error(msprintf(gettext("Wrong value for indexes in \'%s\' parameter: %s."),gettext("Outputs Record Selection"),strcat(string(outmask.slice())," ")),msprintf(gettext("Must be in the interval %s."),gettext("[1, Record Size = ")+string(M)+"]"));
        } else if (N<1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Buffer Size"),N),gettext("Strictly positive integer expected."));
        } else if (swap!=0&&swap!=1) {
block_parameter_error(msprintf(gettext("Wrong value for  \'%s\' parameter: %d."),gettext("Swap Mode"),swap),msprintf(gettext("Must be in the interval %s."),"[0, 1]"));
        } else if (offset<1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Initial Record Index"),offset),gettext("Strictly positive integer expected."));
        } else {
        if (tmask1==[]) {
        ievt = 0;
        tmask1 = 0;
        outpt = [];
        } else {
        ievt = 1;
        outpt = 1;
}
        out = size(outmask,"*");
        [model,graphics,ok] = check_io(model,graphics,[],out,1,outpt);
        frmt1 = part(frmt1,1,3);
        if (ok) {
        if (ievt==0) {
        model.firing = -1;
        } else {
        model.firing = 0;
}
        ipar = [[length(fname1)],[this._str2code[frmt1-1]],[ievt],[N],[M],[swap],[offset],[this._str2code[fname1-1]],[tmask1],[outmask.slice()]];
        if (prod(size(dstate))!=(N*M)+3) {
        dstate = [[-1],[-1],[lunit],[zeros(N*M,1)]];
}
        model.dstate = dstate;
        model.ipar = ipar;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/Sources/RFILE_f.sci" */
function RFILE_f() {
    RFILE_f.prototype.define = function RFILE_f() {
        out = 1;
        nout = sum(out);
        frmt = "(7(e10.3,1x))";
        fname = "foo";
        lunit = 0;
        N = 2;
        rpar = [];
        tmask = 0;
        outmask = 1;
        ipar = [[length(fname)],[length(frmt)],[0],[N],[this._str2code[fname-1]],[this._str2code[frmt-1]],[tmask],[outmask]];
        dstate = [[1],[1],[lunit],[zeros((nout)*N,1)]];
        model = scicos_model();
        model.sim = "readf";
        model.out = nout;
        model.evtin = 1;
        model.dstate = dstate;
        model.ipar = [[length(fname)],[length(frmt)],[0],[N],[this._str2code[fname-1]],[this._str2code[frmt-1]],[tmask],[outmask]];
        model.blocktype = "d";
        model.dep_ut = [false,false];
        exprs = [[sci2exp([])],[sci2exp(outmask)],[fname],[frmt],[string(N)],[sci2exp(out)]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    RFILE_f.prototype.details = function RFILE_f() {
    }
    RFILE_f.prototype.get = function RFILE_f() {
    }
    RFILE_f.prototype.set = function RFILE_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        dstate = model.dstate;
        ipar = model.ipar;
        ievt = ipar[3-1];
        N = ipar[4-1];
        imask = 5+ipar[1-1]+ipar[2-1];
        tmask = ipar[imask-1];
        lunit = dstate[3-1];
        fname = exprs[3-1];
        frmt = exprs[4-1];
        if (size(exprs,"*")>5) {
        exprs[6-1] = [];
}
        while (true) {
        [ok,tmask1,outmask,fname1,frmt1,N,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"RFILE_f")],[" "],[gettext("Read from an input file")],[" "],[gettext("Read is done on:")],[gettext("&nbsp; - A binary file if no format given")],[gettext("&nbsp; - A formatted text file if a  format (fortran type) is given")]],[[gettext("Time Record Selection")],[gettext("Outputs Record Selection")],[gettext("Input File Name")],[gettext("Input Format")],[gettext("Buffer Size")]],list("vec",-1,"vec",-1,"str",1,"str",1,"vec",1),exprs);
        if (!ok) {
break;
}
        fname1 = pathconvert(stripblanks(fname1),false,true);
        frmt1 = stripblanks(frmt1);
        nout = size(outmask,"*");
        if (prod(size(tmask1))>1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %s."),gettext("Time Record Selection"),strcat(string(tmask1.slice())," ")),gettext("Empty matrix or scalar expected."));
        } else if (tmask1!=[]&&tmask1<1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d"),gettext("Time Record Selection"),tmask1),gettext("Strictly positive integer expected."));
        } else if (lunit>0&&min(length(frmt),1)!=min(length(frmt1),1)) {
block_parameter_error([gettext("Simulation running !!! You cannot switch <br />between formatted and unformatted")],gettext("End current simulation first."));
        } else if (lunit>0&&fname1!=fname) {
block_parameter_error(gettext("Simulation running !!! You cannot modify \'Input File Name\'"),gettext("End current simulation first."));
        } else if (lunit>0&&size(tmask1)!=size(tmask)) {
block_parameter_error(gettext("Simulation running !!! You cannot modify \'Time Record Selection\'"),gettext("End current simulation first."));
        } else if (fname1=="") {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %s"),gettext("Input File Name"),fname1),gettext("You must provide a filename."));
        } else if (frmt1!=""&&(part(frmt1,1)!="("||part(frmt1,length(frmt1))!=")")) {
block_parameter_error(msprintf(gettext("Wrong format for \'%s\' parameter: %s."),gettext("Input Format"),frmt1),gettext("You must enclose the format\'s string between parentheses."));
        } else if (N<2) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Buffer Size"),N),gettext("Buffer size must be at least 2."));
        } else if (nout==0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Outputs Record Selection"),nout),gettext("You must read at least one field in record."));
        } else if (min(outmask)<1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %s"),gettext("Outputs Record Selection"),strcat(string(outmask.slice())," ")),gettext("Strictly positive indexes expected."));
        } else {
        if (tmask1==[]) {
        ievt = 0;
        cout = [];
        tmask1 = 0;
        } else {
        ievt = 1;
        cout = 1;
}
        [model,graphics,ok] = check_io(model,graphics,[],nout,1,cout);
        if (ok) {
        if (ievt==0) {
        model.firing = [];
        } else {
        model.firing = 0;
}
        ipar = [[length(fname1)],[length(frmt1)],[ievt],[N],[this._str2code[fname1-1]],[this._str2code[frmt1-1]],[tmask1],[outmask.slice()]];
        if (prod(size(dstate))!=(nout+ievt)*N+3) {
        dstate = [[-1],[-1],[lunit],[zeros((nout+ievt)*N,1)]];
}
        model.dstate = dstate;
        model.ipar = ipar;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
}
    }
}
/* autogenerated from "macros/Sources/SAWTOOTH_f.sci" */
function SAWTOOTH_f() {
    SAWTOOTH_f.prototype.define = function SAWTOOTH_f() {
        model = scicos_model();
        model.sim = "sawtth";
        model.out = 1;
        model.evtin = 1;
        model.dstate = 0;
        model.blocktype = "c";
        model.dep_ut = [false,true];
        exprs = " ";
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    SAWTOOTH_f.prototype.details = function SAWTOOTH_f() {
    }
    SAWTOOTH_f.prototype.get = function SAWTOOTH_f() {
    }
    SAWTOOTH_f.prototype.set = function SAWTOOTH_f() {
        x = arg1;
    }
}
/* autogenerated from "macros/Sources/STEP.sci" */
function STEP() {
    STEP.prototype.define = function STEP() {
        rpar = [[0],[1]];
        model = scicos_model();
        model.sim = list("step_func",4);
        model.evtin = 1;
        model.evtout = 1;
        model.out = 1;
        model.out2 = 1;
        model.outtyp = 1;
        model.firing = 1;
        model.rpar = rpar;
        model.blocktype = "c";
        model.dep_ut = [false,false];
        exprs = [[string(1)],[string(rpar)]];
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    STEP.prototype.details = function STEP() {
    }
    STEP.prototype.get = function STEP() {
    }
    STEP.prototype.set = function STEP() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,temps,in1,fi,exprs] = scicos_getvalue([[msprintf(gettext("Set %s block parameters"),"STEP_FUNCTION")],[" "],[gettext("Step Function")],[" "]],[[gettext("Step Time")],[gettext("Initial Value")],[gettext("Final Value")]],list("vec",1,"vec",-1,"vec",-1),exprs);
        if (!ok) {
break;
}
        in1 = in1.slice();
        fi = fi.slice();
        if (size(in1,"*")!=size(fi,"*")) {
        if (size(in1,"*")==1) {
        in1 = in1*ones(fi);
        } else if (size(fi,"*")==1) {
        fi = fi*ones(in1);
        } else {
block_parameter_error(msprintf(gettext("\'Initial Value\' and \'Final Value\': incompatible sizes: %d and %d."),size(in1,"*"),size(fi,"*")),gettext("Same sizes expected."));
        ok = false;
}
}
        if (ok) {
        model.out2 = 1;
        model.outtyp = 1;
        [model,graphics,ok] = check_io(model,graphics,[],size(fi,"*"),1,1);
}
        if (ok) {
        model.firing = temps;
        if (temps==0) {
        rpar = [[fi],[fi]];
        } else {
        rpar = [[in1],[fi]];
}
        model.rpar = rpar;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}
/* autogenerated from "macros/Sources/STEP_FUNCTION.sci" */
function STEP_FUNCTION() {
    STEP_FUNCTION.prototype.define = function STEP_FUNCTION() {
        scs_m_1 = scicos_diagram();
        scs_m_1.objs[1-1] = this.STEP["define"-1];
        scs_m_1.objs[2-1] = OUT_f("define");
        scs_m_1.objs[3-1] = scicos_link();
        scs_m_1.objs[4-1] = scicos_link();
        blk = scs_m_1.objs[1-1];
        graphics = blk.graphics;
        model = blk.model;
        graphics.orig = [0,0];
        graphics.sz = [40,40];
        graphics.pein = 4;
        graphics.peout = 4;
        graphics.pout = 3;
        blk.graphics = graphics;
        blk.model = model;
        scs_m_1.objs[1-1] = blk;
        blk = scs_m_1.objs[2-1];
        graphics = blk.graphics;
        model = blk.model;
        graphics.orig = [80,10];
        graphics.sz = [20,20];
        graphics.exprs = ["1"];
        model.ipar = 1;
        graphics.pin = 3;
        blk.graphics = graphics;
        blk.model = model;
        scs_m_1.objs[2-1] = blk;
        lnk = scs_m_1.objs[3-1];
        lnk.from = [1,1,0];
        lnk.to = [2,1,1];
        scs_m_1.objs[3-1] = lnk;
        lnk = scs_m_1.objs[4-1];
        lnk.xx = [0,20,-20,-20,20,1];
        lnk.yy = [0,-20,-20,60,60,1];
        lnk.ct = [5,-1];
        lnk.from = [1,1,0];
        lnk.to = [1,1,1];
        scs_m_1.objs[4-1] = lnk;
blk={};
lnk={};
        model = scicos_model();
        model.sim = "csuper";
        model.out = 1;
        model.out2 = 1;
        model.outtyp = 1;
        model.rpar = scs_m_1;
        gr_i = [];
        x = standard_define([2,2],model,[],gr_i);
    }
    STEP_FUNCTION.prototype.details = function STEP_FUNCTION() {
    }
    STEP_FUNCTION.prototype.get = function STEP_FUNCTION() {
    }
    STEP_FUNCTION.prototype.set = function STEP_FUNCTION() {
for (i=1;i<=length(arg1.model.rpar.objs);i+=1) {
        o = arg1.model.rpar.objs[i-1];
        if (typeof(o)=="Block"&&o.gui=="STEP") {
        ppath = list(i);
break;
}
}
        newpar = list();
        for (path in ppath) {
        np = size(path,"*");
        spath = list();
for (k=1;k<=np;k+=1) {
        spath[$+1-1] = "model";
        spath[$+1-1] = "rpar";
        spath[$+1-1] = "objs";
        spath[$+1-1] = path[k-1];
}
        xx = arg1[spath-1];
execstr("xxn="+xx.gui+"(\'set\',xx)");
        if (diffobjs(this.xxn,xx)) {
        model = xx.model;
        model_n = this.xxn.model;
        if (!is_modelica_block(xx)) {
        modified = or(model.sim!=model_n.sim)||!isequal(model.state,model_n.state)||!isequal(model.dstate,model_n.dstate)||!isequal(model.rpar,model_n.rpar)||!isequal(model.ipar,model_n.ipar)||!isequal(model.label,model_n.label);
        if (or(model.in1!=model_n.in1)||or(model.out!=model_n.out)) {
        needcompile = 1;
}
        if (or(model.firing!=model_n.firing)) {
        needcompile = 2;
}
        if (model.sim=="input"||model.sim=="output") {
        if (model.ipar!=model_n.ipar) {
        needcompile = 4;
}
}
        if (or(model.blocktype!=model_n.blocktype)||or(model.dep_ut!=model_n.dep_ut)) {
        needcompile = 4;
}
        if ((model.nzcross!=model_n.nzcross)||(model.nmode!=model_n.nmode)) {
        needcompile = 4;
}
        if (prod(size(model_n.sim))>1) {
        if (model_n.sim[2-1]>1000) {
        if (model.sim[1-1]!=model_n.sim[1-1]) {
        needcompile = 4;
}
}
}
        } else {
        modified = or(model_n!=model);
        eq = model.equations;
        eqn = model_n.equations;
        if (or(eq.model!=eqn.model)||or(eq.inputs!=eqn.inputs)||or(eq.outputs!=eqn.outputs)) {
        needcompile = 4;
}
}
        arg1[spath-1] = this.xxn;
        newpar[size(newpar)+1-1] = path;
}
}
        x = arg1;
        y = needcompile;
        typ = newpar;
    }
}
/* autogenerated from "macros/Sources/SampleCLK.sci" */
function SampleCLK() {
    SampleCLK.prototype.define = function SampleCLK() {
        model = scicos_model();
        model.sim = "sampleclk";
        model.evtout = 1;
        model.rpar = [1,0];
        model.blocktype = "d";
        model.firing = -1;
        model.dep_ut = [false,false];
        exprs = [[sci2exp(1)],[sci2exp(0)]];
        x = standard_define([2,2],model,exprs," ");
    }
    SampleCLK.prototype.details = function SampleCLK() {
    }
    SampleCLK.prototype.get = function SampleCLK() {
    }
    SampleCLK.prototype.set = function SampleCLK() {
        x = arg1;
        graphics = arg1.graphics;
        model = arg1.model;
        exprs = graphics.exprs;
        while (true) {
        [ok,frequ,offset,exprs] = scicos_getvalue("Set block parameters",[["Sample time"],["Offset"]],list("vec",1,"vec",1),exprs);
        if (!ok) {
break;
}
        if (frequ<0) {
message("Frequency must be a positif number");
        ok = false;
}
        if (abs(offset)>frequ) {
message("The |Offset| must be less than the Frequency");
        ok = false;
}
        if (ok) {
        if (or(model.rpar.slice()!=[[frequ],[offset]])) {
        needcompile = 4;
        y = needcompile;
}
        model.rpar = [[frequ],[offset]];
        model.evtout = 1;
        model.firing = -1;
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
break;
}
}
needcompile=resume(needcompile)
    }
}
/* autogenerated from "macros/Sources/Sigbuilder.sci" */
function Sigbuilder() {
    Sigbuilder.prototype.define = function Sigbuilder() {
        scs_m_1 = scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["Sigbuilder","./"],tol=[[0.0001],[0.000001],[1.000e-10],[100001],[0],[0],[0]],tf=100,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
        scs_m_1.objs[1-1] = scicos_block(gui="CURVE_c",graphics=scicos_graphics(orig=[329.63473,606.18517],sz=[40,40],flip=true,theta=0,exprs=[["3"],["[0,1,2]"],["[10,20,-30]"],["y"],["n"]],pin=[],pout=6,pein=4,peout=2,gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim=list("curve_c",4),in1=[],in2=[],intyp=1,out=1,out2=[],outtyp=1,evtin=1,evtout=1,state=[],dstate=[],odstate=list(),rpar=[[0],[1],[2],[10],[20],[-30]],ipar=[[3],[3],[1]],opar=list(),blocktype="c",firing=0,dep_ut=[false,true],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[2-1] = scicos_link(xx=[[349.63473],[349.49528]],yy=[[600.47089],[565.10704]],id="drawlink",thick=[0,0],ct=[5,-1],from=[1,1,0],to=[3,1,1]);
        scs_m_1.objs[3-1] = scicos_block(gui="CLKSPLIT_f",graphics=scicos_graphics(orig=[[349.49528],[565.10704]],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=[],pout=[],pein=2,peout=[[8],[4]],gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="split",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=[[1],[1]],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="d",firing=[false,false,false],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[4-1] = scicos_link(xx=[[349.49528],[266.69602],[266.69602],[270.35525],[342.80795],[342.80795],[349.63473]],yy=[[565.10704],[565.10704],[680.99483],[680.99483],[680.99483],[651.89946],[651.89946]],id="drawlink",thick=[0,0],ct=[5,-1],from=[3,2,0],to=[1,1,1]);
        scs_m_1.objs[5-1] = scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[398.20616,616.18517],sz=[20,20],flip=true,theta=0,exprs="1",pin=6,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=-2,intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[6-1] = scicos_link(xx=[[378.20616],[398.20616]],yy=[[626.18517],[626.18517]],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[5,1,1]);
        scs_m_1.objs[7-1] = scicos_block(gui="CLKOUTV_f",graphics=scicos_graphics(orig=[339.49528,505.10704],sz=[20,30],flip=true,theta=0,exprs="1",pin=[],pout=[],pein=8,peout=[],gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="output",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="d",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list()),doc=list());
        scs_m_1.objs[8-1] = scicos_link(xx=[[349.49528],[349.49528]],yy=[[565.10704],[535.10704]],id="drawlink",thick=[0,0],ct=[5,-1],from=[3,1,0],to=[7,1,1]);
        model = scicos_model(sim="csuper",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=1,evtin=[],evtout=1,state=[],dstate=[],odstate=list(),rpar=scs_m_1,ipar=[],opar=list(),blocktype="h",firing=[],dep_ut=[false,false],label="",nzcross=0,nmode=0,equations=list());
        gr_i = [];
        x = standard_define([3,2],model,[],gr_i);
    }
    Sigbuilder.prototype.details = function Sigbuilder() {
    }
    Sigbuilder.prototype.get = function Sigbuilder() {
    }
    Sigbuilder.prototype.set = function Sigbuilder() {
        ppath = list(0);
for (i=1;i<=length(arg1.model.rpar.objs);i+=1) {
        o = arg1.model.rpar.objs[i-1];
        if (typeof(o)=="Block"&&o.gui=="CURVE_c") {
        ppath[1-1] = i;
break;
}
}
        newpar = list();
        this.y = 0;
        for (path in ppath) {
        np = size(path,"*");
        spath = list();
for (k=1;k<=np;k+=1) {
        spath[$+1-1] = "model";
        spath[$+1-1] = "rpar";
        spath[$+1-1] = "objs";
        spath[$+1-1] = path[k-1];
}
        xx = arg1[spath-1];
execstr("xxn="+xx.gui+"(\'set\',xx)");
        if (diffobjs(this.xxn,xx)) {
        model = xx.model;
        model_n = this.xxn.model;
        if (!is_modelica_block(xx)) {
        modified = or(model.sim!=model_n.sim)||!isequal(model.state,model_n.state)||!isequal(model.dstate,model_n.dstate)||!isequal(model.odstate,model_n.odstate)||!isequal(model.rpar,model_n.rpar)||!isequal(model.ipar,model_n.ipar)||!isequal(model.opar,model_n.opar)||!isequal(model.label,model_n.label);
        if (or(model.in1!=model_n.in1)||or(model.out!=model_n.out)||or(model.in2!=model_n.in2)||or(model.out2!=model_n.out2)||or(model.outtyp!=model_n.outtyp)||or(model.intyp!=model_n.intyp)) {
        needcompile = 1;
}
        if (or(model.firing!=model_n.firing)) {
        needcompile = 2;
}
        if ((size(model.in1,"*")!=size(model_n.in1,"*"))||(size(model.out,"*")!=size(model_n.out,"*"))) {
        needcompile = 4;
}
        if (model.sim=="input"||model.sim=="output") {
        if (model.ipar!=model_n.ipar) {
        needcompile = 4;
}
}
        if (or(model.blocktype!=model_n.blocktype)||or(model.dep_ut!=model_n.dep_ut)) {
        needcompile = 4;
}
        if ((model.nzcross!=model_n.nzcross)||(model.nmode!=model_n.nmode)) {
        needcompile = 4;
}
        if (prod(size(model_n.sim))>1) {
        if (model_n.sim[2-1]>1000) {
        if (model.sim[1-1]!=model_n.sim[1-1]) {
        needcompile = 4;
}
}
}
        } else {
        modified = or(model_n!=model);
        eq = model.equations;
        eqn = model_n.equations;
        if (or(eq.model!=eqn.model)||or(eq.inputs!=eqn.inputs)||or(eq.outputs!=eqn.outputs)) {
        needcompile = 4;
}
}
        arg1[spath-1] = this.xxn;
        newpar[size(newpar)+1-1] = path;
        this.y = max(this.y,needcompile);
}
}
        x = arg1;
        typ = newpar;
    }
}
/* autogenerated from "macros/Sources/TIME_f.sci" */
function TIME_f() {
    TIME_f.prototype.define = function TIME_f() {
        model = scicos_model();
        model.sim = "timblk";
        model.out = 1;
        model.blocktype = "c";
        model.dep_ut = [false,true];
        gr_i = [];
        x = standard_define([2,2],model,[],gr_i);
    }
    TIME_f.prototype.details = function TIME_f() {
    }
    TIME_f.prototype.get = function TIME_f() {
    }
    TIME_f.prototype.set = function TIME_f() {
        x = arg1;
    }
}
/* autogenerated from "macros/Sources/TKSCALE.sci" */
function TKSCALE() {
    TKSCALE.prototype.define = function TKSCALE() {
        a = -10;
        b = 10;
        f = 1;
        model = scicos_model();
        model.sim = list("tkscaleblk",5);
        model.out = 1;
        model.evtin = 1;
        model.rpar = [[a],[b],[f]];
        model.blocktype = "d";
        model.dep_ut = [false,false];
        exprs = [[sci2exp(a)],[sci2exp(b)],[sci2exp(f)]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    TKSCALE.prototype.details = function TKSCALE() {
    }
    TKSCALE.prototype.get = function TKSCALE() {
    }
    TKSCALE.prototype.set = function TKSCALE() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        [ok,a,b,f,exprs] = scicos_getvalue("Set scale block parameters",[["Min value"],["Max value"],["Normalization"]],list("vec",1,"vec",1,"vec",1),exprs);
        if (ok) {
        graphics.exprs = exprs;
        model.rpar = [[a],[b],[f]];
        x.graphics = graphics;
        x.model = model;
}
    }
}
/* autogenerated from "macros/Threshold/GENERAL_f.sci" */
function GENERAL_f() {
    GENERAL_f.prototype.define = function GENERAL_f() {
        rpar = [[0],[0],[0],[0]];
        in1 = 1;
        out = 1;
        model = scicos_model();
        model.sim = list("zcross",1);
        model.nzcross = in1;
        model.in1 = in1;
        model.evtout = ones(out,1);
        model.rpar = [[0],[0],[0],[0]];
        model.blocktype = "z";
        model.firing = -ones(out,1);
        model.dep_ut = [true,false];
        exprs = [[strcat(sci2exp(in1))],[strcat(sci2exp(out))]];
        gr_i = [];
        x = standard_define([3,2],model,exprs,gr_i);
    }
    GENERAL_f.prototype.details = function GENERAL_f() {
    }
    GENERAL_f.prototype.get = function GENERAL_f() {
    }
    GENERAL_f.prototype.set = function GENERAL_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        rpar = model.rpar;
        in1 = model.in1;
        out = model.evtout;
        nin = sum(in1);
        nout = sum(out);
        [ok,in1,out,exprs] = scicos_getvalue("Set General Zero-Crossing parameters",[["Input size"],["Number of event output"]],list("vec",1,"vec",1),exprs);
        if (ok) {
        [model,graphics,ok] = check_io(model,graphics,in1,[],[],ones(out,1));
        if (ok) {
        nout1 = out;
        nin1 = in1;
        if (nout==nout1&&nin==nin1) {
        rp = matrix(rpar,nout,2^(2*nin));
        } else {
        rp = -1*ones(nout1,2^(2*nin1));
}
        n = size(rp,2)/2;
        result = x_mdialog("routing matrix",string(1,nout1),string(1,2^(2*nin1)),string(rp.slice().slice()));
        if (result!=[]) {
        rp.slice(1-1,nout1).slice(1-1,2*n) = evstr(result);
        model.nzcross = in1;
        model.rpar = rp.slice();
        model.firing = -ones(out,1);
        graphics.exprs = exprs;
        x.graphics = graphics;
        x.model = model;
}
}
}
    }
}
/* autogenerated from "macros/Threshold/NEGTOPOS_f.sci" */
function NEGTOPOS_f() {
    NEGTOPOS_f.prototype.define = function NEGTOPOS_f() {
        model = scicos_model();
        model.sim = list("zcross",1);
        model.nzcross = 1;
        model.in1 = 1;
        model.evtout = 1;
        model.rpar = [[-1],[-1],[0],[-1]];
        model.blocktype = "z";
        model.firing = -1;
        model.dep_ut = [true,false];
        gr_i = [];
        x = standard_define([2,2],model,[],gr_i);
    }
    NEGTOPOS_f.prototype.details = function NEGTOPOS_f() {
    }
    NEGTOPOS_f.prototype.get = function NEGTOPOS_f() {
    }
    NEGTOPOS_f.prototype.set = function NEGTOPOS_f() {
        x = arg1;
        x.model.firing = -1;
    }
}
/* autogenerated from "macros/Threshold/POSTONEG_f.sci" */
function POSTONEG_f() {
    POSTONEG_f.prototype.define = function POSTONEG_f() {
        rpar = [[-1],[-1],[-1],[0]];
        model = scicos_model();
        model.sim = list("zcross",1);
        model.nzcross = 1;
        model.in1 = 1;
        model.evtout = 1;
        model.rpar = [[-1],[-1],[-1],[0]];
        model.blocktype = "z";
        model.dep_ut = [true,false];
        model.firing = [-1];
        gr_i = [];
        x = standard_define([2,2],model,[],gr_i);
    }
    POSTONEG_f.prototype.details = function POSTONEG_f() {
    }
    POSTONEG_f.prototype.get = function POSTONEG_f() {
    }
    POSTONEG_f.prototype.set = function POSTONEG_f() {
        x = arg1;
        x.model.firing = [-1];
    }
}
/* autogenerated from "macros/Threshold/ZCROSS_f.sci" */
function ZCROSS_f() {
    ZCROSS_f.prototype.define = function ZCROSS_f() {
        rpar = [[-1],[-1],[0],[0]];
        in1 = 1;
        model = scicos_model();
        model.sim = list("zcross",1);
        model.in1 = in1;
        model.nzcross = in1;
        model.evtout = 1;
        model.rpar = [[-1],[-1],[0],[0]];
        model.blocktype = "z";
        model.firing = -1;
        model.dep_ut = [true,false];
        exprs = strcat(sci2exp(in1));
        gr_i = [];
        x = standard_define([2,2],model,exprs,gr_i);
    }
    ZCROSS_f.prototype.details = function ZCROSS_f() {
    }
    ZCROSS_f.prototype.get = function ZCROSS_f() {
    }
    ZCROSS_f.prototype.set = function ZCROSS_f() {
        x = arg1;
        graphics = arg1.graphics;
        exprs = graphics.exprs;
        model = arg1.model;
        while (true) {
        [ok,in1,exprs] = scicos_getvalue([["Set Zero-Crossing parameters"],["All surfaces must cross together"]],"Input size",list("vec",1),exprs);
        if (!ok) {
break;
}
        in1 = int(in1);
        if (in1<=0) {
message("Block must have at least one input");
        } else {
        kk = 0;
for (jj=1;jj<=in1;jj+=1) {
        kk = kk+2^(in1+jj-1);
}
        model.rpar = [[-ones(kk,1)],[zeros(2^(2*in1)-kk,1)]];
        graphics.exprs = exprs;
        model.in1 = in1;
        model.nzcross = in1;
        model.firing = -1;
        x.graphics = graphics;
        x.model = model;
break;
}
}
    }
}

/* made from 270/274 files */
