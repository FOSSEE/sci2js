/* autogenerated from "macros/Hydraulics/SourceP.sci" */
function SourceP() {
SourceP.prototype.get = function SourceP() {
}
SourceP.prototype.set = function SourceP() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,P0,T0,H0,option_temperature,exprs]=scicos_getvalue("Paramètres du puits",["Pression de la source : P0 (Pa)","Temperature de la source : T0 (K)","Enthalpie spécifique de la source : H0 (J/kg)","1:température fixée - 2:enthalpie fixée : option_temperature"],list("vec",-1,"vec",-1,"vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
model.rpar=[P0,T0,H0,option_temperature];
model.equations.parameters[2]=list(P0,T0,H0,option_temperature);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
SourceP.prototype.define = function SourceP() {
model=scicos_model();
P0=300000;
T0=290;
H0=100000;
option_temperature=1;
model.rpar=[P0,T0,H0,option_temperature];
model.sim="Source";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="Source";
mo.inputs=[];
mo.outputs=["C"];
mo.parameters=list(["P0","T0","H0","option_temperature"],[P0,T0,H0,option_temperature]);
model.equations=mo;
model.in=ones(size(mo.inputs,"*"),1);
model.out=ones(size(mo.outputs,"*"),1);
exprs=[string(P0),string(T0),string(H0),string(option_temperature)];
gr_i=[];
x=standard_define([2.5,2],model,exprs,list(gr_i,0));
x.graphics.out_implicit=["I"];
}
SourceP.prototype.details = function SourceP() {
}
}
/* autogenerated from "macros/Hydraulics/Flowmeter.sci" */
function Flowmeter() {
Flowmeter.prototype.get = function Flowmeter() {
}
Flowmeter.prototype.set = function Flowmeter() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
x=arg1;
exprs=x.graphics.exprs;
while (None) {
[ok,Qini,exprs]=scicos_getvalue(["Set Flowmeter block parameters:","","Qini: "],"Qini",list("vec",1),exprs);
if (!ok) {
break
}
x.model.equations.parameters[2]=list(Qini);
x.graphics.exprs=exprs;
break
}
}
Flowmeter.prototype.define = function Flowmeter() {
ModelName="Flowmeter";
PrametersValue=1;
ParametersName="Qini";
model=scicos_model();
Typein=[];
Typeout=[];
MI=[];
MO=[];
P=[50,105,-1,90,0,10,2,0,101,10,-2,0];
PortName=["Mesure","C1","C2"];
for(i=1;i<=size(P,"r");i+=1) {
if (P(i,3)==1) {
Typein=[Typein,"E"];
MI=[MI,PortName(i)];
}
if (P(i,3)==2) {
Typein=[Typein,"I"];
MI=[MI,PortName(i)];
}
if (P(i,3)==-1) {
Typeout=[Typeout,"E"];
MO=[MO,PortName(i)];
}
if (P(i,3)==-2) {
Typeout=[Typeout,"I"];
MO=[MO,PortName(i)];
}
}
model=scicos_model();
mo=modelica();
model.sim=ModelName;
mo.inputs=MI;
mo.outputs=MO;
model.rpar=PrametersValue;
mo.parameters=list(ParametersName,PrametersValue,zeros(ParametersName));
exprs="1";
gr_i=[];
model.blocktype="c";
model.dep_ut=[None,true];
mo.model=ModelName;
model.equations=mo;
model.in=ones(size(MI,"*"),1);
model.out=ones(size(MO,"*"),1);
x=standard_define([2,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=Typein;
x.graphics.out_implicit=Typeout;
}
Flowmeter.prototype.details = function Flowmeter() {
}
}
/* autogenerated from "macros/Hydraulics/VanneReglante.sci" */
function VanneReglante() {
VanneReglante.prototype.get = function VanneReglante() {
}
VanneReglante.prototype.set = function VanneReglante() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,Cvmax,p_rho,exprs]=scicos_getvalue("Paramètres de la vanne reglante",["Cvmax","p_rho"],list("vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
model.rpar=[Cvmax,p_rho];
model.equations.parameters[2]=list(Cvmax,p_rho);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
VanneReglante.prototype.define = function VanneReglante() {
model=scicos_model();
model.in=[1,1];
model.out=[1];
Cvmax=8005.42;
p_rho=0;
model.rpar=[Cvmax,p_rho];
model.sim="VanneReglante";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="VanneReglante";
mo.inputs=["C1","Ouv"];
mo.outputs="C2";
mo.parameters=list(["Cvmax","p_rho"],[Cvmax,p_rho]);
model.equations=mo;
model.in=ones(size(mo.inputs,"*"),1);
model.out=ones(size(mo.outputs,"*"),1);
exprs=[string(Cvmax),string(p_rho)];
gr_i=[];
x=standard_define([2,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I","E"];
x.graphics.out_implicit=["I"];
}
VanneReglante.prototype.details = function VanneReglante() {
}
}
/* autogenerated from "macros/Hydraulics/PerteDP.sci" */
function PerteDP() {
PerteDP.prototype.get = function PerteDP() {
}
PerteDP.prototype.set = function PerteDP() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,L,D,lambda,z1,z2,p_rho,exprs]=scicos_getvalue("Parametres du tuyau",["Longueur du tube : L (m)","Diamètre interne du tube : D (m)","Coefficient de perte de charge-frottement(S.U) : lambda","Altitude entrée tuyauterie : z1 (m)","Altitude sortie tuyauterie : z2 (m)","Si >0, masse volumique imposée fu fluide : p_rho (kg/m3)"],list("vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
model.rpar=[L,D,lambda,z1,z2,p_rho];
model.equations.parameters[2]=list(L,D,lambda,z1,z2,p_rho);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
PerteDP.prototype.define = function PerteDP() {
model=scicos_model();
model.in=[1];
model.out=[1];
L=10;
D=0.2;
lambda=0.03;
z1=0;
z2=0;
p_rho=0;
model.rpar=[L,D,lambda,z1,z2,p_rho];
model.sim="PerteDP";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="PerteDP";
mo.inputs="C1";
mo.outputs="C2";
mo.parameters=list(["L","D","lambda","z1","z2","p_rho"],[L,D,lambda,z1,z2,p_rho]);
model.equations=mo;
model.in=ones(size(mo.inputs,"*"),1);
model.out=ones(size(mo.outputs,"*"),1);
exprs=[string(L),string(D),string(lambda),string(z1),string(z2),string(p_rho)];
gr_i=[];
x=standard_define([2,1],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I"];
}
PerteDP.prototype.details = function PerteDP() {
}
}
/* autogenerated from "macros/Hydraulics/PuitsP.sci" */
function PuitsP() {
PuitsP.prototype.get = function PuitsP() {
}
PuitsP.prototype.set = function PuitsP() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,P0,T0,H0,option_temperature,exprs]=scicos_getvalue("Paramètres du puits",["Pression de la source : P0 (Pa)","Temperature de la source : T0 (K)","Enthalpie spécifique de la source : H0 (J/kg)","1:température fixée - 2:enthalpie fixée : option_temperature"],list("vec",-1,"vec",-1,"vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
model.rpar=[P0,T0,H0,option_temperature];
model.equations.parameters[2]=list(P0,T0,H0,option_temperature);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
PuitsP.prototype.define = function PuitsP() {
model=scicos_model();
P0=100000;
T0=290;
H0=100000;
option_temperature=1;
model.rpar=[P0,T0,H0,option_temperature];
model.sim="Puits";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="Puits";
mo.inputs=["C"];
mo.parameters=list(["P0","T0","H0","option_temperature"],[P0,T0,H0,option_temperature]);
model.equations=mo;
model.in=ones(size(mo.inputs,"*"),1);
exprs=[string(P0),string(T0),string(H0),string(option_temperature)];
gr_i=[];
x=standard_define([2.5,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I"];
}
PuitsP.prototype.details = function PuitsP() {
}
}
/* autogenerated from "macros/Events/EVTDLY_c.sci" */
function EVTDLY_c() {
EVTDLY_c.prototype.get = function EVTDLY_c() {
}
EVTDLY_c.prototype.set = function EVTDLY_c() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,dt,ff,exprs]=scicos_getvalue(["Set Event Delay block parameters","Delay  is the delay between an input event ","       and the generated output event","Block may initially generate an output event before ","       any input event. \"Date of initial output event\"","       gives the date of this event. Set a negative value","       to disable any output event."],["Delay","Date of initial output event"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (dt<=0) {
message("Delay must be positive");
ok=None;
}
if (ok) {
graphics.exprs=exprs;
model.rpar=[dt,ff];
model.firing=ff;
x.graphics=graphics;
x.model=model;
break
}
}
}
EVTDLY_c.prototype.define = function EVTDLY_c() {
dt=0.1;
ff=0.0;
model=scicos_model();
model.sim=list("evtdly4",4);
model.evtin=1;
model.evtout=1;
model.rpar=[dt,ff];
model.blocktype="d";
model.firing=ff;
model.dep_ut=[None,None];
exprs=[string(dt),sci2exp(ff)];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
EVTDLY_c.prototype.details = function EVTDLY_c() {
}
}
/* autogenerated from "macros/Events/CLKSPLIT_f.sci" */
function CLKSPLIT_f() {
CLKSPLIT_f.prototype.get = function CLKSPLIT_f() {
}
CLKSPLIT_f.prototype.set = function CLKSPLIT_f() {
x=arg1;
}
CLKSPLIT_f.prototype.define = function CLKSPLIT_f() {
model=scicos_model();
model.sim="split";
model.evtin=1;
model.evtout=[1,1];
model.blocktype="d";
model.firing=[None,None,None];
model.dep_ut=[None,None];
x=standard_define([1,1]/3,model,[],[]);
}
CLKSPLIT_f.prototype.details = function CLKSPLIT_f() {
}
}
/* autogenerated from "macros/Events/ANDLOG_f.sci" */
function ANDLOG_f() {
ANDLOG_f.prototype.get = function ANDLOG_f() {
}
ANDLOG_f.prototype.set = function ANDLOG_f() {
x=arg1;
}
ANDLOG_f.prototype.define = function ANDLOG_f() {
model=scicos_model();
model.sim="andlog";
model.out=1;
model.evtin=[1,1];
model.blocktype="d";
model.firing=[];
model.dep_ut=[None,None];
gr_i=[];
x=standard_define([3,3],model,[],gr_i);
}
ANDLOG_f.prototype.details = function ANDLOG_f() {
}
}
/* autogenerated from "macros/Events/HALT_f.sci" */
function HALT_f() {
HALT_f.prototype.get = function HALT_f() {
}
HALT_f.prototype.set = function HALT_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,n,exprs]=scicos_getvalue("Set Halt block parameters",["State on halt"],list("vec",1),exprs);
if (!ok) {
break
}
if (ok) {
graphics.exprs=exprs;
model.ipar=n;
x.graphics=graphics;
x.model=model;
break
}
}
}
HALT_f.prototype.define = function HALT_f() {
n=0;
model=scicos_model();
model.sim="hltblk";
model.evtin=1;
model.dstate=0;
model.ipar=0;
model.blocktype="d";
model.dep_ut=[None,None];
exprs=string(n);
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
HALT_f.prototype.details = function HALT_f() {
}
}
/* autogenerated from "macros/Events/VirtualCLK0.sci" */
function VirtualCLK0() {
VirtualCLK0.prototype.get = function VirtualCLK0() {
}
VirtualCLK0.prototype.set = function VirtualCLK0() {
x=arg1;
}
VirtualCLK0.prototype.define = function VirtualCLK0() {
model=scicos_model();
model.sim="vrtclk0";
model.evtin=1;
model.opar=list();
model.ipar=[];
model.blocktype="d";
model.firing=-1;
model.dep_ut=[None,None];
exprs=[];
x=standard_define([2,2],model,exprs," ");
}
VirtualCLK0.prototype.details = function VirtualCLK0() {
}
}
/* autogenerated from "macros/Events/END_c.sci" */
function END_c() {
END_c.prototype.get = function END_c() {
}
END_c.prototype.set = function END_c() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,tf,exprs]=scicos_getvalue("Set final simulation time",["Final simulation time"],list("vec",1),exprs);
if (!ok) {
break
}
if (ok) {
graphics.exprs=exprs;
model.firing=tf;
x.graphics=graphics;
x.model=model;
break
}
}
}
END_c.prototype.define = function END_c() {
tf=100000000;
model=scicos_model();
model.sim=list("scicosexit",4);
model.evtin=1;
model.evtout=1;
model.firing=tf;
model.blocktype="d";
model.dep_ut=[None,None];
exprs=string(tf);
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
END_c.prototype.details = function END_c() {
}
}
/* autogenerated from "macros/Events/CLKSOMV_f.sci" */
function CLKSOMV_f() {
CLKSOMV_f.prototype.get = function CLKSOMV_f() {
}
CLKSOMV_f.prototype.set = function CLKSOMV_f() {
x=arg1;
}
CLKSOMV_f.prototype.define = function CLKSOMV_f() {
model=scicos_model();
model.sim="sum";
model.evtin=[1,1,1];
model.evtout=1;
model.blocktype="d";
model.firing=-1;
model.dep_ut=[None,None];
gr_i=[];
x=standard_define([2,2],model,[],gr_i);
}
CLKSOMV_f.prototype.details = function CLKSOMV_f() {
}
}
/* autogenerated from "macros/Events/EVTGEN_f.sci" */
function EVTGEN_f() {
EVTGEN_f.prototype.get = function EVTGEN_f() {
}
EVTGEN_f.prototype.set = function EVTGEN_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,tt,exprs]=scicos_getvalue("Set Event time",["Event Time"],list("vec",1),exprs);
if (!ok) {
break
}
graphics.exprs=exprs;
if (model.firing!=tt) {
model.firing=tt;
}
x.graphics=graphics;
x.model=model;
break
}
}
EVTGEN_f.prototype.define = function EVTGEN_f() {
tt=0;
model=scicos_model();
model.sim="trash";
model.evtout=1;
model.blocktype="d";
model.firing=tt;
model.dep_ut=[None,None];
exprs=string(tt);
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
EVTGEN_f.prototype.details = function EVTGEN_f() {
}
}
/* autogenerated from "macros/Events/EVTVARDLY.sci" */
function EVTVARDLY() {
EVTVARDLY.prototype.get = function EVTVARDLY() {
}
EVTVARDLY.prototype.set = function EVTVARDLY() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,fir,exprs]=scicos_getvalue("Set parameter of variable event delay","Initial event firing time (<0 if absent)",list("vec",1),exprs);
if (!ok) {
break
}
graphics.exprs=exprs;
model.firing=fir;
x.graphics=graphics;
x.model=model;
break
}
}
EVTVARDLY.prototype.define = function EVTVARDLY() {
model=scicos_model();
model.sim=list("evtvardly",4);
model.in=1;
model.evtin=1;
model.evtout=1;
model.blocktype="d";
model.firing=-1;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=string(model.firing);
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
EVTVARDLY.prototype.details = function EVTVARDLY() {
}
}
/* autogenerated from "macros/Events/EVTDLY_f.sci" */
function EVTDLY_f() {
EVTDLY_f.prototype.get = function EVTDLY_f() {
}
EVTDLY_f.prototype.set = function EVTDLY_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,dt,ff,exprs]=scicos_getvalue(["Set Event Delay  block parameters","Delay  is the delay between an input event ","       and the generated output event","Block may initially generate an output event before ","       any input event. \"Date of initial output event\"","       gives the date of this event. Set a negative value","       if no initial event required"],["Delay","Date of initial output event"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (dt<=0) {
message("Delay must be positive");
ok=None;
}
if (ok) {
graphics.exprs=exprs;
model.rpar=dt;
model.firing=ff;
x.graphics=graphics;
x.model=model;
break
}
}
}
EVTDLY_f.prototype.define = function EVTDLY_f() {
dt=0.1;
ff=dt;
model=scicos_model();
model.sim="evtdly";
model.evtin=1;
model.evtout=1;
model.rpar=dt;
model.blocktype="d";
model.firing=ff;
model.dep_ut=[None,None];
exprs=[string(dt),sci2exp(ff)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
EVTDLY_f.prototype.details = function EVTDLY_f() {
}
}
/* autogenerated from "macros/Events/CLKSOM_f.sci" */
function CLKSOM_f() {
CLKSOM_f.prototype.get = function CLKSOM_f() {
}
CLKSOM_f.prototype.set = function CLKSOM_f() {
x=arg1;
}
CLKSOM_f.prototype.define = function CLKSOM_f() {
model=scicos_model();
model.sim="sum";
model.evtin=[1,1,1];
model.evtout=1;
model.blocktype="d";
model.firing=-1;
model.dep_ut=[None,None];
gr_i=[];
x=standard_define([1,1]/1.2,model,[],gr_i);
}
CLKSOM_f.prototype.details = function CLKSOM_f() {
}
}
/* autogenerated from "macros/Events/MFCLCK_f.sci" */
function MFCLCK_f() {
MFCLCK_f.prototype.get = function MFCLCK_f() {
}
MFCLCK_f.prototype.set = function MFCLCK_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
[ok,dt,nn,exprs]=scicos_getvalue("Set Multifrequency clock parameters",["basic period (1/f)","multiply by (n)"],list("vec",1,"vec",1),exprs);
if (ok) {
model.ipar=nn;
model.rpar=dt;
hh=model.firing;
hh[2]=0;
model.firing=hh;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
}
}
MFCLCK_f.prototype.define = function MFCLCK_f() {
nn=2;
dt=0.1;
model=scicos_model();
model.sim="mfclck";
model.evtin=1;
model.evtout=[1,1];
model.dstate=0;
model.rpar=dt;
model.ipar=nn;
model.blocktype="d";
model.firing=[-1,0];
model.dep_ut=[None,None];
exprs=[string(dt),string(nn)];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
MFCLCK_f.prototype.details = function MFCLCK_f() {
}
}
/* autogenerated from "macros/Linear/REGISTER_f.sci" */
function REGISTER_f() {
REGISTER_f.prototype.get = function REGISTER_f() {
}
REGISTER_f.prototype.set = function REGISTER_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,z0,exprs]=scicos_getvalue("Set delay parameters","Register initial condition",list("vec",-1),exprs);
if (!ok) {
break
}
if (prod(size(z0))<1) {
message("Register length must be at least 1");
ok=None;
}
if (ok) {
graphics.exprs=exprs;
model.dstate=z0;
x.graphics=graphics;
x.model=model;
break
}
}
}
REGISTER_f.prototype.define = function REGISTER_f() {
z0=zeros(10,1);
model=scicos_model();
model.sim="delay";
model.in=1;
model.out=1;
model.evtin=1;
model.dstate=z0;
model.blocktype="d";
model.dep_ut=[None,None];
exprs=strcat(string(z0),";");
gr_i=[];
x=standard_define([2.5,2.5],model,exprs,gr_i);
}
REGISTER_f.prototype.details = function REGISTER_f() {
}
}
/* autogenerated from "macros/Linear/SAMPHOLD.sci" */
function SAMPHOLD() {
SAMPHOLD.prototype.get = function SAMPHOLD() {
}
SAMPHOLD.prototype.set = function SAMPHOLD() {
x=arg1;
x.model.firing=[];
}
SAMPHOLD.prototype.define = function SAMPHOLD() {
in1=-1;
model=scicos_model();
model.sim=list("samphold4",4);
model.in=-1;
model.out=-1;
model.evtin=1;
model.blocktype="d";
model.dep_ut=[true,None];
gr_i=[];
x=standard_define([2,2],model," ",gr_i);
}
SAMPHOLD.prototype.details = function SAMPHOLD() {
}
}
/* autogenerated from "macros/Linear/BIGSOM_f.sci" */
function BIGSOM_f() {
BIGSOM_f.prototype.get = function BIGSOM_f() {
}
BIGSOM_f.prototype.set = function BIGSOM_f() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
while (true) {
[ok,sgn,exprs]=scicos_getvalue("Set sum block parameters","Inputs ports signs/gain",list("vec",-1),exprs);
if (!ok) {
break
}
in1=-ones(size(sgn,"*"),1);
[model,graphics,ok]=check_io(model,graphics,in1,-1,[],[]);
if (ok) {
model.rpar=sgn.slice();
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
BIGSOM_f.prototype.define = function BIGSOM_f() {
sgn=[1,1];
model=scicos_model();
model.sim=list("sum",2);
model.in=[-1,-1];
model.out=-1;
model.rpar=sgn;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=sci2exp(sgn);
gr_i=[];
x=standard_define([2,3],model,exprs,gr_i);
}
BIGSOM_f.prototype.details = function BIGSOM_f() {
}
}
/* autogenerated from "macros/Linear/SAMPLEHOLD_f.sci" */
function SAMPLEHOLD_f() {
SAMPLEHOLD_f.prototype.get = function SAMPLEHOLD_f() {
}
SAMPLEHOLD_f.prototype.set = function SAMPLEHOLD_f() {
x=arg1;
x.model.firing=[];
}
SAMPLEHOLD_f.prototype.define = function SAMPLEHOLD_f() {
in1=-1;
model=scicos_model();
model.sim="samphold";
model.in=-1;
model.out=-1;
model.evtin=1;
model.blocktype="d";
model.dep_ut=[true,None];
gr_i=[];
x=standard_define([2,2],model," ",gr_i);
}
SAMPLEHOLD_f.prototype.details = function SAMPLEHOLD_f() {
}
}
/* autogenerated from "macros/Linear/DIFF_c.sci" */
function DIFF_c() {
DIFF_c.prototype.get = function DIFF_c() {
}
DIFF_c.prototype.set = function DIFF_c() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
ask_again=None;
[ok,x0,xd0,exprs]=scicos_getvalue("Set continuous linear system parameters",["Initial state","Initial Derivative"],list("vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
x0=x0.slice();
N=size(x0,"*");
xd0=xd0.slice();
Nxd=size(xd0,"*");
if ((N!=Nxd)) {
message("Incompatible sizes: states and their derivatives should have the same size ");
ask_again=true;
}
if ((N<=0&&!ask_again)) {
x_message("number of states must be > 0 ");
ask_again=true;
}
if (!ask_again) {
graphics.exprs=exprs;
model.state=[x0,xd0];
model.out=[N];
model.in=N;
x.graphics=graphics;
x.model=model;
break
}
}
x.model.firing=[];
}
DIFF_c.prototype.define = function DIFF_c() {
x0=[0,0];
model=scicos_model();
model.sim=list("diffblk_c",10004);
model.in=1;
model.out=1;
model.state=x0;
model.blocktype="c";
model.dep_ut=[None,true];
exprs=[strcat(sci2exp(x0(1))),strcat(sci2exp(x0(2)))];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
DIFF_c.prototype.details = function DIFF_c() {
}
}
/* autogenerated from "macros/Linear/INTEGRAL_f.sci" */
function INTEGRAL_f() {
INTEGRAL_f.prototype.get = function INTEGRAL_f() {
}
INTEGRAL_f.prototype.set = function INTEGRAL_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,x0,exprs]=scicos_getvalue("Set continuous linear system parameters","Initial state",list("vec",1),exprs);
if (!ok) {
break
}
graphics.exprs=exprs;
model.state=x0;
x.graphics=graphics;
x.model=model;
break
}
x.model.firing=[];
}
INTEGRAL_f.prototype.define = function INTEGRAL_f() {
x0=0;
model=scicos_model();
model.sim="integr";
model.in=1;
model.out=1;
model.state=x0;
model.blocktype="c";
model.dep_ut=[None,true];
exprs=strcat(sci2exp(x0));
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
INTEGRAL_f.prototype.details = function INTEGRAL_f() {
}
}
/* autogenerated from "macros/Linear/DOLLAR_f.sci" */
function DOLLAR_f() {
DOLLAR_f.prototype.get = function DOLLAR_f() {
}
DOLLAR_f.prototype.set = function DOLLAR_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")<2) {
exprs[2]="0";
}
while (true) {
[ok,a,inh,exprs]=scicos_getvalue("Set 1/z block parameters",["initial condition","Inherit (no:0, yes:1)"],list("vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
out=size(a,"*");
if (out==0) {
out=[];
}
in1=out;
if (ok) {
[model,graphics,ok]=check_io(model,graphics,-1,-1,ones(1-inh,1),[]);
}
if (ok) {
graphics.exprs=exprs;
model.dstate=a;
model.in=in1;
model.out=out;
x.graphics=graphics;
x.model=model;
break
}
}
}
DOLLAR_f.prototype.define = function DOLLAR_f() {
z=0;
inh=0;
in1=1;
exprs=string([z,inh]);
model=scicos_model();
model.sim="dollar";
model.in=in1;
model.out=in1;
model.evtin=1-inh;
model.dstate=z;
model.blocktype="d";
model.dep_ut=[None,None];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
DOLLAR_f.prototype.details = function DOLLAR_f() {
}
}
/* autogenerated from "macros/Linear/CLINDUMMY_f.sci" */
function CLINDUMMY_f() {
CLINDUMMY_f.prototype.get = function CLINDUMMY_f() {
}
CLINDUMMY_f.prototype.set = function CLINDUMMY_f() {
x=arg1;
}
CLINDUMMY_f.prototype.define = function CLINDUMMY_f() {
x0=0;
model=scicos_model();
model.sim=list("cdummy",4);
model.state=x0;
model.blocktype="c";
model.firing=[];
model.dep_ut=[None,true];
gr_i=[];
x=standard_define([3,2],model,[],gr_i);
}
CLINDUMMY_f.prototype.details = function CLINDUMMY_f() {
}
}
/* autogenerated from "macros/Linear/DERIV.sci" */
function DERIV() {
DERIV.prototype.get = function DERIV() {
}
DERIV.prototype.set = function DERIV() {
x=arg1;
}
DERIV.prototype.define = function DERIV() {
model=scicos_model();
model.sim=list("deriv",4);
model.in=-1;
model.out=-1;
model.blocktype="x";
model.dep_ut=[true,None];
exprs=[];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
DERIV.prototype.details = function DERIV() {
}
}
/* autogenerated from "macros/Linear/VARIABLE_DELAY.sci" */
function VARIABLE_DELAY() {
VARIABLE_DELAY.prototype.get = function VARIABLE_DELAY() {
}
VARIABLE_DELAY.prototype.set = function VARIABLE_DELAY() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
nin=model.in(1);
while (true) {
[ok,T,init,N,exprs]=scicos_getvalue("Set delay parameters",["Max delay","initial input","Buffer size"],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (N<2) {
message("Buffer must be larger than 2");
ok=None;
}
if (T<=0) {
message("Delay must be positive");
ok=None;
}
if (ok) {
[model,graphics,ok]=check_io(model,graphics,[-1,1],-1,[],[]);
}
if (ok) {
graphics.exprs=exprs;
model.rpar=[T,init];
model.ipar=N;
x.graphics=graphics;
x.model=model;
break
}
}
}
VARIABLE_DELAY.prototype.define = function VARIABLE_DELAY() {
nin=1;
T=1;
init=0;
N=1024;
model=scicos_model();
model.sim=list("variable_delay",4);
model.in=[nin,1];
model.out=nin;
model.rpar=[T,init];
model.ipar=N;
model.blocktype="d";
model.dep_ut=[None,None];
exprs=[string(T),string(init),string(N)];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
VARIABLE_DELAY.prototype.details = function VARIABLE_DELAY() {
}
}
/* autogenerated from "macros/Linear/REGISTER.sci" */
function REGISTER() {
REGISTER.prototype.get = function REGISTER() {
}
REGISTER.prototype.set = function REGISTER() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,1)==1) {
exprs=[exprs,sci2exp(1)];
}
while (true) {
[ok,z0,it,exprs]=scicos_getvalue("Set delay parameters",["Register initial condition","Datatype (1=double 3=int32 ...)"],list("vec",-1,"vec",1),exprs);
if (!ok) {
break
}
if (prod(size(z0))<1) {
message("Register length must be at least 1");
ok=None;
}
if (it==1) {
model.sim=list("delay4",4);
z0=double(z0);
model.dstate=z0;
model.odstate=list();
} else {
if (it==3) {
model.sim=list("delay4_i32",4);
z0=int32(z0);
} else if (it==4) {
model.sim=list("delay4_i16",4);
z0=int16(z0);
} else if (it==5) {
model.sim=list("delay4_i8",4);
z0=int8(z0);
} else if (it==6) {
model.sim=list("delay4_ui32",4);
z0=uint32(z0);
} else if (it==7) {
model.sim=list("delay4_ui16",4);
z0=uint16(z0);
} else if (it==8) {
model.sim=list("delay4_ui8",4);
z0=uint8(z0);
} else {
message("Datatype is not supported");
ok=None;
}
model.odstate=list(z0);
model.dstate=[];
}
if (ok) {
in1=[1,1];
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(in1,it),1,[]);
}
if (ok) {
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
REGISTER.prototype.define = function REGISTER() {
z0=zeros(10,1);
model=scicos_model();
model.sim=list("delay4",4);
model.in=1;
model.out=1;
model.evtin=1;
model.dstate=z0;
model.blocktype="d";
model.dep_ut=[None,None];
exprs=strcat(string(z0),";");
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
REGISTER.prototype.details = function REGISTER() {
}
}
/* autogenerated from "macros/Linear/INTEGRAL.sci" */
function INTEGRAL() {
INTEGRAL.prototype.get = function INTEGRAL() {
}
INTEGRAL.prototype.set = function INTEGRAL() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,x0,reinit,satur,maxp,lowp,exprs]=scicos_getvalue("Set Integral block parameters",["Initial Condition","With re-intialization (1:yes, 0:no)","With saturation (1:yes, 0:no)","Upper limit","Lower limit"],list("vec",-1,"vec",1,"vec",1,"vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
x0=x0.slice();
maxp=maxp.slice();
lowp=lowp.slice();
if (reinit!=0) {
reinit=1;
}
if (satur!=0) {
satur=1;
if (size(maxp,"*")==1) {
maxp=maxp*ones(x0);
}
if (size(lowp,"*")==1) {
lowp=lowp*ones(x0);
}
if ((size(x0,1)!=size(maxp,1)||size(x0,1)!=size(lowp,1))) {
message("x0 and Upper limit and Lower limit must have same size");
ok=None;
} else if (or(maxp<=lowp)) {
message("Upper limits must be > Lower limits");
ok=None;
} else if (or(x0>maxp)||or(x0<lowp)) {
message("Initial condition x0 should be inside the limits");
ok=None;
} else {
rpar=[maxp,lowp];
model.nzcross=size(x0,1);
model.nmode=size(x0,1);
}
} else {
rpar=[];
model.nzcross=0;
model.nmode=0;
}
if (ok) {
model.rpar=rpar;
model.state=x0;
[model,graphics,ok]=check_io(model,graphics,size(x0,1)*[1,ones(reinit,1)],size(x0,1),ones(reinit,1),[]);
}
if (ok) {
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
INTEGRAL.prototype.define = function INTEGRAL() {
maxp=1;
minp=-1;
rpar=[];
model=scicos_model();
model.state=0;
model.sim=list("integral_func",4);
model.in=1;
model.out=1;
model.rpar=rpar;
model.blocktype="c";
model.dep_ut=[None,true];
exprs=string([0,0,0,maxp,minp]);
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
x.graphics.id="1/s";
}
INTEGRAL.prototype.details = function INTEGRAL() {
}
}
/* autogenerated from "macros/Linear/SOM_f.sci" */
function SOM_f() {
SOM_f.prototype.get = function SOM_f() {
}
SOM_f.prototype.set = function SOM_f() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
if (size(exprs,"*")==2) {
exprs=exprs(2);
}
if (size(exprs,"*")!=3) {
exprs=string(model.rpar);
}
if (graphics.flip) {
labs=["down","left","up"];
} else {
labs=["down","right","up"];
}
str=["This sum block is obsolete","parameters cannot be modified. Please replace it with new sum block","and gain blocks in the linear palette"," ","Input ports are located at up, side and  down positions.","Current gains are:"];
str=[str,(part(labs.slice(),1,7)+exprs.slice())];
message(str);
}
SOM_f.prototype.define = function SOM_f() {
sgn=[1,1,1];
model=scicos_model();
model.sim=list("sum",2);
model.in=[-1,-1,-1];
model.out=-1;
model.rpar=sgn;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[sci2exp(1),sci2exp(sgn)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
SOM_f.prototype.details = function SOM_f() {
}
}
/* autogenerated from "macros/Linear/SAMPHOLD_m.sci" */
function SAMPHOLD_m() {
SAMPHOLD_m.prototype.get = function SAMPHOLD_m() {
}
SAMPHOLD_m.prototype.set = function SAMPHOLD_m() {
x=arg1;
x.model.firing=[];
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
while (true) {
[ok,it,exprs]=scicos_getvalue("Set parameters Block",["Datatype(1=real double 2=Complex 3=int32 ...)"],list("vec",1),label);
if (!ok) {
break
}
if (((it<1)||(it>8))) {
message("Datatype is not supported");
ok=None;
}
if (ok) {
in1=[model.in,model.in2];
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(in1,it),1,[]);
if (ok) {
graphics.exprs=exprs;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
}
SAMPHOLD_m.prototype.define = function SAMPHOLD_m() {
model=scicos_model();
model.sim=list("samphold4_m",4);
model.in=-1;
model.in2=-2;
model.intyp=1;
model.outtyp=1;
model.out=-1;
model.out2=-2;
model.evtin=1;
model.blocktype="d";
model.dep_ut=[true,None];
label=[sci2exp(1)];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
SAMPHOLD_m.prototype.details = function SAMPHOLD_m() {
}
}
/* autogenerated from "macros/Linear/TIME_DELAY.sci" */
function TIME_DELAY() {
TIME_DELAY.prototype.get = function TIME_DELAY() {
}
TIME_DELAY.prototype.set = function TIME_DELAY() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
nin=model.in(1);
while (true) {
[ok,T,init,N,exprs]=scicos_getvalue("Set delay parameters",["Delay","initial input","Buffer size"],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (N<2) {
message("Buffer must be larger than 2");
ok=None;
}
if (T<=0) {
message("Delay must be positive");
ok=None;
}
if (ok) {
[model,graphics,ok]=check_io(model,graphics,[-1],-1,[],[]);
}
if (ok) {
graphics.exprs=exprs;
model.rpar=[T,init];
model.ipar=N;
model.dep_ut=[None,true];
x.graphics=graphics;
x.model=model;
break
}
}
}
TIME_DELAY.prototype.define = function TIME_DELAY() {
nin=1;
T=1;
init=0;
N=1024;
model=scicos_model();
model.sim=list("time_delay",4);
model.in=[nin];
model.out=nin;
model.rpar=[T,init];
model.ipar=N;
model.blocktype="x";
model.dep_ut=[None,true];
exprs=[string(T),string(init),string(N)];
gr_i=[];
x=standard_define([3.5,2],model,exprs,gr_i);
}
TIME_DELAY.prototype.details = function TIME_DELAY() {
}
}
/* autogenerated from "macros/Linear/SUM_f.sci" */
function SUM_f() {
SUM_f.prototype.get = function SUM_f() {
}
SUM_f.prototype.set = function SUM_f() {
x=arg1;
}
SUM_f.prototype.define = function SUM_f() {
model=scicos_model();
model.sim=list("plusblk",2);
model.in=[-1,-1,-1];
model.out=-1;
model.blocktype="c";
model.dep_ut=[true,None];
gr_i=[];
exprs=[];
x=standard_define([1,1],model,exprs,gr_i);
}
SUM_f.prototype.details = function SUM_f() {
}
}
/* autogenerated from "macros/Sinks/BARXY.sci" */
function BARXY() {
BARXY.prototype.get = function BARXY() {
}
BARXY.prototype.set = function BARXY() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,xmin,xmax,ymin,ymax,thickness,exprs]=scicos_getvalue("Set Scope parameters",["Xmin","Xmax","Ymin","Ymax","Segs Thickness"],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
mess=[];
if (ymin>=ymax) {
mess=[mess,"Ymax must be greater than Ymin"," "];
ok=None;
}
if (xmin>=xmax) {
mess=[mess,"Xmax must be greater than Xmin"," "];
ok=None;
}
if (thickness<=0) {
mess=[mess,"Thickness must be strictly positive."];
ok=None;
}
if (!ok) {
message(mess);
} else {
model.rpar=[xmin,xmax,ymin,ymax];
model.ipar=thickness;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
BARXY.prototype.define = function BARXY() {
model=scicos_model();
xmin=-15;
xmax=15;
ymin=-15;
ymax=15;
model.sim=list("BARXY_sim",5);
model.blocktype="d";
model.dep_ut=[true,None];
model.in=[-1,-1];
model.intyp=[1];
model.out=[];
model.evtin=[1];
model.rpar=[xmin,xmax,ymin,ymax];
model.ipar=1;
x=standard_define([2,2],model,[],[]);
x.graphics.in_implicit=["E","E"];
x.graphics.out_implicit=[];
x.graphics.exprs=["-15","15","-15","15","1"];
}
BARXY.prototype.details = function BARXY() {
}
}
/* autogenerated from "macros/Sinks/CANIMXY.sci" */
function CANIMXY() {
CANIMXY.prototype.get = function CANIMXY() {
}
CANIMXY.prototype.set = function CANIMXY() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,nbr_curves,clrs,siz,win,wpos,wdim,xmin,xmax,ymin,ymax,N,exprs]=scicos_getvalue("Set Scope parameters",["Number of Curves","color (>0) or mark (<0)","line or mark size","Output window number (-1 for automatic)","Output window position","Output window sizes","Xmin","Xmax","Ymin","Ymax","Buffer size"],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",-1,"vec",-1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
mess=[];
if (size(wpos,"*")!=0&&size(wpos,"*")!=2) {
mess=[mess,"Window position must be [] or a 2 vector"," "];
ok=None;
}
if (size(wdim,"*")!=0&&size(wdim,"*")!=2) {
mess=[mess,"Window dim must be [] or a 2 vector"," "];
ok=None;
}
if (win<-1) {
mess=[mess,"Window number cannot be inferior than -1"," "];
ok=None;
}
if (nbr_curves<=0) {
mess=[mess,"Number of curves cannot be negative or null"," "];
ok=None;
}
if (N<1) {
mess=[mess,"Buffer size must be at least 1"," "];
ok=None;
}
if (N==1&&clrs>0) {
mess=[mess,"Buffer size must be at least 2"," "];
ok=None;
}
if (ymin>=ymax) {
mess=[mess,"Ymax must be greater than Ymin"," "];
ok=None;
}
if (xmin>=xmax) {
mess=[mess,"Xmax must be greater than Xmin"," "];
ok=None;
}
if (!ok) {
message(mess);
} else {
in1=nbr_curves*ones(2,1);
in2=ones(2,1);
[model,graphics,ok]=set_io(model,graphics,list([in1,in2],ones(2,1)),list(),ones(1,1),[]);
if (wpos==[]) {
wpos=[-1,-1];
}
if (wdim==[]) {
wdim=[-1,-1];
}
rpar=[xmin,xmax,ymin,ymax];
ipar=[win,1,N,clrs,siz,0,wpos.slice(),wdim.slice(),nbr_curves];
model.rpar=rpar;
model.ipar=ipar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CANIMXY.prototype.define = function CANIMXY() {
win=-1;
clrs=-4;
N=2;
siz=1;
wpos=[-1,-1];
wdim=[-1,-1];
xmin=-15;
xmax=15;
ymin=-15;
ymax=+15;
nbr_curves=1;
model=scicos_model();
model.sim=list("canimxy",4);
model.in=[1,1];
model.in2=[1,1];
model.intyp=[1,1];
model.evtin=1;
model.rpar=[xmin,xmax,ymin,ymax];
model.ipar=[win,1,N,clrs,siz,0,wpos.slice(),wdim.slice(),nbr_curves];
model.blocktype="d";
model.firing=[];
model.dep_ut=[None,None];
exprs=[string(nbr_curves),string(clrs),string(siz),string(win),"[]","[]",string(xmin),string(xmax),string(ymin),string(ymax),string(N)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CANIMXY.prototype.details = function CANIMXY() {
}
}
/* autogenerated from "macros/Sinks/CSCOPE.sci" */
function CSCOPE() {
CSCOPE.prototype.get = function CSCOPE() {
}
CSCOPE.prototype.set = function CSCOPE() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,clrs,win,wpos,wdim,ymin,ymax,per,N,heritance,nom,exprs]=scicos_getvalue("Set Scope parameters",["Color (>0) or mark (<0) vector (8 entries)","Output window number (-1 for automatic)","Output window position","Output window sizes","Ymin","Ymax","Refresh period","Buffer size","Accept herited events 0/1","Name of Scope (label&Id)"],list("vec",8,"vec",1,"vec",-1,"vec",-1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"str",1),exprs);
if (!ok) {
break
}
mess=[];
if (size(wpos,"*")!=0&&size(wpos,"*")!=2) {
mess=[mess,"Window position must be [] or a 2 vector"," "];
ok=None;
}
if (size(wdim,"*")!=0&&size(wdim,"*")!=2) {
mess=[mess,"Window dim must be [] or a 2 vector"," "];
ok=None;
}
if (win<-1) {
mess=[mess,"Window number can\'t be  < -1"," "];
ok=None;
}
if (per<=0) {
mess=[mess,"Refresh period must be positive"," "];
ok=None;
}
if (N<2) {
mess=[mess,"Buffer size must be at least 2"," "];
ok=None;
}
if (ymin>=ymax) {
mess=[mess,"Ymax must be greater than Ymin"," "];
ok=None;
}
if (!or(heritance==[0,1])) {
mess=[mess,"Accept herited events must be 0 or 1"," "];
ok=None;
}
if (!ok) {
message(["Some specified values are inconsistent:"," ",mess]);
}
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list([-1,1],1),list(),ones(1-heritance,1),[]);
}
if (ok) {
if (wpos==[]) {
wpos=[-1,-1];
}
if (wdim==[]) {
wdim=[-1,-1];
}
rpar=[0,ymin,ymax,per];
ipar=[win,1,N,clrs.slice(),wpos.slice(),wdim.slice()];
model.rpar=rpar;
model.ipar=ipar;
model.evtin=ones(1-heritance,1);
model.label=nom;
graphics.id=nom;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CSCOPE.prototype.define = function CSCOPE() {
win=-1;
wdim=[600,400];
wpos=[-1,-1];
clrs=[1,3,5,7,9,11,13,15];
N=20;
ymin=-15;
ymax=+15;
per=30;
model=scicos_model();
model.sim=list("cscope",4);
model.in=-1;
model.in2=1;
model.evtin=1;
model.rpar=[0,ymin,ymax,per];
model.ipar=[win,1,N,clrs,wpos,wdim];
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[strcat(string(clrs)," "),string(win),sci2exp([]),sci2exp(wdim),string(ymin),string(ymax),string(per),string(N),transpose(string(0)),emptystr()];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CSCOPE.prototype.details = function CSCOPE() {
}
}
/* autogenerated from "macros/Sinks/CANIMXY3D.sci" */
function CANIMXY3D() {
CANIMXY3D.prototype.get = function CANIMXY3D() {
}
CANIMXY3D.prototype.set = function CANIMXY3D() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,nbr_curves,clrs,siz,win,wpos,wdim,vec_x,vec_y,vec_z,param3ds,N,exprs]=scicos_getvalue("Set Scope parameters",["Number of curves","color (>0) or mark (<0)","line or mark size","Output window number (-1 for automatic)","Output window position","Output window sizes","Xmin and Xmax","Ymin and Ymax","Zmin and Zmax","Alpha and Theta","Buffer size"],list("vec",1,"vec",-1,"vec",-1,"vec",1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",1),exprs);
if (!ok) {
break
}
mess=[];
if (size(wpos,"*")!=0&&size(wpos,"*")!=2) {
mess=[mess,"Window position must be [] or a 2 vector"," "];
ok=None;
}
if (size(wdim,"*")!=0&&size(wdim,"*")!=2) {
mess=[mess,"Window dim must be [] or a 2 vector"," "];
ok=None;
}
if (win<-1) {
mess=[mess,"Window number cannot be inferior than -1"," "];
ok=None;
}
if (size(clrs,"*")!=size(siz,"*")) {
mess=[mess,"Colors and Size must have same size"," "];
ok=None;
}
if (nbr_curves<=0) {
mess=[mess,"Number of curves cannot be negative or null"," "];
ok=None;
}
if (size(clrs,"*")<nbr_curves) {
mess=[mess,"You must have at least same size for clrs and the number of curves"," "];
ok=None;
}
if (N<1) {
mess=[mess,"Buffer size must be at least 1"," "];
ok=None;
}
if (N<2) {
for(i=1;i<=nbr_curves;i+=1) {
if (clrs(i)>0) {
mess=[mess,"Buffer size must be at least 2 or Change a color (must be <0)"," "];
ok=None;
}
}
}
if (vec_y(1)>=vec_y(2)) {
mess=[mess,"Ymax must be higher than Ymin"," "];
ok=None;
}
if (vec_x(1)>=vec_x(2)) {
mess=[mess,"Xmax must be higher than Xmin"," "];
ok=None;
}
if (vec_z(1)>=vec_z(2)) {
mess=[mess,"Zmax must be higher than Zmin"," "];
ok=None;
}
if (!ok) {
message(mess);
} else {
in1=nbr_curves*ones(3,1);
in2=ones(3,1);
[model,graphics,ok]=set_io(model,graphics,list([in1,in2],ones(3,1)),list(),ones(1,1),[]);
if (wpos==[]) {
wpos=[-1,-1];
}
if (wdim==[]) {
wdim=[-1,-1];
}
rpar=[vec_x.slice(),vec_y.slice(),vec_z.slice(),param3ds.slice()];
size_siz=size(siz,"*");
ipar=[win,size_siz,N,clrs.slice(),siz.slice(),1,wpos.slice(),wdim.slice(),nbr_curves];
model.rpar=rpar;
model.ipar=ipar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CANIMXY3D.prototype.define = function CANIMXY3D() {
win=-1;
N=2;
clrs=[1,2,3,4,5,6,7,13];
siz=[1,1,1,1,1,1,1,1];
wpos=[-1,-1];
wdim=[-1,-1];
param3ds=[50,280];
vec_x=[-15,15];
vec_y=[-15,15];
vec_z=[-15,15];
nbr_curves=1;
model=scicos_model();
model.sim=list("canimxy3d",4);
model.in=[1,1,1];
model.evtin=1;
model.in2=[1,1,1];
model.intyp=[1,1,1];
model.rpar=[vec_x.slice(),vec_y.slice(),vec_z.slice(),param3ds.slice()];
model.ipar=[win,8,N,clrs.slice(),siz.slice(),8,wpos.slice(),wdim.slice(),nbr_curves];
model.blocktype="d";
model.firing=[];
model.dep_ut=[None,None];
exprs=[string(nbr_curves),strcat(string(clrs)," "),strcat(string(siz)," "),string(win),"[]","[]",strcat(string(vec_x)," "),strcat(string(vec_y)," "),strcat(string(vec_z)," "),strcat(string(param3ds)," "),string(N)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CANIMXY3D.prototype.details = function CANIMXY3D() {
}
}
/* autogenerated from "macros/Sinks/CMAT3D.sci" */
function CMAT3D() {
CMAT3D.prototype.get = function CMAT3D() {
}
CMAT3D.prototype.set = function CMAT3D() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,vec_x,vec_y,colormap,cmin,cmax,exprs]=scicos_getvalue("Set Scope parameters",["Bounds Vector X (-1 for standard)","Bounds Vector Y (-1 for standard)","ColorMap","Zmin","Zmax"],list("vec",-1,"vec",-1,"vec",-1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
mess=[];
if (size(vec_x,"*")!=size(vec_y,"*")) {
mess=[mess,"Vector X and Vector Y must have the same size"," "];
ok=None;
}
if (cmax<=cmin) {
mess=[mess,"Error with minimum and maximum value"," "];
ok=None;
}
if (!ok) {
message(["Some specified values are inconsistent:"," ",mess]);
}
if (ok) {
size_x=size(vec_x,"*");
size_c=size(colormap.slice(),1);
ipar=[cmin,cmax,size_c,size_x];
rpar=[colormap.slice(),vec_x.slice(),vec_y.slice()];
model.ipar=ipar;
model.rpar=rpar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CMAT3D.prototype.define = function CMAT3D() {
cmin=0;
cmax=100;
colormap=jetcolormap(25);
size_c=25;
x=-1;
y=-1;
size_x=1;
size_y=1;
model=scicos_model();
model.sim=list("cmat3d",4);
model.in=-1;
model.in2=-2;
model.intyp=1;
model.evtin=1;
model.ipar=[cmin,cmax,size_c,size_x,size_y];
model.rpar=[colormap.slice(),x,y];
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[strcat(string(x)," "),strcat(string(y)," "),string("jetcolormap(25)"),string(cmin),string(cmax)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CMAT3D.prototype.details = function CMAT3D() {
}
}
/* autogenerated from "macros/Sinks/CSCOPXY3D.sci" */
function CSCOPXY3D() {
CSCOPXY3D.prototype.get = function CSCOPXY3D() {
}
CSCOPXY3D.prototype.set = function CSCOPXY3D() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,nbr_curves,clrs,siz,win,wpos,wdim,vec_x,vec_y,vec_z,param3ds,N,exprs]=scicos_getvalue("Set Scope parameters",["Number of curves","color (>0) or mark (<0)","Line or Mark Size","Output window number (-1 for automatic)","Output window position","Output window sizes","Xmin and Xmax","Ymin and Ymax","Zmin and Zmax","Alpha and Theta","Buffer size"],list("vec",1,"vec",-1,"vec",-1,"vec",1,"vec",-1,"vec",-1,"vec",2,"vec",2,"vec",2,"vec",2,"vec",1),exprs);
if (!ok) {
break
}
mess=[];
if (size(wpos,"*")!=0&&size(wpos,"*")!=2) {
mess=[mess,"Window position must be [] or a 2 vector"," "];
ok=None;
}
if (size(wdim,"*")!=0&&size(wdim,"*")!=2) {
mess=[mess,"Window dim must be [] or a 2 vector"," "];
ok=None;
}
if (size(clrs,"*")!=size(siz,"*")) {
mess=[mess,"Colors and Size must have same size"," "];
ok=None;
}
if (nbr_curves<=0) {
mess=[mess,"Number of curves cannot be negative or null"," "];
ok=None;
}
if (win<-1) {
mess=[mess,"Window number cannot be inferior than -1"," "];
ok=None;
}
if (N<1) {
mess=[mess,"Buffer size must be at least 1"," "];
ok=None;
}
if (N<2) {
for(i=1;i<=size(clrs,"*");i+=1) {
if (clrs(i)>0) {
mess=[mess,"Buffer size must be at least 2 or Change a color (must be >0)"," "];
ok=None;
}
}
}
if (vec_y(1)>=vec_y(2)) {
mess=[mess,"Ymax must be higher than Ymin"," "];
ok=None;
}
if (vec_x(1)>=vec_x(2)) {
mess=[mess,"Xmax must be higher than Xmin"," "];
ok=None;
}
if (vec_z(1)>=vec_z(2)) {
mess=[mess,"Zmax must be higher than Zmin"," "];
ok=None;
}
if (ok) {
in1=nbr_curves*ones(3,1);
in2=ones(3,1);
[model,graphics,ok]=set_io(model,graphics,list([in1,in2],ones(3,1)),list(),ones(1,1),[]);
if (wpos==[]) {
wpos=[-1,-1];
}
if (wdim==[]) {
wdim=[-1,-1];
}
rpar=[vec_x.slice(),vec_y.slice(),vec_z.slice(),param3ds.slice()];
size_siz=size(siz,"*");
ipar=[win,size_siz,N,clrs.slice(),siz.slice(),1,wpos.slice(),wdim.slice(),nbr_curves];
model.rpar=rpar;
model.ipar=ipar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
} else {
message(mess);
}
}
}
CSCOPXY3D.prototype.define = function CSCOPXY3D() {
win=-1;
clrs=[1,2,3,4,5,6,7,13];
siz=[1,1,1,1,1,1,1,1];
wdim=[600,400];
wpos=[-1,-1];
N=2;
param3ds=[50,280];
vec_x=[-15,15];
vec_y=[-15,15];
vec_z=[-15,15];
nbr_curves=1;
model=scicos_model();
model.sim=list("cscopxy3d",4);
model.in=[1,1,1];
model.in2=[1,1,1];
model.intyp=[1,1,1];
model.evtin=1;
model.rpar=[vec_x.slice(),vec_y.slice(),vec_z.slice(),param3ds.slice()];
model.ipar=[win,8,N,clrs.slice(),siz.slice(),8,wpos.slice(),wdim.slice(),nbr_curves];
model.blocktype="d";
model.dep_ut=[None,None];
exprs=[string(nbr_curves),strcat(string(clrs)," "),strcat(string(siz)," "),string(win),sci2exp([]),sci2exp(wdim),strcat(string(vec_x)," "),strcat(string(vec_y)," "),strcat(string(vec_z)," "),strcat(string(param3ds)," "),string(N)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CSCOPXY3D.prototype.details = function CSCOPXY3D() {
}
}
/* autogenerated from "macros/Sinks/CSCOPXY.sci" */
function CSCOPXY() {
CSCOPXY.prototype.get = function CSCOPXY() {
}
CSCOPXY.prototype.set = function CSCOPXY() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,nbr_curves,clrs,siz,win,wpos,wdim,xmin,xmax,ymin,ymax,N,exprs]=scicos_getvalue("Set Scope parameters",["Number of Curves","color (>0) or mark (<0)","line or mark size","Output window number (-1 for automatic)","Output window position","Output window sizes","Xmin","Xmax","Ymin","Ymax","Buffer size"],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",-1,"vec",-1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
mess=[];
if (size(wpos,"*")!=0&&size(wpos,"*")!=2) {
mess=[mess,"Window position must be [] or a 2 vector"," "];
ok=None;
}
if (size(wdim,"*")!=0&&size(wdim,"*")!=2) {
mess=[mess,"Window dim must be [] or a 2 vector"," "];
ok=None;
}
if (nbr_curves<=0) {
mess=[mess,"Number of Curves cannot be negative or null"," "];
ok=None;
}
if (win<-1) {
mess=[mess,"Window number cannot be inferior than -1"," "];
ok=None;
}
if (N<1) {
mess=[mess,"Buffer size must be at least 1"," "];
ok=None;
}
if (N==1&&clrs>0) {
mess=[mess,"Buffer size must be at least 2"," "];
ok=None;
}
if (ymin>=ymax) {
mess=[mess,"Ymax must be greater than Ymin"," "];
ok=None;
}
if (xmin>=xmax) {
mess=[mess,"Xmax must be greater than Xmin"," "];
ok=None;
}
if (!ok) {
message(mess);
} else {
in1=nbr_curves*ones(2,1);
in2=ones(2,1);
[model,graphics,ok]=set_io(model,graphics,list([in1,in2],ones(2,1)),list(),ones(1,1),[]);
if (wpos==[]) {
wpos=[-1,-1];
}
if (wdim==[]) {
wdim=[-1,-1];
}
rpar=[xmin,xmax,ymin,ymax];
ipar=[win,1,N,clrs,siz,1,wpos.slice(),wdim.slice(),nbr_curves];
model.rpar=rpar;
model.ipar=ipar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CSCOPXY.prototype.define = function CSCOPXY() {
win=-1;
clrs=4;
siz=1;
wdim=[600,400];
wpos=[-1,-1];
N=2;
xmin=-15;
xmax=15;
ymin=-15;
ymax=+15;
nbr_curves=1;
model=scicos_model();
model.sim=list("cscopxy",4);
model.in=[1,1];
model.in2=[1,1];
model.intyp=[1,1];
model.evtin=1;
model.rpar=[xmin,xmax,ymin,ymax];
model.ipar=[win,1,N,clrs,siz,1,wpos.slice(),wdim.slice(),nbr_curves];
model.blocktype="d";
model.dep_ut=[None,None];
exprs=[string(nbr_curves),sci2exp(clrs),sci2exp(siz),string(win),sci2exp([]),sci2exp(wdim),string(xmin),string(xmax),string(ymin),string(ymax),string(N)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CSCOPXY.prototype.details = function CSCOPXY() {
}
}
/* autogenerated from "macros/Sinks/OUTIMPL_f.sci" */
function OUTIMPL_f() {
OUTIMPL_f.prototype.get = function OUTIMPL_f() {
}
OUTIMPL_f.prototype.set = function OUTIMPL_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")==2) {
exprs=exprs(1);
}
while (true) {
[ok,prt,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"OUTIMPL_f")," ",gettext("Implicit output port")],gettext("Port number"),list("vec",1),exprs);
if (!ok) {
break
}
prt=int(prt);
if (prt<=0) {
block_parameter_error(msprintf(gettext("Wrong value for \'Port Number\' parameter: %d."),prt),gettext("Strictly positive integer expected."));
} else {
if (model.ipar!=prt) {
needcompile=4;
y=needcompile;
}
model.ipar=prt;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
OUTIMPL_f.prototype.define = function OUTIMPL_f() {
model=scicos_model();
model.in=[-1];
model.in2=[1];
prt=1;
model.sim="outimpl";
model.ipar=[1];
model.blocktype="c";
model.dep_ut=[None,None];
mo=modelica();
mo.model="PORT";
mo.inputs="n";
model.equations=mo;
exprs="1";
gr_i=[];
x=standard_define([1,1],model,exprs,gr_i);
x.graphics.in_implicit=["I"];
}
OUTIMPL_f.prototype.details = function OUTIMPL_f() {
}
}
/* autogenerated from "macros/Sinks/CFSCOPE.sci" */
function CFSCOPE() {
CFSCOPE.prototype.get = function CFSCOPE() {
}
CFSCOPE.prototype.set = function CFSCOPE() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,clrs,win,wpos,wdim,ymin,ymax,per,N,wu,exprs]=scicos_getvalue("Set Scope parameters",["Color (>0) or mark (<0) vector (8 entries)","Output window number (-1 for automatic)","Output window position","Output window sizes","Ymin","Ymax","Refresh period","Buffer size","Links to view"],list("vec",8,"vec",1,"vec",-1,"vec",-1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",-1),exprs);
if (!ok) {
break
}
mess=[];
if (size(wpos,"*")!=0&&size(wpos,"*")!=2) {
mess=[mess,"Window position must be [] or a 2 vector"," "];
ok=None;
}
if (size(wdim,"*")!=0&&size(wdim,"*")!=2) {
mess=[mess,"Window dim must be [] or a 2 vector"," "];
ok=None;
}
if (win<-1) {
mess=[mess,"Window number cannot be inferior than -1"," "];
ok=None;
}
if (per<=0) {
mess=[mess,"Refresh period must be positive"," "];
ok=None;
}
if (N<2) {
mess=[mess,"Buffer size must be at least 2"," "];
ok=None;
}
if (ymin>=ymax) {
mess=[mess,"Ymax must be greater than Ymin"," "];
ok=None;
}
if (wu<0) {
mess=[mess,"Link to view must be positive"," "];
ok=None;
}
if (!ok) {
message(["Some specified values are inconsistent:"," ",mess]);
}
if (ok) {
if (wpos==[]) {
wpos=[-1,-1];
}
if (wdim==[]) {
wdim=[-1,-1];
}
rpar=[0,ymin,ymax,per];
if (size(clrs,"*")>8) {
clrs=clrs.slice(1-1,8);
}
if (size(clrs,"*")<8) {
clrs[8]=0;
}
ipar=[win,1,N,clrs.slice(),wpos.slice(),wdim.slice(),size(wu,"*"),wu.slice()];
model.rpar=rpar;
model.ipar=ipar;
model.firing=[];
model.dep_ut=[true,None];
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CFSCOPE.prototype.define = function CFSCOPE() {
win=-1;
wdim=[600,400];
wpos=[-1,-1];
clrs=[1,3,5,7,9,11,13,15];
N=2;
ymin=-15;
ymax=+15;
per=30;
model=scicos_model();
model.sim=list("cfscope",4);
model.evtin=1;
model.rpar=[0,ymin,ymax,per];
model.ipar=[win,1,N,clrs,wpos,wdim,1,1];
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[strcat(string(clrs)," "),string(win),sci2exp([]),sci2exp(wdim),string(ymin),string(ymax),string(per),string(N),string([1])];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CFSCOPE.prototype.details = function CFSCOPE() {
}
}
/* autogenerated from "macros/Sinks/WRITEAU_f.sci" */
function WRITEAU_f() {
WRITEAU_f.prototype.get = function WRITEAU_f() {
}
WRITEAU_f.prototype.set = function WRITEAU_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
ipar=model.ipar;
dstate=model.dstate;
lunit=dstate(2);
while (true) {
[ok,N,swap,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"WRITEAU_f")," ",gettext("Write \'.au\' sound file on audio device")],[gettext("Buffer Size"),gettext("Swap Mode (0:No, 1:Yes)")],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
nin=1;
fname1="/dev/audio";
frmt1="uc ";
if (alreadyran&&(N!=ipar(5))) {
block_parameter_error(msprintf(gettext("You cannot modify \'%s\' when running."),gettext("Buffer Size")),gettext("End current simulation first"));
ok=None;
} else if (N<1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Buffer Size"),N),gettext("Strictly positive integer expected."));
ok=None;
}
if (swap!=0&&swap!=1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Swap Mode"),swap),msprintf(gettext("Must be in the interval %s."),"[0, 1]"));
ok=None;
}
if (ok) {
ipar=[length(fname1),_str2code(frmt1),N,swap,_str2code(fname1)];
if (prod(size(dstate))!=(nin+1)*N+2) {
dstate=[-1,lunit,zeros((nin+1)*N,1)];
}
model.in=1;
model.dstate=dstate;
model.ipar=ipar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
WRITEAU_f.prototype.define = function WRITEAU_f() {
in1=1;
nin=sum(in1);
frmt="uc ";
fname="/dev/audio";
swap=0;
lunit=0;
N=2;
model=scicos_model();
model.sim=list("writeau",2);
model.in=in1;
model.evtin=1;
model.dstate=[-1,lunit,zeros((nin+1)*N,1)];
model.ipar=[length(fname),_str2code(frmt),N,swap,_str2code(fname)];
model.blocktype="d";
model.dep_ut=[true,None];
exprs=[string(N),string(swap)];
gr_i=[];
x=standard_define([4,2],model,exprs,gr_i);
}
WRITEAU_f.prototype.details = function WRITEAU_f() {
}
}
/* autogenerated from "macros/Sinks/CMATVIEW.sci" */
function CMATVIEW() {
CMATVIEW.prototype.get = function CMATVIEW() {
}
CMATVIEW.prototype.set = function CMATVIEW() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,colormap,cmin,cmax,exprs]=scicos_getvalue("Set Scope parameters",["ColorMap","Minimum level range","Maximum level range"],list("vec",-1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
mess=[];
if (cmax<=cmin) {
mess=[mess,"Error with minimum and maximum value"," "];
ok=None;
}
if (!ok) {
message(["Some specified values are inconsistent:"," ",mess]);
}
if (ok) {
size_c=size(colormap.slice(),1);
sol=inv([cmin,1,cmax,1])*[1,size_c/3];
alpha_c=sol(1);
beta_c=sol(2);
ipar=[cmin,cmax,size_c];
rpar=[alpha_c,beta_c,colormap.slice()];
model.ipar=ipar;
model.rpar=rpar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CMATVIEW.prototype.define = function CMATVIEW() {
cmin=0;
cmax=100;
size_c=25;
colormap=jetcolormap(size_c);
alpha_c=0.24;
beta_c=1;
model=scicos_model();
model.sim=list("cmatview",4);
model.in=-1;
model.in2=-2;
model.intyp=1;
model.evtin=1;
model.ipar=[cmin,cmax,size_c];
model.rpar=[alpha_c,beta_c,colormap.slice()];
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string("jetcolormap(25)"),string(cmin),string(cmax)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CMATVIEW.prototype.details = function CMATVIEW() {
}
}
/* autogenerated from "macros/Sinks/CEVENTSCOPE.sci" */
function CEVENTSCOPE() {
CEVENTSCOPE.prototype.get = function CEVENTSCOPE() {
}
CEVENTSCOPE.prototype.set = function CEVENTSCOPE() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,nclock,clrs,win,wpos,wdim,per,exprs]=scicos_getvalue("Set Scope parameters",["Number of event inputs","colors c (>0) or mark (<0)","Output window number (-1 for automatic)","Output window position","Output window sizes","Refresh period"],list("vec",1,"vec",-1,"vec",1,"vec",-1,"vec",-1,"vec",1),exprs);
nclock=int(nclock);
clrs=int(clrs);
win=int(win);
if (!ok) {
break
}
mess=[];
if (size(wpos,"*")!=0&&size(wpos,"*")!=2) {
mess=[mess,"Window position must be [] or a 2 vector"," "];
ok=None;
}
if (size(wdim,"*")!=0&&size(wdim,"*")!=2) {
mess=[mess,"Window dim must be [] or a 2 vector"," "];
ok=None;
}
if (nclock<=0) {
mess=[mess,"Block must have at least one input event"," "];
ok=None;
}
if (size(clrs,"*")!=nclock) {
mess=[mess,"Inputs color c size must be equal to Number of inputs"," "];
ok=None;
}
if (win<-1) {
mess=[mess,"Window number cannot be inferior than -1"," "];
ok=None;
}
if (per<=0) {
mess=[mess,"Refresh period must be positive"," "];
ok=None;
}
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list(),list(),ones(nclock,1),[]);
} else {
message(["Some specified values are inconsistent:"," ",mess]);
}
if (ok) {
if (wpos==[]) {
wpos=[-1,-1];
}
if (wdim==[]) {
wdim=[-1,-1];
}
rpar=per;
ipar=[win,1,clrs.slice(),wpos.slice(),wdim.slice()];
model.rpar=rpar;
model.ipar=ipar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CEVENTSCOPE.prototype.define = function CEVENTSCOPE() {
nclock=1;
win=-1;
clrs=[1,3,5,7,9,11,13,15];
wdim=[600,400];
wpos=[-1,-1];
per=30;
model=scicos_model();
model.sim=list("cevscpe",4);
model.evtin=1;
model.rpar=per;
model.ipar=[win,1,clrs(nclock),wpos.slice(),wdim.slice()];
model.blocktype="d";
model.dep_ut=[None,None];
exprs=[sci2exp(nclock),strcat(sci2exp(clrs(nclock))," "),string(win),sci2exp([]),sci2exp(wdim),string(per)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CEVENTSCOPE.prototype.details = function CEVENTSCOPE() {
}
}
/* autogenerated from "macros/Sinks/TRASH_f.sci" */
function TRASH_f() {
TRASH_f.prototype.get = function TRASH_f() {
}
TRASH_f.prototype.set = function TRASH_f() {
x=arg1;
}
TRASH_f.prototype.define = function TRASH_f() {
in1=-1;
model=scicos_model();
model.sim="trash";
model.in=in1;
model.evtin=1;
model.blocktype="d";
model.dep_ut=[None,None];
exprs=" ";
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
TRASH_f.prototype.details = function TRASH_f() {
}
}
/* autogenerated from "macros/Sinks/TOWS_c.sci" */
function TOWS_c() {
TOWS_c.prototype.get = function TOWS_c() {
}
TOWS_c.prototype.set = function TOWS_c() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
while (true) {
[ok,nz,varnam,herit,exprs]=scicos_getvalue("Set Xcos buffer block",["Size of buffer","Scilab variable name","Inherit (no:0, yes:1)"],list("vec",1,"str",1,"vec",1),exprs);
if (!ok) {
break
}
if ((nz<=0)) {
message("Size of buffer must be positive");
ok=None;
}
r=None;
ierr=execstr("r = validvar(varnam)","errcatch");
if (!r||ierr!=0||length(varnam)>19) {
message(["Invalid variable name.","Please choose another variable name."]);
ok=None;
}
execstr("if type("+varnam+") <> 17 | or(fieldnames("+varnam+") <> [\"values\"; \"time\"]) then"+" message([\"Protected variable name.\"; \"Please choose another variable name.\"]);"+" ok = %f;"+" end","errcatch");
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list([-1,-2],-1),list(),ones(1-herit,1),[]);
if (herit==1) {
model.blocktype="x";
} else {
model.blocktype="d";
}
model.ipar=[nz,length(varnam),transpose(ascii(varnam))];
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
TOWS_c.prototype.define = function TOWS_c() {
nu=-1;
nz=128;
varnam="A";
herit=0;
model=scicos_model();
model.sim=list("tows_c",4);
model.in=[nu];
model.in2=-2;
model.intyp=-1;
model.out=[];
model.evtin=[1];
model.evtout=[];
model.rpar=[];
model.ipar=[nz,length(varnam),transpose(ascii(varnam))];
model.blocktype="d";
model.firing=[];
model.dep_ut=[None,None];
gr_i=[];
exprs=[string(nz),string(varnam),string(herit)];
x=standard_define([4,2],model,exprs,gr_i);
}
TOWS_c.prototype.details = function TOWS_c() {
}
}
/* autogenerated from "macros/Sinks/CLKOUT_f.sci" */
function CLKOUT_f() {
CLKOUT_f.prototype.get = function CLKOUT_f() {
}
CLKOUT_f.prototype.set = function CLKOUT_f() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
exprs=exprs(1);
while (true) {
[ok,prt,exprs]=scicos_getvalue("Set Event Output block parameters","Port number",list("vec",1),exprs);
if (!ok) {
break
}
prt=int(prt);
if (prt<=0) {
message("Port number must be a positive integer");
} else {
model.ipar=prt;
model.evtin=1;
model.firing=[];
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CLKOUT_f.prototype.define = function CLKOUT_f() {
prt=1;
model=scicos_model();
model.sim="output";
model.evtin=1;
model.ipar=prt;
model.blocktype="d";
model.firing=[];
model.dep_ut=[None,None];
exprs=string(prt);
x=standard_define([1,1],model,exprs," ");
}
CLKOUT_f.prototype.details = function CLKOUT_f() {
}
}
/* autogenerated from "macros/Sinks/OUT_f.sci" */
function OUT_f() {
OUT_f.prototype.get = function OUT_f() {
}
OUT_f.prototype.set = function OUT_f() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
if (size(exprs,"*")==2) {
exprs=exprs(1);
}
while (true) {
[ok,prt,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"OUT_f")," ",gettext("Regular output port")],gettext("Port number"),list("vec",1),exprs);
if (!ok) {
break
}
prt=int(prt);
if (prt<=0) {
block_parameter_error(msprintf(gettext("Wrong value for \'Port Number\' parameter: %d."),prt),gettext("Strictly positive integer expected."));
} else {
model.ipar=prt;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
OUT_f.prototype.define = function OUT_f() {
n=-1;
prt=1;
model=scicos_model();
model.sim="output";
model.in=-1;
model.in2=-2;
model.intyp=-1;
model.ipar=prt;
model.blocktype="c";
model.dep_ut=[None,None];
exprs=string(prt);
gr_i=[];
x=standard_define([1,1],model,exprs,gr_i);
}
OUT_f.prototype.details = function OUT_f() {
}
}
/* autogenerated from "macros/Branching/SWITCH_f.sci" */
function SWITCH_f() {
SWITCH_f.prototype.get = function SWITCH_f() {
}
SWITCH_f.prototype.set = function SWITCH_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
ipar=model.ipar;
while (true) {
[ok,nin,z0,exprs]=scicos_getvalue("Set switch parameters",["number of inputs","connected input"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (z0>nin||z0<=0) {
message("initial connected input is not a valid input port number");
} else {
[model,graphics,ok]=check_io(model,graphics,-ones(nin,1),-1,[],[]);
if (ok) {
graphics.exprs=exprs;
model.ipar=z0-1;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
SWITCH_f.prototype.define = function SWITCH_f() {
i0=0;
in1=[-1,-1];
nin=2;
model=scicos_model();
model.sim=list("switchn",2);
model.in=in1;
model.out=-1;
model.ipar=i0;
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,true];
exprs=[string(nin),string(i0+1)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
SWITCH_f.prototype.details = function SWITCH_f() {
}
}
/* autogenerated from "macros/Branching/FROM.sci" */
function FROM() {
FROM.prototype.get = function FROM() {
}
FROM.prototype.set = function FROM() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,tag,exprs]=scicos_getvalue("Set parameters",["Tag"],list("str",-1),exprs);
if (!ok) {
break
}
if (ok) {
if (model.opar!=list(tag)) {
needcompile=4;
y=needcompile;
}
graphics.exprs=exprs;
model.opar=list(tag);
x.model=model;
x.graphics=graphics;
break
}
}
needcompile=resume(needcompile)
}
FROM.prototype.define = function FROM() {
model=scicos_model();
model.sim="from";
model.in=[];
model.in2=[];
model.intyp=1;
model.out=-1;
model.out2=-2;
model.outtyp=-1;
model.ipar=[];
model.opar=list("A");
model.blocktype="c";
model.dep_ut=[None,None];
exprs=["A"];
gr_i=[];
x=standard_define([2,1],model,exprs,gr_i);
x.graphics.id="From";
}
FROM.prototype.details = function FROM() {
}
}
/* autogenerated from "macros/Branching/SELECT_f.sci" */
function SELECT_f() {
SELECT_f.prototype.get = function SELECT_f() {
}
SELECT_f.prototype.set = function SELECT_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,nin,z0,exprs]=scicos_getvalue("Set parameters",["number of inputs","initial connected input"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (z0>nin||z0<=0) {
message("initial connected input is not a valid input port number");
} else {
[model,graphics,ok]=check_io(model,graphics,-ones(nin,1),-1,ones(nin,1),[]);
if (ok) {
graphics.exprs=exprs;
model.dstate=z0-1;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
SELECT_f.prototype.define = function SELECT_f() {
z0=0;
in1=[-1,-1];
nin=2;
model=scicos_model();
model.sim=list("selector",2);
model.in=in1;
model.out=-1;
model.evtin=ones(in1);
model.dstate=z0;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string(nin),string(z0+1)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
SELECT_f.prototype.details = function SELECT_f() {
}
}
/* autogenerated from "macros/Branching/SWITCH2_m.sci" */
function SWITCH2_m() {
SWITCH2_m.prototype.get = function SWITCH2_m() {
}
SWITCH2_m.prototype.set = function SWITCH2_m() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,ot,rule,thra,nzz,exprs]=scicos_getvalue("Set parameters",["Datatype (1=real double  2=complex 3=int32 ...)","pass first input if: u2>=a (0), u2>a (1), u2~=a (2)","threshold a","use zero crossing: yes (1), no (0)"],list("vec",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
rule=int(rule);
if ((rule<0)) {
rule=0;
}
if ((rule>2)) {
rule=2;
}
graphics.exprs=exprs;
model.ipar=rule;
model.rpar=thra;
if (nzz!=0) {
model.nmode=1;
model.nzcross=1;
} else {
model.nmode=0;
model.nzcross=0;
}
if (((ot<1)||(ot>8))&&(ot!=-1)) {
message("Datatype is not supported");
ok=None;
}
if (ok) {
it[1]=ot;
it[2]=1;
it[3]=ot;
in1=[model.in,model.in2];
out=[model.out,model.out2];
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
if (ok) {
x.graphics=graphics;
x.model=model;
break
}
}
}
SWITCH2_m.prototype.define = function SWITCH2_m() {
ipar=[0];
nzz=1;
rpar=0;
model=scicos_model();
model.sim=list("switch2_m",4);
model.in=[-1,1,-1];
model.in2=[-2,1,-2];
model.intyp=1;
model.out=-1;
model.out2=-2;
model.outtyp=1;
model.ipar=ipar;
model.rpar=rpar;
model.nzcross=nzz;
model.nmode=1;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[sci2exp(1),string(ipar),string(rpar),string(nzz)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
SWITCH2_m.prototype.details = function SWITCH2_m() {
}
}
/* autogenerated from "macros/Branching/EXTRACTOR.sci" */
function EXTRACTOR() {
EXTRACTOR.prototype.get = function EXTRACTOR() {
}
EXTRACTOR.prototype.set = function EXTRACTOR() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,ind,exprs]=scicos_getvalue("Set block parameters",["indices to extract"],list("vec",-1),exprs);
if (!ok) {
break
}
ind=int(ind);
ind=ind.slice();
[model,graphics,ok]=check_io(model,graphics,[-1],size(ind,1),[],[]);
if (ok) {
model.ipar=ind;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
EXTRACTOR.prototype.define = function EXTRACTOR() {
ind=1;
model=scicos_model();
model.sim=list("extractor",4);
model.in=-1;
model.out=1;
model.blocktype="c";
model.dep_ut=[true,None];
model.ipar=ind;
exprs=[sci2exp(ind)];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
EXTRACTOR.prototype.details = function EXTRACTOR() {
}
}
/* autogenerated from "macros/Branching/CLKFROM.sci" */
function CLKFROM() {
CLKFROM.prototype.get = function CLKFROM() {
}
CLKFROM.prototype.set = function CLKFROM() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
while (true) {
[ok,tag,exprs]=scicos_getvalue("Set block parameters","Tag",list("str",-1),exprs);
if (!ok) {
break
}
if (model.opar!=list(tag)) {
needcompile=4;
y=needcompile;
}
model.opar=list(tag);
model.evtout=1;
model.firing=-1;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
needcompile=resume(needcompile)
}
CLKFROM.prototype.define = function CLKFROM() {
model=scicos_model();
model.sim="clkfrom";
model.evtout=1;
model.opar=list("A");
model.blocktype="d";
model.firing=-1;
model.dep_ut=[None,None];
exprs="A";
x=standard_define([2,1],model,exprs," ");
x.graphics.id="From";
}
CLKFROM.prototype.details = function CLKFROM() {
}
}
/* autogenerated from "macros/Branching/SCALAR2VECTOR.sci" */
function SCALAR2VECTOR() {
SCALAR2VECTOR.prototype.get = function SCALAR2VECTOR() {
}
SCALAR2VECTOR.prototype.set = function SCALAR2VECTOR() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,nout,exprs]=scicos_getvalue("Set block parameters",["size of output (-1: if don\'t know)"],list("vec",1),exprs);
if (!ok) {
break
}
nout=int(nout);
if ((nout!=-1&&(nout<=0))) {
message("size of output must be -1 or >0");
ok=None;
}
if (ok) {
[model,graphics,ok]=check_io(model,graphics,[1],nout,[],[]);
}
if (ok) {
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
SCALAR2VECTOR.prototype.define = function SCALAR2VECTOR() {
nout=-1;
model=scicos_model();
model.sim=list("scalar2vector",4);
model.out=nout;
model.in=1;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string([nout])];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
SCALAR2VECTOR.prototype.details = function SCALAR2VECTOR() {
}
}
/* autogenerated from "macros/Branching/SWITCH2.sci" */
function SWITCH2() {
SWITCH2.prototype.get = function SWITCH2() {
}
SWITCH2.prototype.set = function SWITCH2() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,rule,thra,nzz,exprs]=scicos_getvalue("Set parameters",["pass first input if: u2>=a (0), u2>a (1), u2~=a (2)","threshold a","use zero crossing: yes (1), no (0)"],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
rule=int(rule);
if ((rule<0)) {
rule=0;
}
if ((rule>2)) {
rule=2;
}
graphics.exprs=exprs;
model.ipar=rule;
model.rpar=thra;
if (nzz!=0) {
model.nmode=1;
model.nzcross=1;
} else {
model.nmode=0;
model.nzcross=0;
}
x.graphics=graphics;
x.model=model;
break
}
}
SWITCH2.prototype.define = function SWITCH2() {
in1=[-1,1,-1];
ipar=[0];
nzz=1;
rpar=0;
model=scicos_model();
model.sim=list("switch2",4);
model.in=in1;
model.out=-1;
model.ipar=ipar;
model.rpar=rpar;
model.nzcross=nzz;
model.nmode=1;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string(ipar),string(rpar),string(nzz)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
SWITCH2.prototype.details = function SWITCH2() {
}
}
/* autogenerated from "macros/Branching/ESELECT_f.sci" */
function ESELECT_f() {
ESELECT_f.prototype.get = function ESELECT_f() {
}
ESELECT_f.prototype.set = function ESELECT_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
if (size(exprs,"*")==1) {
exprs[2]=string(1);
}
if (size(exprs,"*")==2) {
exprs[3]=string(0);
}
model=arg1.model;
while (true) {
[ok,out,inh,nmod,exprs]=scicos_getvalue("Set ESELECT block parameters",["number of output event ports","Inherit (1: no, 0: yes)","zero-crossing (0: no, 1: yes)"],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (nmod!=0) {
nmod=1;
}
if (inh==0) {
inh=[];
} else {
inh=1;
}
out=int(out);
if (out<2) {
message("Block must have at least two output ports");
} else {
[model,graphics,ok]=check_io(model,graphics,1,[],inh,[ones(out,1)]);
if (ok) {
graphics.exprs=exprs;
model.evtout=ones(out,1);
model.firing=-ones(out,1);
x.graphics=graphics;
model.nmode=nmod;
model.nzcross=nmod;
x.model=model;
break
}
}
}
}
ESELECT_f.prototype.define = function ESELECT_f() {
out=2;
model=scicos_model();
model.sim=list("eselect",-2);
model.in=1;
model.in2=1;
model.intyp=-1;
model.evtin=1;
model.evtout=ones(out,1);
model.blocktype="l";
model.firing=-ones(out,1);
model.dep_ut=[true,None];
model.nmode=0;
model.nzcross=0;
gr_i=[];
exprs=[string(out),string(1),string(model.nmode)];
x=standard_define([4,2],model,exprs,gr_i);
}
ESELECT_f.prototype.details = function ESELECT_f() {
}
}
/* autogenerated from "macros/Branching/GotoTagVisibilityMO.sci" */
function GotoTagVisibilityMO() {
GotoTagVisibilityMO.prototype.get = function GotoTagVisibilityMO() {
}
GotoTagVisibilityMO.prototype.set = function GotoTagVisibilityMO() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,tag,exprs]=scicos_getvalue("Set parameters",["GotoTag"],list("str",-1),exprs);
if (!ok) {
break
}
if (ok) {
if (model.opar!=list(tag)) {
needcompile=4;
y=needcompile;
}
graphics.exprs=exprs;
model.opar=list(tag);
x.graphics=graphics;
x.model=model;
break
}
}
needcompile=resume(needcompile)
}
GotoTagVisibilityMO.prototype.define = function GotoTagVisibilityMO() {
model=scicos_model();
model.sim="gototagvisibilitymo";
model.in=[];
model.in2=[];
model.out=[];
model.out2=[];
model.evtin=[];
model.intyp=1;
model.outtyp=1;
model.opar=list("A");
model.blocktype="c";
model.firing=None;
model.dep_ut=[None,None];
exprs="A";
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
GotoTagVisibilityMO.prototype.details = function GotoTagVisibilityMO() {
}
}
/* autogenerated from "macros/Branching/ISELECT_f.sci" */
function ISELECT_f() {
ISELECT_f.prototype.get = function ISELECT_f() {
}
ISELECT_f.prototype.set = function ISELECT_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,nout,z0,exprs]=scicos_getvalue("Set parameters",["number of outputs","initial connected output"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (z0>nout||z0<=0) {
message("initial connected input is not a valid input port number");
} else {
[model,graphics,ok]=check_io(model,graphics,-1,-ones(nout,1),ones(nout,1),[]);
if (ok) {
graphics.exprs=exprs;
model.dstate=z0-1;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
ISELECT_f.prototype.define = function ISELECT_f() {
z0=0;
out=[-1,-1];
nout=2;
model=scicos_model();
model.sim=list("selector",2);
model.in=-1;
model.out=out;
model.evtin=ones(out);
model.dstate=z0;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string(nout),string(z0+1)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
ISELECT_f.prototype.details = function ISELECT_f() {
}
}
/* autogenerated from "macros/Branching/CLKGotoTagVisibility.sci" */
function CLKGotoTagVisibility() {
CLKGotoTagVisibility.prototype.get = function CLKGotoTagVisibility() {
}
CLKGotoTagVisibility.prototype.set = function CLKGotoTagVisibility() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,tag,exprs]=scicos_getvalue("Set parameters",["GotoTag"],list("str",-1),exprs);
if (!ok) {
break
}
if (ok) {
if (model.opar!=list(tag)) {
needcompile=4;
y=needcompile;
}
graphics.exprs=exprs;
model.opar=list(tag);
x.graphics=graphics;
x.model=model;
break
}
}
needcompile=resume(needcompile)
}
CLKGotoTagVisibility.prototype.define = function CLKGotoTagVisibility() {
model=scicos_model();
model.sim="clkgototagvisibility";
model.in=[];
model.in2=[];
model.out=[];
model.out2=[];
model.evtin=[];
model.intyp=1;
model.outtyp=1;
model.opar=list("A");
model.blocktype="c";
model.firing=None;
model.dep_ut=[None,None];
exprs="A";
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CLKGotoTagVisibility.prototype.details = function CLKGotoTagVisibility() {
}
}
/* autogenerated from "macros/Branching/FROMMO.sci" */
function FROMMO() {
FROMMO.prototype.get = function FROMMO() {
}
FROMMO.prototype.set = function FROMMO() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,tag,exprs]=scicos_getvalue("Set parameters",["Tag"],list("str",-1),exprs);
if (!ok) {
break
}
if (ok) {
if (model.opar!=list(tag)) {
needcompile=4;
y=needcompile;
}
graphics.exprs=exprs;
model.opar=list(tag);
x.model=model;
x.graphics=graphics;
break
}
}
needcompile=resume(needcompile)
}
FROMMO.prototype.define = function FROMMO() {
model=scicos_model();
model.sim="frommo";
model.in=[];
model.in2=[];
model.intyp=1;
model.out=-1;
model.out2=-2;
model.outtyp=-1;
model.ipar=[];
model.opar=list("A");
model.blocktype="c";
model.dep_ut=[None,None];
mo=modelica();
mo.model="frommo";
mo.outputs="n";
exprs=["A"];
gr_i=[];
x=standard_define([2,1],model,exprs,gr_i);
x.graphics.out_implicit=["I"];
}
FROMMO.prototype.details = function FROMMO() {
}
}
/* autogenerated from "macros/Branching/GotoTagVisibility.sci" */
function GotoTagVisibility() {
GotoTagVisibility.prototype.get = function GotoTagVisibility() {
}
GotoTagVisibility.prototype.set = function GotoTagVisibility() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,tag,exprs]=scicos_getvalue("Set parameters",["GotoTag"],list("str",-1),exprs);
if (!ok) {
break
}
if (ok) {
if (model.opar!=list(tag)) {
needcompile=4;
y=needcompile;
}
graphics.exprs=exprs;
model.opar=list(tag);
x.graphics=graphics;
x.model=model;
break
}
}
needcompile=resume(needcompile)
}
GotoTagVisibility.prototype.define = function GotoTagVisibility() {
model=scicos_model();
model.sim="gototagvisibility";
model.in=[];
model.in2=[];
model.out=[];
model.out2=[];
model.evtin=[];
model.intyp=1;
model.outtyp=1;
model.opar=list("A");
model.blocktype="c";
model.firing=None;
model.dep_ut=[None,None];
exprs="A";
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
GotoTagVisibility.prototype.details = function GotoTagVisibility() {
}
}
/* autogenerated from "macros/Branching/RELAY_f.sci" */
function RELAY_f() {
RELAY_f.prototype.get = function RELAY_f() {
}
RELAY_f.prototype.set = function RELAY_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
ipar=model.ipar;
while (true) {
[ok,nin,z0,exprs]=scicos_getvalue("Set parameters",["number of inputs","initial connected input"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (z0>nin||z0<=0) {
message("initial connected input is not a valid input port number");
} else {
[model,graphics,ok]=check_io(model,graphics,-ones(nin,1),-1,ones(nin,1),[]);
if (ok) {
graphics.exprs=exprs;
model.dstate=z0-1;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
RELAY_f.prototype.define = function RELAY_f() {
i0=0;
in1=[-1,-1];
nin=2;
model=scicos_model();
model.sim=list("relay",2);
model.in=in1;
model.out=-1;
model.evtin=ones(in1);
model.dstate=i0;
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,true];
exprs=[string(nin),string(i0+1)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
RELAY_f.prototype.details = function RELAY_f() {
}
}
/* autogenerated from "macros/Branching/NRMSOM_f.sci" */
function NRMSOM_f() {
NRMSOM_f.prototype.get = function NRMSOM_f() {
}
NRMSOM_f.prototype.set = function NRMSOM_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,nin,exprs]=scicos_getvalue("Set parameters",["number of inputs"],list("vec",1),exprs);
if (!ok) {
break
}
[model,graphics,ok]=check_io(model,graphics,-ones(nin,1),-1,[],[]);
if (ok) {
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
NRMSOM_f.prototype.define = function NRMSOM_f() {
in1=[-1,-1];
nin=2;
model=scicos_model();
model.sim="junk";
model.in=in1;
model.out=-1;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string(nin)];
gr_i=[];
x=standard_define([.2,2],model,exprs,gr_i);
}
NRMSOM_f.prototype.details = function NRMSOM_f() {
}
}
/* autogenerated from "macros/Sources/INIMPL_f.sci" */
function INIMPL_f() {
INIMPL_f.prototype.get = function INIMPL_f() {
}
INIMPL_f.prototype.set = function INIMPL_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")==2) {
exprs=exprs(1);
}
while (true) {
[ok,prt,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"INIMPL_f")," ",gettext("Implicit input port")," "],"Port Number",list("vec",1),exprs);
if (!ok) {
break
}
prt=int(prt);
if (prt<=0) {
block_parameter_error(msprintf(gettext("Wrong value for \'Port Number\' parameter: %d."),prt),gettext("Strictly positive integer expected."));
} else {
if (model.ipar!=prt) {
needcompile=4;
y=needcompile;
}
model.ipar=prt;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
INIMPL_f.prototype.define = function INIMPL_f() {
model=scicos_model();
model.sim="inimpl";
model.out=[-1];
model.out2=[1];
model.ipar=[1];
model.dep_ut=[None,None];
model.blocktype="c";
mo=modelica();
mo.model="PORT";
mo.outputs="n";
model.equations=mo;
prt=1;
exprs="1";
gr_i=[];
x=standard_define([1,1],model,exprs,gr_i);
x.graphics.out_implicit=["I"];
}
INIMPL_f.prototype.details = function INIMPL_f() {
}
}
/* autogenerated from "macros/Sources/GENSQR_f.sci" */
function GENSQR_f() {
GENSQR_f.prototype.get = function GENSQR_f() {
}
GENSQR_f.prototype.set = function GENSQR_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")==2) {
exprs=exprs(2);
}
while (true) {
[ok,Amplitude,exprs]=scicos_getvalue(["Set Square generator block parameters"],["Amplitude"],list("vec",1),exprs);
if (!ok) {
break
}
graphics.exprs=exprs;
model.dstate=Amplitude;
model.out2=1;
model.outtyp=1;
x.graphics=graphics;
x.model=model;
break
}
}
GENSQR_f.prototype.define = function GENSQR_f() {
Amplitude=1;
model=scicos_model();
model.sim="gensqr";
model.out=1;
model.out2=1;
model.outtyp=1;
model.evtin=1;
model.dstate=Amplitude;
model.blocktype="d";
model.dep_ut=[None,None];
exprs=string(Amplitude);
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
GENSQR_f.prototype.details = function GENSQR_f() {
}
}
/* autogenerated from "macros/Sources/IN_f.sci" */
function IN_f() {
IN_f.prototype.get = function IN_f() {
}
IN_f.prototype.set = function IN_f() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
if (size(exprs,"*")==2) {
exprs=exprs(1);
}
if (size(exprs,"*")==1) {
exprs=[exprs(1),"[-1 -2]","-1"];
}
while (true) {
[ok,prt,otsz,ot,exprs]=getvalue(_("Set Input block parameters"),[_("Port number"),_("Outport size ([-1 -2] for inherit)"),_("Outport Type (-1 for inherit)")],list("vec",1,"vec",-1,"vec",1),exprs);
if (!ok) {
break
}
prt=int(prt);
if (prt<=0) {
message(_("Port number must be a positive integer"));
} else if (!isequal(size(otsz,"*"),2)) {
message(_("Outport Size must be a 2 elements vector"));
} else if (((ot<1||ot>9)&&(ot!=-1))) {
message(_("Outport type must be a number between 1 and 9, or -1 for inheritance."));
} else {
if (model.ipar!=prt) {
needcompile=4;
y=needcompile;
}
model.ipar=prt;
model.firing=[];
model.out=otsz(1);
model.out2=otsz(2);
model.outtyp=ot;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
IN_f.prototype.define = function IN_f() {
prt=1;
model=scicos_model();
model.sim="input";
model.out=-1;
model.out2=-2;
model.outtyp=-1;
model.ipar=prt;
model.blocktype="c";
model.dep_ut=[None,None];
exprs=sci2exp(prt);
gr_i=[];
x=standard_define([1,1],model,exprs,gr_i);
}
IN_f.prototype.details = function IN_f() {
}
}
/* autogenerated from "macros/Sources/TKSCALE.sci" */
function TKSCALE() {
TKSCALE.prototype.get = function TKSCALE() {
}
TKSCALE.prototype.set = function TKSCALE() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
[ok,a,b,f,exprs]=scicos_getvalue("Set scale block parameters",["Min value","Max value","Normalization"],list("vec",1,"vec",1,"vec",1),exprs);
if (ok) {
graphics.exprs=exprs;
model.rpar=[a,b,f];
x.graphics=graphics;
x.model=model;
}
}
TKSCALE.prototype.define = function TKSCALE() {
a=-10;
b=10;
f=1;
model=scicos_model();
model.sim=list("tkscaleblk",5);
model.out=1;
model.evtin=1;
model.rpar=[a,b,f];
model.blocktype="d";
model.dep_ut=[None,None];
exprs=[sci2exp(a),sci2exp(b),sci2exp(f)];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
TKSCALE.prototype.details = function TKSCALE() {
}
}
/* autogenerated from "macros/Sources/CURV_f.sci" */
function CURV_f() {
CURV_f.prototype.get = function CURV_f() {
}
CURV_f.prototype.set = function CURV_f() {
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
rpar=model.rpar;
ipar=model.ipar;
n=ipar(1);
xx=rpar.slice(1-1,n);
yy=rpar.slice(n+1-1,2*n);
gc=list(rpar.slice(2*n+1-1,2*n+4),ipar.slice(2-1,5));
while (true) {
[ln,fun]=where()
if (!or(fun=="do_eval")) {
[xx,yy,ok,gc]=edit_curv(xx,yy,"axy",[" "," "," "],gc);
} else {
ok=true;
}
if (!ok) {
break
}
n=size(xx,"*");
if (or(xx.slice(2-1,n)-xx.slice(1-1,n-1)<0)) {
message("You have not defined a function");
ok=None;
}
if (ok) {
model.sim="intplt";
model.firing=[];
rect=gc(1);
model.rpar=[xx.slice(),yy.slice(),rect.slice()];
axisdata=gc(2);
model.ipar=[size(xx,"*"),axisdata.slice()];
x.graphics=graphics;
x.model=model;
break
}
}
}
CURV_f.prototype.define = function CURV_f() {
xx=[0,1,2];
yy=[-5,5,0];
rect=[0,-5,2,5];
axisdata=[2,10,2,10];
ipar=[size(xx,1),axisdata.slice()];
rpar=[xx,yy,rect.slice()];
model=scicos_model();
model.sim="intplt";
model.in=[];
model.out=1;
model.rpar=[xx,yy,rect.slice()];
model.ipar=[size(xx,1),axisdata.slice()];
model.blocktype="c";
model.dep_ut=[None,true];
gr_i=[];
x=standard_define([2,2],model,[],gr_i);
}
CURV_f.prototype.details = function CURV_f() {
}
}
/* autogenerated from "macros/Sources/RAMP.sci" */
function RAMP() {
RAMP.prototype.get = function RAMP() {
}
RAMP.prototype.set = function RAMP() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,slope,stt,iout,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"RAMP")," ",gettext("Ramp function")," "],[gettext("Slope"),gettext("Start Time"),gettext("Initial Value")],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (stt<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'Start Time\' parameter: %e."),stt),gettext("Null or positive integer expected."));
} else {
model.rpar=[slope,stt,iout];
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
RAMP.prototype.define = function RAMP() {
slope=0;
iout=0;
stt=0;
rpar=[slope,stt,iout];
model=scicos_model();
model.sim=list("ramp",4);
model.in=[];
model.out=1;
model.rpar=rpar;
model.blocktype="c";
model.nmode=1;
model.nzcross=1;
model.dep_ut=[None,true];
exprs=[string(rpar)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
RAMP.prototype.details = function RAMP() {
}
}
/* autogenerated from "macros/Sources/CONST_f.sci" */
function CONST_f() {
CONST_f.prototype.get = function CONST_f() {
}
CONST_f.prototype.set = function CONST_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,C,exprs]=scicos_getvalue(["Set Contant Block"],"Constant",list("vec",-1),exprs);
if (!ok) {
break
}
nout=size(C,"*");
if (nout==0) {
message("C must have at least one element");
} else {
model.rpar=C.slice();
model.out=nout;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CONST_f.prototype.define = function CONST_f() {
C=1;
model=scicos_model();
model.sim=list("cstblk",1);
model.in=[];
model.out=1;
model.rpar=C;
model.blocktype="d";
model.dep_ut=[None,None];
exprs=strcat(sci2exp(C));
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CONST_f.prototype.details = function CONST_f() {
}
}
/* autogenerated from "macros/Sources/Ground_g.sci" */
function Ground_g() {
Ground_g.prototype.get = function Ground_g() {
}
Ground_g.prototype.set = function Ground_g() {
x=arg1;
}
Ground_g.prototype.define = function Ground_g() {
C=[0];
model=scicos_model();
model.sim=list("cstblk4_m",4);
model.in=[];
model.out=1;
model.in2=[];
model.out2=1;
model.outtyp=-1;
model.rpar=[];
model.opar=list(C);
model.blocktype="d";
model.dep_ut=[None,None];
exprs=[];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
Ground_g.prototype.details = function Ground_g() {
}
}
/* autogenerated from "macros/Sources/Counter.sci" */
function Counter() {
Counter.prototype.get = function Counter() {
}
Counter.prototype.set = function Counter() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,minim,maxim,rule,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"Counter")," ",gettext("Integer counter generator")," "],[gettext("Minimum"),gettext("Maximum"),gettext("Rule (1:Increment, 2:Decrement)")],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
maxim=int(maxim);
minim=int(minim);
if (maxim<minim) {
block_parameter_error(msprintf(gettext("Wrong values for \'Maximum\' and \'Minimum\' parameters: %d &lt; %d"),minim,maxim),msprintf(gettext("\'Minimum\' must be less than \'Maximum\'.")));
} else if ((rule!=1&&rule!=2)) {
block_parameter_error(msprintf(gettext("Wrong value for \'Rule\' parameter: %d"),rule),msprintf(gettext("Must be in the interval %s."),"[1,2]"));
} else {
graphics.exprs=exprs;
model.dstate=0;
model.ipar=[rule,maxim,minim];
x.graphics=graphics;
x.model=model;
break
}
}
}
Counter.prototype.define = function Counter() {
minim=0;
maxim=2;
rule=1;
model=scicos_model();
model.sim=list("counter",4);
model.evtin=1;
model.out=1;
model.out2=1;
model.dstate=0;
model.ipar=[rule,maxim,minim];
model.blocktype="c";
model.dep_ut=[None,None];
exprs=[string(minim),string(maxim),string(rule)];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
Counter.prototype.details = function Counter() {
}
}
/* autogenerated from "macros/Sources/FROMWS_c.sci" */
function FROMWS_c() {
FROMWS_c.prototype.get = function FROMWS_c() {
}
FROMWS_c.prototype.set = function FROMWS_c() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,varnam,Method,ZC,OutEnd,exprs]=scicos_getvalue("Set From_Workspace block parameters",["Variable name","Interpolation Method","Enable zero crossing(0:No, 1:Yes)?","Output at end(0:Zero, 1:Hold, 2:Repeat)"],list("str",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (!(Method==0||Method==1||Method==2||Method==3)) {
message("Interpolation method should be chosen in [0,1,2,3]");
ok=None;
}
if (!(ZC==0||ZC==1)) {
message("Zero crossing should be either 0 or 1");
ok=None;
}
if (!(OutEnd==0||OutEnd==1||OutEnd==2)) {
message("Output at end option should be either 0 or 1");
ok=None;
}
r=None;
ierr=execstr("r=validvar(varnam)","errcatch");
if (!r) {
message(["Invalid variable name.","Please choose another variable name."]);
ok=None;
}
if (ok) {
model.ipar=[length(varnam),_str2code(varnam),Method,ZC,OutEnd];
[model,graphics,ok]=set_io(model,graphics,list(),list([-1,-2],-1),1,1);
if (ok) {
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
FROMWS_c.prototype.define = function FROMWS_c() {
varnam="V";
Method=1;
ZC=1;
OutEnd=0;
model=scicos_model();
model.sim=list("fromws_c",4);
model.out=-1;
model.out2=-2;
model.outtyp=-1;
model.ipar=[length(varnam),_str2code(varnam),Method,ZC,OutEnd];
model.evtin=[1];
model.evtout=[1];
model.firing=[0];
model.blocktype="d";
model.dep_ut=[None,true];
gr_i=[];
exprs=[string(varnam),string(Method),string(ZC),string(OutEnd)];
x=standard_define([3.5,2],model,exprs,gr_i);
}
FROMWS_c.prototype.details = function FROMWS_c() {
}
}
/* autogenerated from "macros/Sources/SAWTOOTH_f.sci" */
function SAWTOOTH_f() {
SAWTOOTH_f.prototype.get = function SAWTOOTH_f() {
}
SAWTOOTH_f.prototype.set = function SAWTOOTH_f() {
x=arg1;
}
SAWTOOTH_f.prototype.define = function SAWTOOTH_f() {
model=scicos_model();
model.sim="sawtth";
model.out=1;
model.evtin=1;
model.dstate=0;
model.blocktype="c";
model.dep_ut=[None,true];
exprs=" ";
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
SAWTOOTH_f.prototype.details = function SAWTOOTH_f() {
}
}
/* autogenerated from "macros/Sources/RAND_f.sci" */
function RAND_f() {
RAND_f.prototype.get = function RAND_f() {
}
RAND_f.prototype.set = function RAND_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")==5) {
exprs=exprs.slice(1-1,3);
}
if (size(exprs,"*")==3) {
exprs=[exprs,string(model.dstate(1))];
}
while (true) {
[ok,flag,a,b,seed_c,exprs]=scicos_getvalue(["Set Random generator block parameters","flag = 0 : Uniform distribution A is min and A+B max","flag = 1 : Normal distribution A is mean and B deviation"," ","A and B must be vector with equal sizes","seed is the seed of random number generator (integer<2**31)"],["flag","A","B","seed"],list("vec",1,"vec",-1,"vec","size(%2,\'*\')","vec",1),exprs);
if (!ok) {
break
}
if (flag!=0&&flag!=1) {
message("flag must be equal to 1 or 0");
} else {
nout=size(a,"*");
graphics.exprs=exprs;
model.out=nout;
model.ipar=flag;
model.rpar=[a.slice(),b.slice()];
model.dstate=[seed_c,0*a.slice()];
x.graphics=graphics;
x.model=model;
break
}
}
}
RAND_f.prototype.define = function RAND_f() {
a=0;
b=1;
dt=0;
out=1;
flag=0;
model=scicos_model();
model.sim="rndblk";
model.out=out;
model.evtin=1;
model.dstate=[int(rand()*(10^7-1)),0*a.slice()];
model.rpar=[a.slice(),b.slice()];
model.ipar=flag;
model.blocktype="d";
model.dep_ut=[None,None];
exprs=[string(flag),sci2exp(a.slice()),sci2exp(b.slice()),string(model.dstate(1))];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
RAND_f.prototype.details = function RAND_f() {
}
}
/* autogenerated from "macros/Sources/READAU_f.sci" */
function READAU_f() {
READAU_f.prototype.get = function READAU_f() {
}
READAU_f.prototype.set = function READAU_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
out=model.out;
dstate=model.dstate;
ipar=model.ipar;
imask=9+ipar(1);
tmask=ipar(imask);
lunit=dstate(3);
fname=exprs(1);
while (true) {
[ok,fname1,N,swap,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"READAU_f")," ",gettext("(Read Audio File)")," ",gettext("Read is done on a binary \'.au\' file")],[gettext("Input File Name"),gettext("Buffer size"),gettext("Swap Mode (0:No, 1:Yes)")],list("str",1,"vec",1,"vec",1),exprs);
tmask1=[];
outmask=1;
frmt1="uc";
M=1;
offset=1;
if (!ok) {
break
}
fname1=stripblanks(fname1);
frmt1=stripblanks(frmt1);
if (alreadyran&&fname1!=fname) {
block_parameter_error(gettext("Simulation running !!! You cannot modify Input file name"),gettext("End current simulation first."));
} else if (fname1=="") {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter."),gettext("Input File Name")),gettext("You must provide a filename."));
} else if (N<1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Buffer size"),N),msprintf(gettext("Must be greater than %d."),1));
} else if (alreadyran&&(N!=ipar(6))) {
block_parameter_error(msprintf(gettext("You cannot modify \'%s\' when running."),gettext("Buffer Size")),gettext("End current simulation first."));
} else if (swap!=0&&swap!=1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Swap Mode"),swap),msprintf(gettext("Must be in the interval %s."),"[0, 1]"));
} else {
[model,graphics,ok]=check_io(model,graphics,[],1,1,[]);
frmt1=part(frmt1,1,3);
if (ok) {
ipar=[length(fname1),_str2code(frmt1),0,N,M,swap,offset,_str2code(fname1),tmask1,outmask.slice()];
if (prod(size(dstate))!=(N*M)+3) {
dstate=[-1,-1,lunit,zeros(N*M,1)];
}
model.dstate=dstate;
model.ipar=ipar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
READAU_f.prototype.define = function READAU_f() {
frmt="uc ";
fname="test.au";
lunit=0;
N=20;
M=1;
tmask=[];
swap=0;
offset=1;
outmask=1;
ievt=0;
nout=size(outmask,"*");
model=scicos_model();
model.sim=list("readau",2);
model.out=nout;
model.evtin=1;
model.dstate=[1,1,lunit,zeros(N*M,1)];
model.ipar=[length(fname),_str2code(frmt),ievt,N,M,swap,offset,_str2code(fname),tmask,outmask];
model.blocktype="d";
model.dep_ut=[None,None];
exprs=[fname,string(N),string(swap)];
gr_i=[];
x=standard_define([5,2],model,exprs,gr_i);
}
READAU_f.prototype.details = function READAU_f() {
}
}
/* autogenerated from "macros/Sources/CLKIN_f.sci" */
function CLKIN_f() {
CLKIN_f.prototype.get = function CLKIN_f() {
}
CLKIN_f.prototype.set = function CLKIN_f() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
exprs=exprs(1);
while (true) {
[ok,prt,exprs]=scicos_getvalue("Set Event Input block parameters","Port number",list("vec",1),exprs);
prt=int(prt);
if (!ok) {
break
}
if (prt<=0) {
message("Port number must be a positive integer");
} else {
model.ipar=prt;
model.evtout=1;
model.firing=-1;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CLKIN_f.prototype.define = function CLKIN_f() {
prt=1;
model=scicos_model();
model.sim="input";
model.evtout=1;
model.ipar=prt;
model.blocktype="d";
model.firing=-1;
model.dep_ut=[None,None];
exprs=string(prt);
x=standard_define([1,1],model,exprs," ");
}
CLKIN_f.prototype.details = function CLKIN_f() {
}
}
/* autogenerated from "macros/Sources/TIME_f.sci" */
function TIME_f() {
TIME_f.prototype.get = function TIME_f() {
}
TIME_f.prototype.set = function TIME_f() {
x=arg1;
}
TIME_f.prototype.define = function TIME_f() {
model=scicos_model();
model.sim="timblk";
model.out=1;
model.blocktype="c";
model.dep_ut=[None,true];
gr_i=[];
x=standard_define([2,2],model,[],gr_i);
}
TIME_f.prototype.details = function TIME_f() {
}
}
/* autogenerated from "macros/Sources/SampleCLK.sci" */
function SampleCLK() {
SampleCLK.prototype.get = function SampleCLK() {
}
SampleCLK.prototype.set = function SampleCLK() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
while (true) {
[ok,frequ,offset,exprs]=scicos_getvalue("Set block parameters",["Sample time","Offset"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (frequ<0) {
message("Frequency must be a positif number");
ok=None;
}
if (abs(offset)>frequ) {
message("The |Offset| must be less than the Frequency");
ok=None;
}
if (ok) {
if (or(model.rpar.slice()!=[frequ,offset])) {
needcompile=4;
y=needcompile;
}
model.rpar=[frequ,offset];
model.evtout=1;
model.firing=-1;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
needcompile=resume(needcompile)
}
SampleCLK.prototype.define = function SampleCLK() {
model=scicos_model();
model.sim="sampleclk";
model.evtout=1;
model.rpar=[1,0];
model.blocktype="d";
model.firing=-1;
model.dep_ut=[None,None];
exprs=[sci2exp(1),sci2exp(0)];
x=standard_define([2,2],model,exprs," ");
}
SampleCLK.prototype.details = function SampleCLK() {
}
}
/* autogenerated from "macros/Sources/READC_f.sci" */
function READC_f() {
READC_f.prototype.get = function READC_f() {
}
READC_f.prototype.set = function READC_f() {
x=arg1;
model=x.model;
graphics=arg1.graphics;
exprs=graphics.exprs;
out=model.out;
dstate=model.dstate;
ipar=model.ipar;
imask=9+ipar(1);
tmask=ipar(imask);
lunit=dstate(3);
fname=exprs(3);
frmt=exprs(4);
while (true) {
[ok,tmask1,outmask,fname1,frmt1,M,N,offset,swap,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"READC_f")," ",gettext("Read from C binary file")],[gettext("Time Record Selection"),gettext("Outputs Record Selection"),gettext("Input File Name"),gettext("Input Format"),gettext("Record Size"),gettext("Buffer Size"),gettext("Initial Record Index"),gettext("Swap Mode (0:No, 1:Yes)")],list("vec",-1,"vec",-1,"str",1,"str",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
fname1=pathconvert(stripblanks(fname1),None,true);
frmt1=stripblanks(frmt1);
fmts=["s","l","d","f","c","us","ul","uc","ull","uls","ubl","ubs","dl","fl","ll","sl","db","fb","lb","sb"];
nout=size(outmask,"*");
if (prod(size(tmask1))>1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter."),gettext("Time Record Selection")),gettext("Must be a scalar or an empty matrix."));
} else if (and(frmt1!=fmts)) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %s."),gettext("Input Format"),frmt1),gettext("Valid formats are: "+strcat(fmts,", ")));
} else if (alreadyran&&fname1!=fname) {
block_parameter_error(msprintf(gettext("You cannot modify \'%s\' when running"),gettext("Input File Name")),gettext("End current simulation first."));
} else if (N!=ipar(6)&&alreadyran) {
block_parameter_error(msprintf(gettext("You cannot modify \'%s\' when running."),gettext("Buffer Size")),gettext("End current simulation first"));
} else if (alreadyran&&size(tmask1)!=size(tmask)) {
block_parameter_error(msprintf(gettext("You cannot modify \'%s\' when running."),gettext("Time Record Selection")),gettext("End current simulation first."));
} else if (fname1=="") {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter."),gettext("Input File Name")),gettext("You must provide a file name."));
} else if (M<1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Record Size"),M),gettext("Strictly positive integer expected."));
} else if (tmask1!=[]&&(tmask1<1||tmask1>M)) {
block_parameter_error(msprintf(gettext("Wrong value for  \'%s\' parameter: %d."),gettext("Time Record Selection"),tmask1),msprintf(gettext("Must be in the interval %s."),gettext("[1, Record Size = ")+string(M)+"]"));
} else if (nout==0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Outputs Record Selection"),nout),gettext("Strictly positive integer expected."));
} else if (nout>M) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Outputs Record Selection"),nout),msprintf(gettext("Must be in the interval %s."),gettext("[1, Record Size = ")+string(M)+"]"));
} else if (max(outmask)>M||min(outmask)<1) {
block_parameter_error(msprintf(gettext("Wrong value for indexes in \'%s\' parameter: %s."),gettext("Outputs Record Selection"),strcat(string(outmask.slice())," ")),msprintf(gettext("Must be in the interval %s."),gettext("[1, Record Size = ")+string(M)+"]"));
} else if (N<1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Buffer Size"),N),gettext("Strictly positive integer expected."));
} else if (swap!=0&&swap!=1) {
block_parameter_error(msprintf(gettext("Wrong value for  \'%s\' parameter: %d."),gettext("Swap Mode"),swap),msprintf(gettext("Must be in the interval %s."),"[0, 1]"));
} else if (offset<1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Initial Record Index"),offset),gettext("Strictly positive integer expected."));
} else {
if (tmask1==[]) {
ievt=0;
tmask1=0;
outpt=[];
} else {
ievt=1;
outpt=1;
}
out=size(outmask,"*");
[model,graphics,ok]=check_io(model,graphics,[],out,1,outpt);
frmt1=part(frmt1,1,3);
if (ok) {
if (ievt==0) {
model.firing=-1;
} else {
model.firing=0;
}
ipar=[length(fname1),_str2code(frmt1),ievt,N,M,swap,offset,_str2code(fname1),tmask1,outmask.slice()];
if (prod(size(dstate))!=(N*M)+3) {
dstate=[-1,-1,lunit,zeros(N*M,1)];
}
model.dstate=dstate;
model.ipar=ipar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
READC_f.prototype.define = function READC_f() {
frmt="d  ";
fname="foo";
lunit=0;
N=20;
M=1;
rpar=[];
tmask=0;
swap=0;
offset=1;
outmask=1;
ievt=0;
nout=size(outmask,"*");
ipar=[length(fname),_str2code(frmt),ievt,N,M,swap,offset,_str2code(fname),tmask,outmask];
model=scicos_model();
model.sim=list("readc",2);
model.out=nout;
model.evtin=1;
model.evtout=[];
model.dstate=[1,1,lunit,zeros(N*M,1)];
model.ipar=[length(fname),_str2code(frmt),ievt,N,M,swap,offset,_str2code(fname),tmask,outmask];
model.blocktype="d";
model.firing=-1;
model.dep_ut=[None,None];
exprs=["[]",sci2exp(outmask),fname,frmt,string(M),string(N),string(offset),string(swap)];
gr_i=[];
x=standard_define([4,2],model,exprs,gr_i);
}
READC_f.prototype.details = function READC_f() {
}
}
/* autogenerated from "macros/Sources/CONST.sci" */
function CONST() {
CONST.prototype.get = function CONST() {
}
CONST.prototype.set = function CONST() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,C,exprs]=scicos_getvalue(["Set Contant Block"],"Constant",list("vec",-1),exprs);
if (!ok) {
break
}
sz=size(C);
nout=size(C,"*");
if (nout==0) {
message("C must have at least one element");
} else if (and(sz>1)) {
message("C matrix is not supported, use CONST_m instead");
} else {
model.rpar=C.slice();
model.out=nout;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CONST.prototype.define = function CONST() {
C=1;
model=scicos_model();
model.sim=list("cstblk4",4);
model.in=[];
model.out=1;
model.rpar=C;
model.blocktype="d";
model.dep_ut=[None,None];
exprs=strcat(sci2exp(C));
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CONST.prototype.details = function CONST() {
}
}
/* autogenerated from "macros/Sources/Modulo_Count.sci" */
function Modulo_Count() {
Modulo_Count.prototype.get = function Modulo_Count() {
}
Modulo_Count.prototype.set = function Modulo_Count() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,ini_c,base,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"Modulo_Count")," ",gettext("Modulo counter (0 to N counter)")," "],[gettext("Initial State (zero or positive number)"),gettext("Upper Limit (positive number)")],list("vec",1,"vec",1),exprs);
ini_c=int(ini_c);
base=int(base);
if (!ok) {
break
}
if (ini_c<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'Initial State\' parameter: %d."),ini_c),gettext("Null or positive integer expected."));
} else if (base<=0) {
block_parameter_error(msprintf(gettext("Wrong values for \'Upper Limit\' parameter: %d."),base),gettext("Strictly positive integer expected."));
} else {
graphics.exprs=exprs;
model.ipar=base;
model.dstate=ini_c;
x.graphics=graphics;
x.model=model;
break
}
}
}
Modulo_Count.prototype.define = function Modulo_Count() {
ini_c=0;
base=3;
model=scicos_model();
model.sim=list("modulo_count",4);
model.evtin=1;
model.out=1;
model.dstate=ini_c;
model.ipar=base;
model.blocktype="c";
model.dep_ut=[None,None];
exprs=[string(ini_c),string(base)];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
Modulo_Count.prototype.details = function Modulo_Count() {
}
}
/* autogenerated from "macros/Sources/CONST_m.sci" */
function CONST_m() {
CONST_m.prototype.get = function CONST_m() {
}
CONST_m.prototype.set = function CONST_m() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,C,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"CONST_m")," ",gettext("Constant value generator")," "],gettext("Constant Value"),list("vec",-1),exprs);
if (!ok) {
break
}
nout=size(C);
if (find(nout==0)!=[]) {
block_parameter_error(msprintf(gettext("Wrong size for \'%s\' parameter"),gettext("Constant Value")),gettext("Constant value must have at least one element."));
} else {
model.sim=list("cstblk4_m",4);
model.opar=list(C);
if ((type(C)==1)) {
if (isreal(C)) {
ot=1;
} else {
ot=2;
}
} else if ((typeof(C)=="int32")) {
ot=3;
} else if ((typeof(C)=="int16")) {
ot=4;
} else if ((typeof(C)=="int8")) {
ot=5;
} else if ((typeof(C)=="uint32")) {
ot=6;
} else if ((typeof(C)=="uint16")) {
ot=7;
} else if ((typeof(C)=="uint8")) {
ot=8;
} else {
block_parameter_error(msprintf(gettext("Wrong type for \'%s\' parameter"),gettext("Constant Value")),gettext("Value type must be a numeric type (double, complex, int, int8, ...)."));
ok=None;
}
if (ok) {
model.rpar=[];
[model,graphics,ok]=set_io(model,graphics,list(),list(nout,ot),[],[]);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
CONST_m.prototype.define = function CONST_m() {
C=[1];
model=scicos_model();
model.sim=list("cstblk4",4);
model.in=[];
model.out=size(C,1);
model.in2=[];
model.out2=size(C,2);
model.rpar=C;
model.opar=list();
model.blocktype="d";
model.dep_ut=[None,None];
exprs=sci2exp(C);
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CONST_m.prototype.details = function CONST_m() {
}
}
/* autogenerated from "macros/Sources/CLKINV_f.sci" */
function CLKINV_f() {
CLKINV_f.prototype.get = function CLKINV_f() {
}
CLKINV_f.prototype.set = function CLKINV_f() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
exprs=exprs(1);
while (true) {
[ok,prt,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"CLKINV_f")," ",gettext("Event input port")," "],"Port Number",list("vec",1),exprs);
prt=int(prt);
if (!ok) {
break
}
if (prt<=0) {
block_parameter_error(msprintf(gettext("Wrong values for \'Port Number\' parameter: %d."),prt),gettext("Strictly positive integer expected."));
} else {
model.ipar=prt;
model.evtout=1;
model.firing=-1;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CLKINV_f.prototype.define = function CLKINV_f() {
prt=1;
model=scicos_model();
model.sim="input";
model.evtout=1;
model.ipar=prt;
model.blocktype="d";
model.firing=-1;
model.dep_ut=[None,None];
exprs=string(prt);
gr_i=[];
x=standard_define([1,1],model,exprs,gr_i);
}
CLKINV_f.prototype.details = function CLKINV_f() {
}
}
/* autogenerated from "macros/Sources/GENSIN_f.sci" */
function GENSIN_f() {
GENSIN_f.prototype.get = function GENSIN_f() {
}
GENSIN_f.prototype.set = function GENSIN_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,M,F,P,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"GENSIN_f")," ",gettext("Sine wave generator")," "],[gettext("Magnitude"),gettext("Frequency (rad/s)"),gettext("Phase (rad)")],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (F<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'Frequency\' parameter: %e."),F),gettext("Strictly positive integer expected."));
ok=None;
}
if (ok) {
[model,graphics,ok]=check_io(model,graphics,[],1,[],[]);
model.rpar=[M,F,P];
model.out2=1;
model.outtyp=1;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
GENSIN_f.prototype.define = function GENSIN_f() {
rpar=[1,1,0];
model=scicos_model();
model.sim="gensin";
model.in=[];
model.out=1;
model.out2=1;
model.outtyp=1;
model.rpar=[1,1,0];
model.blocktype="c";
model.dep_ut=[None,true];
exprs=[string(rpar(1)),string(rpar(2)),string(rpar(3))];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
GENSIN_f.prototype.details = function GENSIN_f() {
}
}
/* autogenerated from "macros/MatrixOp/SQRT.sci" */
function SQRT() {
SQRT.prototype.get = function SQRT() {
}
SQRT.prototype.set = function SQRT() {
x=arg1;
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
while (true) {
[ok,typ,exprs]=scicos_getvalue("Set SQRT Block",["Datatype(1=real double  2=Complex)"],list("vec",1),label);
if (!ok) {
break
}
if ((typ==1)) {
function_name="mat_sqrt";
} else if ((typ==2)) {
function_name="matz_sqrt";
} else {
message("type is not supported");
ok=None;
}
it=typ;
ot=typ;
in1=[model.in,model.in2];
out=[model.out,model.out2];
funtyp=4;
if (ok) {
label=exprs;
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
model.sim=list(function_name,funtyp);
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
SQRT.prototype.define = function SQRT() {
model=scicos_model();
model.sim=list("mat_sqrt",4);
model.in=-1;
model.in2=-2;
model.intyp=1;
model.outtyp=1;
model.out=-1;
model.out2=-2;
model.dep_ut=[true,None];
label=[sci2exp(1)];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
SQRT.prototype.details = function SQRT() {
}
}
/* autogenerated from "macros/MatrixOp/MATEXPM.sci" */
function MATEXPM() {
MATEXPM.prototype.get = function MATEXPM() {
}
MATEXPM.prototype.set = function MATEXPM() {
x=arg1;
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
if (size(label,"*")==14) {
label[9]=[];
}
while (true) {
[ok,typ,exprs]=scicos_getvalue("Set EXPM Block",["Datatype(1=real double  2=Complex)"],list("vec",1),label);
if (!ok) {
break
}
if ((typ==1)) {
function_name="mat_expm";
ot=1;
it=1;
} else if ((typ==2)) {
function_name="matz_expm";
ot=2;
it=2;
} else {
message("Datatype is not supported");
ok=None;
}
in1=[model.in,model.in2];
out=[model.out,model.out2];
funtyp=4;
if (ok) {
label=exprs;
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
model.sim=list(function_name,funtyp);
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
MATEXPM.prototype.define = function MATEXPM() {
model=scicos_model();
function_name="mat_expm";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in=-1;
model.in2=-1;
model.intyp=1;
model.out=-1;
model.out2=-1;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1)];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
MATEXPM.prototype.details = function MATEXPM() {
}
}
/* autogenerated from "macros/MatrixOp/MATPINV.sci" */
function MATPINV() {
MATPINV.prototype.get = function MATPINV() {
}
MATPINV.prototype.set = function MATPINV() {
x=arg1;
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
if (size(label,"*")==14) {
label[9]=[];
}
while (true) {
[ok,typ,exprs]=scicos_getvalue("Set MATPINV Block",["Datatype(1=real double  2=Complex)"],list("vec",1),label);
if (!ok) {
break
}
if ((typ==1)) {
function_name="mat_pinv";
ot=1;
it=1;
} else if ((typ==2)) {
function_name="matz_pinv";
ot=2;
it=2;
} else {
message("Datatype is not supported");
ok=None;
}
in1=[model.in,model.in2];
out=[model.out,model.out2];
funtyp=4;
if (ok) {
label=exprs;
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
model.sim=list(function_name,funtyp);
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
MATPINV.prototype.define = function MATPINV() {
model=scicos_model();
function_name="mat_pinv";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in=-1;
model.in2=-2;
model.intyp=1;
model.out=-2;
model.out2=-1;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1)];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
MATPINV.prototype.details = function MATPINV() {
}
}
/* autogenerated from "macros/MatrixOp/MATDIAG.sci" */
function MATDIAG() {
MATDIAG.prototype.get = function MATDIAG() {
}
MATDIAG.prototype.set = function MATDIAG() {
x=arg1;
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
if (size(label,"*")==14) {
label[9]=[];
}
while (true) {
[ok,typ,exprs]=scicos_getvalue("Set MATDIAG Block",["Datatype (1=real double  2=Complex)"],list("vec",1),label);
if (!ok) {
break
}
if ((typ==1)) {
function_name="mat_diag";
ot=1;
it=1;
} else if ((typ==2)) {
function_name="matz_diag";
ot=2;
it=2;
} else {
message("Datatype is not supported");
ok=None;
}
in1=[model.in,model.in2];
out=[model.out,model.out2];
funtyp=4;
if (ok) {
label=exprs;
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
model.sim=list(function_name,funtyp);
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
MATDIAG.prototype.define = function MATDIAG() {
model=scicos_model();
function_name="mat_diag";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in=-1;
model.in2=1;
model.intyp=1;
model.out=-1;
model.out2=-1;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1)];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
MATDIAG.prototype.details = function MATDIAG() {
}
}
/* autogenerated from "macros/MatrixOp/MATZCONJ.sci" */
function MATZCONJ() {
MATZCONJ.prototype.get = function MATZCONJ() {
}
MATZCONJ.prototype.set = function MATZCONJ() {
x=arg1;
}
MATZCONJ.prototype.define = function MATZCONJ() {
model=scicos_model();
function_name="matz_conj";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in=-1;
model.in2=-2;
model.intyp=2;
model.out=-1;
model.out2=-2;
model.outtyp=2;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
MATZCONJ.prototype.details = function MATZCONJ() {
}
}
/* autogenerated from "macros/MatrixOp/MATINV.sci" */
function MATINV() {
MATINV.prototype.get = function MATINV() {
}
MATINV.prototype.set = function MATINV() {
x=arg1;
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
if (size(label,"*")==14) {
label[9]=[];
}
while (true) {
[ok,typ,exprs]=scicos_getvalue("Set MATINV Block",["Datatype(1=real double  2=Complex)"],list("vec",1),label);
if (!ok) {
break
}
if ((typ==1)) {
function_name="mat_inv";
ot=1;
it=1;
} else if ((typ==2)) {
function_name="matz_inv";
ot=2;
it=2;
} else {
message("Datatype is not supported");
ok=None;
}
in1=[model.in,model.in2];
out=[model.out,model.out2];
funtyp=4;
if (ok) {
label=exprs;
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
model.sim=list(function_name,funtyp);
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
MATINV.prototype.define = function MATINV() {
model=scicos_model();
function_name="mat_inv";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in=-1;
model.in2=-1;
model.intyp=1;
model.out=-1;
model.out2=-1;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1)];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
MATINV.prototype.details = function MATINV() {
}
}
/* autogenerated from "macros/MatrixOp/MATLU.sci" */
function MATLU() {
MATLU.prototype.get = function MATLU() {
}
MATLU.prototype.set = function MATLU() {
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
label=graphics.exprs;
if (size(label,"*")==14) {
label[9]=[];
}
while (true) {
[ok,typ,lab]=scicos_getvalue("Set MATLU block parameters",["Datatype(1=real double  2=Complex)"],list("vec",1),label);
if (!ok) {
break
}
if ((typ==1)) {
function_name="mat_lu";
ot=[1,1];
it=1;
} else if ((typ==2)) {
function_name="matz_lu";
ot=[2,2];
it=2;
} else {
message("Datatype is not supported");
ok=None;
}
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list([model.in,model.in2],it),list([model.out,model.out2],ot),[],[]);
}
if (ok) {
funtyp=4;
model.sim=list(function_name,funtyp);
graphics.exprs=lab;
x.graphics=graphics;
x.model=model;
break
}
}
}
MATLU.prototype.define = function MATLU() {
model=scicos_model();
function_name="mat_lu";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in=-1;
model.in2=-1;
model.intyp=1;
model.out=[-1,-1];
model.out2=[-1,-1];
model.outtyp=[1,1];
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=sci2exp(1);
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
MATLU.prototype.details = function MATLU() {
}
}
/* autogenerated from "macros/MatrixOp/MATBKSL.sci" */
function MATBKSL() {
MATBKSL.prototype.get = function MATBKSL() {
}
MATBKSL.prototype.set = function MATBKSL() {
x=arg1;
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
if (size(label,"*")==14) {
label[9]=[];
}
while (true) {
[ok,typ,exprs]=scicos_getvalue("Set MATBKSL Block",["Datatype (1=real double  2=Complex)"],list("vec",1),label);
if (!ok) {
break
}
if ((typ==1)) {
function_name="mat_bksl";
ot=1;
it=[1,1];
} else if ((typ==2)) {
function_name="matz_bksl";
ot=2;
it=[2,2];
} else {
message("Datatype is not supported");
ok=None;
}
in1=[model.in,model.in2];
out=[model.out,model.out2];
funtyp=4;
if (ok) {
label=exprs;
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
model.sim=list(function_name,funtyp);
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
MATBKSL.prototype.define = function MATBKSL() {
model=scicos_model();
function_name="mat_bksl";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in=[-1,-1];
model.in2=[-2,-3];
model.intyp=[1,1];
model.out=-2;
model.out2=-3;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1)];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
MATBKSL.prototype.details = function MATBKSL() {
}
}
/* autogenerated from "macros/MatrixOp/MATRESH.sci" */
function MATRESH() {
MATRESH.prototype.get = function MATRESH() {
}
MATRESH.prototype.set = function MATRESH() {
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
label=graphics.exprs;
if (size(label,"*")==14) {
label[9]=[];
}
while (true) {
[ok,typ,l1,out,lab]=scicos_getvalue("Set MATRESH block parameters",["Datatype(1=real double  2=Complex)","input size","output size desired"],list("vec",-1,"vec",-1,"vec",-1),label);
if (!ok) {
break
}
nout=size(out);
nin=size(l1);
if (nout==0) {
message("output must have at least one element");
ok=None;
}
if (nin==0) {
message("input must have at least one element");
ok=None;
}
if (ok) {
if (((out(1)>(l1(1)*l1(2))))) {
message("the first dimension of the output is too big");
ok=None;
}
if (((out(2)>(l1(1)*l1(2))))) {
message("the second dimension of the output is too big");
ok=None;
}
if ((((out(2)*out(1))>(l1(1)*l1(2))))) {
message("the dimensions of the output are too big");
ok=None;
}
}
if ((typ==1)) {
function_name="mat_reshape";
ot=1;
it=1;
} else if ((typ==2)) {
function_name="matz_reshape";
ot=2;
it=2;
} else {
message("Datatype is not supported");
ok=None;
}
if (ok) {
label=lab;
[model,graphics,ok]=set_io(model,graphics,list(l1,it),list(out,ot),[],[]);
}
if (ok) {
funtyp=4;
model.sim=list(function_name,funtyp);
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
needcompile=resume(needcompile)
}
MATRESH.prototype.define = function MATRESH() {
model=scicos_model();
function_name="mat_reshape";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in=-1;
model.in2=-2;
model.intyp=1;
model.out=-1;
model.out2=-2;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1),sci2exp([1,1]),sci2exp([1,1])];
gr_i=[];
x=standard_define([3,2],model,label,gr_i);
}
MATRESH.prototype.details = function MATRESH() {
}
}
/* autogenerated from "macros/MatrixOp/MATTRAN.sci" */
function MATTRAN() {
MATTRAN.prototype.get = function MATTRAN() {
}
MATTRAN.prototype.set = function MATTRAN() {
x=arg1;
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
if (size(label,"*")==1) {
label[2]=sci2exp(1);
}
while (true) {
[ok,typ,rule,exprs]=scicos_getvalue("Set MATTRAN Block",["Datatype(1=real double 2=Complex)","rule (1=.\' 2=\')"],list("vec",1,"vec",1),label);
if (!ok) {
break
}
if ((typ==1)) {
function_name="mattran_m";
ot=1;
it=1;
} else if ((typ==2)) {
if (rule==1) {
function_name="matztran_m";
} else {
function_name="mathermit_m";
}
ot=2;
it=2;
} else {
message("Datatype is not supported");
ok=None;
}
in1=[model.in,model.in2];
out=[model.out,model.out2];
funtyp=4;
if (ok) {
label=exprs;
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
model.sim=list(function_name,funtyp);
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
MATTRAN.prototype.define = function MATTRAN() {
model=scicos_model();
model.sim=list("mattran_m",4);
model.in=-1;
model.in2=-2;
model.out=-2;
model.out2=-1;
model.dep_ut=[true,None];
label=[sci2exp(1)];
gr_i=[];
x=standard_define([3,2],model,label,gr_i);
}
MATTRAN.prototype.details = function MATTRAN() {
}
}
/* autogenerated from "macros/MatrixOp/RICC.sci" */
function RICC() {
RICC.prototype.get = function RICC() {
}
RICC.prototype.set = function RICC() {
x=arg1;
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
if (size(label,"*")==14) {
label[9]=[];
}
while (true) {
[ok,tpe,mod,exprs]=scicos_getvalue("Set RICC Block",["Type (1=Cont  2=Disc)","Model(1=Schr  2=sign(cont) inv(disc))"],list("vec",1,"vec",1),label);
if (!ok) {
break
}
in1=[model.in,model.in2];
out=[model.out,model.out2];
it=[1,1,1];
ot=1;
label=exprs;
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
if (ok) {
model.ipar=[tpe,mod];
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
RICC.prototype.define = function RICC() {
model=scicos_model();
function_name="ricc_m";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in=[-1,-1,-1];
model.in2=[-1,-1,-1];
model.intyp=[1,1,1];
model.out=-1;
model.out2=-1;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[1,1];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1),sci2exp(1)];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
RICC.prototype.details = function RICC() {
}
}
/* autogenerated from "macros/MatrixOp/MATDET.sci" */
function MATDET() {
MATDET.prototype.get = function MATDET() {
}
MATDET.prototype.set = function MATDET() {
x=arg1;
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
if (size(label,"*")==14) {
label[9]=[];
}
while (true) {
[ok,typ,exprs]=scicos_getvalue("Set MATDET Block",["Datatype(1=real double  2=Complex)"],list("vec",1),label);
if (!ok) {
break
}
if ((typ==1)) {
function_name="mat_det";
ot=1;
it=1;
} else if ((typ==2)) {
function_name="matz_det";
ot=2;
it=2;
} else {
message("Datatype is not supported");
ok=None;
}
in1=[model.in,model.in2];
out=[model.out,model.out2];
funtyp=4;
if (ok) {
label=exprs;
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
model.sim=list(function_name,funtyp);
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
MATDET.prototype.define = function MATDET() {
model=scicos_model();
function_name="mat_det";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in=-1;
model.in2=-1;
model.intyp=1;
model.out=1;
model.out2=1;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1)];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
MATDET.prototype.details = function MATDET() {
}
}
/* autogenerated from "macros/MatrixOp/MATDIV.sci" */
function MATDIV() {
MATDIV.prototype.get = function MATDIV() {
}
MATDIV.prototype.set = function MATDIV() {
x=arg1;
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
if (size(label,"*")==14) {
label[9]=[];
}
while (true) {
[ok,typ,exprs]=scicos_getvalue("Set MATDIV Block",["Datatype(1=real double  2=Complex)"],list("vec",1),label);
if (!ok) {
break
}
if ((typ==1)) {
function_name="mat_div";
ot=1;
it=[1,1];
} else if ((typ==2)) {
function_name="matz_div";
ot=2;
it=[2,2];
} else {
message("Datatype is not supported");
ok=None;
}
in1=[model.in,model.in2];
out=[model.out,model.out2];
funtyp=4;
if (ok) {
label=exprs;
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
model.sim=list(function_name,funtyp);
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
MATDIV.prototype.define = function MATDIV() {
model=scicos_model();
function_name="mat_div";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in=[-1,-2];
model.in2=[-3,-3];
model.intyp=[1,1];
model.out=-1;
model.out2=-2;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1)];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
MATDIV.prototype.details = function MATDIV() {
}
}
/* autogenerated from "macros/MatrixOp/EXTTRI.sci" */
function EXTTRI() {
EXTTRI.prototype.get = function EXTTRI() {
}
EXTTRI.prototype.set = function EXTTRI() {
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
label=graphics.exprs;
if (size(label,"*")==14) {
label[9]=[];
}
while (true) {
[ok,typ,decomptyp,lab]=scicos_getvalue("Set EXTTRI block parameters",["Datatype(1=real double  2=Complex)","extraction type (1=lower  2=upper  3=diagonal)"],list("vec",1,"vec",1),label);
if (!ok) {
break
}
label=lab;
if ((typ==1)) {
if ((decomptyp==1)) {
function_name="exttril";
} else if ((decomptyp==2)) {
function_name="exttriu";
} else if ((decomptyp==3)) {
function_name="extdiag";
} else {
message("decomposition type is not supported");
ok=None;
}
it=1;
ot=1;
} else if ((typ==2)) {
if ((decomptyp==1)) {
function_name="exttrilz";
} else if ((decomptyp==2)) {
function_name="exttriuz";
} else if ((decomptyp==3)) {
function_name="extdiagz";
} else {
message("decomposition type is not supported");
ok=None;
}
it=2;
ot=2;
} else {
message("Datatype is not supported");
ok=None;
}
in1=[model.in,model.in2];
out=[model.out,model.out2];
funtyp=4;
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
if (ok) {
model.sim=list(function_name,funtyp);
arg1.model=model;
graphics.exprs=label;
arg1.graphics=graphics;
x=arg1;
break
}
}
}
EXTTRI.prototype.define = function EXTTRI() {
model=scicos_model();
function_name="extrilz";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in=-1;
model.in2=-2;
model.intyp=1;
model.out=-1;
model.out2=-2;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1),sci2exp(1)];
gr_i=[];
x=standard_define([3,2],model,label,gr_i);
}
EXTTRI.prototype.details = function EXTTRI() {
}
}
/* autogenerated from "macros/Threshold/NEGTOPOS_f.sci" */
function NEGTOPOS_f() {
NEGTOPOS_f.prototype.get = function NEGTOPOS_f() {
}
NEGTOPOS_f.prototype.set = function NEGTOPOS_f() {
x=arg1;
x.model.firing=-1;
}
NEGTOPOS_f.prototype.define = function NEGTOPOS_f() {
model=scicos_model();
model.sim=list("zcross",1);
model.nzcross=1;
model.in=1;
model.evtout=1;
model.rpar=[-1,-1,0,-1];
model.blocktype="z";
model.firing=-1;
model.dep_ut=[true,None];
gr_i=[];
x=standard_define([2,2],model,[],gr_i);
}
NEGTOPOS_f.prototype.details = function NEGTOPOS_f() {
}
}
/* autogenerated from "macros/Threshold/POSTONEG_f.sci" */
function POSTONEG_f() {
POSTONEG_f.prototype.get = function POSTONEG_f() {
}
POSTONEG_f.prototype.set = function POSTONEG_f() {
x=arg1;
x.model.firing=[-1];
}
POSTONEG_f.prototype.define = function POSTONEG_f() {
rpar=[-1,-1,-1,0];
model=scicos_model();
model.sim=list("zcross",1);
model.nzcross=1;
model.in=1;
model.evtout=1;
model.rpar=[-1,-1,-1,0];
model.blocktype="z";
model.dep_ut=[true,None];
model.firing=[-1];
gr_i=[];
x=standard_define([2,2],model,[],gr_i);
}
POSTONEG_f.prototype.details = function POSTONEG_f() {
}
}
/* autogenerated from "macros/Electrical/PotentialSensor.sci" */
function PotentialSensor() {
PotentialSensor.prototype.get = function PotentialSensor() {
}
PotentialSensor.prototype.set = function PotentialSensor() {
x=arg1;
}
PotentialSensor.prototype.define = function PotentialSensor() {
model=scicos_model();
model.in=[1];
model.out=[1];
model.rpar=[];
model.sim="PotentialSensor";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="PotentialSensor";
mo.inputs="p";
mo.outputs=["v"];
model.equations=mo;
gr_i=[];
x=standard_define([2,2],model,"",list(gr_i,0));
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["E"];
}
PotentialSensor.prototype.details = function PotentialSensor() {
}
}
/* autogenerated from "macros/Electrical/SineVoltage.sci" */
function SineVoltage() {
SineVoltage.prototype.get = function SineVoltage() {
}
SineVoltage.prototype.set = function SineVoltage() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,V,ph,frq,offset,start,exprs]=scicos_getvalue("Set voltage source parameter",["Amplitude (Volt)","phase (rad)","Frequency (Hz)","Voltageoffset (V)","Timeoffset (s)"],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
model.rpar=[V,ph,frq,offset,start];
model.equations.parameters[2]=list(V,ph,frq,offset,start);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
SineVoltage.prototype.define = function SineVoltage() {
model=scicos_model();
model.in=[1];
model.out=[1];
V=1;
ph=0;
frq=1;
offset=0;
start=0;
model.rpar=[V,ph,frq,offset,start];
model.sim="SineVoltage";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="SineVoltage";
mo.inputs="p";
mo.outputs="n";
mo.parameters=list(["V","phase","freqHz","offset","startTime"],list(V,ph,frq,offset,start));
model.equations=mo;
exprs=[string(V),string(ph),string(frq),string(offset),string(start)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I"];
}
SineVoltage.prototype.details = function SineVoltage() {
}
}
/* autogenerated from "macros/Electrical/CCS.sci" */
function CCS() {
CCS.prototype.get = function CCS() {
}
CCS.prototype.set = function CCS() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
x=arg1;
}
CCS.prototype.define = function CCS() {
ModelName="CCS";
PrametersValue=[];
ParametersName=[];
model=scicos_model();
Typein=[];
Typeout=[];
MI=[];
MO=[];
P=[2,50,1,0,70,98,2,0,70,2,-2,0];
PortName=["Iin","p","n"];
for(i=1;i<=size(P,"r");i+=1) {
if (P(i,3)==1) {
Typein=[Typein,"E"];
MI=[MI,PortName(i)];
}
if (P(i,3)==2) {
Typein=[Typein,"I"];
MI=[MI,PortName(i)];
}
if (P(i,3)==-1) {
Typeout=[Typeout,"E"];
MO=[MO,PortName(i)];
}
if (P(i,3)==-2) {
Typeout=[Typeout,"I"];
MO=[MO,PortName(i)];
}
}
model=scicos_model();
mo=modelica();
model.sim=ModelName;
mo.inputs=MI;
mo.outputs=MO;
model.rpar=PrametersValue;
mo.parameters=list(ParametersName,PrametersValue,zeros(ParametersName));
exprs=[];
gr_i=[];
model.blocktype="c";
model.dep_ut=[None,true];
mo.model=ModelName;
model.equations=mo;
model.in=ones(size(MI,"*"),1);
model.out=ones(size(MO,"*"),1);
x=standard_define([2.1,3],model,exprs,list(gr_i,0));
x.graphics.in_implicit=Typein;
x.graphics.out_implicit=Typeout;
}
CCS.prototype.details = function CCS() {
}
}
/* autogenerated from "macros/Electrical/PMOS.sci" */
function PMOS() {
PMOS.prototype.get = function PMOS() {
}
PMOS.prototype.set = function PMOS() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,W,L,Beta,Vt,K2,K5,dW,dL,RDS,exprs]=scicos_getvalue("Set PMOS Transistor parameters",["Width [m]","Length [m]","Transconductance parameter [A/(V*V)]","Zero bias threshold voltage [V]","Bulk threshold parameter","Reduction of pinch-off region","Narrowing of channel [m]","Shortening of channel [m]","Drain-Source-Resistance [Ohm]"],list("vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
model.equations.parameters[2]=list(W,L,Beta,Vt,K2,K5,dW,dL,RDS);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
PMOS.prototype.define = function PMOS() {
model=scicos_model();
W=50.0e-6;
L=6.0e-6;
Beta=0.0105e-3;
Vt=-1;
K2=0.41;
K5=0.839;
dW=-2.5e-6;
dL=-2.1e-6;
RDS=1.e+7;
model.sim="PMOS";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="PMOS";
mo.outputs=["D","B","S"];
mo.inputs="G";
mo.parameters=list(["W","L","Beta","Vt","K2","K5","dW","dL","RDS"],[W,L,Beta,Vt,K2,K5,dW,dL,RDS]);
model.equations=mo;
model.in=ones(size(mo.inputs,"*"),1);
model.out=ones(size(mo.outputs,"*"),1);
exprs=[string(W),string(L),string(Beta),string(Vt),string(K2),string(K5),string(dW),string(dL),string(RDS)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I","I","I"];
}
PMOS.prototype.details = function PMOS() {
}
}
/* autogenerated from "macros/Electrical/Diode.sci" */
function Diode() {
Diode.prototype.get = function Diode() {
}
Diode.prototype.set = function Diode() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,Ids,Vt,Maxexp,R,exprs]=scicos_getvalue("Set Diode block parameter",["Saturation cuurent (A)","Voltage equivalent to temperature (Volt)","Max exponent for linear continuation","R (ohm)"],list("vec",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
model.rpar=[Ids,Vt,Maxexp,R];
model.equations.parameters=list(["Ids","Vt","Maxexp","R"],list(Ids,Vt,Maxexp,R));
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
Diode.prototype.define = function Diode() {
Ids=1.e-6;
Vt=0.04;
Maxexp=15;
R=1.e8;
model=scicos_model();
model.rpar=[Ids,Vt,Maxexp,R];
model.in=1;
model.out=1;
model.sim="Diode";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="Diode";
mo.inputs="p";
mo.outputs="n";
mo.parameters=list(["Ids","Vt","Maxexp","R"],list(Ids,Vt,Maxexp,R));
model.equations=mo;
exprs=string([Ids,Vt,Maxexp,R]);
gr_i=[];
x=standard_define([2,1],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I"];
}
Diode.prototype.details = function Diode() {
}
}
/* autogenerated from "macros/Electrical/IdealTransformer.sci" */
function IdealTransformer() {
IdealTransformer.prototype.get = function IdealTransformer() {
}
IdealTransformer.prototype.set = function IdealTransformer() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
x=arg1;
exprs=x.graphics.exprs;
while (true) {
[ok,N,exprs]=scicos_getvalue(["Set Transformer block parameters:","","N:"+" Turn ratio (N1/N2)"],["N"],list("vec",1),exprs);
if (!ok) {
break
}
x.model.equations.parameters[2]=list(N);
x.graphics.exprs=exprs;
break
}
}
IdealTransformer.prototype.define = function IdealTransformer() {
ModelName="IdealTransformer";
PrametersValue=[1];
ParametersName=["N"];
model=scicos_model();
Typein=[];
Typeout=[];
MI=[];
MO=[];
P=[2.5,90,2,0,2.5,10,2,0,97.5,90,-2,0,97.5,10,-2,0];
PortName=["p1","n1","p2","n2"];
for(i=1;i<=size(P,"r");i+=1) {
if (P(i,3)==1) {
Typein=[Typein,"E"];
MI=[MI,PortName(i)];
}
if (P(i,3)==2) {
Typein=[Typein,"I"];
MI=[MI,PortName(i)];
}
if (P(i,3)==-1) {
Typeout=[Typeout,"E"];
MO=[MO,PortName(i)];
}
if (P(i,3)==-2) {
Typeout=[Typeout,"I"];
MO=[MO,PortName(i)];
}
}
model=scicos_model();
mo=modelica();
model.sim=ModelName;
mo.inputs=MI;
mo.outputs=MO;
model.rpar=PrametersValue;
mo.parameters=list(ParametersName,PrametersValue,zeros(ParametersName));
exprs=["1"];
gr_i=[];
model.blocktype="c";
model.dep_ut=[None,true];
mo.model=ModelName;
model.equations=mo;
model.in=ones(size(MI,"*"),1);
model.out=ones(size(MO,"*"),1);
x=standard_define([2,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=Typein;
x.graphics.out_implicit=Typeout;
}
IdealTransformer.prototype.details = function IdealTransformer() {
}
}
/* autogenerated from "macros/Electrical/Ground.sci" */
function Ground() {
Ground.prototype.get = function Ground() {
}
Ground.prototype.set = function Ground() {
x=arg1;
}
Ground.prototype.define = function Ground() {
model=scicos_model();
model.in=[1];
model.out=[];
model.sim="Ground";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="Ground";
mo.inputs="p";
model.equations=mo;
exprs="";
gr_i=[];
x=standard_define([1,1],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I"];
}
Ground.prototype.details = function Ground() {
}
}
/* autogenerated from "macros/Electrical/CVS.sci" */
function CVS() {
CVS.prototype.get = function CVS() {
}
CVS.prototype.set = function CVS() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
x=arg1;
}
CVS.prototype.define = function CVS() {
ModelName="CVS";
PrametersValue=[];
ParametersName=[];
model=scicos_model();
Typein=[];
Typeout=[];
MI=[];
MO=[];
P=[2,50,1,0,70,98,2,0,70,2,-2,0];
PortName=["vin","p","n"];
for(i=1;i<=size(P,"r");i+=1) {
if (P(i,3)==1) {
Typein=[Typein,"E"];
MI=[MI,PortName(i)];
}
if (P(i,3)==2) {
Typein=[Typein,"I"];
MI=[MI,PortName(i)];
}
if (P(i,3)==-1) {
Typeout=[Typeout,"E"];
MO=[MO,PortName(i)];
}
if (P(i,3)==-2) {
Typeout=[Typeout,"I"];
MO=[MO,PortName(i)];
}
}
model=scicos_model();
mo=modelica();
model.sim=ModelName;
mo.inputs=MI;
mo.outputs=MO;
model.rpar=PrametersValue;
mo.parameters=list(ParametersName,PrametersValue,zeros(ParametersName));
exprs=[];
gr_i=[];
model.blocktype="c";
model.dep_ut=[None,true];
mo.model=ModelName;
model.equations=mo;
model.in=ones(size(MI,"*"),1);
model.out=ones(size(MO,"*"),1);
x=standard_define([2.1,3],model,exprs,list(gr_i,0));
x.graphics.in_implicit=Typein;
x.graphics.out_implicit=Typeout;
}
CVS.prototype.details = function CVS() {
}
}
/* autogenerated from "macros/Electrical/Resistor.sci" */
function Resistor() {
Resistor.prototype.get = function Resistor() {
}
Resistor.prototype.set = function Resistor() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,R,exprs]=scicos_getvalue("Set Resistor block parameter","R (ohm)",list("vec",1),exprs);
if (!ok) {
break
}
model.rpar=R;
model.equations.parameters[2]=list(R);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
Resistor.prototype.define = function Resistor() {
model=scicos_model();
R=0.01;
model.rpar=R;
model.sim="resistor";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="Resistor";
mo.inputs="p";
mo.outputs="n";
mo.parameters=list("R",list(R));
model.equations=mo;
model.in=ones(size(mo.inputs,"*"),1);
model.out=ones(size(mo.outputs,"*"),1);
exprs=string(R);
gr_i=[];
x=standard_define([2,1],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I"];
}
Resistor.prototype.details = function Resistor() {
}
}
/* autogenerated from "macros/Electrical/CurrentSensor.sci" */
function CurrentSensor() {
CurrentSensor.prototype.get = function CurrentSensor() {
}
CurrentSensor.prototype.set = function CurrentSensor() {
x=arg1;
}
CurrentSensor.prototype.define = function CurrentSensor() {
model=scicos_model();
model.in=1;
model.out=[1,1];
model.sim="CurrentSensor";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="CurrentSensor";
mo.inputs="p";
mo.outputs=["n","i"];
model.equations=mo;
exprs=[];
gr_i=[];
x=standard_define([2,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I","E"];
}
CurrentSensor.prototype.details = function CurrentSensor() {
}
}
/* autogenerated from "macros/Electrical/ConstantVoltage.sci" */
function ConstantVoltage() {
ConstantVoltage.prototype.get = function ConstantVoltage() {
}
ConstantVoltage.prototype.set = function ConstantVoltage() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,V,exprs]=scicos_getvalue("Set ConstantVoltage block parameter","V (volt)",list("vec",1),exprs);
if (!ok) {
break
}
model.rpar=V;
model.equations.parameters[2]=list(V);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
ConstantVoltage.prototype.define = function ConstantVoltage() {
V=0.01;
model=scicos_model();
model.rpar=V;
model.in=1;
model.out=1;
model.sim="ConstantVoltage";
model.blocktype="c";
model.dep_ut=[None,None];
mo=modelica();
mo.model="ConstantVoltage";
mo.inputs="p";
mo.outputs="n";
mo.parameters=list("V",list(V));
model.equations=mo;
exprs=string(V);
gr_i=[];
x=standard_define([1.5,1.1],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I"];
}
ConstantVoltage.prototype.details = function ConstantVoltage() {
}
}
/* autogenerated from "macros/Electrical/VVsourceAC.sci" */
function VVsourceAC() {
VVsourceAC.prototype.get = function VVsourceAC() {
}
VVsourceAC.prototype.set = function VVsourceAC() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,FR,exprs]=scicos_getvalue("Set voltage source parameter",["Frequency (Hz)"],list("vec",-1),exprs);
if (!ok) {
break
}
model.rpar=[FR];
model.equations.parameters[2]=list(FR);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
VVsourceAC.prototype.define = function VVsourceAC() {
model=scicos_model();
model.in=[1,1];
model.out=[1];
VA=220;
FR=50;
model.rpar=[FR];
model.sim="VVsourceAC";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="VVsourceAC";
mo.inputs=["p","VA"];
mo.outputs="n";
mo.parameters=list(["f"],list(FR));
model.equations=mo;
exprs=[string(FR)];
gr_i=[];
x=standard_define([2,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I","E"];
x.graphics.out_implicit=["I"];
}
VVsourceAC.prototype.details = function VVsourceAC() {
}
}
/* autogenerated from "macros/Electrical/VoltageSensor.sci" */
function VoltageSensor() {
VoltageSensor.prototype.get = function VoltageSensor() {
}
VoltageSensor.prototype.set = function VoltageSensor() {
x=arg1;
}
VoltageSensor.prototype.define = function VoltageSensor() {
model=scicos_model();
model.in=1;
model.out=[1,1];
model.sim="VoltageSensor";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="VoltageSensor";
mo.inputs="p";
mo.outputs=["n","v"];
model.equations=mo;
exprs=[];
gr_i=[];
x=standard_define([2,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I","E"];
}
VoltageSensor.prototype.details = function VoltageSensor() {
}
}
/* autogenerated from "macros/Electrical/VariableResistor.sci" */
function VariableResistor() {
VariableResistor.prototype.get = function VariableResistor() {
}
VariableResistor.prototype.set = function VariableResistor() {
x=arg1;
}
VariableResistor.prototype.define = function VariableResistor() {
model=scicos_model();
model.sim="VariableResistor";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="VariableResistor";
mo.inputs=["p","R"];
mo.outputs="n";
model.equations=mo;
model.in=ones(size(mo.inputs,"*"),1);
model.out=ones(size(mo.outputs,"*"),1);
exprs=[];
gr_i=[];
x=standard_define([2,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I","E"];
x.graphics.out_implicit=["I"];
}
VariableResistor.prototype.details = function VariableResistor() {
}
}
/* autogenerated from "macros/Electrical/Switch.sci" */
function Switch() {
Switch.prototype.get = function Switch() {
}
Switch.prototype.set = function Switch() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,Ron,Roff,exprs]=scicos_getvalue("Set non-ideal electrical switch parameters",["Resistance in On state (Ohm)","Resistance in Off state (Ohm)"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
model.equations.parameters[2]=list(Ron,Roff);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
Switch.prototype.define = function Switch() {
model=scicos_model();
Ron=0.01;
Roff=1e5;
S=["Ron","Roff"];
Z=eval(S);
model.sim="Switch";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model=model.sim;
mo.inputs=["p","inp"];
mo.outputs="n";
mo.parameters=list(S,Z);
model.equations=mo;
model.in=ones(size(mo.inputs,"*"),1);
model.out=ones(size(mo.outputs,"*"),1);
model.rpar=Z;
exprs=string(Z);
gr_i=[];
x=standard_define([2,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I","E"];
x.graphics.out_implicit=["I"];
}
Switch.prototype.details = function Switch() {
}
}
/* autogenerated from "macros/Electrical/MOTOR.sci" */
function MOTOR() {
MOTOR.prototype.get = function MOTOR() {
}
MOTOR.prototype.set = function MOTOR() {
x=arg1;
}
MOTOR.prototype.define = function MOTOR() {
model=scicos_model();
model.out=[1,1];
model.in=[1];
model.sim="motor";
model.blocktype="c";
model.dep_ut=[true,None];
gr_i=[];
exprs="";
x=standard_define([2,2],model,exprs,gr_i);
x.graphics.out_implicit=["I","I"];
x.graphics.in_implicit=["I"];
}
MOTOR.prototype.details = function MOTOR() {
}
}
/* autogenerated from "macros/Electrical/NMOS.sci" */
function NMOS() {
NMOS.prototype.get = function NMOS() {
}
NMOS.prototype.set = function NMOS() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,W,L,Beta,Vt,K2,K5,dW,dL,RDS,exprs]=scicos_getvalue("Set NMOS Transistor block parameters",["Width [m]","Length [m]","Transconductance parameter [A/(V*V)]","Zero bias threshold voltage [V]","Bulk threshold parameter","Reduction of pinch-off region","Narrowing of channel [m]","Shortening of channel [m]","Drain-Source-Resistance [Ohm]"],list("vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
model.equations.parameters[2]=list(W,L,Beta,Vt,K2,K5,dW,dL,RDS);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
NMOS.prototype.define = function NMOS() {
model=scicos_model();
W=20.e-6;
L=6.e-6;
Beta=0.041e-3;
Vt=0.8;
K2=1.144;
K5=0.7311;
dW=-2.5e-6;
dL=-1.5e-6;
RDS=1.e+7;
model.sim="NMOS";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="NMOS";
mo.outputs=["D","B","S"];
mo.inputs="G";
mo.parameters=list(["W","L","Beta","Vt","K2","K5","dW","dL","RDS"],[W,L,Beta,Vt,K2,K5,dW,dL,RDS]);
model.equations=mo;
model.in=ones(size(mo.inputs,"*"),1);
model.out=ones(size(mo.outputs,"*"),1);
exprs=[string(W),string(L),string(Beta),string(Vt),string(K2),string(K5),string(dW),string(dL),string(RDS)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I","I","I"];
}
NMOS.prototype.details = function NMOS() {
}
}
/* autogenerated from "macros/Electrical/VsourceAC.sci" */
function VsourceAC() {
VsourceAC.prototype.get = function VsourceAC() {
}
VsourceAC.prototype.set = function VsourceAC() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,VA,FR,exprs]=scicos_getvalue("Set voltage source parameter",["Amplitude (Volt)","Frequency (Hz)"],list("vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
model.rpar=[VA,FR];
model.equations.parameters[2]=list(VA,FR);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
VsourceAC.prototype.define = function VsourceAC() {
model=scicos_model();
model.in=[1];
model.out=[1];
VA=220;
FR=50;
model.rpar=[VA,FR];
model.sim="VsourceAC";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="VsourceAC";
mo.inputs="p";
mo.outputs="n";
mo.parameters=list(["VA","f"],list(VA,FR));
model.equations=mo;
exprs=[string(VA),string(FR)];
gr_i=[];
x=standard_define([2,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I"];
}
VsourceAC.prototype.details = function VsourceAC() {
}
}
/* autogenerated from "macros/Electrical/OpAmp.sci" */
function OpAmp() {
OpAmp.prototype.get = function OpAmp() {
}
OpAmp.prototype.set = function OpAmp() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (None) {
[ok,OLGain,SatH,SatL,exprs]=scicos_getvalue("Set the Operational Amplifier parameters",["Open Loop Gain","Positive saturation voltage","Negative saturation voltage"],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
model.equations.parameters[2]=list(OLGain,SatH,SatL);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
OpAmp.prototype.define = function OpAmp() {
S=[];
Z=[];
model=scicos_model();
model.sim="OpAmp";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model=model.sim;
mo.inputs=["in_p","in_n"];
mo.outputs=["out"];
mo.parameters=list(S,Z);
model.equations=mo;
model.in=ones(size(mo.inputs,"*"),1);
model.out=ones(size(mo.outputs,"*"),1);
model.rpar=Z;
exprs=string(Z);
gr_i=[];
x=standard_define([3,5],model,exprs,gr_i);
x.graphics.in_implicit=["I","I"];
x.graphics.out_implicit=["I"];
}
OpAmp.prototype.details = function OpAmp() {
}
}
/* autogenerated from "macros/Electrical/Gyrator.sci" */
function Gyrator() {
Gyrator.prototype.get = function Gyrator() {
}
Gyrator.prototype.set = function Gyrator() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
x=arg1;
exprs=x.graphics.exprs;
while (true) {
[ok,G1,G2,exprs]=scicos_getvalue(["Set Gyrator block parameters:","","G1: Gyration conductance","G2: Gyration conductance"],["G1","G2"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
x.model.equations.parameters[2]=list(G1,G2);
x.graphics.exprs=exprs;
break
}
}
Gyrator.prototype.define = function Gyrator() {
ModelName="Gyrator";
PrametersValue=[1,1];
ParametersName=["G1","G2"];
model=scicos_model();
Typein=[];
Typeout=[];
MI=[];
MO=[];
P=[2.5,90,2,0,2.5,10,2,0,97.5,90,-2,0,97.5,10,-2,0];
PortName=["p1","n1","p2","n2"];
for(i=1;i<=size(P,"r");i+=1) {
if (P(i,3)==1) {
Typein=[Typein,"E"];
MI=[MI,PortName(i)];
}
if (P(i,3)==2) {
Typein=[Typein,"I"];
MI=[MI,PortName(i)];
}
if (P(i,3)==-1) {
Typeout=[Typeout,"E"];
MO=[MO,PortName(i)];
}
if (P(i,3)==-2) {
Typeout=[Typeout,"I"];
MO=[MO,PortName(i)];
}
}
model=scicos_model();
mo=modelica();
model.sim=ModelName;
mo.inputs=MI;
mo.outputs=MO;
model.rpar=PrametersValue;
mo.parameters=list(ParametersName,PrametersValue,zeros(ParametersName));
exprs=["1","1"];
gr_i=[];
model.blocktype="c";
model.dep_ut=[None,true];
mo.model=ModelName;
model.equations=mo;
model.in=ones(size(MI,"*"),1);
model.out=ones(size(MO,"*"),1);
x=standard_define([2,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=Typein;
x.graphics.out_implicit=Typeout;
}
Gyrator.prototype.details = function Gyrator() {
}
}
/* autogenerated from "macros/Misc/DEADBAND.sci" */
function DEADBAND() {
DEADBAND.prototype.get = function DEADBAND() {
}
DEADBAND.prototype.set = function DEADBAND() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,maxp,minp,zeroc,exprs]=scicos_getvalue("Set Deadband parameters",["End of dead band","Start of dead band","zero crossing (0:no, 1:yes)"],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (maxp<=minp) {
message("Upper limit must be > Lower limit");
} else {
rpar=[maxp,minp];
model.rpar=rpar;
if (zeroc!=0) {
model.nzcross=2;
model.nmode=1;
} else {
model.nzcross=0;
model.nmode=0;
}
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
DEADBAND.prototype.define = function DEADBAND() {
minp=-.5;
maxp=.5;
rpar=[maxp,minp];
model=scicos_model();
model.sim=list("deadband",4);
model.in=1;
model.nzcross=2;
model.nmode=1;
model.out=1;
model.rpar=rpar;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string(maxp),string(minp),string(model.nmode)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
DEADBAND.prototype.details = function DEADBAND() {
}
}
/* autogenerated from "macros/Misc/fortran_block.sci" */
function fortran_block() {
fortran_block.prototype.get = function fortran_block() {
}
fortran_block.prototype.set = function fortran_block() {
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
label=graphics.exprs;
while (true) {
[ok,i,o,rpar,funam,lab]=scicos_getvalue("Set fortran_block parameters",["input ports sizes","output port sizes","System parameters vector","function name"],list("vec",-1,"vec",-1,"vec",-1,"str",-1),label(1));
if (!ok) {
break
}
if (funam==" ") {
break
}
label[1]=lab;
rpar=rpar.slice();
i=int(i.slice());
ni=size(i,1);
o=int(o.slice());
no=size(o,1);
tt=label.slice(2-1);
if (model.sim(1)!=funam||size(model.in,"*")!=size(i,"*")||size(model.out,"*")!=size(o,"*")) {
tt=[];
}
[ok,tt]=FORTR(funam,tt,i,o);
if (!ok) {
break
}
[model,graphics,ok]=check_io(model,graphics,i,o,[],[]);
if (ok) {
model.sim[1]=funam;
model.rpar=rpar;
label[2]=tt;
x.model=model;
graphics.exprs=label;
x.graphics=graphics;
break
}
}
}
fortran_block.prototype.define = function fortran_block() {
model=scicos_model();
model.sim=list(" ",1001);
model.in=1;
model.out=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=0;
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
funam="forty";
label=list([sci2exp(model.in),sci2exp(model.out),strcat(sci2exp(model.rpar)),funam],list([]));
gr_i=[];
x=standard_define([4,2],model,label,gr_i);
}
fortran_block.prototype.details = function fortran_block() {
}
}
/* autogenerated from "macros/Misc/DIFF_f.sci" */
function DIFF_f() {
DIFF_f.prototype.get = function DIFF_f() {
}
DIFF_f.prototype.set = function DIFF_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,x0,xd0,exprs]=scicos_getvalue("Set continuous linear system parameters",["Initial state","Initial Derivative"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
graphics.exprs=exprs;
model.state=[x0.slice(),xd0.slice()];
x.graphics=graphics;
x.model=model;
break
}
x.model.firing=[];
}
DIFF_f.prototype.define = function DIFF_f() {
x0=[0,0];
model=scicos_model();
model.sim=list("diffblk",10001);
model.in=1;
model.out=1;
model.state=x0;
model.blocktype="c";
model.dep_ut=[None,true];
exprs=[strcat(sci2exp(x0(1))),strcat(sci2exp(x0(2)))];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
DIFF_f.prototype.details = function DIFF_f() {
}
}
/* autogenerated from "macros/Misc/BOUNCE.sci" */
function BOUNCE() {
BOUNCE.prototype.get = function BOUNCE() {
}
BOUNCE.prototype.set = function BOUNCE() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")<9) {
exprs[8]="9.81";
exprs[9]="0";
}
while (true) {
[ok,rpar1,rpar2,walls,xt,xd,y,yd,g,C,exprs]=scicos_getvalue(["Set Bounce Block"],["Mass","Radius","[xmin,xmax,ymin,ymax]","xpos","xdpos","ypos","ydpos","g (gravity)","C (aerodynamic coeff"],list("vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
xt=xt.slice();
y=y.slice();
xd=xd.slice();
yd=yd.slice();
rpar1=rpar1.slice();
rpar2=rpar2.slice();
n=size(xt,"*");
walls=walls.slice();
if (walls(1)>walls(2)) {
walls=walls([2,1]);
}
if (walls(3)>walls(3)) {
walls=walls([3,4]);
}
if (n!=size(y,"*")||n!=size(rpar1,"*")||n!=size(rpar2,"*")||n!=size(xd,"*")||n!=size(yd,"*")) {
message("All vectors must have equal size");
ok=None;
} else if (!(min([rpar1,rpar2])>0)) {
message("Mass and radius must be >0");
ok=None;
}
if (!ok) {
break
}
[model,graphics,ok]=check_io(model,graphics,[],[n,n],[],[]);
if (ok) {
k=1;
ipar=[];
for(i=1;i<=n;i+=1) {
for(j=i+1;j<=n;j+=1) {
ipar[k]=i;
k=k+1;
ipar[k]=j;
k=k+1;
}
}
model.rpar=[rpar1,rpar2,walls,g,C];
model.ipar=ipar;
state=[xt,xd,y,yd];
state=transpose(state);
model.state=state.slice();
model.nzcross=n*(n-1)/2+4*n;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
BOUNCE.prototype.define = function BOUNCE() {
n=2;
k=1;
ipar=[];
for(i=1;i<=n;i+=1) {
for(j=i+1;j<=n;j+=1) {
ipar[k]=i;
k=k+1;
ipar[k]=j;
k=k+1;
}
}
walls=[0,5,0,5];
x=[2,2.5];
xd=[0,0];
y=[3,5];
yd=[0,0];
g=9.81;
C=0;
rpar1=ones(n,1);
rpar2=rpar1;
state=[x,xd,y,yd];
state=transpose(state);
model=scicos_model();
model.sim=list("bounce_ball",4);
model.in=[];
model.out=[n,n];
model.state=state.slice();
model.rpar=[rpar1,rpar2,walls,g,C];
model.ipar=ipar;
model.nzcross=n*(n-1)/2+4*n;
model.blocktype="c";
model.dep_ut=[None,true];
exprs=[strcat(sci2exp(rpar1)),strcat(sci2exp(rpar2)),strcat(sci2exp(walls)),strcat(sci2exp(x)),strcat(sci2exp(xd)),strcat(sci2exp(y)),strcat(sci2exp(yd))];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
BOUNCE.prototype.details = function BOUNCE() {
}
}
/* autogenerated from "macros/Misc/scifunc_block_m.sci" */
function scifunc_block_m() {
scifunc_block_m.prototype.get = function scifunc_block_m() {
}
scifunc_block_m.prototype.set = function scifunc_block_m() {
needcompile=0;
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
exprs=graphics.exprs;
while (true) {
[ok,i,o,ci,co,xx,z,rpar,auto0,deptime,lab]=scicos_getvalue(["Set scifunc_block parameters","only regular blocks supported"],["input ports sizes","output port sizes","input event ports sizes","output events ports sizes","initial continuous state","initial discrete state","System parameters vector","initial firing vector (<0 for no firing)","is block always active (0:no, 1:yes)"],list("mat",[-1,2],"mat",[-2,2],"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",1),exprs(1));
if (!ok) {
break
}
exprs[1]=lab;
xx=xx.slice();
z=z.slice();
rpar=rpar.slice();
it=ones(1,size(i,1));
ot=ones(1,size(o,1));
nrp=prod(size(rpar));
ni=size(i,1);
no=size(o,1);
ci=int(ci.slice());
nci=size(ci,1);
co=int(co.slice());
nco=size(co,1);
[ok,tt,dep_ut]=genfunc2(exprs.slice(2-1),i,o,nci,nco,size(xx,1),size(z,1),nrp,"c");
dep_ut[2]=(1==deptime);
if (!ok) {
break
}
[model,graphics,ok]=set_io(model,graphics,list(i,it),list(o,ot),ci,co);
if (ok) {
auto=auto0;
model.state=xx;
model.dstate=z;
model.rpar=rpar;
if (model.ipar!=0) {
model.opar=model.ipar;
model.ipar=0;
}
if (or(model.opar!=tt)) {
needcompile=4;
}
model.opar=tt;
model.firing=auto;
model.dep_ut=dep_ut;
x.model=model;
exprs[2]=tt;
graphics.exprs=exprs;
x.graphics=graphics;
break
}
}
needcompile=resume(needcompile)
}
scifunc_block_m.prototype.define = function scifunc_block_m() {
in1=1;
out=1;
clkin=[];
clkout=[];
x0=[];
z0=[];
typ="c";
auto=[];
rpar=[];
it=1;
model=scicos_model();
model.sim=list("scifunc",3);
model.in=in1;
model.in2=in1;
model.intyp=it;
model.out=out;
model.out2=out;
model.outtyp=it;
model.evtin=clkin;
model.evtout=clkout;
model.state=x0;
model.dstate=z0;
model.rpar=rpar;
model.ipar=0;
model.opar=list();
model.blocktype=typ;
model.firing=auto;
model.dep_ut=[true,None];
exprs=list([sci2exp([in1,in1]),sci2exp([out,out]),sci2exp(clkin),sci2exp(clkout),strcat(sci2exp(x0)),strcat(sci2exp(z0)),strcat(sci2exp(rpar)),sci2exp(auto),sci2exp(0)],list("y1=sin(u1)"," "," ","y1=sin(u1)"," "," "," "));
gr_i=[];
x=standard_define([4,2],model,exprs,gr_i);
}
scifunc_block_m.prototype.details = function scifunc_block_m() {
}
}
/* autogenerated from "macros/Misc/c_block.sci" */
function c_block() {
c_block.prototype.get = function c_block() {
}
c_block.prototype.set = function c_block() {
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
label=graphics.exprs;
while (true) {
[ok,i,o,rpar,funam,lab]=scicos_getvalue("Set C_block parameters",["input ports sizes","output port sizes","System parameters vector","function name"],list("vec",-1,"vec",-1,"vec",-1,"str",-1),label(1));
if (!ok) {
break
}
if (funam==" ") {
break
}
label[1]=lab;
rpar=rpar.slice();
i=int(i.slice());
ni=size(i,1);
o=int(o.slice());
no=size(o,1);
tt=label.slice(2-1);
if (model.sim(1)!=funam||size(model.in,"*")!=size(i,"*")||size(model.out,"*")!=size(o,"*")) {
tt=[];
}
[ok,tt]=CFORTR(funam,tt,i,o);
if (!ok) {
break
}
[model,graphics,ok]=check_io(model,graphics,i,o,[],[]);
if (ok) {
model.sim[1]=funam;
model.rpar=rpar;
label[2]=tt;
x.model=model;
graphics.exprs=label;
x.graphics=graphics;
break
}
}
}
c_block.prototype.define = function c_block() {
in1=1;
out=1;
clkin=[];
clkout=[];
x0=[];
z0=[];
typ="c";
auto=[];
rpar=[];
funam="toto";
model=scicos_model();
model.sim=list(" ",2001);
model.in=in1;
model.out=out;
model.evtin=clkin;
model.evtout=clkout;
model.state=x0;
model.dstate=z0;
model.rpar=rpar;
model.ipar=0;
model.blocktype=typ;
model.firing=auto;
model.dep_ut=[true,None];
label=list([sci2exp(in1),sci2exp(out),strcat(sci2exp(rpar)),funam],list([]));
gr_i=[];
x=standard_define([3,2],model,label,gr_i);
}
c_block.prototype.details = function c_block() {
}
}
/* autogenerated from "macros/Misc/CONSTRAINT2_c.sci" */
function CONSTRAINT2_c() {
CONSTRAINT2_c.prototype.get = function CONSTRAINT2_c() {
}
CONSTRAINT2_c.prototype.set = function CONSTRAINT2_c() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
ask_again=None;
[ok,x0,xd0,id,exprs]=scicos_getvalue("Set Constraint block parameters",["Initial guess values of states x","Initial guess values of derivative x\'","Id(i)=1: if x\'(i) is present in the feedback, else Id(i)=0"],list("vec",-1,"vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
x0=x0.slice();
N=size(x0,"*");
xd0=xd0.slice();
Nxd=size(xd0,"*");
id=id.slice();
Nid=size(id,"*");
if ((N!=Nxd)||(N!=Nid)) {
message("incompatible sizes, states, their derivatives, and ID should be the same size ");
ask_again=true;
}
if ((N<=0&&!ask_again)) {
x_message("number of states (constraints) must be > 0 ");
ask_again=true;
}
if ((!ask_again)) {
for(i=1;i<=N;i+=1) {
if (!((id(i)==0)||(id(i)==1))) {
ask_again=true;
x_message(["Id(i) must be either","0 when x\'(i) is not present in the feedback","1: when x\'(i) is present in the feedback"]);
break
}
if ((id(i)==0)) {
id[i]=-1;
}
}
}
if (!ask_again) {
graphics.exprs=exprs;
model.state=[x0,xd0];
model.out=[N,N];
model.in=N;
model.ipar=id;
x.graphics=graphics;
x.model=model;
break
}
}
}
CONSTRAINT2_c.prototype.define = function CONSTRAINT2_c() {
x0=[0];
xd0=[0];
id=[0];
model=scicos_model();
model.sim=list("constraint_c",10004);
model.in=1;
model.out=[1,1];
model.state=[x0,xd0];
model.ipar=id;
model.blocktype="c";
model.dep_ut=[None,true];
exprs=list(strcat(sci2exp(x0)),strcat(sci2exp(xd0)),strcat(sci2exp(id)));
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
CONSTRAINT2_c.prototype.details = function CONSTRAINT2_c() {
}
}
/* autogenerated from "macros/Misc/RATELIMITER.sci" */
function RATELIMITER() {
RATELIMITER.prototype.get = function RATELIMITER() {
}
RATELIMITER.prototype.set = function RATELIMITER() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,maxp,minp,exprs]=scicos_getvalue("Set rate limiter parameters",["max slope","min slope"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (maxp<=minp||maxp<=0||minp>=0) {
message("We must have max_slope> 0 > min_slope.");
} else {
rpar=[maxp,minp];
model.rpar=rpar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
RATELIMITER.prototype.define = function RATELIMITER() {
minp=-1;
maxp=1;
rpar=[maxp,minp];
model=scicos_model();
model.sim=list("ratelimiter",4);
model.in=1;
model.out=1;
model.rpar=rpar;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string(maxp),string(minp)];
gr_i=[];
x=standard_define([3.5,2],model,exprs,gr_i);
}
RATELIMITER.prototype.details = function RATELIMITER() {
}
}
/* autogenerated from "macros/Misc/CONSTRAINT_c.sci" */
function CONSTRAINT_c() {
CONSTRAINT_c.prototype.get = function CONSTRAINT_c() {
}
CONSTRAINT_c.prototype.set = function CONSTRAINT_c() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,x0,exprs]=scicos_getvalue("Set solver block parameters","Initial guess values",list("vec",-1),exprs);
if (!ok) {
break
}
x0=x0.slice();
N=size(x0,"*");
if (N<=0) {
message("number of states (constraints) must be > 0 ");
} else {
[model,graphics,ok]=check_io(model,graphics,N,N,[],[]);
if (ok) {
graphics.exprs=exprs;
model.state=[x0,zeros(N,1)];
model.out=N;
model.in=N;
model.ipar=-1*ones(N,1);
x.graphics=graphics;
x.model=model;
break
}
}
}
}
CONSTRAINT_c.prototype.define = function CONSTRAINT_c() {
x0=[0,0];
model=scicos_model();
model.sim=list("constraint_c",10004);
model.in=1;
model.out=1;
model.ipar=0;
model.state=x0;
model.blocktype="c";
model.dep_ut=[None,true];
exprs="0";
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
CONSTRAINT_c.prototype.details = function CONSTRAINT_c() {
}
}
/* autogenerated from "macros/Misc/IMPSPLIT_f.sci" */
function IMPSPLIT_f() {
IMPSPLIT_f.prototype.get = function IMPSPLIT_f() {
}
IMPSPLIT_f.prototype.set = function IMPSPLIT_f() {
x=arg1;
}
IMPSPLIT_f.prototype.define = function IMPSPLIT_f() {
model=scicos_model();
model.sim="limpsplit";
mo=modelica();
mo.model="limpsplit";
mo.inputs="n";
mo.outputs=["n","n"];
model.equations=mo;
model.in=ones(size(mo.inputs,"*"),1);
model.out=ones(size(mo.outputs,"*"),1);
x=standard_define([1,1]/3,model,[],[]);
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I","I"];
}
IMPSPLIT_f.prototype.details = function IMPSPLIT_f() {
}
}
/* autogenerated from "macros/Misc/DEBUG_SCICOS.sci" */
function DEBUG_SCICOS() {
DEBUG_SCICOS.prototype.get = function DEBUG_SCICOS() {
}
DEBUG_SCICOS.prototype.set = function DEBUG_SCICOS() {
arg1.gui="DEBUG";
[x,y,typ]=DEBUG("set",arg1);
}
DEBUG_SCICOS.prototype.define = function DEBUG_SCICOS() {
x=DEBUG("define");
}
DEBUG_SCICOS.prototype.details = function DEBUG_SCICOS() {
}
}
/* autogenerated from "macros/Misc/EDGETRIGGER.sci" */
function EDGETRIGGER() {
EDGETRIGGER.prototype.get = function EDGETRIGGER() {
}
EDGETRIGGER.prototype.set = function EDGETRIGGER() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,edge,exprs]=scicos_getvalue("Set edge trigger block parameters",["rising (1), falling (-1), both (0)"],list("vec",1),exprs);
if (!ok) {
break
}
model.ipar=sign(edge);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
EDGETRIGGER.prototype.define = function EDGETRIGGER() {
edge=1;
model=scicos_model();
model.sim=list("edgetrig",4);
model.in=1;
model.out=1;
model.dstate=0;
model.nzcross=1;
model.ipar=sign(edge);
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string(edge)];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
EDGETRIGGER.prototype.details = function EDGETRIGGER() {
}
}
/* autogenerated from "macros/Misc/BOUNCEXY.sci" */
function BOUNCEXY() {
BOUNCEXY.prototype.get = function BOUNCEXY() {
}
BOUNCEXY.prototype.set = function BOUNCEXY() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
dstate=model.dstate;
while (true) {
[ok,clrs,siz,win,imode,xmin,xmax,ymin,ymax,exprs]=scicos_getvalue("Set Scope parameters",["colors","radii","window number (-1 for automatic)","animation mode (0,1)","Xmin","Xmax","Ymin","Ymax"],list("vec",-1,"vec",-1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
mess=[];
if (size(clrs,"*")!=size(siz,"*")) {
mess=[mess,"colors and radii must have equal size (number of balls)"," "];
ok=None;
}
if (win<-1) {
mess=[mess,"Window number cannot be inferior than -1"," "];
ok=None;
}
if (ymin>=ymax) {
mess=[mess,"Ymax must be greater than Ymin"," "];
ok=None;
}
if (xmin>=xmax) {
mess=[mess,"Xmax must be greater than Xmin"," "];
ok=None;
}
if (!ok) {
message(mess);
} else {
rpar=[xmin,xmax,ymin,ymax];
ipar=[win,imode,clrs.slice()];
z=[];
for(i=1;i<=size(clrs,"*");i+=1) {
z[6*(i-1)+1]=0;
z[6*(i-1)+2]=0;
z[6*(i-1)+3]=2*siz(i);
z[6*(i-1)+4]=2*siz(i);
z[6*(i-1)+5]=0.000;
z[6*(i-1)+6]=64.0*360.000;
}
model.dstate=z;
model.rpar=rpar;
model.ipar=ipar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
BOUNCEXY.prototype.define = function BOUNCEXY() {
win=-1;
imode=1;
clrs=[1,2];
siz=[1,1];
xmin=-5;
xmax=5;
ymin=0;
ymax=15;
model=scicos_model();
model.sim=list("bouncexy",4);
model.in=[-1,-1];
model.in2=[1,1];
model.intyp=[1,1];
model.evtin=1;
z=[];
for(i=1;i<=size(clrs,"*");i+=1) {
z[6*(i-1)+1]=0;
z[6*(i-1)+2]=0;
z[6*(i-1)+3]=2*siz(i);
z[6*(i-1)+4]=2*siz(i);
z[6*(i-1)+5]=0.000;
z[6*(i-1)+6]=64.0*360.000;
}
model.dstate=z;
model.rpar=[xmin,xmax,ymin,ymax];
model.ipar=[win,imode,clrs.slice()];
model.blocktype="d";
model.firing=[];
model.dep_ut=[None,None];
exprs=[strcat(sci2exp(clrs)),strcat(sci2exp(siz)),strcat(sci2exp(win)),strcat(sci2exp(1)),strcat(sci2exp(xmin)),strcat(sci2exp(xmax)),strcat(sci2exp(ymin)),strcat(sci2exp(ymax))];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
BOUNCEXY.prototype.details = function BOUNCEXY() {
}
}
/* autogenerated from "macros/Misc/BACKLASH.sci" */
function BACKLASH() {
BACKLASH.prototype.get = function BACKLASH() {
}
BACKLASH.prototype.set = function BACKLASH() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
rpar=model.rpar;
while (true) {
[ok,ini,gap,zcr,exprs]=scicos_getvalue("Set backlash parameters",["initial output","gap","use zero-crossing (0:no, 1:yes)"],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (ok) {
graphics.exprs=exprs;
rpar[1]=ini;
rpar[2]=gap;
if (zcr!=0) {
model.nzcross=2;
} else {
model.nzcross=0;
}
model.rpar=rpar;
x.graphics=graphics;
x.model=model;
break
}
}
}
BACKLASH.prototype.define = function BACKLASH() {
exprs=["0","1","1"];
model=scicos_model();
model.sim=list("backlash",4);
model.in=1;
model.out=1;
model.rpar=[0,1];
model.nzcross=2;
model.blocktype="c";
model.dep_ut=[true,None];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
BACKLASH.prototype.details = function BACKLASH() {
}
}
/* autogenerated from "macros/Misc/BPLATFORM.sci" */
function BPLATFORM() {
BPLATFORM.prototype.get = function BPLATFORM() {
}
BPLATFORM.prototype.set = function BPLATFORM() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
dstate=model.dstate;
while (true) {
[ok,plen,csiz,phi,xmin,xmax,ymin,ymax,exprs]=scicos_getvalue("Set Scope parameters",["pendulum length","cart size (square side)","slope","Xmin","Xmax","Ymin","Ymax"],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
mess=[];
if (plen<=0||csiz<=0) {
mess=[mess,"Pendulum length and cart size must be positive."," "];
ok=None;
}
if (ymin>=ymax) {
mess=[mess,"Ymax must be greater than Ymin"," "];
ok=None;
}
if (xmin>=xmax) {
mess=[mess,"Xmax must be greater than Xmin"," "];
ok=None;
}
if (!ok) {
message(mess);
} else {
rpar=[plen,csiz,phi,xmin,xmax,ymin,ymax];
model.rpar=rpar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
BPLATFORM.prototype.define = function BPLATFORM() {
plen=2;
csiz=2;
phi=0;
xmin=-5;
xmax=5;
ymin=0;
ymax=15;
model=scicos_model();
model.sim=list("bplatform2",5);
model.in=[1,1];
model.evtin=1;
model.dstate=0;
model.rpar=[plen,csiz,phi,xmin,xmax,ymin,ymax];
model.blocktype="d";
model.dep_ut=[None,None];
exprs=string(model.rpar);
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
BPLATFORM.prototype.details = function BPLATFORM() {
}
}
/* autogenerated from "macros/Misc/func_block.sci" */
function func_block() {
func_block.prototype.get = function func_block() {
}
func_block.prototype.set = function func_block() {
model=arg1.model;
graphics=arg1.graphics;
exprs=graphics.exprs;
x=arg1;
model=x.model;
[ok,mac,exprs]=genfunc(exprs);
if (ok) {
model.sim=mac;
graphics.exprs=exprs;
x.model=model;
x.graphics=graphics;
}
}
func_block.prototype.define = function func_block() {
model=scicos_model();
model.sim=" ";
model.in=1;
model.out=1;
model.blocktype="c";
model.dep_ut=[true,None];
exprs="v=sin(u);y=u*v";
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
func_block.prototype.details = function func_block() {
}
}
/* autogenerated from "macros/Misc/SPLIT_f.sci" */
function SPLIT_f() {
SPLIT_f.prototype.get = function SPLIT_f() {
}
SPLIT_f.prototype.set = function SPLIT_f() {
x=arg1;
}
SPLIT_f.prototype.define = function SPLIT_f() {
model=scicos_model();
model.sim="lsplit";
model.in=-1;
model.out=[-1,-1,-1];
model.blocktype="c";
model.dep_ut=[true,None];
x=standard_define([1,1]/3,model,[],[]);
}
SPLIT_f.prototype.details = function SPLIT_f() {
}
}
/* autogenerated from "macros/Misc/PENDULUM_ANIM.sci" */
function PENDULUM_ANIM() {
PENDULUM_ANIM.prototype.get = function PENDULUM_ANIM() {
}
PENDULUM_ANIM.prototype.set = function PENDULUM_ANIM() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
dstate=model.dstate;
while (true) {
[ok,plen,csiz,phi,xmin,xmax,ymin,ymax,exprs]=scicos_getvalue("Set Scope parameters",["pendulum length","cart size (square side)","slope","Xmin","Xmax","Ymin","Ymax"],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
mess=[];
if (plen<=0||csiz<=0) {
mess=[mess,"Pendulum length and cart size must be positive."," "];
ok=None;
}
if (ymin>=ymax) {
mess=[mess,"Ymax must be greater than Ymin"," "];
ok=None;
}
if (xmin>=xmax) {
mess=[mess,"Xmax must be greater than Xmin"," "];
ok=None;
}
if (!ok) {
message(mess);
} else {
rpar=[plen,csiz,phi,xmin,xmax,ymin,ymax];
model.rpar=rpar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
PENDULUM_ANIM.prototype.define = function PENDULUM_ANIM() {
plen=2;
csiz=2;
phi=0;
xmin=-5;
xmax=5;
ymin=-5;
ymax=5;
model=scicos_model();
model.sim=list("anim_pen",5);
model.in=[1,1];
model.evtin=1;
model.dstate=0;
model.rpar=[plen,csiz,phi,xmin,xmax,ymin,ymax];
model.blocktype="d";
model.dep_ut=[None,None];
exprs=string(model.rpar);
gr_i=[];
x=standard_define([3,3],model,exprs,gr_i);
}
PENDULUM_ANIM.prototype.details = function PENDULUM_ANIM() {
}
}
/* autogenerated from "macros/Misc/MEMORY_f.sci" */
function MEMORY_f() {
MEMORY_f.prototype.get = function MEMORY_f() {
}
MEMORY_f.prototype.set = function MEMORY_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,a,inh,exprs]=scicos_getvalue("Set memory block parameters",["initial condition","Inherit (1: no, 0: yes)"],list("vec",-1,"vec",1),exprs);
if (!ok) {
break
}
if (inh==0) {
inh=[];
} else {
inh=1;
}
[model,graphics,ok]=check_io(model,graphics,-1,-1,inh,[]);
out=size(a,"*");
if (out==0) {
ok=None;
messagebox("Initial condition empty","modal","error");
}
in1=out;
if (ok) {
graphics.exprs=exprs;
model.rpar=a;
model.in=in1;
model.out=out;
x.graphics=graphics;
x.model=model;
break
}
}
}
MEMORY_f.prototype.define = function MEMORY_f() {
z=0;
in1=1;
exprs=[string(z),string(1)];
model=scicos_model();
model.sim="memo";
model.in=in1;
model.out=in1;
model.evtin=1;
model.dstate=0;
model.rpar=z;
model.blocktype="m";
model.dep_ut=[None,None];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
MEMORY_f.prototype.details = function MEMORY_f() {
}
}
/* autogenerated from "macros/IntegerOp/INTMUL.sci" */
function INTMUL() {
INTMUL.prototype.get = function INTMUL() {
}
INTMUL.prototype.set = function INTMUL() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
while (true) {
[ok,Datatype,np,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"INTMUL")," ",gettext("Integer matrix multiplication")," "],[msprintf(gettext("Data Type %s"),"(3:int32, 4:int16, 5:int8, ...)"),gettext("Do on Overflow (0:Nothing, 1:Saturate, 2:Error)")],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
it=Datatype*ones(1,2);
ot=Datatype;
if ((np!=0&&np!=1&&np!=2)) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Do on Overflow"),np),msprintf(gettext("Must be in the interval %s."),"[0, 2]"));
ok=None;
} else if (Datatype==3) {
if (np==0) {
model.sim=list("matmul_i32n",4);
} else if (np==1) {
model.sim=list("matmul_i32s",4);
} else {
model.sim=list("matmul_i32e",4);
}
} else if (Datatype==4) {
if (np==0) {
model.sim=list("matmul_i16n",4);
} else if (np==1) {
model.sim=list("matmul_i16s",4);
} else {
model.sim=list("matmul_i16e",4);
}
} else if (Datatype==5) {
if (np==0) {
model.sim=list("matmul_i8n",4);
} else if (np==1) {
model.sim=list("matmul_i8s",4);
} else {
model.sim=list("matmul_i8e",4);
}
} else if (Datatype==6) {
if (np==0) {
model.sim=list("matmul_ui32n",4);
} else if (np==1) {
model.sim=list("matmul_ui32s",4);
} else {
model.sim=list("matmul_ui32e",4);
}
} else if (Datatype==7) {
if (np==0) {
model.sim=list("matmul_ui16n",4);
} else if (np==1) {
model.sim=list("matmul_ui16s",4);
} else {
model.sim=list("matmul_ui16e",4);
}
} else if (Datatype==8) {
if (np==0) {
model.sim=list("matmul_ui8n",4);
} else if (np==1) {
model.sim=list("matmul_ui8s",4);
} else {
model.sim=list("matmul_ui8e",4);
}
} else {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Data Type"),ot),msprintf(gettext("Must be in the interval %s."),"[3, 8]"));
ok=None;
}
in1=[model.in,model.in2];
out=[model.out,model.out2];
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
if (ok) {
model.ipar=np;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
INTMUL.prototype.define = function INTMUL() {
sgn=0;
model=scicos_model();
model.sim=list("matmul_i32",4);
model.in=[-1,-2];
model.out=-1;
model.in2=[-2,-3];
model.out2=-3;
model.intyp=[3,3];
model.outtyp=3;
model.rpar=[];
model.ipar=sgn;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[sci2exp(3),sci2exp(0)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
INTMUL.prototype.details = function INTMUL() {
}
}
/* autogenerated from "macros/IntegerOp/CONVERT.sci" */
function CONVERT() {
CONVERT.prototype.get = function CONVERT() {
}
CONVERT.prototype.set = function CONVERT() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
while (true) {
[ok,it,ot,np,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"CONVERT")," ",gettext("Type conversion")," "],[gettext("Input Type (1:double, 3:int32, 4:int16, 5:int8, ...)"),gettext("Output Type (1:double, 3:int32, 4:int16, 5:int8, ...)"),gettext("Do on Overflow (0:Nothing, 1:Saturate, 2:Error)")],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (it==2) {
it=1;
}
if (ot==2) {
ot=1;
}
if ((np!=0&&np!=1&&np!=2)) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Do on Overflow"),np),msprintf(gettext("Must be in the interval %s."),"[0, 2]"));
ok=None;
} else if ((it>8||it<1)) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Input Type"),it),msprintf(gettext("Must be in the interval %s."),"[1, 8]"));
ok=None;
} else if ((ot>8||ot<1)) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Output Type"),ot),msprintf(gettext("Must be in the interval %s."),"[1, 8]"));
ok=None;
}
model.sim=list("convert",4);
if ((it==ot)) {
model.ipar=1;
} else {
if ((np==0)) {
if ((it==1)) {
if ((ot==3)) {
model.ipar=2;
} else if ((ot==4)) {
model.ipar=3;
} else if ((ot==5)) {
model.ipar=4;
} else if ((ot==6)) {
model.ipar=5;
} else if ((ot==7)) {
model.ipar=6;
} else if ((ot==8)) {
model.ipar=7;
}
} else if ((it==3)) {
if ((ot==1)) {
model.ipar=8;
} else if ((ot==4)) {
model.ipar=9;
} else if ((ot==5)) {
model.ipar=10;
} else if ((ot==6)) {
model.ipar=1;
} else if ((ot==7)) {
model.ipar=11;
} else if ((ot==8)) {
model.ipar=12;
}
} else if ((it==4)) {
if ((ot==1)) {
model.ipar=13;
} else if ((ot==3)) {
model.ipar=14;
} else if ((ot==5)) {
model.ipar=15;
} else if ((ot==6)) {
model.ipar=16;
} else if ((ot==7)) {
model.ipar=1;
} else if ((ot==8)) {
model.ipar=17;
}
} else if ((it==5)) {
if ((ot==1)) {
model.ipar=18;
} else if ((ot==3)) {
model.ipar=19;
} else if ((ot==4)) {
model.ipar=20;
} else if ((ot==6)) {
model.ipar=21;
} else if ((ot==7)) {
model.ipar=22;
} else if ((ot==8)) {
model.ipar=1;
}
} else if ((it==6)) {
if ((ot==1)) {
model.ipar=23;
} else if ((ot==3)) {
model.ipar=1;
} else if ((ot==4)) {
model.ipar=24;
} else if ((ot==5)) {
model.ipar=25;
} else if ((ot==7)) {
model.ipar=26;
} else if ((ot==8)) {
model.ipar=27;
}
} else if ((it==7)) {
if ((ot==1)) {
model.ipar=28;
} else if ((ot==3)) {
model.ipar=29;
} else if ((ot==4)) {
model.ipar=1;
} else if ((ot==5)) {
model.ipar=30;
} else if ((ot==6)) {
model.ipar=31;
} else if ((ot==8)) {
model.ipar=32;
}
} else if ((it==8)) {
if ((ot==1)) {
model.ipar=33;
} else if ((ot==3)) {
model.ipar=34;
} else if ((ot==4)) {
model.ipar=35;
} else if ((ot==5)) {
model.ipar=1;
} else if ((ot==6)) {
model.ipar=36;
} else if ((ot==7)) {
model.ipar=37;
}
}
} else if ((np==1)) {
if ((it==1)) {
if ((ot==3)) {
model.ipar=38;
} else if ((ot==4)) {
model.ipar=39;
} else if ((ot==5)) {
model.ipar=40;
} else if ((ot==6)) {
model.ipar=41;
} else if ((ot==7)) {
model.ipar=42;
} else if ((ot==8)) {
model.ipar=43;
}
} else if ((it==3)) {
if ((ot==1)) {
model.ipar=8;
} else if ((ot==4)) {
model.ipar=44;
} else if ((ot==5)) {
model.ipar=45;
} else if ((ot==6)) {
model.ipar=46;
} else if ((ot==7)) {
model.ipar=47;
} else if ((ot==8)) {
model.ipar=48;
}
} else if ((it==4)) {
if ((ot==1)) {
model.ipar=13;
} else if ((ot==3)) {
model.ipar=14;
} else if ((ot==5)) {
model.ipar=49;
} else if ((ot==6)) {
model.ipar=50;
} else if ((ot==7)) {
model.ipar=51;
} else if ((ot==8)) {
model.ipar=52;
}
} else if ((it==5)) {
if ((ot==1)) {
model.ipar=18;
} else if ((ot==3)) {
model.ipar=19;
} else if ((ot==4)) {
model.ipar=20;
} else if ((ot==6)) {
model.ipar=53;
} else if ((ot==7)) {
model.ipar=54;
} else if ((ot==8)) {
model.ipar=55;
}
} else if ((it==6)) {
if ((ot==1)) {
model.ipar=23;
} else if ((ot==3)) {
model.ipar=56;
} else if ((ot==4)) {
model.ipar=57;
} else if ((ot==5)) {
model.ipar=58;
} else if ((ot==7)) {
model.ipar=59;
} else if ((ot==8)) {
model.ipar=60;
}
} else if ((it==7)) {
if ((ot==1)) {
model.ipar=28;
} else if ((ot==3)) {
model.ipar=29;
} else if ((ot==4)) {
model.ipar=61;
} else if ((ot==5)) {
model.ipar=62;
} else if ((ot==6)) {
model.ipar=31;
} else if ((ot==8)) {
model.ipar=63;
}
} else if ((it==8)) {
if ((ot==1)) {
model.ipar=33;
} else if ((ot==3)) {
model.ipar=34;
} else if ((ot==4)) {
model.ipar=35;
} else if ((ot==5)) {
model.ipar=64;
} else if ((ot==6)) {
model.ipar=36;
} else if ((ot==7)) {
model.ipar=37;
}
}
} else if ((np==2)) {
if ((it==1)) {
if ((ot==3)) {
model.ipar=65;
} else if ((ot==4)) {
model.ipar=66;
} else if ((ot==5)) {
model.ipar=67;
} else if ((ot==6)) {
model.ipar=68;
} else if ((ot==7)) {
model.ipar=69;
} else if ((ot==8)) {
model.ipar=70;
}
} else if ((it==3)) {
if ((ot==1)) {
model.ipar=8;
} else if ((ot==4)) {
model.ipar=71;
} else if ((ot==5)) {
model.ipar=72;
} else if ((ot==6)) {
model.ipar=73;
} else if ((ot==7)) {
model.ipar=74;
} else if ((ot==8)) {
model.ipar=75;
}
} else if ((it==4)) {
if ((ot==1)) {
model.ipar=13;
} else if ((ot==3)) {
model.ipar=14;
} else if ((ot==5)) {
model.ipar=76;
} else if ((ot==6)) {
model.ipar=77;
} else if ((ot==7)) {
model.ipar=78;
} else if ((ot==8)) {
model.ipar=79;
}
} else if ((it==5)) {
if ((ot==1)) {
model.ipar=18;
} else if ((ot==3)) {
model.ipar=19;
} else if ((ot==4)) {
model.ipar=20;
} else if ((ot==6)) {
model.ipar=80;
} else if ((ot==7)) {
model.ipar=81;
} else if ((ot==8)) {
model.ipar=82;
}
} else if ((it==6)) {
if ((ot==1)) {
model.ipar=23;
} else if ((ot==3)) {
model.ipar=83;
} else if ((ot==4)) {
model.ipar=84;
} else if ((ot==5)) {
model.ipar=85;
} else if ((ot==7)) {
model.ipar=86;
} else if ((ot==8)) {
model.ipar=87;
}
} else if ((it==7)) {
if ((ot==1)) {
model.ipar=28;
} else if ((ot==3)) {
model.ipar=29;
} else if ((ot==4)) {
model.ipar=88;
} else if ((ot==5)) {
model.ipar=89;
} else if ((ot==6)) {
model.ipar=31;
} else if ((ot==8)) {
model.ipar=90;
}
} else if ((it==8)) {
if ((ot==1)) {
model.ipar=33;
} else if ((ot==3)) {
model.ipar=34;
} else if ((ot==4)) {
model.ipar=35;
} else if ((ot==5)) {
model.ipar=91;
} else if ((ot==6)) {
model.ipar=36;
} else if ((ot==7)) {
model.ipar=37;
}
}
}
}
in1=[model.in,model.in2];
out=[model.out,model.out2];
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
if (ok) {
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CONVERT.prototype.define = function CONVERT() {
sgn=2;
model=scicos_model();
model.sim=list("convert",4);
model.in=-1;
model.out=-1;
model.in2=-2;
model.out2=-2;
model.intyp=1;
model.outtyp=3;
model.rpar=[];
model.ipar=sgn;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[sci2exp(1),sci2exp(3),sci2exp(0)];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
CONVERT.prototype.details = function CONVERT() {
}
}
/* autogenerated from "macros/IntegerOp/BITSET.sci" */
function BITSET() {
BITSET.prototype.get = function BITSET() {
}
BITSET.prototype.set = function BITSET() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,Datatype,bit,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"BITSET")," ",gettext("Set a bit")," "],[msprintf(gettext("Data Type %s"),"(3:int32, 4:int16, 5:int8, ...)"),gettext("Index of Bit (0 is least significant)")],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
in1=[model.in,model.in2];
if (floor(bit)!=bit) {
block_parameter_error(msprintf(gettext("Wrong type for \'%s\' parameter: %5.1f."),gettext("Index of Bit"),bit),gettext("Must be integer."));
ok=None;
}
if ((Datatype==3)||(Datatype==6)) {
if (bit>31||bit<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Index of Bit"),bit),msprintf(gettext("Must be in the interval %s."),"[0, 31]"));
ok=None;
}
bit=uint32(bit);
n=2^bit;
n=uint32(n);
model.sim=list("bit_set_32",4);
} else if ((Datatype==4)||(Datatype==7)) {
if (bit>15||bit<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Index of Bit"),bit),msprintf(gettext("Must be in the interval %s."),"[0, 15]"));
ok=None;
}
bit=uint16(bit);
n=2^bit;
n=uint16(n);
model.sim=list("bit_set_16",4);
} else if ((Datatype==5)||(Datatype==8)) {
if (bit>7||bit<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Index of Bit"),bit),msprintf(gettext("Must be in the interval %s."),"[0, 7]"));
ok=None;
}
bit=uint8(bit);
n=2^bit;
n=uint8(n);
model.sim=list("bit_set_8",4);
} else {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Data Type"),Datatype),msprintf(gettext("Must be in the interval %s."),"[3, 8]"));
ok=None;
}
if (ok) {
it=Datatype;
ot=Datatype;
out=[1,1];
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
if (ok) {
graphics.exprs=exprs;
model.opar=list(n);
x.graphics=graphics;
x.model=model;
break
}
}
}
BITSET.prototype.define = function BITSET() {
model=scicos_model();
model.sim=list("bit_set_32",4);
model.in=1;
model.in2=1;
model.out=1;
model.out2=1;
model.intyp=3;
model.outtyp=3;
model.opar=list(uint32(0));
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[sci2exp(3),sci2exp(0)];
gr_i=[];
x=standard_define([4,2],model,exprs,gr_i);
}
BITSET.prototype.details = function BITSET() {
}
}
/* autogenerated from "macros/IntegerOp/BITCLEAR.sci" */
function BITCLEAR() {
BITCLEAR.prototype.get = function BITCLEAR() {
}
BITCLEAR.prototype.set = function BITCLEAR() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,Datatype,bit,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"BITCLEAR")," ",gettext("Clear a bit")," "],[msprintf(gettext("Data Type %s"),"(3:int32, 4:int16, 5:int8, ...)"),gettext("Index of Bit (0 is least significant)")],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
in1=[model.in,model.in2];
if (floor(bit)!=bit) {
block_parameter_error(msprintf(gettext("Wrong type for \'%s\' parameter: %5.1f."),gettext("Index of Bit"),bit),gettext("Must be integer."));
ok=None;
} else if ((Datatype==3)||(Datatype==6)) {
if (bit>31||bit<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Index of Bit"),bit),msprintf(gettext("Must be in the interval %s."),"[0, 31]"));
ok=None;
} else {
bit=uint32(bit);
n=(2^32-1)-2^bit;
n=uint32(n);
model.sim=list("bit_clear_32",4);
}
} else if ((Datatype==4)||(Datatype==7)) {
if (bit>15||bit<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Index of Bit"),bit),msprintf(gettext("Must be in the interval %s."),"[0, 15]"));
ok=None;
} else {
bit=uint16(bit);
n=(2^16-1)-2^bit;
n=uint16(n);
model.sim=list("bit_clear_16",4);
}
} else if ((Datatype==5)||(Datatype==8)) {
if (bit>7||bit<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Index of Bit"),bit),msprintf(gettext("Must be in the interval %s."),"[0, 7]"));
ok=None;
} else {
bit=uint8(bit);
n=(2^8-1)-2^bit;
n=uint8(n);
model.sim=list("bit_clear_8",4);
}
} else {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Data Type"),Datatype),msprintf(gettext("Must be in the interval %s."),"[3, 8]"));
ok=None;
}
if (ok) {
it=Datatype;
ot=Datatype;
out=[1,1];
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
if (ok) {
graphics.exprs=exprs;
model.opar=list(n);
x.graphics=graphics;
x.model=model;
break
}
}
}
BITCLEAR.prototype.define = function BITCLEAR() {
model=scicos_model();
model.sim=list("bit_clear_32",4);
model.in=1;
model.in2=1;
model.out=1;
model.out2=1;
model.intyp=3;
model.outtyp=3;
model.opar=list(int32(0));
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[sci2exp(3),sci2exp(0)];
gr_i=[];
x=standard_define([4,2],model,exprs,gr_i);
}
BITCLEAR.prototype.details = function BITCLEAR() {
}
}
/* autogenerated from "macros/IntegerOp/LOGIC.sci" */
function LOGIC() {
LOGIC.prototype.get = function LOGIC() {
}
LOGIC.prototype.set = function LOGIC() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,mat,herit,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"LOGIC")," ",gettext("Combinatorial logic")," ",gettext("&nbsp; Rows of the matrix are the output values"),gettext("&nbsp; Number of rows must be a power of two."),gettext("&nbsp; Number of columns gives the number of outputs.")," "],[gettext("Truth Table (matrix of outputs)"),gettext("Accepts Inherited Events (0:No, 1:Yes)")],list("mat",[-1,-2],"vec",1),exprs);
if (!ok) {
break
}
nout=size(mat,2);
nin=(log(size(mat,1))/log(2));
u1=floor(nin);
if ((u1!=nin)) {
block_parameter_error(msprintf(gettext("Wrong size for \'%s\' parameter: %d."),gettext("Truth Table"),size(mat,1)),gettext("Number of rows must be a power of two."));
ok=None;
} else if ((find(mat.slice()!=0&&mat.slice()!=1)!=[])) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter."),gettext("Truth Table")),msprintf(gettext("Elements must be in the interval %s."),"[0, 1]"));
ok=None;
} else if (herit<0||herit>1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Accepts Inherited Events"),herit),msprintf(gettext("Must be in the interval %s."),"[0, 1]"));
ok=None;
}
if (ok) {
in1=[ones(nin,1),ones(nin,1)];
out=[ones(nout,1),ones(nout,1)];
it=5*ones(1,nin);
ot=5*ones(1,nout);
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),ones(1-herit,1),[]);
}
if (ok) {
graphics.exprs=exprs;
mat=int8(mat);
model.opar=list(mat);
x.graphics=graphics;
x.model=model;
break
}
}
}
LOGIC.prototype.define = function LOGIC() {
mat=[0,0,0,1];
model=scicos_model();
model.sim=list("logic",4);
model.in=[1,1];
model.in2=[1,1];
model.out=1;
model.out2=1;
model.evtin=1;
model.intyp=[5,5];
model.outtyp=5;
model.opar=list(int8(mat));
model.blocktype="c";
model.firing=None;
model.dep_ut=[true,None];
exprs=[sci2exp(mat),sci2exp(0)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
LOGIC.prototype.details = function LOGIC() {
}
}
/* autogenerated from "macros/NonLinear/INTRP2BLK_f.sci" */
function INTRP2BLK_f() {
INTRP2BLK_f.prototype.get = function INTRP2BLK_f() {
}
INTRP2BLK_f.prototype.set = function INTRP2BLK_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,a,b,c,exprs]=scicos_getvalue("Set Interpolation block parameters",["X coord.","Y coord.","Z values"],list("vec",-1,"vec",-1,"mat",[-1,-1]),exprs);
if (!ok) {
break
}
if (size(a,"*")!=size(c,"c")||size(b,"*")!=size(c,"r")) {
message("incompatible dimension");
} else if (min(a.slice(2-1,$)-a.slice(1-1,$-1))<=0||min(b.slice(2-1,$)-b.slice(1-1,$-1))<=0) {
message("X and Y must be strictly increasing");
} else {
if (ok) {
graphics.exprs=exprs;
model.rpar=[a.slice(),b.slice(),c.slice()];
model.ipar=[size(a,"*"),size(b,"*")];
x.graphics=graphics;
x.model=model;
break
}
}
}
}
INTRP2BLK_f.prototype.define = function INTRP2BLK_f() {
a=[0,1];
b=[0,1];
c=[0,1,1,2];
model=scicos_model();
model.sim=list("intrp2",1);
model.in=[1,1];
model.out=1;
model.rpar=[a,b,c.slice()];
model.ipar=[2,2];
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[strcat(sci2exp(a)),strcat(sci2exp(b)),strcat(sci2exp(c,0))];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
INTRP2BLK_f.prototype.details = function INTRP2BLK_f() {
}
}
/* autogenerated from "macros/NonLinear/PRODUCT.sci" */
function PRODUCT() {
PRODUCT.prototype.get = function PRODUCT() {
}
PRODUCT.prototype.set = function PRODUCT() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
while (true) {
[ok,sgn,exprs]=scicos_getvalue(["         Set multiplication block parameters","(multiplication is set with + 1, division with -1)",""],"Number of inputs or sign vector",list("vec",-1),exprs);
if (!ok) {
break
}
sgn=sgn.slice();
if (size(sgn,1)==1) {
if (sgn<1) {
message("Number of inputs must be > 0");
ok=None;
} else if (sgn==1) {
in1=-1;
sgn=[];
nout=1;
} else {
in1=-ones(sgn,1);
sgn=ones(sgn,1);
nout=-1;
}
} else {
if (!and(abs(sgn)==1)) {
message("Signs can only be +1 or -1");
ok=None;
} else {
in1=-ones(size(sgn,1),1);
nout=-1;
}
}
if (ok) {
[model,graphics,ok]=check_io(model,graphics,in1,nout,[],[]);
}
if (ok) {
model.ipar=sgn;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
PRODUCT.prototype.define = function PRODUCT() {
sgn=[1,-1];
model=scicos_model();
model.sim=list("product",4);
model.in=[-1,-1];
model.out=-1;
model.ipar=sgn;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=sci2exp(sgn);
gr_i=[];
x=standard_define([2,3],model,exprs,gr_i);
}
PRODUCT.prototype.details = function PRODUCT() {
}
}
/* autogenerated from "macros/NonLinear/COSBLK_f.sci" */
function COSBLK_f() {
COSBLK_f.prototype.get = function COSBLK_f() {
}
COSBLK_f.prototype.set = function COSBLK_f() {
x=arg1;
}
COSBLK_f.prototype.define = function COSBLK_f() {
in1=1;
model=scicos_model();
model.sim="cosblk";
model.in=-1;
model.out=-1;
model.blocktype="c";
model.dep_ut=[true,None];
gr_i=[];
x=standard_define([2,2],model,[],gr_i);
}
COSBLK_f.prototype.details = function COSBLK_f() {
}
}
/* autogenerated from "macros/NonLinear/SIGNUM.sci" */
function SIGNUM() {
SIGNUM.prototype.get = function SIGNUM() {
}
SIGNUM.prototype.set = function SIGNUM() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,zcr,exprs]=scicos_getvalue("Set block parameters",["use zero_crossing (1: yes) (0:no)"],list("vec",1),exprs);
if (!ok) {
break
}
graphics.exprs=exprs;
if (ok) {
if (zcr!=0) {
model.nmode=-1;
model.nzcross=-1;
} else {
model.nmode=0;
model.nzcross=0;
}
x.graphics=graphics;
x.model=model;
break
}
}
}
SIGNUM.prototype.define = function SIGNUM() {
nu=-1;
model=scicos_model();
model.sim=list("signum",4);
model.in=nu;
model.out=nu;
model.nzcross=nu;
model.nmode=nu;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string([1])];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
SIGNUM.prototype.details = function SIGNUM() {
}
}
/* autogenerated from "macros/NonLinear/SINBLK_f.sci" */
function SINBLK_f() {
SINBLK_f.prototype.get = function SINBLK_f() {
}
SINBLK_f.prototype.set = function SINBLK_f() {
x=arg1;
}
SINBLK_f.prototype.define = function SINBLK_f() {
model=scicos_model();
model.sim="sinblk";
model.in=-1;
model.out=-1;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=" ";
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
SINBLK_f.prototype.details = function SINBLK_f() {
}
}
/* autogenerated from "macros/NonLinear/SAT_f.sci" */
function SAT_f() {
SAT_f.prototype.get = function SAT_f() {
}
SAT_f.prototype.set = function SAT_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,minp,maxp,pente,exprs]=scicos_getvalue("Set Saturation parameters",["Min","Max","Slope"],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (maxp<=0) {
message("Max must be strictly positive");
} else if (pente<=0) {
message("Slope must be strictly positive");
} else {
rpar=[minp/pente,maxp/pente,pente];
model.rpar=rpar;
model.firing=[];
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
SAT_f.prototype.define = function SAT_f() {
minp=-1;
maxp=1;
slope=1;
rpar=[minp,maxp,slope];
model=scicos_model();
model.sim=list("lusat",1);
model.in=1;
model.nzcross=2;
model.out=1;
model.rpar=[minp,maxp,slope];
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string(minp),string(maxp),string(slope)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
SAT_f.prototype.details = function SAT_f() {
}
}
/* autogenerated from "macros/NonLinear/LOOKUP_f.sci" */
function LOOKUP_f() {
LOOKUP_f.prototype.get = function LOOKUP_f() {
}
LOOKUP_f.prototype.set = function LOOKUP_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
rpar=model.rpar;
n=size(rpar,"*")/2;
xx=rpar.slice(1-1,n);
yy=rpar.slice(n+1-1,2*n);
while (true) {
[ln,fun]=where()
if (!or(fun=="do_eval")) {
[xx,yy,ok,gc]=edit_curv(xx,yy,"axy");
} else {
ok=true;
}
if (!ok) {
break
}
n=size(xx,"*");
if (or(xx.slice(2-1,n)-xx.slice(1-1,n-1)<=0)) {
message("You have not defined a function");
ok=None;
}
if (ok) {
model.rpar=[xx.slice(),yy.slice()];
x.graphics=graphics;
x.model=model;
break
}
}
}
LOOKUP_f.prototype.define = function LOOKUP_f() {
model=scicos_model();
model.sim="lookup";
model.in=1;
model.out=1;
model.rpar=[-2,-1,1,2,-1,1,-1,1];
model.blocktype="c";
model.dep_ut=[true,None];
gr_i=[];
x=standard_define([2,2],model,[],gr_i);
}
LOOKUP_f.prototype.details = function LOOKUP_f() {
}
}
/* autogenerated from "macros/NonLinear/INTRPLBLK_f.sci" */
function INTRPLBLK_f() {
INTRPLBLK_f.prototype.get = function INTRPLBLK_f() {
}
INTRPLBLK_f.prototype.set = function INTRPLBLK_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,a,b,exprs]=scicos_getvalue("Set Interpolation block parameters",["X coord.","Y coord."],list("vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
if (size(a,"*")!=size(b,"*")) {
message("X and Y must have the same size");
} else if (min(a.slice(2-1,$)-a.slice(1-1,$-1))<=0) {
message("X must be strictly increasing");
} else {
if (ok) {
graphics.exprs=exprs;
model.rpar=[a.slice(),b.slice()];
x.graphics=graphics;
x.model=model;
break
}
}
}
}
INTRPLBLK_f.prototype.define = function INTRPLBLK_f() {
a=[0,1];
b=[0,1];
model=scicos_model();
model.sim="intrpl";
model.in=1;
model.out=1;
model.rpar=[a,b];
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[strcat(sci2exp(a)),strcat(sci2exp(b))];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
INTRPLBLK_f.prototype.details = function INTRPLBLK_f() {
}
}
/* autogenerated from "macros/NonLinear/PROD_f.sci" */
function PROD_f() {
PROD_f.prototype.get = function PROD_f() {
}
PROD_f.prototype.set = function PROD_f() {
x=arg1;
}
PROD_f.prototype.define = function PROD_f() {
model=scicos_model();
model.sim=list("prod",2);
model.in=[-1,-1];
model.out=-1;
model.blocktype="c";
model.dep_ut=[true,None];
x=standard_define([1,1],model,[],[]);
}
PROD_f.prototype.details = function PROD_f() {
}
}
/* autogenerated from "macros/NonLinear/DLRADAPT_f.sci" */
function DLRADAPT_f() {
DLRADAPT_f.prototype.get = function DLRADAPT_f() {
}
DLRADAPT_f.prototype.set = function DLRADAPT_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,p,rn,rd,g,last_u,last_y,exprs]=scicos_getvalue("Set block parameters",["Vector of p mesh points","Numerator roots (one line for each mesh)","Denominator roots (one line for each mesh)","Vector of gain at mesh points","past inputs (Num degree values)","past outputs (Den degree values)"],list("vec",-1,"mat",[-1,-1],"mat",["size(%1,\'*\')","-1"],"vec","size(%1,\'*\')","vec","size(%2,2)","vec","size(%3,2)"),exprs);
if (!ok) {
break
}
m=size(rn,2);
[npt,n]=size(rd);
if (m>=n) {
message("Transfer must be strictly proper");
} else if (size(rn,1)!=0&&size(rn,1)!=size(p,"*")) {
message("Numerator roots matrix row size\'s is incorrect");
} else {
rpar=[p.slice(),real(rn.slice()),imag(rn.slice()),real(rd.slice()),imag(rd.slice()),g.slice()];
ipar=[m,n,npt];
model.dstate=[last_u.slice(),last_y.slice()];
model.rpar=rpar;
model.ipar=ipar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
DLRADAPT_f.prototype.define = function DLRADAPT_f() {
p=[0,1];
rn=[];
rd=[math.complex(0.2,0.8),math.complex(0.2,-0.8),math.complex(0.3,0.7),math.complex(0.3,-0.7)];
g=[1,1];
last_u=[];
last_y=[0,0];
model=scicos_model();
model.sim="dlradp";
model.in=[1,1];
model.out=1;
model.evtin=1;
model.dstate=[last_u,last_y];
model.rpar=[p.slice(),real(rn.slice()),imag(rn.slice()),real(rd.slice()),imag(rd.slice()),g.slice()];
model.ipar=[0,2,2];
model.blocktype="d";
model.firing=[];
model.dep_ut=[true,None];
exprs=[sci2exp(p),sci2exp(rn),sci2exp(rd,0),sci2exp(g),sci2exp(last_u),sci2exp(last_y)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
DLRADAPT_f.prototype.details = function DLRADAPT_f() {
}
}
/* autogenerated from "macros/NonLinear/QUANT_f.sci" */
function QUANT_f() {
QUANT_f.prototype.get = function QUANT_f() {
}
QUANT_f.prototype.set = function QUANT_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,pas,meth,exprs]=scicos_getvalue("Set parameters",["Step","Quantization Type (1-4)"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (meth<1||meth>4) {
message("Quantization Type must be from 1 to 4");
} else {
rpar=pas;
model.rpar=rpar;
model.ipar=meth;
switch (meth) {
case 1:
model.sim="qzrnd";
case 2:
model.sim="qztrn";
case 3:
model.sim="qzflr";
case 4:
model.sim="qzcel";
}
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
QUANT_f.prototype.define = function QUANT_f() {
pas=0.1;
meth=1;
model=scicos_model();
model.sim="qzrnd";
model.in=-1;
model.out=-1;
model.rpar=pas;
model.ipar=meth;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string(pas),string(meth)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
QUANT_f.prototype.details = function QUANT_f() {
}
}
/* autogenerated from "macros/NonLinear/LOGBLK_f.sci" */
function LOGBLK_f() {
LOGBLK_f.prototype.get = function LOGBLK_f() {
}
LOGBLK_f.prototype.set = function LOGBLK_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")==2) {
exprs=exprs(2);
}
while (true) {
[ok,a,exprs]=scicos_getvalue("Set log block parameters","Basis (>1)",list("vec",1),exprs);
if (!ok) {
break
}
if (a<=1) {
message("Basis must be larger than 1");
} else {
if (ok) {
graphics.exprs=exprs;
model.rpar=a;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
LOGBLK_f.prototype.define = function LOGBLK_f() {
in1=1;
a=math.E;
model=scicos_model();
model.sim="logblk";
model.in=-1;
model.out=-1;
model.rpar=a;
model.blocktype="c";
model.dep_ut=[true,None];
exprs="%e";
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
LOGBLK_f.prototype.details = function LOGBLK_f() {
}
}
/* autogenerated from "macros/NonLinear/MAX_f.sci" */
function MAX_f() {
MAX_f.prototype.get = function MAX_f() {
}
MAX_f.prototype.set = function MAX_f() {
x=arg1;
}
MAX_f.prototype.define = function MAX_f() {
in1=-1;
model=scicos_model();
model.sim="maxblk";
model.in=in1;
model.out=1;
model.dstate=[0,0];
model.blocktype="c";
model.dep_ut=[true,None];
exprs=" ";
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
MAX_f.prototype.details = function MAX_f() {
}
}
/* autogenerated from "macros/NonLinear/INVBLK.sci" */
function INVBLK() {
INVBLK.prototype.get = function INVBLK() {
}
INVBLK.prototype.set = function INVBLK() {
x=arg1;
}
INVBLK.prototype.define = function INVBLK() {
in1=-1;
model=scicos_model();
model.sim=list("invblk4",4);
model.in=in1;
model.out=in1;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=" ";
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
INVBLK.prototype.details = function INVBLK() {
}
}
/* autogenerated from "macros/NonLinear/EXPBLK_m.sci" */
function EXPBLK_m() {
EXPBLK_m.prototype.get = function EXPBLK_m() {
}
EXPBLK_m.prototype.set = function EXPBLK_m() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")==2) {
exprs=exprs(2);
}
while (true) {
[ok,a,exprs]=scicos_getvalue("Set a^u  block parameters","a (>0)",list("vec",1),exprs);
if (!ok) {
break
}
if (or(a<=0)) {
message("a^u : a must be positive");
} else {
graphics.exprs=exprs;
model.rpar=a;
x.graphics=graphics;
x.model=model;
break
}
}
}
EXPBLK_m.prototype.define = function EXPBLK_m() {
in1=1;
a=math.E;
model=scicos_model();
model.sim=list("expblk_m",4);
model.in=-1;
model.in2=-2;
model.out=-1;
model.out2=-2;
model.intyp=1;
model.outtyp=1;
model.rpar=a;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=["%e"];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
EXPBLK_m.prototype.details = function EXPBLK_m() {
}
}
/* autogenerated from "macros/NonLinear/ABS_VALUE.sci" */
function ABS_VALUE() {
ABS_VALUE.prototype.get = function ABS_VALUE() {
}
ABS_VALUE.prototype.set = function ABS_VALUE() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,zcr,exprs]=scicos_getvalue("Set block parameters",["use zero_crossing (1: yes) (0:no)"],list("vec",1),exprs);
if (!ok) {
break
}
graphics.exprs=exprs;
if (ok) {
if (zcr!=0) {
model.nmode=-1;
model.nzcross=-1;
} else {
model.nmode=0;
model.nzcross=0;
}
x.graphics=graphics;
x.model=model;
break
}
}
}
ABS_VALUE.prototype.define = function ABS_VALUE() {
nu=-1;
model=scicos_model();
model.sim=list("absolute_value",4);
model.in=nu;
model.out=nu;
model.nzcross=nu;
model.nmode=nu;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string([1])];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
ABS_VALUE.prototype.details = function ABS_VALUE() {
}
}
/* autogenerated from "macros/NonLinear/MIN_f.sci" */
function MIN_f() {
MIN_f.prototype.get = function MIN_f() {
}
MIN_f.prototype.set = function MIN_f() {
x=arg1;
}
MIN_f.prototype.define = function MIN_f() {
in1=-1;
model=scicos_model();
model.sim="minblk";
model.in=in1;
model.out=1;
model.dstate=[0,0];
model.blocktype="c";
model.dep_ut=[true,None];
exprs=sci2exp(in1);
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
MIN_f.prototype.details = function MIN_f() {
}
}
/* autogenerated from "macros/NonLinear/SATURATION.sci" */
function SATURATION() {
SATURATION.prototype.get = function SATURATION() {
}
SATURATION.prototype.set = function SATURATION() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,maxp,minp,zeroc,exprs]=scicos_getvalue("Set Saturation parameters",["Upper limit","Lower limit","zero crossing (0:no, 1:yes)"],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (maxp<=minp) {
message("Upper limit must be > Lower limit");
} else {
rpar=[maxp,minp];
model.rpar=rpar;
if (zeroc!=0) {
model.nzcross=2;
model.nmode=1;
} else {
model.nzcross=0;
model.nmode=0;
}
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
SATURATION.prototype.define = function SATURATION() {
minp=-1;
maxp=1;
rpar=[maxp,minp];
model=scicos_model();
model.sim=list("satur",4);
model.in=1;
model.nzcross=2;
model.nmode=1;
model.out=1;
model.rpar=rpar;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string(maxp),string(minp),string(model.nmode)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
SATURATION.prototype.details = function SATURATION() {
}
}
/* autogenerated from "macros/NonLinear/TANBLK_f.sci" */
function TANBLK_f() {
TANBLK_f.prototype.get = function TANBLK_f() {
}
TANBLK_f.prototype.set = function TANBLK_f() {
x=arg1;
x.model.firing=[];
}
TANBLK_f.prototype.define = function TANBLK_f() {
in1=-1;
model=scicos_model();
model.sim="tanblk";
model.in=in1;
model.out=in1;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=sci2exp(in1);
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
TANBLK_f.prototype.details = function TANBLK_f() {
}
}
/* autogenerated from "macros/NonLinear/FSV_f.sci" */
function FSV_f() {
FSV_f.prototype.get = function FSV_f() {
}
FSV_f.prototype.set = function FSV_f() {
x=arg1;
}
FSV_f.prototype.define = function FSV_f() {
in1=1;
model=scicos_model();
model.sim=list("fsv",1);
model.in=in1;
model.out=in1;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=" ";
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
FSV_f.prototype.details = function FSV_f() {
}
}
/* autogenerated from "macros/NonLinear/EXPBLK_f.sci" */
function EXPBLK_f() {
EXPBLK_f.prototype.get = function EXPBLK_f() {
}
EXPBLK_f.prototype.set = function EXPBLK_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")==2) {
exprs=exprs(2);
}
while (true) {
[ok,a,exprs]=scicos_getvalue("Set a^u  block parameters","a (>0)",list("vec",1),exprs);
if (!ok) {
break
}
if (or(a<=0)) {
message("a^u : a must be positive");
} else {
graphics.exprs=exprs;
model.rpar=a;
x.graphics=graphics;
x.model=model;
break
}
}
}
EXPBLK_f.prototype.define = function EXPBLK_f() {
in1=1;
a=math.E;
model=scicos_model();
model.sim="expblk";
model.in=-1;
model.out=-1;
model.rpar=a;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=["%e"];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
EXPBLK_f.prototype.details = function EXPBLK_f() {
}
}
/* autogenerated from "macros/NonLinear/ABSBLK_f.sci" */
function ABSBLK_f() {
ABSBLK_f.prototype.get = function ABSBLK_f() {
}
ABSBLK_f.prototype.set = function ABSBLK_f() {
x=arg1;
}
ABSBLK_f.prototype.define = function ABSBLK_f() {
model=scicos_model();
model.sim=list("absblk",1);
model.in=-1;
model.out=-1;
model.blocktype="c";
model.dep_ut=[true,None];
gr_i=[];
x=standard_define([2,2],model,[],gr_i);
}
ABSBLK_f.prototype.details = function ABSBLK_f() {
}
}
/* autogenerated from "macros/NonLinear/POWBLK_f.sci" */
function POWBLK_f() {
POWBLK_f.prototype.get = function POWBLK_f() {
}
POWBLK_f.prototype.set = function POWBLK_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")==2) {
exprs=exprs(2);
}
while (true) {
[ok,a,exprs]=scicos_getvalue("Set u^a block parameters","to the power of",list("vec",1),exprs);
if (!ok) {
break
}
graphics.exprs=exprs;
if (a==int(a)) {
model.ipar=a;
model.rpar=[];
} else {
model.rpar=a;
model.ipar=[];
}
model.firing=[];
x.graphics=graphics;
x.model=model;
break
}
}
POWBLK_f.prototype.define = function POWBLK_f() {
in1=1;
a=1.5;
model=scicos_model();
model.sim="powblk";
model.in=-1;
model.out=-1;
model.rpar=a;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=string(a);
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
POWBLK_f.prototype.details = function POWBLK_f() {
}
}
/* autogenerated from "macros/NonLinear/INVBLK_f.sci" */
function INVBLK_f() {
INVBLK_f.prototype.get = function INVBLK_f() {
}
INVBLK_f.prototype.set = function INVBLK_f() {
x=arg1;
}
INVBLK_f.prototype.define = function INVBLK_f() {
in1=-1;
model=scicos_model();
model.sim="invblk";
model.in=in1;
model.out=in1;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=" ";
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
INVBLK_f.prototype.details = function INVBLK_f() {
}
}
