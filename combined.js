/* autogenerated from "macros/Hydraulics/SourceP.sci" */
function SourceP() {
SourceP.prototype.get = function SourceP() {
}
SourceP.prototype.set = function SourceP() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,P0,T0,H0,option_temperature,exprs]=scicos_getvalue("Paramètres du puits",["Pression de la source : P0 (Pa)","Temperature de la source : T0 (K)","Enthalpie spécifique de la source : H0 (J/kg)","1:température fixée - 2:enthalpie fixée : option_temperature"],list("vec",-1,"vec",-1,"vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
model.rpar=[P0,T0,H0,option_temperature];
model.equations.parameters[2-1]=list(P0,T0,H0,option_temperature);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
SourceP.prototype.define = function SourceP() {
model=scicos_model();
P0=300000;
T0=290;
H0=100000;
option_temperature=1;
model.rpar=[P0,T0,H0,option_temperature];
model.sim="Source";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="Source";
mo.inputs=[];
mo.outputs=["C"];
mo.parameters=list(["P0","T0","H0","option_temperature"],[P0,T0,H0,option_temperature]);
model.equations=mo;
model.in1=ones(size(mo.inputs,"*"),1);
model.out=ones(size(mo.outputs,"*"),1);
exprs=[string(P0),string(T0),string(H0),string(option_temperature)];
gr_i=[];
x=standard_define([2.5,2],model,exprs,list(gr_i,0));
x.graphics.out_implicit=["I"];
}
SourceP.prototype.details = function SourceP() {
}
}
/* autogenerated from "macros/Hydraulics/Flowmeter.sci" */
function Flowmeter() {
Flowmeter.prototype.get = function Flowmeter() {
}
Flowmeter.prototype.set = function Flowmeter() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
x=arg1;
exprs=x.graphics.exprs;
while (None) {
[ok,Qini,exprs]=scicos_getvalue(["Set Flowmeter block parameters:","","Qini: "],"Qini",list("vec",1),exprs);
if (!ok) {
break
}
x.model.equations.parameters[2-1]=list(Qini);
x.graphics.exprs=exprs;
break
}
}
Flowmeter.prototype.define = function Flowmeter() {
ModelName="Flowmeter";
PrametersValue=1;
ParametersName="Qini";
model=scicos_model();
Typein=[];
Typeout=[];
MI=[];
MO=[];
P=[50,105,-1,90,0,10,2,0,101,10,-2,0];
PortName=["Mesure","C1","C2"];
for(i=1;i<=size(P,"r");i+=1) {
if (P(i,3)==1) {
Typein=[Typein,"E"];
MI=[MI,PortName(i)];
}
if (P(i,3)==2) {
Typein=[Typein,"I"];
MI=[MI,PortName(i)];
}
if (P(i,3)==-1) {
Typeout=[Typeout,"E"];
MO=[MO,PortName(i)];
}
if (P(i,3)==-2) {
Typeout=[Typeout,"I"];
MO=[MO,PortName(i)];
}
}
model=scicos_model();
mo=modelica();
model.sim=ModelName;
mo.inputs=MI;
mo.outputs=MO;
model.rpar=PrametersValue;
mo.parameters=list(ParametersName,PrametersValue,zeros(ParametersName));
exprs="1";
gr_i=[];
model.blocktype="c";
model.dep_ut=[None,true];
mo.model=ModelName;
model.equations=mo;
model.in1=ones(size(MI,"*"),1);
model.out=ones(size(MO,"*"),1);
x=standard_define([2,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=Typein;
x.graphics.out_implicit=Typeout;
}
Flowmeter.prototype.details = function Flowmeter() {
}
}
/* autogenerated from "macros/Hydraulics/VanneReglante.sci" */
function VanneReglante() {
VanneReglante.prototype.get = function VanneReglante() {
}
VanneReglante.prototype.set = function VanneReglante() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,Cvmax,p_rho,exprs]=scicos_getvalue("Paramètres de la vanne reglante",["Cvmax","p_rho"],list("vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
model.rpar=[Cvmax,p_rho];
model.equations.parameters[2-1]=list(Cvmax,p_rho);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
VanneReglante.prototype.define = function VanneReglante() {
model=scicos_model();
model.in1=[1,1];
model.out=[1];
Cvmax=8005.42;
p_rho=0;
model.rpar=[Cvmax,p_rho];
model.sim="VanneReglante";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="VanneReglante";
mo.inputs=["C1","Ouv"];
mo.outputs="C2";
mo.parameters=list(["Cvmax","p_rho"],[Cvmax,p_rho]);
model.equations=mo;
model.in1=ones(size(mo.inputs,"*"),1);
model.out=ones(size(mo.outputs,"*"),1);
exprs=[string(Cvmax),string(p_rho)];
gr_i=[];
x=standard_define([2,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I","E"];
x.graphics.out_implicit=["I"];
}
VanneReglante.prototype.details = function VanneReglante() {
}
}
/* autogenerated from "macros/Hydraulics/PerteDP.sci" */
function PerteDP() {
PerteDP.prototype.get = function PerteDP() {
}
PerteDP.prototype.set = function PerteDP() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,L,D,lambda,z1,z2,p_rho,exprs]=scicos_getvalue("Parametres du tuyau",["Longueur du tube : L (m)","Diamètre interne du tube : D (m)","Coefficient de perte de charge-frottement(S.U) : lambda","Altitude entrée tuyauterie : z1 (m)","Altitude sortie tuyauterie : z2 (m)","Si >0, masse volumique imposée fu fluide : p_rho (kg/m3)"],list("vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
model.rpar=[L,D,lambda,z1,z2,p_rho];
model.equations.parameters[2-1]=list(L,D,lambda,z1,z2,p_rho);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
PerteDP.prototype.define = function PerteDP() {
model=scicos_model();
model.in1=[1];
model.out=[1];
L=10;
D=0.2;
lambda=0.03;
z1=0;
z2=0;
p_rho=0;
model.rpar=[L,D,lambda,z1,z2,p_rho];
model.sim="PerteDP";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="PerteDP";
mo.inputs="C1";
mo.outputs="C2";
mo.parameters=list(["L","D","lambda","z1","z2","p_rho"],[L,D,lambda,z1,z2,p_rho]);
model.equations=mo;
model.in1=ones(size(mo.inputs,"*"),1);
model.out=ones(size(mo.outputs,"*"),1);
exprs=[string(L),string(D),string(lambda),string(z1),string(z2),string(p_rho)];
gr_i=[];
x=standard_define([2,1],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I"];
}
PerteDP.prototype.details = function PerteDP() {
}
}
/* autogenerated from "macros/Hydraulics/PuitsP.sci" */
function PuitsP() {
PuitsP.prototype.get = function PuitsP() {
}
PuitsP.prototype.set = function PuitsP() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,P0,T0,H0,option_temperature,exprs]=scicos_getvalue("Paramètres du puits",["Pression de la source : P0 (Pa)","Temperature de la source : T0 (K)","Enthalpie spécifique de la source : H0 (J/kg)","1:température fixée - 2:enthalpie fixée : option_temperature"],list("vec",-1,"vec",-1,"vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
model.rpar=[P0,T0,H0,option_temperature];
model.equations.parameters[2-1]=list(P0,T0,H0,option_temperature);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
PuitsP.prototype.define = function PuitsP() {
model=scicos_model();
P0=100000;
T0=290;
H0=100000;
option_temperature=1;
model.rpar=[P0,T0,H0,option_temperature];
model.sim="Puits";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="Puits";
mo.inputs=["C"];
mo.parameters=list(["P0","T0","H0","option_temperature"],[P0,T0,H0,option_temperature]);
model.equations=mo;
model.in1=ones(size(mo.inputs,"*"),1);
exprs=[string(P0),string(T0),string(H0),string(option_temperature)];
gr_i=[];
x=standard_define([2.5,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I"];
}
PuitsP.prototype.details = function PuitsP() {
}
}
/* autogenerated from "macros/Events/EVTDLY_c.sci" */
function EVTDLY_c() {
EVTDLY_c.prototype.get = function EVTDLY_c() {
}
EVTDLY_c.prototype.set = function EVTDLY_c() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,dt,ff,exprs]=scicos_getvalue(["Set Event Delay block parameters","Delay  is the delay between an input event ","       and the generated output event","Block may initially generate an output event before ","       any input event. \"Date of initial output event\"","       gives the date of this event. Set a negative value","       to disable any output event."],["Delay","Date of initial output event"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (dt<=0) {
message("Delay must be positive");
ok=None;
}
if (ok) {
graphics.exprs=exprs;
model.rpar=[dt,ff];
model.firing=ff;
x.graphics=graphics;
x.model=model;
break
}
}
}
EVTDLY_c.prototype.define = function EVTDLY_c() {
dt=0.1;
ff=0.0;
model=scicos_model();
model.sim=list("evtdly4",4);
model.evtin=1;
model.evtout=1;
model.rpar=[dt,ff];
model.blocktype="d";
model.firing=ff;
model.dep_ut=[None,None];
exprs=[string(dt),sci2exp(ff)];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
EVTDLY_c.prototype.details = function EVTDLY_c() {
}
}
/* autogenerated from "macros/Events/CLKSPLIT_f.sci" */
function CLKSPLIT_f() {
CLKSPLIT_f.prototype.get = function CLKSPLIT_f() {
}
CLKSPLIT_f.prototype.set = function CLKSPLIT_f() {
x=arg1;
}
CLKSPLIT_f.prototype.define = function CLKSPLIT_f() {
model=scicos_model();
model.sim="split";
model.evtin=1;
model.evtout=[1,1];
model.blocktype="d";
model.firing=[None,None,None];
model.dep_ut=[None,None];
x=standard_define([1,1]/3,model,[],[]);
}
CLKSPLIT_f.prototype.details = function CLKSPLIT_f() {
}
}
/* autogenerated from "macros/Events/ANDLOG_f.sci" */
function ANDLOG_f() {
ANDLOG_f.prototype.get = function ANDLOG_f() {
}
ANDLOG_f.prototype.set = function ANDLOG_f() {
x=arg1;
}
ANDLOG_f.prototype.define = function ANDLOG_f() {
model=scicos_model();
model.sim="andlog";
model.out=1;
model.evtin=[1,1];
model.blocktype="d";
model.firing=[];
model.dep_ut=[None,None];
gr_i=[];
x=standard_define([3,3],model,[],gr_i);
}
ANDLOG_f.prototype.details = function ANDLOG_f() {
}
}
/* autogenerated from "macros/Events/ANDBLK.sci" */
function ANDBLK() {
ANDBLK.prototype.get = function ANDBLK() {
}
ANDBLK.prototype.set = function ANDBLK() {
x=arg1;
}
ANDBLK.prototype.define = function ANDBLK() {
andlog=ANDLOG_f("define");
andlog.graphics.orig=[194,133];
andlog.graphics.sz=[60,60];
andlog.graphics.flip=true;
andlog.graphics.pout=9;
andlog.graphics.pein=[4,11];
input_port1=CLKIN_f("define");
input_port1.graphics.orig=[149,287];
input_port1.graphics.sz=[20,20];
input_port1.graphics.flip=true;
input_port1.graphics.exprs="1";
input_port1.graphics.peout=4;
input_port1.model.ipar=1;
output_port=CLKOUT_f("define");
output_port.graphics.orig=[450,83];
output_port.graphics.sz=[20,20];
output_port.graphics.flip=true;
output_port.graphics.exprs="1";
output_port.graphics.pein=8;
output_port.model.ipar=1;
input_port2=CLKIN_f("define");
input_port2.graphics.orig=[141,330];
input_port2.graphics.sz=[20,20];
input_port2.graphics.flip=true;
input_port2.graphics.exprs="2";
input_port2.graphics.peout=6;
input_port2.model.ipar=2;
ifthel=IFTHEL_f("define");
ifthel.graphics.orig=[331,137];
ifthel.graphics.sz=[60,60];
ifthel.graphics.flip=true;
ifthel.graphics.pin=9;
ifthel.graphics.pein=12;
ifthel.graphics.peout=[8,0];
split=CLKSPLIT_f("define");
split.graphics.orig=[234,275.78348];
split.graphics.pein=6;
split.graphics.peout=[11,12];
diagram=scicos_diagram();
diagram.objs[1-1]=andlog;
diagram.objs[2-1]=input_port1;
diagram.objs[3-1]=output_port;
diagram.objs[4-1]=scicos_link(xx=[169,214,214],yy=[297,297,198.71],ct=[5,-1],from=[2,1],to=[1,1]);
diagram.objs[5-1]=input_port2;
diagram.objs[6-1]=scicos_link(xx=[161,234,234],yy=[340,340,275.78],ct=[5,-1],from=[5,1],to=[10,1]);
diagram.objs[7-1]=ifthel;
diagram.objs[8-1]=scicos_link(xx=[351,351,450],yy=[131.29,93,93],ct=[5,-1],from=[7,1],to=[3,1]);
diagram.objs[9-1]=scicos_link(xx=[262.57,322.43],yy=[163,167],ct=[1,1],from=[1,1],to=[7,1]);
diagram.objs[10-1]=split;
diagram.objs[11-1]=scicos_link(xx=[234,234],yy=[275.78,198.71],ct=[5,-1],from=[10,1],to=[1,2]);
diagram.objs[12-1]=scicos_link(xx=[234,361,361],yy=[275.78,275.78,202.71],ct=[5,-1],from=[10,2],to=[7,1]);
x=scicos_block();
x.gui="ANDBLK";
x.graphics.sz=[2,2];
x.graphics.gr_i=[];
x.graphics.pein=[0,0];
x.graphics.peout=0;
x.model.sim="csuper";
x.model.evtin=[1,1];
x.model.evtout=1;
x.model.blocktype="h";
x.model.firing=None;
x.model.dep_ut=[None,None];
x.model.rpar=diagram;
}
ANDBLK.prototype.details = function ANDBLK() {
}
}
/* autogenerated from "macros/Events/HALT_f.sci" */
function HALT_f() {
HALT_f.prototype.get = function HALT_f() {
}
HALT_f.prototype.set = function HALT_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,n,exprs]=scicos_getvalue("Set Halt block parameters",["State on halt"],list("vec",1),exprs);
if (!ok) {
break
}
if (ok) {
graphics.exprs=exprs;
model.ipar=n;
x.graphics=graphics;
x.model=model;
break
}
}
}
HALT_f.prototype.define = function HALT_f() {
n=0;
model=scicos_model();
model.sim="hltblk";
model.evtin=1;
model.dstate=0;
model.ipar=0;
model.blocktype="d";
model.dep_ut=[None,None];
exprs=string(n);
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
HALT_f.prototype.details = function HALT_f() {
}
}
/* autogenerated from "macros/Events/IFTHEL_f.sci" */
function IFTHEL_f() {
IFTHEL_f.prototype.get = function IFTHEL_f() {
}
IFTHEL_f.prototype.set = function IFTHEL_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (exprs==[]) {
exprs=string(1);
}
if (size(exprs,"*")==1) {
exprs[2-1]=string(1);
}
while (true) {
[ok,inh,nmod,exprs]=scicos_getvalue("Set parameters",["Inherit (1: no, 0: yes)","zero-crossing (0: no, 1: yes)"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
model.dep_ut=[true,None];
if (nmod!=0) {
nmod=1;
}
if (inh!=1) {
inh=[];
}
[model,graphics,ok]=check_io(model,graphics,1,[],inh,[1,1]);
if (ok) {
graphics.exprs=exprs;
model.evtin=inh;
model.sim[2-1]=-1;
model.nmode=nmod;
model.nzcross=nmod;
x.graphics=graphics;
x.model=model;
break
}
}
}
IFTHEL_f.prototype.define = function IFTHEL_f() {
model=scicos_model();
model.sim=list("ifthel",-1);
model.in1=1;
model.in2=1;
model.intyp=-1;
model.evtin=1;
model.evtout=[1,1];
model.blocktype="l";
model.firing=[-1,-1];
model.dep_ut=[true,None];
model.nmode=1;
model.nzcross=1;
gr_i=[];
exprs=[string(model.in1),string(model.nmode)];
x=standard_define([3,3],model,exprs,gr_i);
}
IFTHEL_f.prototype.details = function IFTHEL_f() {
}
}
/* autogenerated from "macros/Events/VirtualCLK0.sci" */
function VirtualCLK0() {
VirtualCLK0.prototype.get = function VirtualCLK0() {
}
VirtualCLK0.prototype.set = function VirtualCLK0() {
x=arg1;
}
VirtualCLK0.prototype.define = function VirtualCLK0() {
model=scicos_model();
model.sim="vrtclk0";
model.evtin=1;
model.opar=list();
model.ipar=[];
model.blocktype="d";
model.firing=-1;
model.dep_ut=[None,None];
exprs=[];
x=standard_define([2,2],model,exprs," ");
}
VirtualCLK0.prototype.details = function VirtualCLK0() {
}
}
/* autogenerated from "macros/Events/END_c.sci" */
function END_c() {
END_c.prototype.get = function END_c() {
}
END_c.prototype.set = function END_c() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,tf,exprs]=scicos_getvalue("Set final simulation time",["Final simulation time"],list("vec",1),exprs);
if (!ok) {
break
}
if (ok) {
graphics.exprs=exprs;
model.firing=tf;
x.graphics=graphics;
x.model=model;
break
}
}
}
END_c.prototype.define = function END_c() {
tf=100000000;
model=scicos_model();
model.sim=list("scicosexit",4);
model.evtin=1;
model.evtout=1;
model.firing=tf;
model.blocktype="d";
model.dep_ut=[None,None];
exprs=string(tf);
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
END_c.prototype.details = function END_c() {
}
}
/* autogenerated from "macros/Events/CLKSOMV_f.sci" */
function CLKSOMV_f() {
CLKSOMV_f.prototype.get = function CLKSOMV_f() {
}
CLKSOMV_f.prototype.set = function CLKSOMV_f() {
x=arg1;
}
CLKSOMV_f.prototype.define = function CLKSOMV_f() {
model=scicos_model();
model.sim="sum";
model.evtin=[1,1,1];
model.evtout=1;
model.blocktype="d";
model.firing=-1;
model.dep_ut=[None,None];
gr_i=[];
x=standard_define([2,2],model,[],gr_i);
}
CLKSOMV_f.prototype.details = function CLKSOMV_f() {
}
}
/* autogenerated from "macros/Events/EVTGEN_f.sci" */
function EVTGEN_f() {
EVTGEN_f.prototype.get = function EVTGEN_f() {
}
EVTGEN_f.prototype.set = function EVTGEN_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,tt,exprs]=scicos_getvalue("Set Event time",["Event Time"],list("vec",1),exprs);
if (!ok) {
break
}
graphics.exprs=exprs;
if (model.firing!=tt) {
model.firing=tt;
}
x.graphics=graphics;
x.model=model;
break
}
}
EVTGEN_f.prototype.define = function EVTGEN_f() {
tt=0;
model=scicos_model();
model.sim="trash";
model.evtout=1;
model.blocktype="d";
model.firing=tt;
model.dep_ut=[None,None];
exprs=string(tt);
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
EVTGEN_f.prototype.details = function EVTGEN_f() {
}
}
/* autogenerated from "macros/Events/MCLOCK_f.sci" */
function MCLOCK_f() {
MCLOCK_f.prototype.get = function MCLOCK_f() {
}
MCLOCK_f.prototype.set = function MCLOCK_f() {
for(i=1;i<=length(arg1.model.rpar.objs);i+=1) {
o=arg1.model.rpar.objs(i);
if (typeof(o)=="Block"&&o.gui=="MFCLCK_f") {
path=i;
break
}
}
newpar=list();
spath=list("model","rpar","objs",path);
xx=arg1(spath);
execstr("xxn="+xx.gui+"(\'set\',xx)");
if (or(xxn!=xx)) {
arg1[spath-1]=xxn;
newpar[size(newpar)+1-1]=path;
}
x=arg1;
y=0;
typ=newpar;
}
MCLOCK_f.prototype.define = function MCLOCK_f() {
nn=2;
dt=0.1;
exprs=[string(dt),string(nn)];
mfclck=MFCLCK_f("define");
mfclck.graphics.orig=[334,199];
mfclck.graphics.sz=[40,40];
mfclck.graphics.flip=true;
mfclck.graphics.exprs=exprs;
mfclck.graphics.pein=12;
mfclck.graphics.peout=[4,3];
mfclck.model.rpar=0.1;
mfclck.model.ipar=nn;
mfclck.model.firing=[-1,0];
clksom=CLKSOM_f("define");
clksom.graphics.orig=[457,161];
clksom.graphics.sz=[16.666667,16.666667];
clksom.graphics.flip=true;
clksom.graphics.exprs=["0.1","0.1"];
clksom.graphics.pein=[4,9,0];
clksom.graphics.peout=5;
output_port1=CLKOUT_f("define");
output_port1.graphics.orig=[509,261];
output_port1.graphics.sz=[20,20];
output_port1.graphics.flip=true;
output_port1.graphics.exprs="1";
output_port1.graphics.pein=10;
output_port1.model.ipar=1;
output_port2=CLKOUT_f("define");
output_port2.graphics.orig=[509,142];
output_port2.graphics.sz=[20,20];
output_port2.graphics.flip=true;
output_port2.graphics.exprs="2";
output_port2.graphics.pein=13;
output_port2.model.ipar=2;
split1=CLKSPLIT_f("define");
split1.graphics.orig=[411.92504,169.33333];
split1.graphics.pein=3;
split1.graphics.peout=[9,10];
split2=CLKSPLIT_f("define");
split2.graphics.orig=[482.45315,169.33333];
split2.graphics.pein=5;
split2.graphics.peout=[12,13];
gr_i=[];
diagram=scicos_diagram();
diagram.objs[1-1]=mfclck;
diagram.objs[2-1]=clksom;
diagram.objs[3-1]=scicos_link(xx=[360.7,360.7,411.9],yy=[193.3,169.3,169.3],ct=[10,-1],from=[1,2],to=[8,1]);
diagram.objs[4-1]=scicos_link(xx=[347.3,347.3,461.8,461.8],yy=[193.3,155.5,155.5,161],ct=[10,-1],from=[1,1],to=[2,1]);
diagram.objs[5-1]=scicos_link(xx=[468.9,482.5],yy=[169.3,169.3],ct=[10,-1],from=[2,1],to=[11,1]);
diagram.objs[6-1]=output_port1;
diagram.objs[7-1]=output_port2;
diagram.objs[8-1]=split1;
diagram.objs[9-1]=scicos_link(xx=[411.9,457],yy=[169.3,169.3],ct=[10,-1],from=[8,1],to=[2,2]);
diagram.objs[10-1]=scicos_link(xx=[411.9,411.9,509],yy=[169.3,271,271],ct=[10,-1],from=[8,2],to=[6,1]);
diagram.objs[11-1]=split2;
diagram.objs[12-1]=scicos_link(xx=[482.5,489.6,489.6,354,354],yy=[169.3,169.3,338.3,338.3,244.7],ct=[10,-1],from=[11,1],to=[1,1]);
diagram.objs[13-1]=scicos_link(xx=[482.4,482.4,509],yy=[169.3,152,152],ct=[10,-1],from=[11,2],to=[7,1]);
x=scicos_block();
x.gui="MCLOCK_f";
x.graphics.sz=[3,2];
x.graphics.gr_i=gr_i;
x.model.sim="csuper";
x.model.evtout=[1,1];
x.model.blocktype="h";
x.model.rpar=diagram;
x.graphics.peout=[0,0];
}
MCLOCK_f.prototype.details = function MCLOCK_f() {
}
}
/* autogenerated from "macros/Events/EVTVARDLY.sci" */
function EVTVARDLY() {
EVTVARDLY.prototype.get = function EVTVARDLY() {
}
EVTVARDLY.prototype.set = function EVTVARDLY() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,fir,exprs]=scicos_getvalue("Set parameter of variable event delay","Initial event firing time (<0 if absent)",list("vec",1),exprs);
if (!ok) {
break
}
graphics.exprs=exprs;
model.firing=fir;
x.graphics=graphics;
x.model=model;
break
}
}
EVTVARDLY.prototype.define = function EVTVARDLY() {
model=scicos_model();
model.sim=list("evtvardly",4);
model.in1=1;
model.evtin=1;
model.evtout=1;
model.blocktype="d";
model.firing=-1;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=string(model.firing);
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
EVTVARDLY.prototype.details = function EVTVARDLY() {
}
}
/* autogenerated from "macros/Events/EVTDLY_f.sci" */
function EVTDLY_f() {
EVTDLY_f.prototype.get = function EVTDLY_f() {
}
EVTDLY_f.prototype.set = function EVTDLY_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,dt,ff,exprs]=scicos_getvalue(["Set Event Delay  block parameters","Delay  is the delay between an input event ","       and the generated output event","Block may initially generate an output event before ","       any input event. \"Date of initial output event\"","       gives the date of this event. Set a negative value","       if no initial event required"],["Delay","Date of initial output event"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (dt<=0) {
message("Delay must be positive");
ok=None;
}
if (ok) {
graphics.exprs=exprs;
model.rpar=dt;
model.firing=ff;
x.graphics=graphics;
x.model=model;
break
}
}
}
EVTDLY_f.prototype.define = function EVTDLY_f() {
dt=0.1;
ff=dt;
model=scicos_model();
model.sim="evtdly";
model.evtin=1;
model.evtout=1;
model.rpar=dt;
model.blocktype="d";
model.firing=ff;
model.dep_ut=[None,None];
exprs=[string(dt),sci2exp(ff)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
EVTDLY_f.prototype.details = function EVTDLY_f() {
}
}
/* autogenerated from "macros/Events/CLKSOM_f.sci" */
function CLKSOM_f() {
CLKSOM_f.prototype.get = function CLKSOM_f() {
}
CLKSOM_f.prototype.set = function CLKSOM_f() {
x=arg1;
}
CLKSOM_f.prototype.define = function CLKSOM_f() {
model=scicos_model();
model.sim="sum";
model.evtin=[1,1,1];
model.evtout=1;
model.blocktype="d";
model.firing=-1;
model.dep_ut=[None,None];
gr_i=[];
x=standard_define([1,1]/1.2,model,[],gr_i);
}
CLKSOM_f.prototype.details = function CLKSOM_f() {
}
}
/* autogenerated from "macros/Events/MFCLCK_f.sci" */
function MFCLCK_f() {
MFCLCK_f.prototype.get = function MFCLCK_f() {
}
MFCLCK_f.prototype.set = function MFCLCK_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
[ok,dt,nn,exprs]=scicos_getvalue("Set Multifrequency clock parameters",["basic period (1/f)","multiply by (n)"],list("vec",1,"vec",1),exprs);
if (ok) {
model.ipar=nn;
model.rpar=dt;
hh=model.firing;
hh[2-1]=0;
model.firing=hh;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
}
}
MFCLCK_f.prototype.define = function MFCLCK_f() {
nn=2;
dt=0.1;
model=scicos_model();
model.sim="mfclck";
model.evtin=1;
model.evtout=[1,1];
model.dstate=0;
model.rpar=dt;
model.ipar=nn;
model.blocktype="d";
model.firing=[-1,0];
model.dep_ut=[None,None];
exprs=[string(dt),string(nn)];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
MFCLCK_f.prototype.details = function MFCLCK_f() {
}
}
/* autogenerated from "macros/Linear/REGISTER_f.sci" */
function REGISTER_f() {
REGISTER_f.prototype.get = function REGISTER_f() {
}
REGISTER_f.prototype.set = function REGISTER_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,z0,exprs]=scicos_getvalue("Set delay parameters","Register initial condition",list("vec",-1),exprs);
if (!ok) {
break
}
if (prod(size(z0))<1) {
message("Register length must be at least 1");
ok=None;
}
if (ok) {
graphics.exprs=exprs;
model.dstate=z0;
x.graphics=graphics;
x.model=model;
break
}
}
}
REGISTER_f.prototype.define = function REGISTER_f() {
z0=zeros(10,1);
model=scicos_model();
model.sim="delay";
model.in1=1;
model.out=1;
model.evtin=1;
model.dstate=z0;
model.blocktype="d";
model.dep_ut=[None,None];
exprs=strcat(string(z0),";");
gr_i=[];
x=standard_define([2.5,2.5],model,exprs,gr_i);
}
REGISTER_f.prototype.details = function REGISTER_f() {
}
}
/* autogenerated from "macros/Linear/SUMMATION.sci" */
function SUMMATION() {
SUMMATION.prototype.get = function SUMMATION() {
}
SUMMATION.prototype.set = function SUMMATION() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
if (size(exprs,1)==1) {
exprs=[sci2exp(1),exprs,sci2exp(0)];
} else if (size(exprs,1)==2) {
exprs=[exprs,sci2exp(0)];
}
while (true) {
[ok,Datatype,sgn,satur,exprs]=scicos_getvalue("Set sum block parameters",["Datatype (1=real double  2=complex 3=int32 ...)","Number of inputs or sign vector (of +1, -1)","Do on Overflow(0=Nothing 1=Saturate 2=Error)"],list("vec",1,"vec",-1,"vec",1),exprs);
if (!ok) {
break
}
sgn=sgn.slice();
if ((satur!=0&&satur!=1&&satur!=2)) {
message("Do on overflow must be 0,1,2");
ok=None;
}
if (size(sgn,1)==1) {
if (sgn<1) {
message("Number of inputs must be > 0");
ok=None;
} else if (sgn==1) {
in1=-1;
in2=-2;
sgn=[];
nout=1;
nout2=1;
} else {
in1=-ones(sgn,1);
in2=2*in1;
sgn=ones(sgn,1);
nout=-1;
nout2=-2;
}
} else {
if (!and(abs(sgn)==1)) {
message("Signs can only be +1 or -1");
ok=None;
} else {
in1=-ones(size(sgn,1),1);
in2=2*in1;
nout=-1;
nout2=-2;
}
}
it=Datatype*ones(1,size(in1,1));
ot=Datatype;
if (Datatype==1) {
model.sim=list("summation",4);
} else if (Datatype==2) {
model.sim=list("summation_z",4);
} else if (((Datatype<1)||(Datatype>8))) {
message("Datatype is not supported");
ok=None;
} else {
if (satur==0) {
if (Datatype==3) {
model.sim=list("summation_i32n",4);
} else if (Datatype==4) {
model.sim=list("summation_i16n",4);
} else if (Datatype==5) {
model.sim=list("summation_i8n",4);
} else if (Datatype==6) {
model.sim=list("summation_ui32n",4);
} else if (Datatype==7) {
model.sim=list("summation_ui16n",4);
} else if (Datatype==8) {
model.sim=list("summation_ui8n",4);
}
} else if (satur==1) {
if (Datatype==3) {
model.sim=list("summation_i32s",4);
} else if (Datatype==4) {
model.sim=list("summation_i16s",4);
} else if (Datatype==5) {
model.sim=list("summation_i8s",4);
} else if (Datatype==6) {
model.sim=list("summation_ui32s",4);
} else if (Datatype==7) {
model.sim=list("summation_ui16s",4);
} else if (Datatype==8) {
model.sim=list("summation_ui8s",4);
}
} else if (satur==2) {
if (Datatype==3) {
model.sim=list("summation_i32e",4);
} else if (Datatype==4) {
model.sim=list("summation_i16e",4);
} else if (Datatype==5) {
model.sim=list("summation_i8e",4);
} else if (Datatype==6) {
model.sim=list("summation_ui32e",4);
} else if (Datatype==7) {
model.sim=list("summation_ui16e",4);
} else if (Datatype==8) {
model.sim=list("summation_ui8e",4);
}
}
}
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list([in1,in2],it),list([nout,nout2],ot),[],[]);
}
if (ok) {
model.rpar=satur;
model.ipar=sgn;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
SUMMATION.prototype.define = function SUMMATION() {
sgn=[1,-1];
model=scicos_model();
model.sim=list("summation",4);
model.in1=[-1,-1];
model.out=-1;
model.in2=[-2,-2];
model.out2=-2;
model.ipar=sgn;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=sci2exp(sgn);
gr_i=[];
x=standard_define([2,3],model,exprs,gr_i);
}
SUMMATION.prototype.details = function SUMMATION() {
}
}
/* autogenerated from "macros/Linear/GAINBLK_f.sci" */
function GAINBLK_f() {
GAINBLK_f.prototype.get = function GAINBLK_f() {
}
GAINBLK_f.prototype.set = function GAINBLK_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,gain,exprs]=scicos_getvalue("Set gain block parameters",["Gain"],list("mat",[-1,-1]),exprs(1));
if (!ok) {
break
}
if (gain==[]) {
message("Gain must have at least one element");
} else {
[out,in1]=size(gain);
[model,graphics,ok]=check_io(model,graphics,in1,out,[],[]);
if (ok) {
graphics.exprs=exprs;
model.rpar=gain.slice();
x.graphics=graphics;
x.model=model;
break
}
}
}
}
GAINBLK_f.prototype.define = function GAINBLK_f() {
gain=1;
in1=1;
out=1;
model=scicos_model();
model.sim="gain";
model.in1=in1;
model.out=out;
model.rpar=gain;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[strcat(sci2exp(gain))];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
GAINBLK_f.prototype.details = function GAINBLK_f() {
}
}
/* autogenerated from "macros/Linear/SAMPHOLD.sci" */
function SAMPHOLD() {
SAMPHOLD.prototype.get = function SAMPHOLD() {
}
SAMPHOLD.prototype.set = function SAMPHOLD() {
x=arg1;
x.model.firing=[];
}
SAMPHOLD.prototype.define = function SAMPHOLD() {
in1=-1;
model=scicos_model();
model.sim=list("samphold4",4);
model.in1=-1;
model.out=-1;
model.evtin=1;
model.blocktype="d";
model.dep_ut=[true,None];
gr_i=[];
x=standard_define([2,2],model," ",gr_i);
}
SAMPHOLD.prototype.details = function SAMPHOLD() {
}
}
/* autogenerated from "macros/Linear/BIGSOM_f.sci" */
function BIGSOM_f() {
BIGSOM_f.prototype.get = function BIGSOM_f() {
}
BIGSOM_f.prototype.set = function BIGSOM_f() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
while (true) {
[ok,sgn,exprs]=scicos_getvalue("Set sum block parameters","Inputs ports signs/gain",list("vec",-1),exprs);
if (!ok) {
break
}
in1=-ones(size(sgn,"*"),1);
[model,graphics,ok]=check_io(model,graphics,in1,-1,[],[]);
if (ok) {
model.rpar=sgn.slice();
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
BIGSOM_f.prototype.define = function BIGSOM_f() {
sgn=[1,1];
model=scicos_model();
model.sim=list("sum",2);
model.in1=[-1,-1];
model.out=-1;
model.rpar=sgn;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=sci2exp(sgn);
gr_i=[];
x=standard_define([2,3],model,exprs,gr_i);
}
BIGSOM_f.prototype.details = function BIGSOM_f() {
}
}
/* autogenerated from "macros/Linear/SAMPLEHOLD_f.sci" */
function SAMPLEHOLD_f() {
SAMPLEHOLD_f.prototype.get = function SAMPLEHOLD_f() {
}
SAMPLEHOLD_f.prototype.set = function SAMPLEHOLD_f() {
x=arg1;
x.model.firing=[];
}
SAMPLEHOLD_f.prototype.define = function SAMPLEHOLD_f() {
in1=-1;
model=scicos_model();
model.sim="samphold";
model.in1=-1;
model.out=-1;
model.evtin=1;
model.blocktype="d";
model.dep_ut=[true,None];
gr_i=[];
x=standard_define([2,2],model," ",gr_i);
}
SAMPLEHOLD_f.prototype.details = function SAMPLEHOLD_f() {
}
}
/* autogenerated from "macros/Linear/DIFF_c.sci" */
function DIFF_c() {
DIFF_c.prototype.get = function DIFF_c() {
}
DIFF_c.prototype.set = function DIFF_c() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
ask_again=None;
[ok,x0,xd0,exprs]=scicos_getvalue("Set continuous linear system parameters",["Initial state","Initial Derivative"],list("vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
x0=x0.slice();
N=size(x0,"*");
xd0=xd0.slice();
Nxd=size(xd0,"*");
if ((N!=Nxd)) {
message("Incompatible sizes: states and their derivatives should have the same size ");
ask_again=true;
}
if ((N<=0&&!ask_again)) {
x_message("number of states must be > 0 ");
ask_again=true;
}
if (!ask_again) {
graphics.exprs=exprs;
model.state=[x0,xd0];
model.out=[N];
model.in1=N;
x.graphics=graphics;
x.model=model;
break
}
}
x.model.firing=[];
}
DIFF_c.prototype.define = function DIFF_c() {
x0=[0,0];
model=scicos_model();
model.sim=list("diffblk_c",10004);
model.in1=1;
model.out=1;
model.state=x0;
model.blocktype="c";
model.dep_ut=[None,true];
exprs=[strcat(sci2exp(x0(1))),strcat(sci2exp(x0(2)))];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
DIFF_c.prototype.details = function DIFF_c() {
}
}
/* autogenerated from "macros/Linear/DLSS_f.sci" */
function DLSS_f() {
DLSS_f.prototype.get = function DLSS_f() {
}
DLSS_f.prototype.set = function DLSS_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
if (size(exprs,"*")==7) {
exprs=exprs([1:4,7]);
}
model=arg1.model;
while (true) {
[ok,A,B,C,D,x0,exprs]=scicos_getvalue("Set discrete linear system parameters",["A matrix","B matrix","C matrix","D matrix","Initial state"],list("mat",[-1,-1],"mat",["size(%1,2)","-1"],"mat",["-1","size(%1,2)"],"mat",[-1,-1],"vec","size(%1,2)"),exprs);
if (!ok) {
break
}
out=size(C,1);
if (out==0) {
out=[];
}
in1=size(B,2);
if (in1==0) {
in1=[];
}
[ms,ns]=size(A);
if (ms!=ns) {
message("A matrix must be square");
} else {
[model,graphics,ok]=check_io(model,graphics,in1,out,1,[]);
if (ok) {
graphics.exprs=exprs;
rpar=[A.slice(),B.slice(),C.slice(),D.slice()];
if (D!=[]) {
if (norm(D,1)!=0) {
mmm=[true,None];
} else {
mmm=[None,None];
}
if (or(model.dep_ut!=mmm)) {
model.dep_ut=mmm;
}
} else {
model.dep_ut=[None,None];
}
model.dstate=x0.slice();
model.rpar=rpar;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
DLSS_f.prototype.define = function DLSS_f() {
x0=0;
A=-1;
B=1;
C=1;
D=0;
model=scicos_model();
model.sim=list("dsslti",1);
model.in1=1;
model.out=1;
model.evtin=1;
model.dstate=x0.slice();
model.rpar=[A.slice(),B.slice(),C.slice(),D.slice()];
model.blocktype="d";
model.dep_ut=[None,None];
exprs=[strcat(sci2exp(A)),strcat(sci2exp(B)),strcat(sci2exp(C)),strcat(sci2exp(D)),strcat(sci2exp(x0))];
gr_i=[];
x=standard_define([4,2],model,exprs,gr_i);
}
DLSS_f.prototype.details = function DLSS_f() {
}
}
/* autogenerated from "macros/Linear/INTEGRAL_f.sci" */
function INTEGRAL_f() {
INTEGRAL_f.prototype.get = function INTEGRAL_f() {
}
INTEGRAL_f.prototype.set = function INTEGRAL_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,x0,exprs]=scicos_getvalue("Set continuous linear system parameters","Initial state",list("vec",1),exprs);
if (!ok) {
break
}
graphics.exprs=exprs;
model.state=x0;
x.graphics=graphics;
x.model=model;
break
}
x.model.firing=[];
}
INTEGRAL_f.prototype.define = function INTEGRAL_f() {
x0=0;
model=scicos_model();
model.sim="integr";
model.in1=1;
model.out=1;
model.state=x0;
model.blocktype="c";
model.dep_ut=[None,true];
exprs=strcat(sci2exp(x0));
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
INTEGRAL_f.prototype.details = function INTEGRAL_f() {
}
}
/* autogenerated from "macros/Linear/DOLLAR_f.sci" */
function DOLLAR_f() {
DOLLAR_f.prototype.get = function DOLLAR_f() {
}
DOLLAR_f.prototype.set = function DOLLAR_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")<2) {
exprs[2-1]="0";
}
while (true) {
[ok,a,inh,exprs]=scicos_getvalue("Set 1/z block parameters",["initial condition","Inherit (no:0, yes:1)"],list("vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
out=size(a,"*");
if (out==0) {
out=[];
}
in1=out;
if (ok) {
[model,graphics,ok]=check_io(model,graphics,-1,-1,ones(1-inh,1),[]);
}
if (ok) {
graphics.exprs=exprs;
model.dstate=a;
model.in1=in1;
model.out=out;
x.graphics=graphics;
x.model=model;
break
}
}
}
DOLLAR_f.prototype.define = function DOLLAR_f() {
z=0;
inh=0;
in1=1;
exprs=string([z,inh]);
model=scicos_model();
model.sim="dollar";
model.in1=in1;
model.out=in1;
model.evtin=1-inh;
model.dstate=z;
model.blocktype="d";
model.dep_ut=[None,None];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
DOLLAR_f.prototype.details = function DOLLAR_f() {
}
}
/* autogenerated from "macros/Linear/CLINDUMMY_f.sci" */
function CLINDUMMY_f() {
CLINDUMMY_f.prototype.get = function CLINDUMMY_f() {
}
CLINDUMMY_f.prototype.set = function CLINDUMMY_f() {
x=arg1;
}
CLINDUMMY_f.prototype.define = function CLINDUMMY_f() {
x0=0;
model=scicos_model();
model.sim=list("cdummy",4);
model.state=x0;
model.blocktype="c";
model.firing=[];
model.dep_ut=[None,true];
gr_i=[];
x=standard_define([3,2],model,[],gr_i);
}
CLINDUMMY_f.prototype.details = function CLINDUMMY_f() {
}
}
/* autogenerated from "macros/Linear/DELAY_f.sci" */
function DELAY_f() {
DELAY_f.prototype.get = function DELAY_f() {
}
DELAY_f.prototype.set = function DELAY_f() {
ppath=list(0,0);
for(i=1;i<=length(arg1.model.rpar.objs);i+=1) {
o=arg1.model.rpar.objs(i);
if (typeof(o)=="Block"&&o.gui=="REGISTER_f") {
ppath[1-1]=i;
}
if (typeof(o)=="Block"&&o.gui=="EVTDLY_f") {
ppath[2-1]=i;
}
if (and(ppath!=list(0,0))) {
break
}
}
x=arg1;
newpar=list();
register=x.model.rpar.objs(ppath[1-1]);
evtdly=x.model.rpar.objs(ppath[2-1]);
register_exprs=register.graphics.exprs;
evtdly_exprs=evtdly.graphics.exprs;
exprs=[evtdly_exprs(1),register_exprs];
while (true) {
[ok,dt,z0,exprs]=scicos_getvalue(["This block implements as a discretized delay","it is consist of a shift register and a clock","value of the delay is given by;","the discretization time step multiplied by the","number-1 of state of the register"],["Discretization time step","Register initial state"],list("vec",1,"vec",-1),exprs);
if (!ok) {
break
}
mess=[];
if (prod(size(z0))<1) {
mess=[mess,"Register length must be at least 1"," "];
ok=None;
}
if (dt<=0) {
mess=[mess,"Discretization time step must be positive"," "];
ok=None;
}
if (!ok) {
message(mess);
} else {
evtdly.graphics.exprs[1-1]=exprs(1);
if (evtdly.model.rpar!=dt) {
evtdly.model.rpar=dt;
newpar[$+1-1]=ppath[2-1];
}
x.model.rpar.objs[ppath[2-1]-1]=evtdly;
register.graphics.exprs=exprs(2);
if (or(register.model.dstate!=z0.slice())) {
register.model.dstate=z0.slice();
newpar[$+1-1]=ppath[1-1];
}
x.model.rpar.objs[ppath[1-1]-1]=register;
break
}
}
needcompile=0;
y=needcompile;
typ=newpar;
}
DELAY_f.prototype.define = function DELAY_f() {
evtdly=EVTDLY_f("define");
evtdly.graphics.orig=[243,296];
evtdly.graphics.sz=[40,40];
evtdly.graphics.flip=true;
evtdly.graphics.exprs=["0.1","0"];
evtdly.graphics.pein=10;
evtdly.graphics.peout=7;
evtdly.model.rpar=0.1;
evtdly.model.firing=0;
register=REGISTER_f("define");
register.graphics.orig=[238,195];
register.graphics.sz=[50,50];
register.graphics.flip=true;
register.graphics.exprs="0;0;0;0;0;0;0;0;0;0";
register.graphics.pin=6;
register.graphics.pout=5;
register.graphics.pein=9;
input_port=IN_f("define");
input_port.graphics.orig=[92,210];
input_port.graphics.sz=[20,20];
input_port.graphics.flip=true;
input_port.graphics.exprs=["1","1"];
input_port.graphics.pout=6;
input_port.model.ipar=1;
output_port=OUT_f("define");
output_port.graphics.orig=[440,210];
output_port.graphics.sz=[20,20];
output_port.graphics.flip=true;
output_port.graphics.exprs=["1","1"];
output_port.graphics.pin=5;
output_port.model.ipar=1;
split=CLKSPLIT_f("define");
split.graphics.orig=[263,271.2];
split.graphics.pein=7;
split.graphics.peout=[9,10];
diagram=scicos_diagram();
diagram.objs[1-1]=input_port;
diagram.objs[2-1]=output_port;
diagram.objs[3-1]=register;
diagram.objs[4-1]=evtdly;
diagram.objs[5-1]=scicos_link(xx=[296.6,440],yy=[220,220],from=[3,1],to=[2,1]);
diagram.objs[6-1]=scicos_link(xx=[112,229.4],yy=[220,220],from=[1,1],to=[3,1]);
diagram.objs[7-1]=scicos_link(xx=[263,263],yy=[290.3,271.2],ct=[5,-1],from=[4,1],to=[8,1]);
diagram.objs[8-1]=split;
diagram.objs[9-1]=scicos_link(xx=[263,263],yy=[271.2,250.7],ct=[5,-1],from=[8,1],to=[3,1]);
diagram.objs[10-1]=scicos_link(xx=[263,308.6,308.6,263,263],yy=[271.2,271.2,367,367,341.7],ct=[5,-1],from=[8,2],to=[4,1]);
x=scicos_block();
x.gui="DELAY_f";
x.graphics.sz=[2,2];
x.graphics.gr_i=[];
x.graphics.pin=0;
x.graphics.pout=0;
x.model.sim="csuper";
x.model.in1=1;
x.model.out=1;
x.model.blocktype="h";
x.model.dep_ut=[None,None];
x.model.rpar=diagram;
x.graphics.in_implicit=["E"];
x.graphics.in_style="";
x.graphics.out_implicit=["E"];
x.graphics.out_style="";
}
DELAY_f.prototype.details = function DELAY_f() {
}
}
/* autogenerated from "macros/Linear/TCLSS_f.sci" */
function TCLSS_f() {
TCLSS_f.prototype.get = function TCLSS_f() {
}
TCLSS_f.prototype.set = function TCLSS_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")==7) {
exprs=exprs([1:4,7]);
}
while (true) {
[ok,A,B,C,D,x0,exprs]=scicos_getvalue("Set continuous linear system parameters",["A matrix","B matrix","C matrix","D matrix","Initial state"],list("mat",[-1,-1],"mat",["size(%1,2)","-1"],"mat",["-1","size(%1,2)"],"mat",[-1,-1],"vec","size(%1,2)"),exprs);
if (!ok) {
break
}
out=size(C,1);
if (out==0) {
out=[];
}
in1=size(B,2);
if (in1==0) {
in1=[];
}
[ms,ns]=size(A);
if (ms!=ns) {
message("A matrix must be square");
} else {
[model,graphics,ok]=check_io(model,graphics,[in1,ms],out,1,[]);
if (ok) {
graphics.exprs=exprs;
rpar=[A.slice(),B.slice(),C.slice(),D.slice()];
if (D!=[]) {
if (norm(D,1)!=0) {
mmm=[true,true];
} else {
mmm=[None,true];
}
if (or(model.dep_ut!=mmm)) {
model.dep_ut=mmm;
}
} else {
model.dep_ut=[None,true];
}
model.state=x0.slice();
model.rpar=rpar;
if (D!=[]) {
model.sim=list("tcslti",1);
} else {
model.sim=list("tcsltj",1);
}
x.graphics=graphics;
x.model=model;
break
}
}
}
}
TCLSS_f.prototype.define = function TCLSS_f() {
x0=0;
A=0;
B=1;
C=1;
D=0;
in1=1;
nx=size(x0,"*");
out=1;
model=scicos_model();
model.sim=list("tcslti",1);
model.in1=[in1,nx];
model.out=out;
model.evtin=1;
model.state=x0;
model.rpar=[A.slice(),B.slice(),C.slice(),D.slice()];
model.blocktype="c";
model.dep_ut=[None,true];
exprs=[strcat(sci2exp(A)),strcat(sci2exp(B)),strcat(sci2exp(C)),strcat(sci2exp(D)),strcat(sci2exp(x0))];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
TCLSS_f.prototype.details = function TCLSS_f() {
}
}
/* autogenerated from "macros/Linear/DERIV.sci" */
function DERIV() {
DERIV.prototype.get = function DERIV() {
}
DERIV.prototype.set = function DERIV() {
x=arg1;
}
DERIV.prototype.define = function DERIV() {
model=scicos_model();
model.sim=list("deriv",4);
model.in1=-1;
model.out=-1;
model.blocktype="x";
model.dep_ut=[true,None];
exprs=[];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
DERIV.prototype.details = function DERIV() {
}
}
/* autogenerated from "macros/Linear/VARIABLE_DELAY.sci" */
function VARIABLE_DELAY() {
VARIABLE_DELAY.prototype.get = function VARIABLE_DELAY() {
}
VARIABLE_DELAY.prototype.set = function VARIABLE_DELAY() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
nin=model.in1(1);
while (true) {
[ok,T,init,N,exprs]=scicos_getvalue("Set delay parameters",["Max delay","initial input","Buffer size"],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (N<2) {
message("Buffer must be larger than 2");
ok=None;
}
if (T<=0) {
message("Delay must be positive");
ok=None;
}
if (ok) {
[model,graphics,ok]=check_io(model,graphics,[-1,1],-1,[],[]);
}
if (ok) {
graphics.exprs=exprs;
model.rpar=[T,init];
model.ipar=N;
x.graphics=graphics;
x.model=model;
break
}
}
}
VARIABLE_DELAY.prototype.define = function VARIABLE_DELAY() {
nin=1;
T=1;
init=0;
N=1024;
model=scicos_model();
model.sim=list("variable_delay",4);
model.in1=[nin,1];
model.out=nin;
model.rpar=[T,init];
model.ipar=N;
model.blocktype="d";
model.dep_ut=[None,None];
exprs=[string(T),string(init),string(N)];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
VARIABLE_DELAY.prototype.details = function VARIABLE_DELAY() {
}
}
/* autogenerated from "macros/Linear/REGISTER.sci" */
function REGISTER() {
REGISTER.prototype.get = function REGISTER() {
}
REGISTER.prototype.set = function REGISTER() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,1)==1) {
exprs=[exprs,sci2exp(1)];
}
while (true) {
[ok,z0,it,exprs]=scicos_getvalue("Set delay parameters",["Register initial condition","Datatype (1=double 3=int32 ...)"],list("vec",-1,"vec",1),exprs);
if (!ok) {
break
}
if (prod(size(z0))<1) {
message("Register length must be at least 1");
ok=None;
}
if (it==1) {
model.sim=list("delay4",4);
z0=double(z0);
model.dstate=z0;
model.odstate=list();
} else {
if (it==3) {
model.sim=list("delay4_i32",4);
z0=int32(z0);
} else if (it==4) {
model.sim=list("delay4_i16",4);
z0=int16(z0);
} else if (it==5) {
model.sim=list("delay4_i8",4);
z0=int8(z0);
} else if (it==6) {
model.sim=list("delay4_ui32",4);
z0=uint32(z0);
} else if (it==7) {
model.sim=list("delay4_ui16",4);
z0=uint16(z0);
} else if (it==8) {
model.sim=list("delay4_ui8",4);
z0=uint8(z0);
} else {
message("Datatype is not supported");
ok=None;
}
model.odstate=list(z0);
model.dstate=[];
}
if (ok) {
in1=[1,1];
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(in1,it),1,[]);
}
if (ok) {
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
REGISTER.prototype.define = function REGISTER() {
z0=zeros(10,1);
model=scicos_model();
model.sim=list("delay4",4);
model.in1=1;
model.out=1;
model.evtin=1;
model.dstate=z0;
model.blocktype="d";
model.dep_ut=[None,None];
exprs=strcat(string(z0),";");
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
REGISTER.prototype.details = function REGISTER() {
}
}
/* autogenerated from "macros/Linear/INTEGRAL.sci" */
function INTEGRAL() {
INTEGRAL.prototype.get = function INTEGRAL() {
}
INTEGRAL.prototype.set = function INTEGRAL() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,x0,reinit,satur,maxp,lowp,exprs]=scicos_getvalue("Set Integral block parameters",["Initial Condition","With re-intialization (1:yes, 0:no)","With saturation (1:yes, 0:no)","Upper limit","Lower limit"],list("vec",-1,"vec",1,"vec",1,"vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
x0=x0.slice();
maxp=maxp.slice();
lowp=lowp.slice();
if (reinit!=0) {
reinit=1;
}
if (satur!=0) {
satur=1;
if (size(maxp,"*")==1) {
maxp=maxp*ones(x0);
}
if (size(lowp,"*")==1) {
lowp=lowp*ones(x0);
}
if ((size(x0,1)!=size(maxp,1)||size(x0,1)!=size(lowp,1))) {
message("x0 and Upper limit and Lower limit must have same size");
ok=None;
} else if (or(maxp<=lowp)) {
message("Upper limits must be > Lower limits");
ok=None;
} else if (or(x0>maxp)||or(x0<lowp)) {
message("Initial condition x0 should be inside the limits");
ok=None;
} else {
rpar=[maxp,lowp];
model.nzcross=size(x0,1);
model.nmode=size(x0,1);
}
} else {
rpar=[];
model.nzcross=0;
model.nmode=0;
}
if (ok) {
model.rpar=rpar;
model.state=x0;
[model,graphics,ok]=check_io(model,graphics,size(x0,1)*[1,ones(reinit,1)],size(x0,1),ones(reinit,1),[]);
}
if (ok) {
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
INTEGRAL.prototype.define = function INTEGRAL() {
maxp=1;
minp=-1;
rpar=[];
model=scicos_model();
model.state=0;
model.sim=list("integral_func",4);
model.in1=1;
model.out=1;
model.rpar=rpar;
model.blocktype="c";
model.dep_ut=[None,true];
exprs=string([0,0,0,maxp,minp]);
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
x.graphics.id="1/s";
}
INTEGRAL.prototype.details = function INTEGRAL() {
}
}
/* autogenerated from "macros/Linear/GAINBLK.sci" */
function GAINBLK() {
GAINBLK.prototype.get = function GAINBLK() {
}
GAINBLK.prototype.set = function GAINBLK() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")==1) {
exprs=[exprs,sci2exp(0)];
}
while (true) {
[ok,gain,over,exprs]=scicos_getvalue("Set gain block parameters",["Gain","Do On Overflow(0=Nothing 1=Saturate 2=Error)"],list("mat",[-1,-1],"vec",1),exprs);
if (!ok) {
break
}
if (gain==[]) {
message("Gain must have at least one element");
} else {
if (typeof(gain)=="constant") {
if (isreal(gain)) {
it=1;
ot=1;
model.sim=list("gainblk",4);
model.rpar=gain.slice();
model.opar=list();
} else {
message("type is not supported");
ok=None;
}
} else {
if ((over==0)) {
if ((typeof(gain)=="int32")) {
ot=3;
model.sim=list("gainblk_i32n",4);
} else if ((typeof(gain)=="int16")) {
ot=4;
model.sim=list("gainblk_i16n",4);
} else if ((typeof(gain)=="int8")) {
ot=5;
model.sim=list("gainblk_i8n",4);
} else if ((typeof(gain)=="uint32")) {
ot=6;
model.sim=list("gainblk_ui32n",4);
} else if ((typeof(gain)=="uint16")) {
ot=7;
model.sim=list("gainblk_ui16n",4);
} else if ((typeof(gain)=="uint8")) {
ot=8;
model.sim=list("gainblk_ui8n",4);
} else {
message("type is not supported.");
ok=None;
}
} else if ((over==1)) {
if ((typeof(gain)=="int32")) {
ot=3;
model.sim=list("gainblk_i32s",4);
} else if ((typeof(gain)=="int16")) {
ot=4;
model.sim=list("gainblk_i16s",4);
} else if ((typeof(gain)=="int8")) {
ot=5;
model.sim=list("gainblk_i8s",4);
} else if ((typeof(gain)=="uint32")) {
ot=6;
model.sim=list("gainblk_ui32s",4);
} else if ((typeof(gain)=="uint16")) {
ot=7;
model.sim=list("gainblk_ui16s",4);
} else if ((typeof(gain)=="uint8")) {
ot=8;
model.sim=list("gainblk_ui8s",4);
} else {
message("type is not supported.");
ok=None;
}
} else if ((over==2)) {
if ((typeof(gain)=="int32")) {
ot=3;
model.sim=list("gainblk_i32e",4);
} else if ((typeof(gain)=="int16")) {
ot=4;
model.sim=list("gainblk_i16e",4);
} else if ((typeof(gain)=="int8")) {
ot=5;
model.sim=list("gainblk_i8e",4);
} else if ((typeof(gain)=="uint32")) {
ot=6;
model.sim=list("gainblk_ui32e",4);
} else if ((typeof(gain)=="uint16")) {
ot=7;
model.sim=list("gainblk_ui16e",4);
} else if ((typeof(gain)=="uint8")) {
ot=8;
model.sim=list("gainblk_ui8e",4);
} else {
message("type is not an integer.");
ok=None;
}
} else {
message("Do on Overflow must be 0,1,2");
ok=None;
}
model.rpar=[];
model.opar=list(gain.slice());
}
if (ok) {
[out,in1]=size(gain);
if (out*in1!=1) {
[model,graphics,ok]=set_io(model,graphics,list([in1,-1],ot),list([out,-1],ot),[],[]);
} else {
[model,graphics,ok]=set_io(model,graphics,list([-1,-2],ot),list([-1,-2],ot),[],[]);
}
}
if (ok) {
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
GAINBLK.prototype.define = function GAINBLK() {
gain=1;
in1=-1;
out=-1;
in2=-2;
out2=-2;
model=scicos_model();
model.sim=list("gainblk",4);
model.in1=in1;
model.out=out;
model.in2=in2;
model.out2=out2;
model.rpar=gain;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[strcat(sci2exp(gain))];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
GAINBLK.prototype.details = function GAINBLK() {
}
}
/* autogenerated from "macros/Linear/SOM_f.sci" */
function SOM_f() {
SOM_f.prototype.get = function SOM_f() {
}
SOM_f.prototype.set = function SOM_f() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
if (size(exprs,"*")==2) {
exprs=exprs(2);
}
if (size(exprs,"*")!=3) {
exprs=string(model.rpar);
}
if (graphics.flip) {
labs=["down","left","up"];
} else {
labs=["down","right","up"];
}
str=["This sum block is obsolete","parameters cannot be modified. Please replace it with new sum block","and gain blocks in the linear palette"," ","Input ports are located at up, side and  down positions.","Current gains are:"];
str=[str,(part(labs.slice(),1,7)+exprs.slice())];
message(str);
}
SOM_f.prototype.define = function SOM_f() {
sgn=[1,1,1];
model=scicos_model();
model.sim=list("sum",2);
model.in1=[-1,-1,-1];
model.out=-1;
model.rpar=sgn;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[sci2exp(1),sci2exp(sgn)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
SOM_f.prototype.details = function SOM_f() {
}
}
/* autogenerated from "macros/Linear/DOLLAR_m.sci" */
function DOLLAR_m() {
DOLLAR_m.prototype.get = function DOLLAR_m() {
}
DOLLAR_m.prototype.set = function DOLLAR_m() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")<2) {
exprs[2-1]="0";
}
while (true) {
[ok,a,inh,exprs]=scicos_getvalue("Set 1/z block parameters",["initial condition","Inherit (no:0, yes:1)"],list("mat",[-1,-2],"vec",-1),exprs);
if (!ok) {
break
}
out=[size(a,1),size(a,2)];
if (out==0) {
out=[];
}
in1=out;
model.sim=list("dollar4_m",4);
model.odstate=list(a);
model.dstate=[];
if ((type(a)==1)) {
if (isreal(a)) {
it=1;
ot=1;
if ((size(a,1)==1||size(a,2)==1)) {
model.sim=list("dollar4",4);
model.dstate=a.slice();
model.odstate=list();
}
} else {
it=2;
ot=2;
}
} else if ((typeof(a)=="int32")) {
it=3;
ot=3;
} else if ((typeof(a)=="int16")) {
it=4;
ot=4;
} else if ((typeof(a)=="int8")) {
it=5;
ot=5;
} else if ((typeof(a)=="uint32")) {
it=6;
ot=6;
} else if ((typeof(a)=="uint16")) {
it=7;
ot=7;
} else if ((typeof(a)=="uint8")) {
it=8;
ot=8;
} else {
message("type is not recognized");
ok=None;
}
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),ones(1-inh,1),[]);
}
if (ok) {
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
DOLLAR_m.prototype.define = function DOLLAR_m() {
z=0;
inh=0;
in1=1;
exprs=string([z,inh]);
model=scicos_model();
model.sim=list("dollar4",4);
model.in1=in1;
model.out=in1;
model.evtin=1-inh;
model.dstate=z;
model.blocktype="d";
model.dep_ut=[None,None];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
DOLLAR_m.prototype.details = function DOLLAR_m() {
}
}
/* autogenerated from "macros/Linear/DELAYV_f.sci" */
function DELAYV_f() {
DELAYV_f.prototype.get = function DELAYV_f() {
}
DELAYV_f.prototype.set = function DELAYV_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
nin=model.in1(1);
z0=model.dstate;
zz0=z0.slice(1-1,$-1);
told=z0($);
while (true) {
[ok,nin,zz0,T,exprs]=scicos_getvalue("Set delay parameters",["Number of inputs","Register initial condition","Max delay"],list("vec",1,"vec",-1,"vec",1),exprs);
if (!ok) {
break
}
if (size(zz0,"*")<2) {
message("Register length must be at least 2");
ok=None;
}
if (T<=0) {
message("Delay must be positive");
ok=None;
}
if (ok) {
[model,graphics,ok]=check_io(model,graphics,[nin,1],nin,1,[1,1]);
}
if (ok) {
graphics.exprs=exprs;
model.dstate=[zz0.slice(),told];
model.rpar=T/(size(zz0,"*"));
x.graphics=graphics;
x.model=model;
break
}
}
}
DELAYV_f.prototype.define = function DELAYV_f() {
nin=1;
z0=zeros(11,1);
zz0=z0.slice(1-1,$-1);
T=1;
model=scicos_model();
model.sim=list("delayv",1);
model.in1=[nin,1];
model.out=nin;
model.evtin=1;
model.evtout=[1,1];
model.dstate=z0;
model.rpar=T/(size(zz0,"*"));
model.blocktype="d";
model.firing=[0,-1];
model.dep_ut=[true,None];
exprs=[string(nin),strcat(string(z0.slice(1-1,$-1)),";"),string(T)];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
DELAYV_f.prototype.details = function DELAYV_f() {
}
}
/* autogenerated from "macros/Linear/CLSS_f.sci" */
function CLSS_f() {
CLSS_f.prototype.get = function CLSS_f() {
}
CLSS_f.prototype.set = function CLSS_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
if (size(exprs,"*")==7) {
exprs=exprs([1:4,7]);
}
model=arg1.model;
while (true) {
[ok,A,B,C,D,x0,exprs]=scicos_getvalue("Set continuous linear system parameters",["A matrix","B matrix","C matrix","D matrix","Initial state"],list("mat",[-1,-1],"mat",["size(%1,2)","-1"],"mat",["-1","size(%1,2)"],"mat",[-1,-1],"vec","size(%1,2)"),exprs);
if (!ok) {
break
}
out=size(C,1);
if (out==0) {
out=[];
}
in1=size(B,2);
if (in1==0) {
in1=[];
}
[ms,ns]=size(A);
if (ms!=ns) {
message("A matrix must be square");
} else {
[model,graphics,ok]=check_io(model,graphics,in1,out,[],[]);
if (ok) {
graphics.exprs=exprs;
rpar=[A.slice(),B.slice(),C.slice(),D.slice()];
if (D!=[]) {
if (norm(D,1)!=0) {
mmm=[true,true];
} else {
mmm=[None,true];
}
if (or(model.dep_ut!=mmm)) {
model.dep_ut=mmm;
}
} else {
model.dep_ut=[None,true];
}
model.state=x0.slice();
model.rpar=rpar;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
CLSS_f.prototype.define = function CLSS_f() {
x0=0;
A=-1;
B=1;
C=1;
D=0;
in1=1;
out=1;
model=scicos_model();
model.sim=list("csslti",1);
model.in1=in1;
model.out=out;
model.state=x0;
model.rpar=[A.slice(),B.slice(),C.slice(),D.slice()];
model.blocktype="c";
model.dep_ut=[None,true];
exprs=[strcat(sci2exp(A)),strcat(sci2exp(B)),strcat(sci2exp(C)),strcat(sci2exp(D)),strcat(sci2exp(x0))];
gr_i=[];
x=standard_define([4,2],model,exprs,gr_i);
}
CLSS_f.prototype.details = function CLSS_f() {
}
}
/* autogenerated from "macros/Linear/CLSS.sci" */
function CLSS() {
CLSS.prototype.get = function CLSS() {
}
CLSS.prototype.set = function CLSS() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
if (size(exprs,"*")==7) {
exprs=exprs([1:4,7]);
}
model=arg1.model;
while (true) {
[ok,A,B,C,D,x0,exprs]=scicos_getvalue("Set continuous linear system parameters",["A matrix","B matrix","C matrix","D matrix","Initial state"],list("mat",[-1,-1],"mat",["size(%1,2)","-1"],"mat",["-1","size(%1,2)"],"mat",[-1,-1],"vec","size(%1,2)"),exprs);
if (!ok) {
break
}
out=size(C,1);
if (out==0) {
out=[];
}
in1=size(B,2);
if (in1==0) {
in1=[];
}
[ms,ns]=size(A);
okD=true;
if (size(D,"*")!=size(C,1)*size(B,2)) {
if (size(D,"*")==1) {
D=D*ones(C*B);
} else if (size(D,"*")==0) {
D=zeros(C*B);
} else {
okD=None;
}
}
if (ms!=ns||!okD) {
message(_("Matrix A is not square or D has wrong dimension"));
} else {
[model,graphics,ok]=check_io(model,graphics,in1,out,[],[]);
if (ok) {
graphics.exprs=exprs;
rpar=[A.slice(),B.slice(),C.slice(),D.slice()];
if (D!=[]) {
if (norm(D,1)!=0) {
mmm=[true,true];
} else {
mmm=[None,true];
}
if (or(model.dep_ut!=mmm)) {
model.dep_ut=mmm;
}
} else {
model.dep_ut=[None,true];
}
model.state=x0.slice();
model.rpar=rpar;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
CLSS.prototype.define = function CLSS() {
x0=0;
A=-1;
B=1;
C=1;
D=0;
in1=1;
out=1;
model=scicos_model();
model.sim=list("csslti4",4);
model.in1=in1;
model.out=out;
model.state=x0;
model.rpar=[A.slice(),B.slice(),C.slice(),D.slice()];
model.blocktype="c";
model.dep_ut=[None,true];
exprs=[strcat(sci2exp(A)),strcat(sci2exp(B)),strcat(sci2exp(C)),strcat(sci2exp(D)),strcat(sci2exp(x0))];
gr_i=[];
x=standard_define([4,2],model,exprs,gr_i);
}
CLSS.prototype.details = function CLSS() {
}
}
/* autogenerated from "macros/Linear/SAMPHOLD_m.sci" */
function SAMPHOLD_m() {
SAMPHOLD_m.prototype.get = function SAMPHOLD_m() {
}
SAMPHOLD_m.prototype.set = function SAMPHOLD_m() {
x=arg1;
x.model.firing=[];
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
while (true) {
[ok,it,exprs]=scicos_getvalue("Set parameters Block",["Datatype(1=real double 2=Complex 3=int32 ...)"],list("vec",1),label);
if (!ok) {
break
}
if (((it<1)||(it>8))) {
message("Datatype is not supported");
ok=None;
}
if (ok) {
in1=[model.in1,model.in2];
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(in1,it),1,[]);
if (ok) {
graphics.exprs=exprs;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
}
SAMPHOLD_m.prototype.define = function SAMPHOLD_m() {
model=scicos_model();
model.sim=list("samphold4_m",4);
model.in1=-1;
model.in2=-2;
model.intyp=1;
model.outtyp=1;
model.out=-1;
model.out2=-2;
model.evtin=1;
model.blocktype="d";
model.dep_ut=[true,None];
label=[sci2exp(1)];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
SAMPHOLD_m.prototype.details = function SAMPHOLD_m() {
}
}
/* autogenerated from "macros/Linear/TIME_DELAY.sci" */
function TIME_DELAY() {
TIME_DELAY.prototype.get = function TIME_DELAY() {
}
TIME_DELAY.prototype.set = function TIME_DELAY() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
nin=model.in1(1);
while (true) {
[ok,T,init,N,exprs]=scicos_getvalue("Set delay parameters",["Delay","initial input","Buffer size"],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (N<2) {
message("Buffer must be larger than 2");
ok=None;
}
if (T<=0) {
message("Delay must be positive");
ok=None;
}
if (ok) {
[model,graphics,ok]=check_io(model,graphics,[-1],-1,[],[]);
}
if (ok) {
graphics.exprs=exprs;
model.rpar=[T,init];
model.ipar=N;
model.dep_ut=[None,true];
x.graphics=graphics;
x.model=model;
break
}
}
}
TIME_DELAY.prototype.define = function TIME_DELAY() {
nin=1;
T=1;
init=0;
N=1024;
model=scicos_model();
model.sim=list("time_delay",4);
model.in1=[nin];
model.out=nin;
model.rpar=[T,init];
model.ipar=N;
model.blocktype="x";
model.dep_ut=[None,true];
exprs=[string(T),string(init),string(N)];
gr_i=[];
x=standard_define([3.5,2],model,exprs,gr_i);
}
TIME_DELAY.prototype.details = function TIME_DELAY() {
}
}
/* autogenerated from "macros/Linear/DLSS.sci" */
function DLSS() {
DLSS.prototype.get = function DLSS() {
}
DLSS.prototype.set = function DLSS() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
if (size(exprs,"*")==7) {
exprs=exprs([1:4,7]);
}
model=arg1.model;
while (true) {
[ok,A,B,C,D,x0,exprs]=scicos_getvalue("Set discrete linear system parameters",["A matrix","B matrix","C matrix","D matrix","Initial state"],list("mat",[-1,-1],"mat",["size(%1,2)","-1"],"mat",["-1","size(%1,2)"],"mat",[-1,-1],"vec","size(%1,2)"),exprs);
if (!ok) {
break
}
out=size(C,1);
if (out==0) {
out=[];
}
in1=size(B,2);
if (in1==0) {
in1=[];
}
[ms,ns]=size(A);
okD=true;
if (size(D,"*")!=size(C,1)*size(B,2)) {
if (size(D,"*")==1) {
D=D*ones(C*B);
} else if (size(D,"*")==0) {
D=zeros(C*B);
} else {
okD=None;
}
}
if (ms!=ns||!okD) {
message(_("Matrix A is not square or D has wrong dimension"));
} else {
[model,graphics,ok]=check_io(model,graphics,in1,out,1,[]);
if (ok) {
graphics.exprs=exprs;
rpar=[A.slice(),B.slice(),C.slice(),D.slice()];
if (D!=[]) {
if (norm(D,1)!=0) {
mmm=[true,None];
} else {
mmm=[None,None];
}
if (or(model.dep_ut!=mmm)) {
model.dep_ut=mmm;
}
} else {
model.dep_ut=[None,None];
}
model.dstate=x0.slice();
model.rpar=rpar;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
DLSS.prototype.define = function DLSS() {
x0=0;
A=-1;
B=1;
C=1;
D=0;
model=scicos_model();
model.sim=list("dsslti4",4);
model.in1=1;
model.out=1;
model.evtin=1;
model.dstate=x0.slice();
model.rpar=[A.slice(),B.slice(),C.slice(),D.slice()];
model.blocktype="d";
model.dep_ut=[None,None];
exprs=[strcat(sci2exp(A)),strcat(sci2exp(B)),strcat(sci2exp(C)),strcat(sci2exp(D)),strcat(sci2exp(x0))];
gr_i=[];
x=standard_define([4,2],model,exprs,gr_i);
}
DLSS.prototype.details = function DLSS() {
}
}
/* autogenerated from "macros/Linear/INTEGRAL_m.sci" */
function INTEGRAL_m() {
INTEGRAL_m.prototype.get = function INTEGRAL_m() {
}
INTEGRAL_m.prototype.set = function INTEGRAL_m() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,x0,reinit,satur,maxp,lowp,exprs]=scicos_getvalue("Set Integral block parameters",["Initial Condition","With re-intialization (1:yes, 0:no)","With saturation (1:yes, 0:no)","Upper limit","Lower limit"],list("mat",[-1,-1],"vec",1,"vec",1,"mat",[-1,-1],"mat",[-1,-1]),exprs);
if (!ok) {
break
}
if (isreal(x0)) {
Datatype=1;
} else {
Datatype=2;
}
if (reinit!=0) {
reinit=1;
}
if (satur!=0) {
satur=1;
if (Datatype==1) {
if (size(maxp,"*")==1) {
maxp=maxp*ones(x0);
}
if (size(lowp,"*")==1) {
lowp=lowp*ones(x0);
}
if ((size(x0)!=size(maxp)||size(x0)!=size(lowp))) {
message("x0 and Upper limit and Lower limit must have same size");
ok=None;
} else if (or(maxp<=lowp)) {
message("Upper limits must be > Lower limits");
ok=None;
} else if (or(x0>maxp)||or(x0<lowp)) {
message("Initial condition x0 should be inside the limits");
ok=None;
} else {
rpar=[real(maxp.slice()),real(lowp.slice())];
model.nzcross=size(x0,"*");
model.nmode=size(x0,"*");
}
} else if ((Datatype==2)) {
if (size(maxp,"*")==1) {
maxp=math.complex(maxp*ones(x0),(maxp*ones(x0)));
}
if (size(lowp,"*")==1) {
lowp=math.complex(lowp*ones(x0),(lowp*ones(x0)));
}
if ((size(x0)!=size(maxp)||size(x0)!=size(lowp))) {
message("x0 and Upper limit and Lower limit must have same size");
ok=None;
} else if (or(real(maxp)<=real(lowp))||or(imag(maxp)<=imag(lowp))) {
message("Upper limits must be > Lower limits");
ok=None;
} else if (or(real(x0)>real(maxp))||or(real(x0)<real(lowp))||or(imag(x0)>imag(maxp))||or(imag(x0)<imag(lowp))) {
message("Initial condition x0 should be inside the limits");
ok=None;
} else {
rpar=[real(maxp.slice()),real(lowp.slice()),imag(maxp.slice()),imag(lowp.slice())];
model.nzcross=2*size(x0,"*");
model.nmode=2*size(x0,"*");
}
}
} else {
rpar=[];
model.nzcross=0;
model.nmode=0;
}
if (ok) {
model.rpar=rpar;
if ((Datatype==1)) {
model.state=real(x0.slice());
model.sim=list("integral_func",4);
it=[1,ones(reinit,1)];
ot=1;
} else if ((Datatype==2)) {
model.state=[real(x0.slice()),imag(x0.slice())];
model.sim=list("integralz_func",4);
it=[2,2*ones(reinit,1)];
ot=2;
} else {
message("Datatype is not supported");
ok=None;
}
if (ok) {
in1=[size(x0,1)*[1,ones(reinit,1)],size(x0,2)*[1,ones(reinit,1)]];
out=size(x0);
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),ones(reinit,1),[]);
}
}
if (ok) {
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
INTEGRAL_m.prototype.define = function INTEGRAL_m() {
maxp=1;
minp=-1;
rpar=[];
model=scicos_model();
model.state=0;
model.sim=list("integral_func",4);
model.in1=1;
model.out=1;
model.in2=1;
model.out2=1;
model.rpar=rpar;
model.blocktype="c";
model.dep_ut=[None,true];
exprs=string([0,0,0,maxp,minp]);
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
INTEGRAL_m.prototype.details = function INTEGRAL_m() {
}
}
/* autogenerated from "macros/Linear/DOLLAR.sci" */
function DOLLAR() {
DOLLAR.prototype.get = function DOLLAR() {
}
DOLLAR.prototype.set = function DOLLAR() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")<2) {
exprs[2-1]="0";
}
while (true) {
[ok,a,inh,exprs]=scicos_getvalue("Set 1/z block parameters",["initial condition","Inherit (no:0, yes:1)"],list("mat",[-1,-2],"vec",-1),exprs);
if (!ok) {
break
}
out=[size(a,1),size(a,2)];
if (out==0) {
out=[];
}
in1=out;
model.sim=list("dollar4_m",4);
model.odstate=list(a);
model.dstate=[];
if (type((a)==1)) {
if (isreal(a)) {
it=1;
ot=1;
if ((size(a,1)==1||size(a,2)==1)) {
model.sim=list("dollar4",4);
model.dstate=a.slice();
model.odstate=list();
}
} else {
it=2;
ot=2;
}
} else if ((typeof(a)=="int32")) {
it=3;
ot=3;
} else if ((typeof(a)=="int16")) {
it=4;
ot=4;
} else if ((typeof(a)=="int8")) {
it=5;
ot=5;
} else if ((typeof(a)=="uint32")) {
it=6;
ot=6;
} else if ((typeof(a)=="uint16")) {
it=7;
ot=7;
} else if ((typeof(a)=="uint8")) {
it=8;
ot=8;
} else {
message("type is not recognized");
ok=None;
}
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),ones(1-inh,1),[]);
}
if (ok) {
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
DOLLAR.prototype.define = function DOLLAR() {
z=0;
inh=0;
in1=1;
exprs=string([z,inh]);
model=scicos_model();
model.sim=list("dollar4",4);
model.in1=in1;
model.out=in1;
model.evtin=1-inh;
model.dstate=z;
model.blocktype="d";
model.dep_ut=[None,None];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
DOLLAR.prototype.details = function DOLLAR() {
}
}
/* autogenerated from "macros/Linear/TCLSS.sci" */
function TCLSS() {
TCLSS.prototype.get = function TCLSS() {
}
TCLSS.prototype.set = function TCLSS() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")==7) {
exprs=exprs([1:4,7]);
}
while (true) {
[ok,A,B,C,D,x0,exprs]=scicos_getvalue("Set continuous linear system parameters",["A matrix","B matrix","C matrix","D matrix","Initial state"],list("mat",[-1,-1],"mat",["size(%1,2)","-1"],"mat",["-1","size(%1,2)"],"mat",[-1,-1],"vec","size(%1,2)"),exprs);
if (!ok) {
break
}
out=size(C,1);
if (out==0) {
out=[];
}
in1=size(B,2);
if (in1==0) {
in1=[];
}
[ms,ns]=size(A);
if (ms!=ns) {
message("A matrix must be square");
} else {
[model,graphics,ok]=check_io(model,graphics,[in1,ms],out,1,[]);
if (ok) {
graphics.exprs=exprs;
rpar=[A.slice(),B.slice(),C.slice(),D.slice()];
if (D!=[]) {
if (norm(D,1)!=0) {
mmm=[true,true];
} else {
mmm=[None,true];
}
if (or(model.dep_ut!=mmm)) {
model.dep_ut=mmm;
}
} else {
model.dep_ut=[None,true];
}
model.state=x0.slice();
model.rpar=rpar;
if (D!=[]) {
model.sim=list("tcslti4",4);
} else {
model.sim=list("tcsltj4",4);
}
x.graphics=graphics;
x.model=model;
break
}
}
}
}
TCLSS.prototype.define = function TCLSS() {
x0=0;
A=0;
B=1;
C=1;
D=0;
in1=1;
nx=size(x0,"*");
out=1;
model=scicos_model();
model.sim=list("tcslti4",4);
model.in1=[in1,nx];
model.out=out;
model.evtin=1;
model.state=x0;
model.rpar=[A.slice(),B.slice(),C.slice(),D.slice()];
model.blocktype="c";
model.dep_ut=[None,true];
exprs=[strcat(sci2exp(A)),strcat(sci2exp(B)),strcat(sci2exp(C)),strcat(sci2exp(D)),strcat(sci2exp(x0))];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
TCLSS.prototype.details = function TCLSS() {
}
}
/* autogenerated from "macros/Linear/SUM_f.sci" */
function SUM_f() {
SUM_f.prototype.get = function SUM_f() {
}
SUM_f.prototype.set = function SUM_f() {
x=arg1;
}
SUM_f.prototype.define = function SUM_f() {
model=scicos_model();
model.sim=list("plusblk",2);
model.in1=[-1,-1,-1];
model.out=-1;
model.blocktype="c";
model.dep_ut=[true,None];
gr_i=[];
exprs=[];
x=standard_define([1,1],model,exprs,gr_i);
}
SUM_f.prototype.details = function SUM_f() {
}
}
/* autogenerated from "macros/Linear/GAIN_f.sci" */
function GAIN_f() {
GAIN_f.prototype.get = function GAIN_f() {
}
GAIN_f.prototype.set = function GAIN_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,gain,exprs]=scicos_getvalue("Set gain block parameters",["Gain"],list("mat",[-1,-1]),exprs(1));
if (!ok) {
break
}
if (gain==[]) {
message("Gain must have at least one element");
} else {
[out,in1]=size(gain);
[model,graphics,ok]=check_io(model,graphics,in1,out,[],[]);
if (ok) {
graphics.exprs=exprs;
model.rpar=gain.slice();
x.graphics=graphics;
x.model=model;
break
}
}
}
}
GAIN_f.prototype.define = function GAIN_f() {
gain=1;
in1=1;
out=1;
model=scicos_model();
model.sim="gain";
model.in1=1;
model.out=1;
model.rpar=gain;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[strcat(sci2exp(gain)),strcat(sci2exp(in1)),strcat(sci2exp(out))];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
GAIN_f.prototype.details = function GAIN_f() {
}
}
/* autogenerated from "macros/Linear/PID.sci" */
function PID() {
PID.prototype.get = function PID() {
}
PID.prototype.set = function PID() {
ppath=list(0,0,0);
for(i=1;i<=length(arg1.model.rpar.objs);i+=1) {
o=arg1.model.rpar.objs(i);
if (typeof(o)=="Link") {
from=arg1.model.rpar.objs(o.from(1));
to=arg1.model.rpar.objs(o.to(1));
if (from.gui=="GAINBLK") {
switch (to.gui) {
case "SUMMATION":
ppath[1-1]=o.from(1);
case "INTEGRAL_m":
ppath[2-1]=o.from(1);
case "DERIV":
ppath[3-1]=o.from(1);
}
} else if (to.gui=="GAINBLK") {
switch (from.gui) {
case "SUMMATION":
ppath[1-1]=o.to(1);
case "INTEGRAL_m":
ppath[2-1]=o.to(1);
case "DERIV":
ppath[3-1]=o.to(1);
}
}
if (and(ppath!=list(0,0,0))) {
break
}
}
}
newpar=list();
xx1=arg1.model.rpar.objs(ppath[1-1]);
exprs[1-1]=xx1.graphics.exprs(1);
p_old=xx1.model.rpar;
xx2=arg1.model.rpar.objs(ppath[2-1]);
exprs[2-1]=xx2.graphics.exprs(1);
i_old=xx2.model.rpar;
xx3=arg1.model.rpar.objs(ppath[3-1]);
exprs[3-1]=xx3.graphics.exprs(1);
d_old=xx3.model.rpar;
y=0;
while (true) {
[ok,p,i,d,exprs0]=scicos_getvalue("Set PID parameters",["Proportional","Integral","Derivation"],list("vec",-1,"vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
if (ok) {
xx1.graphics.exprs=exprs0(1);
xx1.model.rpar=p;
xx2.graphics.exprs=exprs0(2);
xx2.model.rpar=i;
xx3.graphics.exprs=exprs0(3);
xx3.model.rpar=d;
arg1.model.rpar.objs[ppath[1-1]-1]=xx1;
arg1.model.rpar.objs[ppath[2-1]-1]=xx2;
arg1.model.rpar.objs[ppath[3-1]-1]=xx3;
break
}
}
needcompile=0;
if (!(p_old==p&&i_old==i&&d_old==d)) {
newpar[size(newpar)+1-1]=ppath[1-1];
newpar[size(newpar)+1-1]=ppath[2-1];
newpar[size(newpar)+1-1]=ppath[3-1];
needcompile=2;
}
x=arg1;
y=max(y,needcompile);
typ=newpar;
}
PID.prototype.define = function PID() {
scs_m=scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["PID"],tol=[0.0001,0.000001,1.000e-10,100001,0,0],tf=100000,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
scs_m.objs[1-1]=scicos_block(gui="INTEGRAL_m",graphics=scicos_graphics(orig=[318.304,183.11733],sz=[40,40],flip=true,theta=0,exprs=["0","0","0","1","-1"],pin=7,pout=9,pein=[],peout=[],gr_i=[],id="1/s",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("integral_func",4),in1=1,in2=1,intyp=1,out=1,out2=1,outtyp=1,evtin=[],evtout=[],state=0,dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[None,true],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[2-1]=scicos_block(gui="SUMMATION",graphics=scicos_graphics(orig=[387.97067,172.85067],sz=[40,60],flip=true,theta=0,exprs=["1","[1;1;1]"],pin=[10,9,11],pout=19,pein=[],peout=[],gr_i=[],id="",in_implicit=["E","E","E"],out_implicit="E"),model=scicos_model(sim=list("summation",4),in1=[-1,-1,-1],in2=[-2,-2,-2],intyp=[1,1,1],out=-1,out2=-2,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[1,1,1],opar=list(),blocktype="c",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[3-1]=scicos_block(gui="GAINBLK",graphics=scicos_graphics(orig=[321.23733,235.91733],sz=[40,40],flip=true,theta=0,exprs="1",pin=17,pout=10,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("gainblk",4),in1=-1,in2=-2,intyp=1,out=-1,out2=-2,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=1,ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[4-1]=scicos_block(gui="DERIV",graphics=scicos_graphics(orig=[319.03733,135.45067],sz=[40,40],flip=true,theta=0,exprs=[],pin=8,pout=11,pein=[],peout=[],gr_i=[],id="s",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("deriv",4),in1=-1,in2=-2,intyp=1,out=-1,out2=-2,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="x",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[5-1]=scicos_block(gui="GAINBLK",graphics=scicos_graphics(orig=[255.23733,183.11733],sz=[40,40],flip=true,theta=0,exprs="1",pin=13,pout=7,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("gainblk",4),in1=-1,in2=-2,intyp=1,out=-1,out2=-2,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=1,ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[6-1]=scicos_block(gui="GAINBLK",graphics=scicos_graphics(orig=[255.23733,135.45067],sz=[40,40],flip=true,theta=0,exprs="1",pin=14,pout=8,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("gainblk",4),in1=-1,in2=-2,intyp=1,out=-1,out2=-2,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=1,ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[7-1]=scicos_link(xx=[303.80876,309.73257],yy=[203.11733,203.11733],id="drawlink",thick=[0,0],ct=[1,1],from=[5,1,0],to=[1,1,1]);
scs_m.objs[8-1]=scicos_link(xx=[303.80876,310.4659],yy=[155.45067,155.45067],id="drawlink",thick=[0,0],ct=[1,1],from=[6,1,0],to=[4,1,1]);
scs_m.objs[9-1]=scicos_link(xx=[366.87543,379.39924],yy=[203.11733,202.85067],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[2,2,1]);
scs_m.objs[10-1]=scicos_link(xx=[369.80876,379.39924,379.39924],yy=[255.91733,255.91733,217.85067],id="drawlink",thick=[0,0],ct=[1,1],from=[3,1,0],to=[2,1,1]);
scs_m.objs[11-1]=scicos_link(xx=[367.60876,379.39924,379.39924],yy=[155.45067,155.45067,187.85067],id="drawlink",thick=[0,0],ct=[1,1],from=[4,1,0],to=[2,3,1]);
scs_m.objs[12-1]=scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[234.704,203.11733],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=16,pout=[13,14],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=["E","E","E"]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[-1,-1,-1],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[13-1]=scicos_link(xx=[234.704,246.6659],yy=[203.11733,203.11733],id="drawlink",thick=[0,0],ct=[1,1],from=[12,1,0],to=[5,1,1]);
scs_m.objs[14-1]=scicos_link(xx=[234.704,234.704,246.6659],yy=[203.11733,155.45067,155.45067],id="drawlink",thick=[0,0],ct=[1,1],from=[12,2,0],to=[6,1,1]);
scs_m.objs[15-1]=scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[233.97067,203.11733],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=21,pout=[16,17],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=["E","E","E"]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[-1,-1,-1],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[16-1]=scicos_link(xx=[233.97067,234.704],yy=[203.11733,203.11733],id="drawlink",thick=[0,0],ct=[1,1],from=[15,1,0],to=[12,1,1]);
scs_m.objs[17-1]=scicos_link(xx=[233.97067,233.97067,312.6659],yy=[203.11733,255.91733,255.91733],id="drawlink",thick=[0,0],ct=[1,1],from=[15,2,0],to=[3,1,1]);
scs_m.objs[18-1]=scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[456.5421,192.85067],sz=[20,20],flip=true,theta=0,exprs="1",pin=19,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[19-1]=scicos_link(xx=[436.5421,456.5421],yy=[202.85067,202.85067],id="drawlink",thick=[0,0],ct=[1,1],from=[2,1,0],to=[18,1,1]);
scs_m.objs[20-1]=scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[193.97067,193.11733],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=21,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[21-1]=scicos_link(xx=[213.97067,233.97067],yy=[203.11733,203.11733],id="drawlink",thick=[0,0],ct=[1,1],from=[20,1,0],to=[15,1,1]);
model=scicos_model();
model.sim="csuper";
model.in1=-1;
model.in2=-2;
model.out=-1;
model.out2=-2;
model.intyp=1;
model.outtyp=1;
model.blocktype="h";
model.firing=None;
model.dep_ut=[None,None];
model.rpar=scs_m;
gr_i=[];
x=standard_define([2,2],model,[],gr_i);
}
PID.prototype.details = function PID() {
}
}
/* autogenerated from "macros/Sinks/BARXY.sci" */
function BARXY() {
BARXY.prototype.get = function BARXY() {
}
BARXY.prototype.set = function BARXY() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,xmin,xmax,ymin,ymax,thickness,exprs]=scicos_getvalue("Set Scope parameters",["Xmin","Xmax","Ymin","Ymax","Segs Thickness"],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
mess=[];
if (ymin>=ymax) {
mess=[mess,"Ymax must be greater than Ymin"," "];
ok=None;
}
if (xmin>=xmax) {
mess=[mess,"Xmax must be greater than Xmin"," "];
ok=None;
}
if (thickness<=0) {
mess=[mess,"Thickness must be strictly positive."];
ok=None;
}
if (!ok) {
message(mess);
} else {
model.rpar=[xmin,xmax,ymin,ymax];
model.ipar=thickness;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
BARXY.prototype.define = function BARXY() {
model=scicos_model();
xmin=-15;
xmax=15;
ymin=-15;
ymax=15;
model.sim=list("BARXY_sim",5);
model.blocktype="d";
model.dep_ut=[true,None];
model.in1=[-1,-1];
model.intyp=[1];
model.out=[];
model.evtin=[1];
model.rpar=[xmin,xmax,ymin,ymax];
model.ipar=1;
x=standard_define([2,2],model,[],[]);
x.graphics.in_implicit=["E","E"];
x.graphics.out_implicit=[];
x.graphics.exprs=["-15","15","-15","15","1"];
}
BARXY.prototype.details = function BARXY() {
}
}
/* autogenerated from "macros/Sinks/CANIMXY.sci" */
function CANIMXY() {
CANIMXY.prototype.get = function CANIMXY() {
}
CANIMXY.prototype.set = function CANIMXY() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,nbr_curves,clrs,siz,win,wpos,wdim,xmin,xmax,ymin,ymax,N,exprs]=scicos_getvalue("Set Scope parameters",["Number of Curves","color (>0) or mark (<0)","line or mark size","Output window number (-1 for automatic)","Output window position","Output window sizes","Xmin","Xmax","Ymin","Ymax","Buffer size"],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",-1,"vec",-1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
mess=[];
if (size(wpos,"*")!=0&&size(wpos,"*")!=2) {
mess=[mess,"Window position must be [] or a 2 vector"," "];
ok=None;
}
if (size(wdim,"*")!=0&&size(wdim,"*")!=2) {
mess=[mess,"Window dim must be [] or a 2 vector"," "];
ok=None;
}
if (win<-1) {
mess=[mess,"Window number cannot be inferior than -1"," "];
ok=None;
}
if (nbr_curves<=0) {
mess=[mess,"Number of curves cannot be negative or null"," "];
ok=None;
}
if (N<1) {
mess=[mess,"Buffer size must be at least 1"," "];
ok=None;
}
if (N==1&&clrs>0) {
mess=[mess,"Buffer size must be at least 2"," "];
ok=None;
}
if (ymin>=ymax) {
mess=[mess,"Ymax must be greater than Ymin"," "];
ok=None;
}
if (xmin>=xmax) {
mess=[mess,"Xmax must be greater than Xmin"," "];
ok=None;
}
if (!ok) {
message(mess);
} else {
in1=nbr_curves*ones(2,1);
in2=ones(2,1);
[model,graphics,ok]=set_io(model,graphics,list([in1,in2],ones(2,1)),list(),ones(1,1),[]);
if (wpos==[]) {
wpos=[-1,-1];
}
if (wdim==[]) {
wdim=[-1,-1];
}
rpar=[xmin,xmax,ymin,ymax];
ipar=[win,1,N,clrs,siz,0,wpos.slice(),wdim.slice(),nbr_curves];
model.rpar=rpar;
model.ipar=ipar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CANIMXY.prototype.define = function CANIMXY() {
win=-1;
clrs=-4;
N=2;
siz=1;
wpos=[-1,-1];
wdim=[-1,-1];
xmin=-15;
xmax=15;
ymin=-15;
ymax=+15;
nbr_curves=1;
model=scicos_model();
model.sim=list("canimxy",4);
model.in1=[1,1];
model.in2=[1,1];
model.intyp=[1,1];
model.evtin=1;
model.rpar=[xmin,xmax,ymin,ymax];
model.ipar=[win,1,N,clrs,siz,0,wpos.slice(),wdim.slice(),nbr_curves];
model.blocktype="d";
model.firing=[];
model.dep_ut=[None,None];
exprs=[string(nbr_curves),string(clrs),string(siz),string(win),"[]","[]",string(xmin),string(xmax),string(ymin),string(ymax),string(N)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CANIMXY.prototype.details = function CANIMXY() {
}
}
/* autogenerated from "macros/Sinks/CSCOPE.sci" */
function CSCOPE() {
CSCOPE.prototype.get = function CSCOPE() {
}
CSCOPE.prototype.set = function CSCOPE() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,clrs,win,wpos,wdim,ymin,ymax,per,N,heritance,nom,exprs]=scicos_getvalue("Set Scope parameters",["Color (>0) or mark (<0) vector (8 entries)","Output window number (-1 for automatic)","Output window position","Output window sizes","Ymin","Ymax","Refresh period","Buffer size","Accept herited events 0/1","Name of Scope (label&Id)"],list("vec",8,"vec",1,"vec",-1,"vec",-1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"str",1),exprs);
if (!ok) {
break
}
mess=[];
if (size(wpos,"*")!=0&&size(wpos,"*")!=2) {
mess=[mess,"Window position must be [] or a 2 vector"," "];
ok=None;
}
if (size(wdim,"*")!=0&&size(wdim,"*")!=2) {
mess=[mess,"Window dim must be [] or a 2 vector"," "];
ok=None;
}
if (win<-1) {
mess=[mess,"Window number can\'t be  < -1"," "];
ok=None;
}
if (per<=0) {
mess=[mess,"Refresh period must be positive"," "];
ok=None;
}
if (N<2) {
mess=[mess,"Buffer size must be at least 2"," "];
ok=None;
}
if (ymin>=ymax) {
mess=[mess,"Ymax must be greater than Ymin"," "];
ok=None;
}
if (!or(heritance==[0,1])) {
mess=[mess,"Accept herited events must be 0 or 1"," "];
ok=None;
}
if (!ok) {
message(["Some specified values are inconsistent:"," ",mess]);
}
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list([-1,1],1),list(),ones(1-heritance,1),[]);
}
if (ok) {
if (wpos==[]) {
wpos=[-1,-1];
}
if (wdim==[]) {
wdim=[-1,-1];
}
rpar=[0,ymin,ymax,per];
ipar=[win,1,N,clrs.slice(),wpos.slice(),wdim.slice()];
model.rpar=rpar;
model.ipar=ipar;
model.evtin=ones(1-heritance,1);
model.label=nom;
graphics.id=nom;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CSCOPE.prototype.define = function CSCOPE() {
win=-1;
wdim=[600,400];
wpos=[-1,-1];
clrs=[1,3,5,7,9,11,13,15];
N=20;
ymin=-15;
ymax=+15;
per=30;
model=scicos_model();
model.sim=list("cscope",4);
model.in1=-1;
model.in2=1;
model.evtin=1;
model.rpar=[0,ymin,ymax,per];
model.ipar=[win,1,N,clrs,wpos,wdim];
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[strcat(string(clrs)," "),string(win),sci2exp([]),sci2exp(wdim),string(ymin),string(ymax),string(per),string(N),transpose(string(0)),emptystr()];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CSCOPE.prototype.details = function CSCOPE() {
}
}
/* autogenerated from "macros/Sinks/CANIMXY3D.sci" */
function CANIMXY3D() {
CANIMXY3D.prototype.get = function CANIMXY3D() {
}
CANIMXY3D.prototype.set = function CANIMXY3D() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,nbr_curves,clrs,siz,win,wpos,wdim,vec_x,vec_y,vec_z,param3ds,N,exprs]=scicos_getvalue("Set Scope parameters",["Number of curves","color (>0) or mark (<0)","line or mark size","Output window number (-1 for automatic)","Output window position","Output window sizes","Xmin and Xmax","Ymin and Ymax","Zmin and Zmax","Alpha and Theta","Buffer size"],list("vec",1,"vec",-1,"vec",-1,"vec",1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",1),exprs);
if (!ok) {
break
}
mess=[];
if (size(wpos,"*")!=0&&size(wpos,"*")!=2) {
mess=[mess,"Window position must be [] or a 2 vector"," "];
ok=None;
}
if (size(wdim,"*")!=0&&size(wdim,"*")!=2) {
mess=[mess,"Window dim must be [] or a 2 vector"," "];
ok=None;
}
if (win<-1) {
mess=[mess,"Window number cannot be inferior than -1"," "];
ok=None;
}
if (size(clrs,"*")!=size(siz,"*")) {
mess=[mess,"Colors and Size must have same size"," "];
ok=None;
}
if (nbr_curves<=0) {
mess=[mess,"Number of curves cannot be negative or null"," "];
ok=None;
}
if (size(clrs,"*")<nbr_curves) {
mess=[mess,"You must have at least same size for clrs and the number of curves"," "];
ok=None;
}
if (N<1) {
mess=[mess,"Buffer size must be at least 1"," "];
ok=None;
}
if (N<2) {
for(i=1;i<=nbr_curves;i+=1) {
if (clrs(i)>0) {
mess=[mess,"Buffer size must be at least 2 or Change a color (must be <0)"," "];
ok=None;
}
}
}
if (vec_y(1)>=vec_y(2)) {
mess=[mess,"Ymax must be higher than Ymin"," "];
ok=None;
}
if (vec_x(1)>=vec_x(2)) {
mess=[mess,"Xmax must be higher than Xmin"," "];
ok=None;
}
if (vec_z(1)>=vec_z(2)) {
mess=[mess,"Zmax must be higher than Zmin"," "];
ok=None;
}
if (!ok) {
message(mess);
} else {
in1=nbr_curves*ones(3,1);
in2=ones(3,1);
[model,graphics,ok]=set_io(model,graphics,list([in1,in2],ones(3,1)),list(),ones(1,1),[]);
if (wpos==[]) {
wpos=[-1,-1];
}
if (wdim==[]) {
wdim=[-1,-1];
}
rpar=[vec_x.slice(),vec_y.slice(),vec_z.slice(),param3ds.slice()];
size_siz=size(siz,"*");
ipar=[win,size_siz,N,clrs.slice(),siz.slice(),1,wpos.slice(),wdim.slice(),nbr_curves];
model.rpar=rpar;
model.ipar=ipar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CANIMXY3D.prototype.define = function CANIMXY3D() {
win=-1;
N=2;
clrs=[1,2,3,4,5,6,7,13];
siz=[1,1,1,1,1,1,1,1];
wpos=[-1,-1];
wdim=[-1,-1];
param3ds=[50,280];
vec_x=[-15,15];
vec_y=[-15,15];
vec_z=[-15,15];
nbr_curves=1;
model=scicos_model();
model.sim=list("canimxy3d",4);
model.in1=[1,1,1];
model.evtin=1;
model.in2=[1,1,1];
model.intyp=[1,1,1];
model.rpar=[vec_x.slice(),vec_y.slice(),vec_z.slice(),param3ds.slice()];
model.ipar=[win,8,N,clrs.slice(),siz.slice(),8,wpos.slice(),wdim.slice(),nbr_curves];
model.blocktype="d";
model.firing=[];
model.dep_ut=[None,None];
exprs=[string(nbr_curves),strcat(string(clrs)," "),strcat(string(siz)," "),string(win),"[]","[]",strcat(string(vec_x)," "),strcat(string(vec_y)," "),strcat(string(vec_z)," "),strcat(string(param3ds)," "),string(N)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CANIMXY3D.prototype.details = function CANIMXY3D() {
}
}
/* autogenerated from "macros/Sinks/CMAT3D.sci" */
function CMAT3D() {
CMAT3D.prototype.get = function CMAT3D() {
}
CMAT3D.prototype.set = function CMAT3D() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,vec_x,vec_y,colormap,cmin,cmax,exprs]=scicos_getvalue("Set Scope parameters",["Bounds Vector X (-1 for standard)","Bounds Vector Y (-1 for standard)","ColorMap","Zmin","Zmax"],list("vec",-1,"vec",-1,"vec",-1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
mess=[];
if (size(vec_x,"*")!=size(vec_y,"*")) {
mess=[mess,"Vector X and Vector Y must have the same size"," "];
ok=None;
}
if (cmax<=cmin) {
mess=[mess,"Error with minimum and maximum value"," "];
ok=None;
}
if (!ok) {
message(["Some specified values are inconsistent:"," ",mess]);
}
if (ok) {
size_x=size(vec_x,"*");
size_c=size(colormap.slice(),1);
ipar=[cmin,cmax,size_c,size_x];
rpar=[colormap.slice(),vec_x.slice(),vec_y.slice()];
model.ipar=ipar;
model.rpar=rpar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CMAT3D.prototype.define = function CMAT3D() {
cmin=0;
cmax=100;
colormap=jetcolormap(25);
size_c=25;
x=-1;
y=-1;
size_x=1;
size_y=1;
model=scicos_model();
model.sim=list("cmat3d",4);
model.in1=-1;
model.in2=-2;
model.intyp=1;
model.evtin=1;
model.ipar=[cmin,cmax,size_c,size_x,size_y];
model.rpar=[colormap.slice(),x,y];
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[strcat(string(x)," "),strcat(string(y)," "),string("jetcolormap(25)"),string(cmin),string(cmax)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CMAT3D.prototype.details = function CMAT3D() {
}
}
/* autogenerated from "macros/Sinks/CSCOPXY3D.sci" */
function CSCOPXY3D() {
CSCOPXY3D.prototype.get = function CSCOPXY3D() {
}
CSCOPXY3D.prototype.set = function CSCOPXY3D() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,nbr_curves,clrs,siz,win,wpos,wdim,vec_x,vec_y,vec_z,param3ds,N,exprs]=scicos_getvalue("Set Scope parameters",["Number of curves","color (>0) or mark (<0)","Line or Mark Size","Output window number (-1 for automatic)","Output window position","Output window sizes","Xmin and Xmax","Ymin and Ymax","Zmin and Zmax","Alpha and Theta","Buffer size"],list("vec",1,"vec",-1,"vec",-1,"vec",1,"vec",-1,"vec",-1,"vec",2,"vec",2,"vec",2,"vec",2,"vec",1),exprs);
if (!ok) {
break
}
mess=[];
if (size(wpos,"*")!=0&&size(wpos,"*")!=2) {
mess=[mess,"Window position must be [] or a 2 vector"," "];
ok=None;
}
if (size(wdim,"*")!=0&&size(wdim,"*")!=2) {
mess=[mess,"Window dim must be [] or a 2 vector"," "];
ok=None;
}
if (size(clrs,"*")!=size(siz,"*")) {
mess=[mess,"Colors and Size must have same size"," "];
ok=None;
}
if (nbr_curves<=0) {
mess=[mess,"Number of curves cannot be negative or null"," "];
ok=None;
}
if (win<-1) {
mess=[mess,"Window number cannot be inferior than -1"," "];
ok=None;
}
if (N<1) {
mess=[mess,"Buffer size must be at least 1"," "];
ok=None;
}
if (N<2) {
for(i=1;i<=size(clrs,"*");i+=1) {
if (clrs(i)>0) {
mess=[mess,"Buffer size must be at least 2 or Change a color (must be >0)"," "];
ok=None;
}
}
}
if (vec_y(1)>=vec_y(2)) {
mess=[mess,"Ymax must be higher than Ymin"," "];
ok=None;
}
if (vec_x(1)>=vec_x(2)) {
mess=[mess,"Xmax must be higher than Xmin"," "];
ok=None;
}
if (vec_z(1)>=vec_z(2)) {
mess=[mess,"Zmax must be higher than Zmin"," "];
ok=None;
}
if (ok) {
in1=nbr_curves*ones(3,1);
in2=ones(3,1);
[model,graphics,ok]=set_io(model,graphics,list([in1,in2],ones(3,1)),list(),ones(1,1),[]);
if (wpos==[]) {
wpos=[-1,-1];
}
if (wdim==[]) {
wdim=[-1,-1];
}
rpar=[vec_x.slice(),vec_y.slice(),vec_z.slice(),param3ds.slice()];
size_siz=size(siz,"*");
ipar=[win,size_siz,N,clrs.slice(),siz.slice(),1,wpos.slice(),wdim.slice(),nbr_curves];
model.rpar=rpar;
model.ipar=ipar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
} else {
message(mess);
}
}
}
CSCOPXY3D.prototype.define = function CSCOPXY3D() {
win=-1;
clrs=[1,2,3,4,5,6,7,13];
siz=[1,1,1,1,1,1,1,1];
wdim=[600,400];
wpos=[-1,-1];
N=2;
param3ds=[50,280];
vec_x=[-15,15];
vec_y=[-15,15];
vec_z=[-15,15];
nbr_curves=1;
model=scicos_model();
model.sim=list("cscopxy3d",4);
model.in1=[1,1,1];
model.in2=[1,1,1];
model.intyp=[1,1,1];
model.evtin=1;
model.rpar=[vec_x.slice(),vec_y.slice(),vec_z.slice(),param3ds.slice()];
model.ipar=[win,8,N,clrs.slice(),siz.slice(),8,wpos.slice(),wdim.slice(),nbr_curves];
model.blocktype="d";
model.dep_ut=[None,None];
exprs=[string(nbr_curves),strcat(string(clrs)," "),strcat(string(siz)," "),string(win),sci2exp([]),sci2exp(wdim),strcat(string(vec_x)," "),strcat(string(vec_y)," "),strcat(string(vec_z)," "),strcat(string(param3ds)," "),string(N)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CSCOPXY3D.prototype.details = function CSCOPXY3D() {
}
}
/* autogenerated from "macros/Sinks/CSCOPXY.sci" */
function CSCOPXY() {
CSCOPXY.prototype.get = function CSCOPXY() {
}
CSCOPXY.prototype.set = function CSCOPXY() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,nbr_curves,clrs,siz,win,wpos,wdim,xmin,xmax,ymin,ymax,N,exprs]=scicos_getvalue("Set Scope parameters",["Number of Curves","color (>0) or mark (<0)","line or mark size","Output window number (-1 for automatic)","Output window position","Output window sizes","Xmin","Xmax","Ymin","Ymax","Buffer size"],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",-1,"vec",-1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
mess=[];
if (size(wpos,"*")!=0&&size(wpos,"*")!=2) {
mess=[mess,"Window position must be [] or a 2 vector"," "];
ok=None;
}
if (size(wdim,"*")!=0&&size(wdim,"*")!=2) {
mess=[mess,"Window dim must be [] or a 2 vector"," "];
ok=None;
}
if (nbr_curves<=0) {
mess=[mess,"Number of Curves cannot be negative or null"," "];
ok=None;
}
if (win<-1) {
mess=[mess,"Window number cannot be inferior than -1"," "];
ok=None;
}
if (N<1) {
mess=[mess,"Buffer size must be at least 1"," "];
ok=None;
}
if (N==1&&clrs>0) {
mess=[mess,"Buffer size must be at least 2"," "];
ok=None;
}
if (ymin>=ymax) {
mess=[mess,"Ymax must be greater than Ymin"," "];
ok=None;
}
if (xmin>=xmax) {
mess=[mess,"Xmax must be greater than Xmin"," "];
ok=None;
}
if (!ok) {
message(mess);
} else {
in1=nbr_curves*ones(2,1);
in2=ones(2,1);
[model,graphics,ok]=set_io(model,graphics,list([in1,in2],ones(2,1)),list(),ones(1,1),[]);
if (wpos==[]) {
wpos=[-1,-1];
}
if (wdim==[]) {
wdim=[-1,-1];
}
rpar=[xmin,xmax,ymin,ymax];
ipar=[win,1,N,clrs,siz,1,wpos.slice(),wdim.slice(),nbr_curves];
model.rpar=rpar;
model.ipar=ipar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CSCOPXY.prototype.define = function CSCOPXY() {
win=-1;
clrs=4;
siz=1;
wdim=[600,400];
wpos=[-1,-1];
N=2;
xmin=-15;
xmax=15;
ymin=-15;
ymax=+15;
nbr_curves=1;
model=scicos_model();
model.sim=list("cscopxy",4);
model.in1=[1,1];
model.in2=[1,1];
model.intyp=[1,1];
model.evtin=1;
model.rpar=[xmin,xmax,ymin,ymax];
model.ipar=[win,1,N,clrs,siz,1,wpos.slice(),wdim.slice(),nbr_curves];
model.blocktype="d";
model.dep_ut=[None,None];
exprs=[string(nbr_curves),sci2exp(clrs),sci2exp(siz),string(win),sci2exp([]),sci2exp(wdim),string(xmin),string(xmax),string(ymin),string(ymax),string(N)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CSCOPXY.prototype.details = function CSCOPXY() {
}
}
/* autogenerated from "macros/Sinks/OUTIMPL_f.sci" */
function OUTIMPL_f() {
OUTIMPL_f.prototype.get = function OUTIMPL_f() {
}
OUTIMPL_f.prototype.set = function OUTIMPL_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")==2) {
exprs=exprs(1);
}
while (true) {
[ok,prt,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"OUTIMPL_f")," ",gettext("Implicit output port")],gettext("Port number"),list("vec",1),exprs);
if (!ok) {
break
}
prt=int(prt);
if (prt<=0) {
block_parameter_error(msprintf(gettext("Wrong value for \'Port Number\' parameter: %d."),prt),gettext("Strictly positive integer expected."));
} else {
if (model.ipar!=prt) {
needcompile=4;
y=needcompile;
}
model.ipar=prt;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
OUTIMPL_f.prototype.define = function OUTIMPL_f() {
model=scicos_model();
model.in1=[-1];
model.in2=[1];
prt=1;
model.sim="outimpl";
model.ipar=[1];
model.blocktype="c";
model.dep_ut=[None,None];
mo=modelica();
mo.model="PORT";
mo.inputs="n";
model.equations=mo;
exprs="1";
gr_i=[];
x=standard_define([1,1],model,exprs,gr_i);
x.graphics.in_implicit=["I"];
}
OUTIMPL_f.prototype.details = function OUTIMPL_f() {
}
}
/* autogenerated from "macros/Sinks/CFSCOPE.sci" */
function CFSCOPE() {
CFSCOPE.prototype.get = function CFSCOPE() {
}
CFSCOPE.prototype.set = function CFSCOPE() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,clrs,win,wpos,wdim,ymin,ymax,per,N,wu,exprs]=scicos_getvalue("Set Scope parameters",["Color (>0) or mark (<0) vector (8 entries)","Output window number (-1 for automatic)","Output window position","Output window sizes","Ymin","Ymax","Refresh period","Buffer size","Links to view"],list("vec",8,"vec",1,"vec",-1,"vec",-1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",-1),exprs);
if (!ok) {
break
}
mess=[];
if (size(wpos,"*")!=0&&size(wpos,"*")!=2) {
mess=[mess,"Window position must be [] or a 2 vector"," "];
ok=None;
}
if (size(wdim,"*")!=0&&size(wdim,"*")!=2) {
mess=[mess,"Window dim must be [] or a 2 vector"," "];
ok=None;
}
if (win<-1) {
mess=[mess,"Window number cannot be inferior than -1"," "];
ok=None;
}
if (per<=0) {
mess=[mess,"Refresh period must be positive"," "];
ok=None;
}
if (N<2) {
mess=[mess,"Buffer size must be at least 2"," "];
ok=None;
}
if (ymin>=ymax) {
mess=[mess,"Ymax must be greater than Ymin"," "];
ok=None;
}
if (wu<0) {
mess=[mess,"Link to view must be positive"," "];
ok=None;
}
if (!ok) {
message(["Some specified values are inconsistent:"," ",mess]);
}
if (ok) {
if (wpos==[]) {
wpos=[-1,-1];
}
if (wdim==[]) {
wdim=[-1,-1];
}
rpar=[0,ymin,ymax,per];
if (size(clrs,"*")>8) {
clrs=clrs.slice(1-1,8);
}
if (size(clrs,"*")<8) {
clrs[8-1]=0;
}
ipar=[win,1,N,clrs.slice(),wpos.slice(),wdim.slice(),size(wu,"*"),wu.slice()];
model.rpar=rpar;
model.ipar=ipar;
model.firing=[];
model.dep_ut=[true,None];
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CFSCOPE.prototype.define = function CFSCOPE() {
win=-1;
wdim=[600,400];
wpos=[-1,-1];
clrs=[1,3,5,7,9,11,13,15];
N=2;
ymin=-15;
ymax=+15;
per=30;
model=scicos_model();
model.sim=list("cfscope",4);
model.evtin=1;
model.rpar=[0,ymin,ymax,per];
model.ipar=[win,1,N,clrs,wpos,wdim,1,1];
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[strcat(string(clrs)," "),string(win),sci2exp([]),sci2exp(wdim),string(ymin),string(ymax),string(per),string(N),string([1])];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CFSCOPE.prototype.details = function CFSCOPE() {
}
}
/* autogenerated from "macros/Sinks/WRITEAU_f.sci" */
function WRITEAU_f() {
WRITEAU_f.prototype.get = function WRITEAU_f() {
}
WRITEAU_f.prototype.set = function WRITEAU_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
ipar=model.ipar;
dstate=model.dstate;
lunit=dstate(2);
while (true) {
[ok,N,swap,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"WRITEAU_f")," ",gettext("Write \'.au\' sound file on audio device")],[gettext("Buffer Size"),gettext("Swap Mode (0:No, 1:Yes)")],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
nin=1;
fname1="/dev/audio";
frmt1="uc ";
if (alreadyran&&(N!=ipar(5))) {
block_parameter_error(msprintf(gettext("You cannot modify \'%s\' when running."),gettext("Buffer Size")),gettext("End current simulation first"));
ok=None;
} else if (N<1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Buffer Size"),N),gettext("Strictly positive integer expected."));
ok=None;
}
if (swap!=0&&swap!=1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Swap Mode"),swap),msprintf(gettext("Must be in the interval %s."),"[0, 1]"));
ok=None;
}
if (ok) {
ipar=[length(fname1),_str2code(frmt1),N,swap,_str2code(fname1)];
if (prod(size(dstate))!=(nin+1)*N+2) {
dstate=[-1,lunit,zeros((nin+1)*N,1)];
}
model.in1=1;
model.dstate=dstate;
model.ipar=ipar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
WRITEAU_f.prototype.define = function WRITEAU_f() {
in1=1;
nin=sum(in1);
frmt="uc ";
fname="/dev/audio";
swap=0;
lunit=0;
N=2;
model=scicos_model();
model.sim=list("writeau",2);
model.in1=in1;
model.evtin=1;
model.dstate=[-1,lunit,zeros((nin+1)*N,1)];
model.ipar=[length(fname),_str2code(frmt),N,swap,_str2code(fname)];
model.blocktype="d";
model.dep_ut=[true,None];
exprs=[string(N),string(swap)];
gr_i=[];
x=standard_define([4,2],model,exprs,gr_i);
}
WRITEAU_f.prototype.details = function WRITEAU_f() {
}
}
/* autogenerated from "macros/Sinks/WRITEC_f.sci" */
function WRITEC_f() {
WRITEC_f.prototype.get = function WRITEC_f() {
}
WRITEC_f.prototype.set = function WRITEC_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
ipar=model.ipar;
dstate=model.dstate;
lunit=dstate(2);
fname=exprs(2);
frmt=exprs(3);
while (true) {
[ok,in1,fname1,frmt1,N,swap,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"WRITEC_f")," ",gettext("Write to C binary file")],[gettext("Input Size"),gettext("Output File Name"),gettext("Output Format"),gettext("Buffer Size"),gettext("Swap Mode (0:No, 1:Yes)")],list("vec",1,"str",1,"str",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
in1=int(in1);
nin=in1;
fname1=pathconvert(stripblanks(fname1),None,true);
frmt1=stripblanks(frmt1);
fmts=["s","l","d","f","c","us","ul","uc","ull","uls","ubl","ubs","dl","fl","ll","sl","db","fb","lb","sb"];
if (and(frmt1!=fmts)) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %s."),gettext("Input Format"),frmt1),gettext("Valid formats are: "+strcat(fmts,", ")));
ok=None;
} else if (alreadyran&&fname1!=fname) {
block_parameter_error(msprintf(gettext("You cannot modify \'%s\' when running"),gettext("Input Format")),gettext("End current simulation first."));
ok=None;
} else if (alreadyran&&N!=ipar(5)) {
block_parameter_error(msprintf(gettext("You cannot modify \'Buffer Size\' when running."),gettext("Buffer Size")),gettext("End current simulation first"));
ok=None;
} else if (fname1=="") {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter."),gettext("Output File Name")),gettext("You must provide a filename."));
} else if (fileparts(fname1)!="") {
[pa,fn,ex]=fileparts(fname1);
if (!isdir(pa)) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter."),gettext("Output File Name")),msprintf(gettext("Directory \'%s\' does not exist"),pa));
ok=None;
}
} else if (N<1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Buffer Size"),N),gettext("Strictly positive integer expected."));
ok=None;
} else if (in1<=0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Input Size"),in1),gettext("Strictly positive integer expected."));
ok=None;
} else if (swap!=0&&swap!=1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Swap Mode"),swap),msprintf(gettext("Must be in the interval %s."),"[0, 1]"));
ok=None;
}
frmt1=part(frmt1,1,3);
if (ok) {
ipar=[length(fname1),_str2code(frmt1),N,swap,_str2code(fname1)];
if (prod(size(dstate))!=(nin+1)*N+2) {
dstate=[-1,lunit,zeros((nin+1)*N,1)];
}
model.in1=nin;
model.dstate=dstate;
model.ipar=ipar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
WRITEC_f.prototype.define = function WRITEC_f() {
in1=1;
nin=sum(in1);
frmt="c  ";
fname="foo";
swap=0;
lunit=0;
N=2;
model=scicos_model();
model.sim=list("writec",2);
model.in1=in1;
model.evtin=1;
model.dstate=[-1,lunit,zeros((nin+1)*N,1)];
model.ipar=[length(fname),_str2code(frmt),N,swap,_str2code(fname)];
model.blocktype="d";
model.dep_ut=[true,None];
exprs=[sci2exp(in1),fname,frmt,string(N),string(swap)];
gr_i=[];
x=standard_define([4,2],model,exprs,gr_i);
}
WRITEC_f.prototype.details = function WRITEC_f() {
}
}
/* autogenerated from "macros/Sinks/CMSCOPE.sci" */
function CMSCOPE() {
CMSCOPE.prototype.get = function CMSCOPE() {
}
CMSCOPE.prototype.set = function CMSCOPE() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,in1,clrs,win,wpos,wdim,ymin,ymax,per,N,heritance,nom,exprs]=scicos_getvalue("Set Scope parameters",["Input ports sizes","Drawing colors (>0) or mark (<0)","Output window number (-1 for automatic)","Output window position","Output window sizes","Ymin vector","Ymax vector","Refresh period","Buffer size","Accept herited events 0/1","Name of Scope (label&Id)"],list("vec",-1,"vec",-1,"vec",1,"vec",-1,"vec",-1,"vec","size(%1,\'*\')","vec","size(%1,\'*\')","vec","size(%1,\'*\')","vec",1,"vec",1,"str",1),exprs);
if (!ok) {
break
}
mess=[];
if (size(in1,"*")<=0) {
mess=[mess,"Block must have at least one input port"," "];
ok=None;
}
if (min(in1)<=0) {
mess=[mess,"Port sizes must be positive"," "];
ok=None;
}
if (size(clrs,"*")<sum(in1)) {
mess=[mess,"Not enough colors defined (at least "+string(sum(in1))+")"," "];
ok=None;
}
if (size(wpos,"*")!=0&&size(wpos,"*")!=2) {
mess=[mess,"Window position must be [] or a 2 vector"," "];
ok=None;
}
if (size(wdim,"*")!=0&&size(wdim,"*")!=2) {
mess=[mess,"Window dim must be [] or a 2 vector"," "];
ok=None;
}
if (win<-1) {
mess=[mess,"Window number can\'t be  < -1"," "];
ok=None;
}
if (size(per,"*")!=size(ymin,"*")) {
mess=[mess,"Size of Refresh Period must equal size of Ymin/Ymax vector"," "];
ok=None;
}
for(i=1;i<=size(per,"*");i+=1) {
if ((per(i)<=0)) {
mess=[mess,"Refresh Period must be positive"," "];
ok=None;
}
}
if (N<2) {
mess=[mess,"Buffer size must be at least 2"," "];
ok=None;
}
if (or(ymin>=ymax)) {
mess=[mess,"Ymax must be greater than Ymin"," "];
ok=None;
}
if (!or(heritance==[0,1])) {
mess=[mess,"Accept herited events must be 0 or 1"," "];
ok=None;
}
if (!ok) {
message(["Some specified values are inconsistent:"," ",mess]);
}
if (ok) {
in1=in1.slice();
a=size(in1,1);
in2=ones(a,1);
[model,graphics,ok]=set_io(model,graphics,list([in1,in2],ones(a,1)),list(),ones(1-heritance,1),[]);
}
if (ok) {
if (wpos==[]) {
wpos=[-1,-1];
}
if (wdim==[]) {
wdim=[-1,-1];
}
if (ok) {
period=transpose(per.slice());
yy=[transpose(ymin.slice()),transpose(ymax.slice())];
rpar=[0,period.slice(),yy.slice()];
clrs=clrs.slice(1-1,sum(in1));
ipar=[win,size(in1,"*"),N,wpos.slice(),wdim.slice(),in1.slice(),clrs.slice(),heritance];
model.evtin=ones(1-heritance,1);
model.dstate=[];
model.rpar=rpar;
model.ipar=ipar;
model.label=nom;
graphics.id=nom;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
CMSCOPE.prototype.define = function CMSCOPE() {
win=-1;
in1=[1,1];
wdim=[-1,-1];
wpos=[-1,-1];
clrs=[1,3,5,7,9,11,13,15];
N=20;
ymin=[-1,-5];
ymax=[1,5];
per=[30,30];
yy=[transpose(ymin.slice()),transpose(ymax.slice())];
period=transpose(per.slice());
model=scicos_model();
model.sim=list("cmscope",4);
model.in1=in1;
model.in2=[1,1];
model.intyp=[1,1];
model.evtin=1;
model.rpar=[0,period.slice(),yy.slice()];
model.ipar=[win,size(in1,"*"),N,wpos.slice(),wdim.slice(),in1.slice(),clrs.slice(1-1,sum(in1))];
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[strcat(string(in1)," "),strcat(string(clrs)," "),string(win),sci2exp([]),sci2exp([]),strcat(string(ymin)," "),strcat(string(ymax)," "),strcat(string(per)," "),string(N),string(0),emptystr()];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CMSCOPE.prototype.details = function CMSCOPE() {
}
}
/* autogenerated from "macros/Sinks/CMATVIEW.sci" */
function CMATVIEW() {
CMATVIEW.prototype.get = function CMATVIEW() {
}
CMATVIEW.prototype.set = function CMATVIEW() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,colormap,cmin,cmax,exprs]=scicos_getvalue("Set Scope parameters",["ColorMap","Minimum level range","Maximum level range"],list("vec",-1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
mess=[];
if (cmax<=cmin) {
mess=[mess,"Error with minimum and maximum value"," "];
ok=None;
}
if (!ok) {
message(["Some specified values are inconsistent:"," ",mess]);
}
if (ok) {
size_c=size(colormap.slice(),1);
sol=inv([cmin,1,cmax,1])*[1,size_c/3];
alpha_c=sol(1);
beta_c=sol(2);
ipar=[cmin,cmax,size_c];
rpar=[alpha_c,beta_c,colormap.slice()];
model.ipar=ipar;
model.rpar=rpar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CMATVIEW.prototype.define = function CMATVIEW() {
cmin=0;
cmax=100;
size_c=25;
colormap=jetcolormap(size_c);
alpha_c=0.24;
beta_c=1;
model=scicos_model();
model.sim=list("cmatview",4);
model.in1=-1;
model.in2=-2;
model.intyp=1;
model.evtin=1;
model.ipar=[cmin,cmax,size_c];
model.rpar=[alpha_c,beta_c,colormap.slice()];
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string("jetcolormap(25)"),string(cmin),string(cmax)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CMATVIEW.prototype.details = function CMATVIEW() {
}
}
/* autogenerated from "macros/Sinks/CEVENTSCOPE.sci" */
function CEVENTSCOPE() {
CEVENTSCOPE.prototype.get = function CEVENTSCOPE() {
}
CEVENTSCOPE.prototype.set = function CEVENTSCOPE() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,nclock,clrs,win,wpos,wdim,per,exprs]=scicos_getvalue("Set Scope parameters",["Number of event inputs","colors c (>0) or mark (<0)","Output window number (-1 for automatic)","Output window position","Output window sizes","Refresh period"],list("vec",1,"vec",-1,"vec",1,"vec",-1,"vec",-1,"vec",1),exprs);
nclock=int(nclock);
clrs=int(clrs);
win=int(win);
if (!ok) {
break
}
mess=[];
if (size(wpos,"*")!=0&&size(wpos,"*")!=2) {
mess=[mess,"Window position must be [] or a 2 vector"," "];
ok=None;
}
if (size(wdim,"*")!=0&&size(wdim,"*")!=2) {
mess=[mess,"Window dim must be [] or a 2 vector"," "];
ok=None;
}
if (nclock<=0) {
mess=[mess,"Block must have at least one input event"," "];
ok=None;
}
if (size(clrs,"*")!=nclock) {
mess=[mess,"Inputs color c size must be equal to Number of inputs"," "];
ok=None;
}
if (win<-1) {
mess=[mess,"Window number cannot be inferior than -1"," "];
ok=None;
}
if (per<=0) {
mess=[mess,"Refresh period must be positive"," "];
ok=None;
}
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list(),list(),ones(nclock,1),[]);
} else {
message(["Some specified values are inconsistent:"," ",mess]);
}
if (ok) {
if (wpos==[]) {
wpos=[-1,-1];
}
if (wdim==[]) {
wdim=[-1,-1];
}
rpar=per;
ipar=[win,1,clrs.slice(),wpos.slice(),wdim.slice()];
model.rpar=rpar;
model.ipar=ipar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CEVENTSCOPE.prototype.define = function CEVENTSCOPE() {
nclock=1;
win=-1;
clrs=[1,3,5,7,9,11,13,15];
wdim=[600,400];
wpos=[-1,-1];
per=30;
model=scicos_model();
model.sim=list("cevscpe",4);
model.evtin=1;
model.rpar=per;
model.ipar=[win,1,clrs(nclock),wpos.slice(),wdim.slice()];
model.blocktype="d";
model.dep_ut=[None,None];
exprs=[sci2exp(nclock),strcat(sci2exp(clrs(nclock))," "),string(win),sci2exp([]),sci2exp(wdim),string(per)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CEVENTSCOPE.prototype.details = function CEVENTSCOPE() {
}
}
/* autogenerated from "macros/Sinks/TRASH_f.sci" */
function TRASH_f() {
TRASH_f.prototype.get = function TRASH_f() {
}
TRASH_f.prototype.set = function TRASH_f() {
x=arg1;
}
TRASH_f.prototype.define = function TRASH_f() {
in1=-1;
model=scicos_model();
model.sim="trash";
model.in1=in1;
model.evtin=1;
model.blocktype="d";
model.dep_ut=[None,None];
exprs=" ";
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
TRASH_f.prototype.details = function TRASH_f() {
}
}
/* autogenerated from "macros/Sinks/AFFICH_m.sci" */
function AFFICH_m() {
AFFICH_m.prototype.get = function AFFICH_m() {
}
AFFICH_m.prototype.set = function AFFICH_m() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,in1,font,fontsize,colr,nt,nd,herit,exprs]=scicos_getvalue("Set  parameters",["Input Size","Font number","Font size","Color","Total number of digits","Number of rational part digits","Block inherits (1) or not (0)"],list("mat",[1,2],"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
mess=[];
if (font<=0) {
mess=[mess,"Font number must be positive"," "];
ok=None;
}
if (fontsize<=0) {
mess=[mess,"Font size must be positive"," "];
ok=None;
}
if (nt<=3) {
mess=[mess,"Total number of digits must be greater than 3"," "];
ok=None;
}
if (nd<0) {
mess=[mess,"Number of rational part digits must be ","greater or equal 0"," "];
ok=None;
}
if (!ok) {
message(["Some specified values are inconsistent:"," ",mess]);
}
if (!or(herit==[0,1])) {
mess=[mess,"Accept inherited values are 0 and 1"," "];
ok=None;
}
if (!ok) {
message(["Some specified values are inconsistent:"," ",mess]);
}
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list(in1,1),list(),ones(1-herit,1),[]);
}
if (ok) {
model.ipar=[font,fontsize,colr,nt,nd,in1(1,1)];
model.dstate=[-1,0,0,1,1,0,zeros(in1(1,1)*in1(1,2),1)];
model.evtin=ones(1-herit,1);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
AFFICH_m.prototype.define = function AFFICH_m() {
font=1;
fontsize=1;
colr=1;
nt=5;
nd=1;
in1=[1,1];
model=scicos_model();
model.sim=list("affich2",4);
model.in1=in1(1,1);
model.in2=in1(1,2);
model.evtin=1;
model.dstate=[-1,0,0,1,1,0,zeros(in1(1,1)*in1(1,2),1)];
model.ipar=[font,fontsize,colr,1000,nt,nd,in1(1,1)];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
model.label="";
exprs=[sci2exp([model.in1,model.in2]),string(font),string(fontsize),string(colr),string(nt),string(nd),string(0)];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
AFFICH_m.prototype.details = function AFFICH_m() {
}
}
/* autogenerated from "macros/Sinks/TOWS_c.sci" */
function TOWS_c() {
TOWS_c.prototype.get = function TOWS_c() {
}
TOWS_c.prototype.set = function TOWS_c() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
while (true) {
[ok,nz,varnam,herit,exprs]=scicos_getvalue("Set Xcos buffer block",["Size of buffer","Scilab variable name","Inherit (no:0, yes:1)"],list("vec",1,"str",1,"vec",1),exprs);
if (!ok) {
break
}
if ((nz<=0)) {
message("Size of buffer must be positive");
ok=None;
}
r=None;
ierr=execstr("r = validvar(varnam)","errcatch");
if (!r||ierr!=0||length(varnam)>19) {
message(["Invalid variable name.","Please choose another variable name."]);
ok=None;
}
execstr("if type("+varnam+") <> 17 | or(fieldnames("+varnam+") <> [\"values\"; \"time\"]) then"+" message([\"Protected variable name.\"; \"Please choose another variable name.\"]);"+" ok = %f;"+" end","errcatch");
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list([-1,-2],-1),list(),ones(1-herit,1),[]);
if (herit==1) {
model.blocktype="x";
} else {
model.blocktype="d";
}
model.ipar=[nz,length(varnam),transpose(ascii(varnam))];
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
TOWS_c.prototype.define = function TOWS_c() {
nu=-1;
nz=128;
varnam="A";
herit=0;
model=scicos_model();
model.sim=list("tows_c",4);
model.in1=[nu];
model.in2=-2;
model.intyp=-1;
model.out=[];
model.evtin=[1];
model.evtout=[];
model.rpar=[];
model.ipar=[nz,length(varnam),transpose(ascii(varnam))];
model.blocktype="d";
model.firing=[];
model.dep_ut=[None,None];
gr_i=[];
exprs=[string(nz),string(varnam),string(herit)];
x=standard_define([4,2],model,exprs,gr_i);
}
TOWS_c.prototype.details = function TOWS_c() {
}
}
/* autogenerated from "macros/Sinks/CLKOUT_f.sci" */
function CLKOUT_f() {
CLKOUT_f.prototype.get = function CLKOUT_f() {
}
CLKOUT_f.prototype.set = function CLKOUT_f() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
exprs=exprs(1);
while (true) {
[ok,prt,exprs]=scicos_getvalue("Set Event Output block parameters","Port number",list("vec",1),exprs);
if (!ok) {
break
}
prt=int(prt);
if (prt<=0) {
message("Port number must be a positive integer");
} else {
model.ipar=prt;
model.evtin=1;
model.firing=[];
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CLKOUT_f.prototype.define = function CLKOUT_f() {
prt=1;
model=scicos_model();
model.sim="output";
model.evtin=1;
model.ipar=prt;
model.blocktype="d";
model.firing=[];
model.dep_ut=[None,None];
exprs=string(prt);
x=standard_define([1,1],model,exprs," ");
}
CLKOUT_f.prototype.details = function CLKOUT_f() {
}
}
/* autogenerated from "macros/Sinks/OUT_f.sci" */
function OUT_f() {
OUT_f.prototype.get = function OUT_f() {
}
OUT_f.prototype.set = function OUT_f() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
if (size(exprs,"*")==2) {
exprs=exprs(1);
}
while (true) {
[ok,prt,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"OUT_f")," ",gettext("Regular output port")],gettext("Port number"),list("vec",1),exprs);
if (!ok) {
break
}
prt=int(prt);
if (prt<=0) {
block_parameter_error(msprintf(gettext("Wrong value for \'Port Number\' parameter: %d."),prt),gettext("Strictly positive integer expected."));
} else {
model.ipar=prt;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
OUT_f.prototype.define = function OUT_f() {
n=-1;
prt=1;
model=scicos_model();
model.sim="output";
model.in1=-1;
model.in2=-2;
model.intyp=-1;
model.ipar=prt;
model.blocktype="c";
model.dep_ut=[None,None];
exprs=string(prt);
gr_i=[];
x=standard_define([1,1],model,exprs,gr_i);
}
OUT_f.prototype.details = function OUT_f() {
}
}
/* autogenerated from "macros/Branching/SWITCH_f.sci" */
function SWITCH_f() {
SWITCH_f.prototype.get = function SWITCH_f() {
}
SWITCH_f.prototype.set = function SWITCH_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
ipar=model.ipar;
while (true) {
[ok,nin,z0,exprs]=scicos_getvalue("Set switch parameters",["number of inputs","connected input"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (z0>nin||z0<=0) {
message("initial connected input is not a valid input port number");
} else {
[model,graphics,ok]=check_io(model,graphics,-ones(nin,1),-1,[],[]);
if (ok) {
graphics.exprs=exprs;
model.ipar=z0-1;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
SWITCH_f.prototype.define = function SWITCH_f() {
i0=0;
in1=[-1,-1];
nin=2;
model=scicos_model();
model.sim=list("switchn",2);
model.in1=in1;
model.out=-1;
model.ipar=i0;
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,true];
exprs=[string(nin),string(i0+1)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
SWITCH_f.prototype.details = function SWITCH_f() {
}
}
/* autogenerated from "macros/Branching/FROM.sci" */
function FROM() {
FROM.prototype.get = function FROM() {
}
FROM.prototype.set = function FROM() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,tag,exprs]=scicos_getvalue("Set parameters",["Tag"],list("str",-1),exprs);
if (!ok) {
break
}
if (ok) {
if (model.opar!=list(tag)) {
needcompile=4;
y=needcompile;
}
graphics.exprs=exprs;
model.opar=list(tag);
x.model=model;
x.graphics=graphics;
break
}
}
needcompile=resume(needcompile)
}
FROM.prototype.define = function FROM() {
model=scicos_model();
model.sim="from";
model.in1=[];
model.in2=[];
model.intyp=1;
model.out=-1;
model.out2=-2;
model.outtyp=-1;
model.ipar=[];
model.opar=list("A");
model.blocktype="c";
model.dep_ut=[None,None];
exprs=["A"];
gr_i=[];
x=standard_define([2,1],model,exprs,gr_i);
x.graphics.id="From";
}
FROM.prototype.details = function FROM() {
}
}
/* autogenerated from "macros/Branching/ISELECT_m.sci" */
function ISELECT_m() {
ISELECT_m.prototype.get = function ISELECT_m() {
}
ISELECT_m.prototype.set = function ISELECT_m() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,typ,nout,z0,exprs]=scicos_getvalue("Set parameters",["Datatype(1= real double  2=Complex 3=int32 ...)","number of outputs","initial connected output"],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (z0>nout||z0<=0) {
message("initial connected input is not a valid input port number");
} else if (((typ<1)||(typ>8))) {
message("Datatype is not supported");
ok=None;
} else {
it=typ;
ot=typ*ones(1,nout);
if (ok) {
out=[-ones(nout,1),-2*ones(nout,1)];
in1=[-1,-2];
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),ones(nout,1),[]);
if (ok) {
graphics.exprs=exprs;
model.dstate=z0;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
}
ISELECT_m.prototype.define = function ISELECT_m() {
z0=1;
nout=2;
model=scicos_model();
model.sim=list("selector_m",4);
model.out=[-1,-1];
model.out2=[-2,-2];
model.outtyp=1;
model.in1=-1;
model.in2=-2;
model.intyp=1;
model.evtout=[];
model.state=[];
model.rpar=[];
model.ipar=[];
model.firing=[];
model.evtin=ones(nout,1);
model.dstate=z0;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[sci2exp(1),sci2exp(nout),sci2exp(z0)];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
ISELECT_m.prototype.details = function ISELECT_m() {
}
}
/* autogenerated from "macros/Branching/SELECT_f.sci" */
function SELECT_f() {
SELECT_f.prototype.get = function SELECT_f() {
}
SELECT_f.prototype.set = function SELECT_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,nin,z0,exprs]=scicos_getvalue("Set parameters",["number of inputs","initial connected input"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (z0>nin||z0<=0) {
message("initial connected input is not a valid input port number");
} else {
[model,graphics,ok]=check_io(model,graphics,-ones(nin,1),-1,ones(nin,1),[]);
if (ok) {
graphics.exprs=exprs;
model.dstate=z0-1;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
SELECT_f.prototype.define = function SELECT_f() {
z0=0;
in1=[-1,-1];
nin=2;
model=scicos_model();
model.sim=list("selector",2);
model.in1=in1;
model.out=-1;
model.evtin=ones(in1);
model.dstate=z0;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string(nin),string(z0+1)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
SELECT_f.prototype.details = function SELECT_f() {
}
}
/* autogenerated from "macros/Branching/GOTOMO.sci" */
function GOTOMO() {
GOTOMO.prototype.get = function GOTOMO() {
}
GOTOMO.prototype.set = function GOTOMO() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,tag,tagvis,exprs]=scicos_getvalue("Set parameters",["Tag","Tag Visibility(1=Local 2=scoped 3= global)"],list("str",-1,"vec",1),exprs);
if (!ok) {
break
}
tagvis=int(tagvis);
if (((tagvis<1)||(tagvis>3))) {
message("Tag Visibility must be between 1 and 3");
ok=None;
}
if (ok) {
if (((model.ipar!=tagvis)||(model.opar!=list(tag)))) {
needcompile=4;
y=needcompile;
}
graphics.exprs=exprs;
model.opar=list(tag);
model.ipar=tagvis;
x.model=model;
x.graphics=graphics;
arg1=x;
break
}
}
needcompile=resume(needcompile)
}
GOTOMO.prototype.define = function GOTOMO() {
model=scicos_model();
model.sim="gotomo";
model.in1=-1;
model.in2=-2;
model.intyp=[];
model.out=[];
model.out2=[];
model.outtyp=1;
model.ipar=int(1);
model.opar=list("A");
model.blocktype="c";
model.dep_ut=[None,None];
mo=modelica();
mo.model="gotomo";
mo.inputs="p";
exprs=["A",sci2exp(1)];
gr_i=[];
x=standard_define([2,1],model,exprs,gr_i);
x.graphics.in_implicit=["I"];
}
GOTOMO.prototype.details = function GOTOMO() {
}
}
/* autogenerated from "macros/Branching/SWITCH2_m.sci" */
function SWITCH2_m() {
SWITCH2_m.prototype.get = function SWITCH2_m() {
}
SWITCH2_m.prototype.set = function SWITCH2_m() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,ot,rule,thra,nzz,exprs]=scicos_getvalue("Set parameters",["Datatype (1=real double  2=complex 3=int32 ...)","pass first input if: u2>=a (0), u2>a (1), u2~=a (2)","threshold a","use zero crossing: yes (1), no (0)"],list("vec",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
rule=int(rule);
if ((rule<0)) {
rule=0;
}
if ((rule>2)) {
rule=2;
}
graphics.exprs=exprs;
model.ipar=rule;
model.rpar=thra;
if (nzz!=0) {
model.nmode=1;
model.nzcross=1;
} else {
model.nmode=0;
model.nzcross=0;
}
if (((ot<1)||(ot>8))&&(ot!=-1)) {
message("Datatype is not supported");
ok=None;
}
if (ok) {
it[1-1]=ot;
it[2-1]=1;
it[3-1]=ot;
in1=[model.in1,model.in2];
out=[model.out,model.out2];
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
if (ok) {
x.graphics=graphics;
x.model=model;
break
}
}
}
SWITCH2_m.prototype.define = function SWITCH2_m() {
ipar=[0];
nzz=1;
rpar=0;
model=scicos_model();
model.sim=list("switch2_m",4);
model.in1=[-1,1,-1];
model.in2=[-2,1,-2];
model.intyp=1;
model.out=-1;
model.out2=-2;
model.outtyp=1;
model.ipar=ipar;
model.rpar=rpar;
model.nzcross=nzz;
model.nmode=1;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[sci2exp(1),string(ipar),string(rpar),string(nzz)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
SWITCH2_m.prototype.details = function SWITCH2_m() {
}
}
/* autogenerated from "macros/Branching/EXTRACTOR.sci" */
function EXTRACTOR() {
EXTRACTOR.prototype.get = function EXTRACTOR() {
}
EXTRACTOR.prototype.set = function EXTRACTOR() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,ind,exprs]=scicos_getvalue("Set block parameters",["indices to extract"],list("vec",-1),exprs);
if (!ok) {
break
}
ind=int(ind);
ind=ind.slice();
[model,graphics,ok]=check_io(model,graphics,[-1],size(ind,1),[],[]);
if (ok) {
model.ipar=ind;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
EXTRACTOR.prototype.define = function EXTRACTOR() {
ind=1;
model=scicos_model();
model.sim=list("extractor",4);
model.in1=-1;
model.out=1;
model.blocktype="c";
model.dep_ut=[true,None];
model.ipar=ind;
exprs=[sci2exp(ind)];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
EXTRACTOR.prototype.details = function EXTRACTOR() {
}
}
/* autogenerated from "macros/Branching/CLKGOTO.sci" */
function CLKGOTO() {
CLKGOTO.prototype.get = function CLKGOTO() {
}
CLKGOTO.prototype.set = function CLKGOTO() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
while (true) {
[ok,tag,tagvis,exprs]=scicos_getvalue("Set block parameters",["Tag","Tag Visibility (1=Local 2=Scoped 3=Global)"],list("str",-1,"vec",1),exprs);
if (!ok) {
break
}
if (((tagvis<1)||(tagvis>3))) {
message("Tag Visibility must be between 1 and 3");
ok=None;
}
tagvis=int(tagvis);
if (ok) {
if (((model.opar!=list(tag))||(model.ipar!=tagvis))) {
needcompile=4;
y=needcompile;
}
model.opar=list(tag);
model.ipar=tagvis;
model.evtin=1;
model.firing=-1;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
needcompile=resume(needcompile)
}
CLKGOTO.prototype.define = function CLKGOTO() {
model=scicos_model();
model.sim="clkgoto";
model.evtin=1;
model.opar=list("A");
model.ipar=int(1);
model.blocktype="d";
model.firing=-1;
model.dep_ut=[None,None];
exprs=["A",sci2exp(1)];
x=standard_define([2,1],model,exprs," ");
x.graphics.id="Goto";
}
CLKGOTO.prototype.details = function CLKGOTO() {
}
}
/* autogenerated from "macros/Branching/CLKFROM.sci" */
function CLKFROM() {
CLKFROM.prototype.get = function CLKFROM() {
}
CLKFROM.prototype.set = function CLKFROM() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
while (true) {
[ok,tag,exprs]=scicos_getvalue("Set block parameters","Tag",list("str",-1),exprs);
if (!ok) {
break
}
if (model.opar!=list(tag)) {
needcompile=4;
y=needcompile;
}
model.opar=list(tag);
model.evtout=1;
model.firing=-1;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
needcompile=resume(needcompile)
}
CLKFROM.prototype.define = function CLKFROM() {
model=scicos_model();
model.sim="clkfrom";
model.evtout=1;
model.opar=list("A");
model.blocktype="d";
model.firing=-1;
model.dep_ut=[None,None];
exprs="A";
x=standard_define([2,1],model,exprs," ");
x.graphics.id="From";
}
CLKFROM.prototype.details = function CLKFROM() {
}
}
/* autogenerated from "macros/Branching/GOTO.sci" */
function GOTO() {
GOTO.prototype.get = function GOTO() {
}
GOTO.prototype.set = function GOTO() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,tag,tagvis,exprs]=scicos_getvalue("Set parameters",["Tag","Tag Visibility(1=Local 2=scoped 3= global)"],list("str",-1,"vec",1),exprs);
if (!ok) {
break
}
tagvis=int(tagvis);
if (((tagvis<1)||(tagvis>3))) {
message("Tag Visibility must be between 1 and 3");
ok=None;
}
if (ok) {
if (((model.ipar!=tagvis)||(model.opar!=list(tag)))) {
needcompile=4;
y=needcompile;
}
graphics.exprs=exprs;
model.opar=list(tag);
model.ipar=tagvis;
x.model=model;
x.graphics=graphics;
arg1=x;
break
}
}
needcompile=resume(needcompile)
}
GOTO.prototype.define = function GOTO() {
model=scicos_model();
model.sim="goto";
model.in1=-1;
model.in2=-2;
model.intyp=-1;
model.out=[];
model.out2=[];
model.outtyp=1;
model.ipar=int(1);
model.opar=list("A");
model.blocktype="c";
model.dep_ut=[None,None];
exprs=["A",sci2exp(1)];
gr_i=[];
x=standard_define([2,1],model,exprs,gr_i);
x.graphics.id="Goto";
}
GOTO.prototype.details = function GOTO() {
}
}
/* autogenerated from "macros/Branching/SCALAR2VECTOR.sci" */
function SCALAR2VECTOR() {
SCALAR2VECTOR.prototype.get = function SCALAR2VECTOR() {
}
SCALAR2VECTOR.prototype.set = function SCALAR2VECTOR() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,nout,exprs]=scicos_getvalue("Set block parameters",["size of output (-1: if don\'t know)"],list("vec",1),exprs);
if (!ok) {
break
}
nout=int(nout);
if ((nout!=-1&&(nout<=0))) {
message("size of output must be -1 or >0");
ok=None;
}
if (ok) {
[model,graphics,ok]=check_io(model,graphics,[1],nout,[],[]);
}
if (ok) {
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
SCALAR2VECTOR.prototype.define = function SCALAR2VECTOR() {
nout=-1;
model=scicos_model();
model.sim=list("scalar2vector",4);
model.out=nout;
model.in1=1;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string([nout])];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
SCALAR2VECTOR.prototype.details = function SCALAR2VECTOR() {
}
}
/* autogenerated from "macros/Branching/SWITCH2.sci" */
function SWITCH2() {
SWITCH2.prototype.get = function SWITCH2() {
}
SWITCH2.prototype.set = function SWITCH2() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,rule,thra,nzz,exprs]=scicos_getvalue("Set parameters",["pass first input if: u2>=a (0), u2>a (1), u2~=a (2)","threshold a","use zero crossing: yes (1), no (0)"],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
rule=int(rule);
if ((rule<0)) {
rule=0;
}
if ((rule>2)) {
rule=2;
}
graphics.exprs=exprs;
model.ipar=rule;
model.rpar=thra;
if (nzz!=0) {
model.nmode=1;
model.nzcross=1;
} else {
model.nmode=0;
model.nzcross=0;
}
x.graphics=graphics;
x.model=model;
break
}
}
SWITCH2.prototype.define = function SWITCH2() {
in1=[-1,1,-1];
ipar=[0];
nzz=1;
rpar=0;
model=scicos_model();
model.sim=list("switch2",4);
model.in1=in1;
model.out=-1;
model.ipar=ipar;
model.rpar=rpar;
model.nzcross=nzz;
model.nmode=1;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string(ipar),string(rpar),string(nzz)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
SWITCH2.prototype.details = function SWITCH2() {
}
}
/* autogenerated from "macros/Branching/ESELECT_f.sci" */
function ESELECT_f() {
ESELECT_f.prototype.get = function ESELECT_f() {
}
ESELECT_f.prototype.set = function ESELECT_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
if (size(exprs,"*")==1) {
exprs[2-1]=string(1);
}
if (size(exprs,"*")==2) {
exprs[3-1]=string(0);
}
model=arg1.model;
while (true) {
[ok,out,inh,nmod,exprs]=scicos_getvalue("Set ESELECT block parameters",["number of output event ports","Inherit (1: no, 0: yes)","zero-crossing (0: no, 1: yes)"],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (nmod!=0) {
nmod=1;
}
if (inh==0) {
inh=[];
} else {
inh=1;
}
out=int(out);
if (out<2) {
message("Block must have at least two output ports");
} else {
[model,graphics,ok]=check_io(model,graphics,1,[],inh,[ones(out,1)]);
if (ok) {
graphics.exprs=exprs;
model.evtout=ones(out,1);
model.firing=-ones(out,1);
x.graphics=graphics;
model.nmode=nmod;
model.nzcross=nmod;
x.model=model;
break
}
}
}
}
ESELECT_f.prototype.define = function ESELECT_f() {
out=2;
model=scicos_model();
model.sim=list("eselect",-2);
model.in1=1;
model.in2=1;
model.intyp=-1;
model.evtin=1;
model.evtout=ones(out,1);
model.blocktype="l";
model.firing=-ones(out,1);
model.dep_ut=[true,None];
model.nmode=0;
model.nzcross=0;
gr_i=[];
exprs=[string(out),string(1),string(model.nmode)];
x=standard_define([4,2],model,exprs,gr_i);
}
ESELECT_f.prototype.details = function ESELECT_f() {
}
}
/* autogenerated from "macros/Branching/GotoTagVisibilityMO.sci" */
function GotoTagVisibilityMO() {
GotoTagVisibilityMO.prototype.get = function GotoTagVisibilityMO() {
}
GotoTagVisibilityMO.prototype.set = function GotoTagVisibilityMO() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,tag,exprs]=scicos_getvalue("Set parameters",["GotoTag"],list("str",-1),exprs);
if (!ok) {
break
}
if (ok) {
if (model.opar!=list(tag)) {
needcompile=4;
y=needcompile;
}
graphics.exprs=exprs;
model.opar=list(tag);
x.graphics=graphics;
x.model=model;
break
}
}
needcompile=resume(needcompile)
}
GotoTagVisibilityMO.prototype.define = function GotoTagVisibilityMO() {
model=scicos_model();
model.sim="gototagvisibilitymo";
model.in1=[];
model.in2=[];
model.out=[];
model.out2=[];
model.evtin=[];
model.intyp=1;
model.outtyp=1;
model.opar=list("A");
model.blocktype="c";
model.firing=None;
model.dep_ut=[None,None];
exprs="A";
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
GotoTagVisibilityMO.prototype.details = function GotoTagVisibilityMO() {
}
}
/* autogenerated from "macros/Branching/ISELECT_f.sci" */
function ISELECT_f() {
ISELECT_f.prototype.get = function ISELECT_f() {
}
ISELECT_f.prototype.set = function ISELECT_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,nout,z0,exprs]=scicos_getvalue("Set parameters",["number of outputs","initial connected output"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (z0>nout||z0<=0) {
message("initial connected input is not a valid input port number");
} else {
[model,graphics,ok]=check_io(model,graphics,-1,-ones(nout,1),ones(nout,1),[]);
if (ok) {
graphics.exprs=exprs;
model.dstate=z0-1;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
ISELECT_f.prototype.define = function ISELECT_f() {
z0=0;
out=[-1,-1];
nout=2;
model=scicos_model();
model.sim=list("selector",2);
model.in1=-1;
model.out=out;
model.evtin=ones(out);
model.dstate=z0;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string(nout),string(z0+1)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
ISELECT_f.prototype.details = function ISELECT_f() {
}
}
/* autogenerated from "macros/Branching/SELECT_m.sci" */
function SELECT_m() {
SELECT_m.prototype.get = function SELECT_m() {
}
SELECT_m.prototype.set = function SELECT_m() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,typ,nin,z0,exprs]=scicos_getvalue("Set parameters",["Datatype(1= real double  2=Complex 3=int32 ..)","number of inputs","initial connected input"],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (z0>nin||z0<=0) {
message("initial connected input is not a valid input port number");
} else if (((typ<1)||(typ>8))&&(typ!=-1)) {
message("Datatype is not supported");
ok=None;
} else {
it=typ*ones(1,nin);
ot=typ;
if (ok) {
in1=[-ones(nin,1),-2*ones(nin,1)];
out=[-1,-2];
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),ones(nin,1),[]);
if (ok) {
graphics.exprs=exprs;
model.dstate=z0;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
}
SELECT_m.prototype.define = function SELECT_m() {
z0=1;
nin=2;
model=scicos_model();
model.sim=list("selector_m",4);
model.in1=[-1,-1];
model.in2=[-2,-2];
model.intyp=1;
model.out=-1;
model.out2=-2;
model.outtyp=1;
model.evtout=[];
model.state=[];
model.rpar=[];
model.ipar=[];
model.firing=[];
model.evtin=ones(nin,1);
model.dstate=z0;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[sci2exp(1),sci2exp(nin),sci2exp(z0)];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
SELECT_m.prototype.details = function SELECT_m() {
}
}
/* autogenerated from "macros/Branching/CLKGotoTagVisibility.sci" */
function CLKGotoTagVisibility() {
CLKGotoTagVisibility.prototype.get = function CLKGotoTagVisibility() {
}
CLKGotoTagVisibility.prototype.set = function CLKGotoTagVisibility() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,tag,exprs]=scicos_getvalue("Set parameters",["GotoTag"],list("str",-1),exprs);
if (!ok) {
break
}
if (ok) {
if (model.opar!=list(tag)) {
needcompile=4;
y=needcompile;
}
graphics.exprs=exprs;
model.opar=list(tag);
x.graphics=graphics;
x.model=model;
break
}
}
needcompile=resume(needcompile)
}
CLKGotoTagVisibility.prototype.define = function CLKGotoTagVisibility() {
model=scicos_model();
model.sim="clkgototagvisibility";
model.in1=[];
model.in2=[];
model.out=[];
model.out2=[];
model.evtin=[];
model.intyp=1;
model.outtyp=1;
model.opar=list("A");
model.blocktype="c";
model.firing=None;
model.dep_ut=[None,None];
exprs="A";
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CLKGotoTagVisibility.prototype.details = function CLKGotoTagVisibility() {
}
}
/* autogenerated from "macros/Branching/M_SWITCH.sci" */
function M_SWITCH() {
M_SWITCH.prototype.get = function M_SWITCH() {
}
M_SWITCH.prototype.set = function M_SWITCH() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,nin,base,rule,exprs]=scicos_getvalue("Set parameters",["number of inputs","zero base indexing (0), otherwise 1","rounding rule: int (0), round (1), ceil (2), floor (3)"],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
nin=int(nin);
base=int(base);
if (nin<1) {
message("Number of inputs must be >=1 ");
} else if (!((base==1)||(base==0))) {
message("base indexing must be 1 or 0");
} else if (!((rule==1)||(rule==0)||(rule==2)||(rule==3))) {
message("incorrect rounding rule");
} else {
if (nin==1) {
in1=[1,1,-1,1];
out=[1,1];
} else {
in1=[1,-ones(nin,1)];
in2=[1,-2*ones(nin,1)];
in1=[in1,in2];
out=[-1,-2];
}
it=[-1,-2*ones(nin,1)];
ot=-2;
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
if (ok) {
graphics.exprs=exprs;
model.ipar=[base,rule];
x.graphics=graphics;
x.model=model;
break
}
}
}
}
M_SWITCH.prototype.define = function M_SWITCH() {
in1=[1,-1,-1];
ipar=[1,3];
nin=2;
model=scicos_model();
model.sim=list("mswitch",4);
model.in1=in1;
model.out=-1;
model.ipar=ipar;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string(nin),string(ipar)];
gr_i=[];
x=standard_define([2.5,2],model,exprs,gr_i);
}
M_SWITCH.prototype.details = function M_SWITCH() {
}
}
/* autogenerated from "macros/Branching/FROMMO.sci" */
function FROMMO() {
FROMMO.prototype.get = function FROMMO() {
}
FROMMO.prototype.set = function FROMMO() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,tag,exprs]=scicos_getvalue("Set parameters",["Tag"],list("str",-1),exprs);
if (!ok) {
break
}
if (ok) {
if (model.opar!=list(tag)) {
needcompile=4;
y=needcompile;
}
graphics.exprs=exprs;
model.opar=list(tag);
x.model=model;
x.graphics=graphics;
break
}
}
needcompile=resume(needcompile)
}
FROMMO.prototype.define = function FROMMO() {
model=scicos_model();
model.sim="frommo";
model.in1=[];
model.in2=[];
model.intyp=1;
model.out=-1;
model.out2=-2;
model.outtyp=-1;
model.ipar=[];
model.opar=list("A");
model.blocktype="c";
model.dep_ut=[None,None];
mo=modelica();
mo.model="frommo";
mo.outputs="n";
exprs=["A"];
gr_i=[];
x=standard_define([2,1],model,exprs,gr_i);
x.graphics.out_implicit=["I"];
}
FROMMO.prototype.details = function FROMMO() {
}
}
/* autogenerated from "macros/Branching/GotoTagVisibility.sci" */
function GotoTagVisibility() {
GotoTagVisibility.prototype.get = function GotoTagVisibility() {
}
GotoTagVisibility.prototype.set = function GotoTagVisibility() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,tag,exprs]=scicos_getvalue("Set parameters",["GotoTag"],list("str",-1),exprs);
if (!ok) {
break
}
if (ok) {
if (model.opar!=list(tag)) {
needcompile=4;
y=needcompile;
}
graphics.exprs=exprs;
model.opar=list(tag);
x.graphics=graphics;
x.model=model;
break
}
}
needcompile=resume(needcompile)
}
GotoTagVisibility.prototype.define = function GotoTagVisibility() {
model=scicos_model();
model.sim="gototagvisibility";
model.in1=[];
model.in2=[];
model.out=[];
model.out2=[];
model.evtin=[];
model.intyp=1;
model.outtyp=1;
model.opar=list("A");
model.blocktype="c";
model.firing=None;
model.dep_ut=[None,None];
exprs="A";
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
GotoTagVisibility.prototype.details = function GotoTagVisibility() {
}
}
/* autogenerated from "macros/Branching/RELAY_f.sci" */
function RELAY_f() {
RELAY_f.prototype.get = function RELAY_f() {
}
RELAY_f.prototype.set = function RELAY_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
ipar=model.ipar;
while (true) {
[ok,nin,z0,exprs]=scicos_getvalue("Set parameters",["number of inputs","initial connected input"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (z0>nin||z0<=0) {
message("initial connected input is not a valid input port number");
} else {
[model,graphics,ok]=check_io(model,graphics,-ones(nin,1),-1,ones(nin,1),[]);
if (ok) {
graphics.exprs=exprs;
model.dstate=z0-1;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
RELAY_f.prototype.define = function RELAY_f() {
i0=0;
in1=[-1,-1];
nin=2;
model=scicos_model();
model.sim=list("relay",2);
model.in1=in1;
model.out=-1;
model.evtin=ones(in1);
model.dstate=i0;
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,true];
exprs=[string(nin),string(i0+1)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
RELAY_f.prototype.details = function RELAY_f() {
}
}
/* autogenerated from "macros/Branching/NRMSOM_f.sci" */
function NRMSOM_f() {
NRMSOM_f.prototype.get = function NRMSOM_f() {
}
NRMSOM_f.prototype.set = function NRMSOM_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,nin,exprs]=scicos_getvalue("Set parameters",["number of inputs"],list("vec",1),exprs);
if (!ok) {
break
}
[model,graphics,ok]=check_io(model,graphics,-ones(nin,1),-1,[],[]);
if (ok) {
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
NRMSOM_f.prototype.define = function NRMSOM_f() {
in1=[-1,-1];
nin=2;
model=scicos_model();
model.sim="junk";
model.in1=in1;
model.out=-1;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string(nin)];
gr_i=[];
x=standard_define([.2,2],model,exprs,gr_i);
}
NRMSOM_f.prototype.details = function NRMSOM_f() {
}
}
/* autogenerated from "macros/Sources/INIMPL_f.sci" */
function INIMPL_f() {
INIMPL_f.prototype.get = function INIMPL_f() {
}
INIMPL_f.prototype.set = function INIMPL_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")==2) {
exprs=exprs(1);
}
while (true) {
[ok,prt,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"INIMPL_f")," ",gettext("Implicit input port")," "],"Port Number",list("vec",1),exprs);
if (!ok) {
break
}
prt=int(prt);
if (prt<=0) {
block_parameter_error(msprintf(gettext("Wrong value for \'Port Number\' parameter: %d."),prt),gettext("Strictly positive integer expected."));
} else {
if (model.ipar!=prt) {
needcompile=4;
y=needcompile;
}
model.ipar=prt;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
INIMPL_f.prototype.define = function INIMPL_f() {
model=scicos_model();
model.sim="inimpl";
model.out=[-1];
model.out2=[1];
model.ipar=[1];
model.dep_ut=[None,None];
model.blocktype="c";
mo=modelica();
mo.model="PORT";
mo.outputs="n";
model.equations=mo;
prt=1;
exprs="1";
gr_i=[];
x=standard_define([1,1],model,exprs,gr_i);
x.graphics.out_implicit=["I"];
}
INIMPL_f.prototype.details = function INIMPL_f() {
}
}
/* autogenerated from "macros/Sources/RAND_m.sci" */
function RAND_m() {
RAND_m.prototype.get = function RAND_m() {
}
RAND_m.prototype.set = function RAND_m() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")==14) {
exprs[9-1]=[];
}
while (true) {
[ok,typ,flag,a,b,seed_c,exprs]=scicos_getvalue(["Set Random generator block parameters","flag = 0 : Uniform distribution A is min and A+B max","flag = 1 : Normal distribution A is mean and B deviation"," ","A and B must be matrix with equal sizes"],["Datatype(1=real double  2=complex)","flag","A","B","SEED"],list("vec",1,"vec",1,"mat",[-1,-2],"mat","[-1 -2]","mat",[1,2]),exprs);
if (!ok) {
break
}
if (flag!=0&&flag!=1) {
message("flag must be equal to 1 or 0");
} else {
out=size(a);
if (typ==1) {
function_name="rndblk_m";
model.rpar=[real(a.slice()),real(b.slice())];
model.dstate=[seed_c(1),0*real(a.slice())];
ot=1;
} else if (typ==2) {
function_name="rndblkz_m";
ot=2;
model.rpar=[real(a.slice()),imag(a.slice()),real(b.slice()),imag(b.slice())];
model.dstate=[seed_c.slice(),0*[real(a.slice()),imag(a.slice())]];
} else {
message("Datatype is not supported");
ok=None;
}
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list([],[]),list(out,ot),1,[]);
if (ok) {
model.sim=list(function_name,4);
graphics.exprs=exprs;
model.ipar=flag;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
}
RAND_m.prototype.define = function RAND_m() {
a=0;
b=1;
dt=0;
flag=0;
function_name="rndblk_m";
funtyp=4;
model=scicos_model();
model.sim=list(function_name,funtyp);
model.in1=[];
model.in2=[];
model.intyp=[];
model.out=1;
model.out2=1;
model.outtyp=1;
model.evtin=1;
model.evtout=[];
model.state=[];
model.dstate=[int(rand()*(10^7-1)),0*a.slice()];
model.rpar=[a.slice(),b.slice()];
model.ipar=flag;
model.blocktype="d";
model.firing=[];
model.dep_ut=[None,None];
exprs=[sci2exp(1),string(flag),sci2exp([a]),sci2exp([b]),sci2exp([model.dstate(1),int(rand()*(10^7-1))])];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
RAND_m.prototype.details = function RAND_m() {
}
}
/* autogenerated from "macros/Sources/GENSQR_f.sci" */
function GENSQR_f() {
GENSQR_f.prototype.get = function GENSQR_f() {
}
GENSQR_f.prototype.set = function GENSQR_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")==2) {
exprs=exprs(2);
}
while (true) {
[ok,Amplitude,exprs]=scicos_getvalue(["Set Square generator block parameters"],["Amplitude"],list("vec",1),exprs);
if (!ok) {
break
}
graphics.exprs=exprs;
model.dstate=Amplitude;
model.out2=1;
model.outtyp=1;
x.graphics=graphics;
x.model=model;
break
}
}
GENSQR_f.prototype.define = function GENSQR_f() {
Amplitude=1;
model=scicos_model();
model.sim="gensqr";
model.out=1;
model.out2=1;
model.outtyp=1;
model.evtin=1;
model.dstate=Amplitude;
model.blocktype="d";
model.dep_ut=[None,None];
exprs=string(Amplitude);
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
GENSQR_f.prototype.details = function GENSQR_f() {
}
}
/* autogenerated from "macros/Sources/IN_f.sci" */
function IN_f() {
IN_f.prototype.get = function IN_f() {
}
IN_f.prototype.set = function IN_f() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
if (size(exprs,"*")==2) {
exprs=exprs(1);
}
if (size(exprs,"*")==1) {
exprs=[exprs(1),"[-1 -2]","-1"];
}
while (true) {
[ok,prt,otsz,ot,exprs]=getvalue(_("Set Input block parameters"),[_("Port number"),_("Outport size ([-1 -2] for inherit)"),_("Outport Type (-1 for inherit)")],list("vec",1,"vec",-1,"vec",1),exprs);
if (!ok) {
break
}
prt=int(prt);
if (prt<=0) {
message(_("Port number must be a positive integer"));
} else if (!isequal(size(otsz,"*"),2)) {
message(_("Outport Size must be a 2 elements vector"));
} else if (((ot<1||ot>9)&&(ot!=-1))) {
message(_("Outport type must be a number between 1 and 9, or -1 for inheritance."));
} else {
if (model.ipar!=prt) {
needcompile=4;
y=needcompile;
}
model.ipar=prt;
model.firing=[];
model.out=otsz(1);
model.out2=otsz(2);
model.outtyp=ot;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
IN_f.prototype.define = function IN_f() {
prt=1;
model=scicos_model();
model.sim="input";
model.out=-1;
model.out2=-2;
model.outtyp=-1;
model.ipar=prt;
model.blocktype="c";
model.dep_ut=[None,None];
exprs=sci2exp(prt);
gr_i=[];
x=standard_define([1,1],model,exprs,gr_i);
}
IN_f.prototype.details = function IN_f() {
}
}
/* autogenerated from "macros/Sources/TKSCALE.sci" */
function TKSCALE() {
TKSCALE.prototype.get = function TKSCALE() {
}
TKSCALE.prototype.set = function TKSCALE() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
[ok,a,b,f,exprs]=scicos_getvalue("Set scale block parameters",["Min value","Max value","Normalization"],list("vec",1,"vec",1,"vec",1),exprs);
if (ok) {
graphics.exprs=exprs;
model.rpar=[a,b,f];
x.graphics=graphics;
x.model=model;
}
}
TKSCALE.prototype.define = function TKSCALE() {
a=-10;
b=10;
f=1;
model=scicos_model();
model.sim=list("tkscaleblk",5);
model.out=1;
model.evtin=1;
model.rpar=[a,b,f];
model.blocktype="d";
model.dep_ut=[None,None];
exprs=[sci2exp(a),sci2exp(b),sci2exp(f)];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
TKSCALE.prototype.details = function TKSCALE() {
}
}
/* autogenerated from "macros/Sources/STEP.sci" */
function STEP() {
STEP.prototype.get = function STEP() {
}
STEP.prototype.set = function STEP() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,temps,in1,fi,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"STEP_FUNCTION")," ",gettext("Step Function")," "],[gettext("Step Time"),gettext("Initial Value"),gettext("Final Value")],list("vec",1,"vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
in1=in1.slice();
fi=fi.slice();
if (size(in1,"*")!=size(fi,"*")) {
if (size(in1,"*")==1) {
in1=in1*ones(fi);
} else if (size(fi,"*")==1) {
fi=fi*ones(in1);
} else {
block_parameter_error(msprintf(gettext("\'Initial Value\' and \'Final Value\': incompatible sizes: %d and %d."),size(in1,"*"),size(fi,"*")),gettext("Same sizes expected."));
ok=None;
}
}
if (ok) {
model.out2=1;
model.outtyp=1;
[model,graphics,ok]=check_io(model,graphics,[],size(fi,"*"),1,1);
}
if (ok) {
model.firing=temps;
if (temps==0) {
rpar=[fi,fi];
} else {
rpar=[in1,fi];
}
model.rpar=rpar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
STEP.prototype.define = function STEP() {
rpar=[0,1];
model=scicos_model();
model.sim=list("step_func",4);
model.evtin=1;
model.evtout=1;
model.out=1;
model.out2=1;
model.outtyp=1;
model.firing=1;
model.rpar=rpar;
model.blocktype="c";
model.dep_ut=[None,None];
exprs=[string(1),string(rpar)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
STEP.prototype.details = function STEP() {
}
}
/* autogenerated from "macros/Sources/CURV_f.sci" */
function CURV_f() {
CURV_f.prototype.get = function CURV_f() {
}
CURV_f.prototype.set = function CURV_f() {
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
rpar=model.rpar;
ipar=model.ipar;
n=ipar(1);
xx=rpar.slice(1-1,n);
yy=rpar.slice(n+1-1,2*n);
gc=list(rpar.slice(2*n+1-1,2*n+4),ipar.slice(2-1,5));
while (true) {
[ln,fun]=where()
if (!or(fun=="do_eval")) {
[xx,yy,ok,gc]=edit_curv(xx,yy,"axy",[" "," "," "],gc);
} else {
ok=true;
}
if (!ok) {
break
}
n=size(xx,"*");
if (or(xx.slice(2-1,n)-xx.slice(1-1,n-1)<0)) {
message("You have not defined a function");
ok=None;
}
if (ok) {
model.sim="intplt";
model.firing=[];
rect=gc(1);
model.rpar=[xx.slice(),yy.slice(),rect.slice()];
axisdata=gc(2);
model.ipar=[size(xx,"*"),axisdata.slice()];
x.graphics=graphics;
x.model=model;
break
}
}
}
CURV_f.prototype.define = function CURV_f() {
xx=[0,1,2];
yy=[-5,5,0];
rect=[0,-5,2,5];
axisdata=[2,10,2,10];
ipar=[size(xx,1),axisdata.slice()];
rpar=[xx,yy,rect.slice()];
model=scicos_model();
model.sim="intplt";
model.in1=[];
model.out=1;
model.rpar=[xx,yy,rect.slice()];
model.ipar=[size(xx,1),axisdata.slice()];
model.blocktype="c";
model.dep_ut=[None,true];
gr_i=[];
x=standard_define([2,2],model,[],gr_i);
}
CURV_f.prototype.details = function CURV_f() {
}
}
/* autogenerated from "macros/Sources/RAMP.sci" */
function RAMP() {
RAMP.prototype.get = function RAMP() {
}
RAMP.prototype.set = function RAMP() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,slope,stt,iout,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"RAMP")," ",gettext("Ramp function")," "],[gettext("Slope"),gettext("Start Time"),gettext("Initial Value")],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (stt<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'Start Time\' parameter: %e."),stt),gettext("Null or positive integer expected."));
} else {
model.rpar=[slope,stt,iout];
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
RAMP.prototype.define = function RAMP() {
slope=0;
iout=0;
stt=0;
rpar=[slope,stt,iout];
model=scicos_model();
model.sim=list("ramp",4);
model.in1=[];
model.out=1;
model.rpar=rpar;
model.blocktype="c";
model.nmode=1;
model.nzcross=1;
model.dep_ut=[None,true];
exprs=[string(rpar)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
RAMP.prototype.details = function RAMP() {
}
}
/* autogenerated from "macros/Sources/CLOCK_c.sci" */
function CLOCK_c() {
CLOCK_c.prototype.get = function CLOCK_c() {
}
CLOCK_c.prototype.set = function CLOCK_c() {
for(i=1;i<=length(arg1.model.rpar.objs);i+=1) {
o=arg1.model.rpar.objs(i);
if (typeof(o)=="Block"&&o.gui=="EVTDLY_c") {
path=i;
break
}
}
newpar=list();
xx=arg1.model.rpar.objs(path);
exprs=xx.graphics.exprs;
model=xx.model;
t0_old=model.firing;
dt_old=model.rpar(1);
model_n=model;
while (true) {
[ok,dt,t0,exprs0]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"CLOCK_c")," ",gettext("Event clock generator")," ",gettext("&nbsp; Do not start if \'Initialisation Time\' is negative")," "],[gettext("Period"),gettext("Initialisation Time")],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (dt<=0) {
block_parameter_error(msprintf(gettext("Wrong values for \'%s\' parameter: %5.1e."),gettext("Period"),dt),gettext("Strictly positive number expected."));
ok=None;
}
if (ok) {
xx.graphics.exprs=exprs0;
model.rpar=[dt,t0];
model.firing=t0;
xx.model=model;
arg1.model.rpar.objs[path-1]=xx;
break
}
}
if (!and([t0_old,dt_old]==[t0,dt])) {
newpar[size(newpar)+1-1]=path;
}
if (t0_old!=t0) {
needcompile=2;
} else {
needcompile=0;
}
x=arg1;
y=needcompile;
typ=newpar;
}
CLOCK_c.prototype.define = function CLOCK_c() {
evtdly=EVTDLY_c("define");
evtdly.graphics.orig=[320,232];
evtdly.graphics.sz=[40,40];
evtdly.graphics.flip=true;
evtdly.graphics.exprs=["0.1","0.1"];
evtdly.graphics.pein=6;
evtdly.graphics.peout=3;
evtdly.model.rpar=[0.1,0.1];
evtdly.model.firing=0.1;
output_port=CLKOUT_f("define");
output_port.graphics.orig=[399,162];
output_port.graphics.sz=[20,20];
output_port.graphics.flip=true;
output_port.graphics.exprs="1";
output_port.graphics.pein=5;
output_port.model.ipar=1;
split=CLKSPLIT_f("define");
split.graphics.orig=[380.71066,172];
split.graphics.pein=3;
split.graphics.peout=[5,6];
gr_i=[];
diagram=scicos_diagram();
diagram.objs[1-1]=output_port;
diagram.objs[2-1]=evtdly;
diagram.objs[3-1]=scicos_link(xx=[340,340,380.71],yy=[226.29,172,172],ct=[5,-1],from=[2,1],to=[4,1]);
diagram.objs[4-1]=split;
diagram.objs[5-1]=scicos_link(xx=[380.71,399],yy=[172,172],ct=[5,-1],from=[4,1],to=[1,1]);
diagram.objs[6-1]=scicos_link(xx=[380.71,380.71,340,340],yy=[172,302,302,277.71],ct=[5,-1],from=[4,2],to=[2,1]);
x=scicos_block();
x.gui="CLOCK_c";
x.graphics.sz=[2,2];
x.graphics.gr_i=gr_i;
x.graphics.peout=0;
x.model.sim="csuper";
x.model.evtout=1;
x.model.blocktype="h";
x.model.firing=None;
x.model.dep_ut=[None,None];
x.model.rpar=diagram;
}
CLOCK_c.prototype.details = function CLOCK_c() {
}
}
/* autogenerated from "macros/Sources/CONST_f.sci" */
function CONST_f() {
CONST_f.prototype.get = function CONST_f() {
}
CONST_f.prototype.set = function CONST_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,C,exprs]=scicos_getvalue(["Set Contant Block"],"Constant",list("vec",-1),exprs);
if (!ok) {
break
}
nout=size(C,"*");
if (nout==0) {
message("C must have at least one element");
} else {
model.rpar=C.slice();
model.out=nout;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CONST_f.prototype.define = function CONST_f() {
C=1;
model=scicos_model();
model.sim=list("cstblk",1);
model.in1=[];
model.out=1;
model.rpar=C;
model.blocktype="d";
model.dep_ut=[None,None];
exprs=strcat(sci2exp(C));
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CONST_f.prototype.details = function CONST_f() {
}
}
/* autogenerated from "macros/Sources/Ground_g.sci" */
function Ground_g() {
Ground_g.prototype.get = function Ground_g() {
}
Ground_g.prototype.set = function Ground_g() {
x=arg1;
}
Ground_g.prototype.define = function Ground_g() {
C=[0];
model=scicos_model();
model.sim=list("cstblk4_m",4);
model.in1=[];
model.out=1;
model.in2=[];
model.out2=1;
model.outtyp=-1;
model.rpar=[];
model.opar=list(C);
model.blocktype="d";
model.dep_ut=[None,None];
exprs=[];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
Ground_g.prototype.details = function Ground_g() {
}
}
/* autogenerated from "macros/Sources/Counter.sci" */
function Counter() {
Counter.prototype.get = function Counter() {
}
Counter.prototype.set = function Counter() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,minim,maxim,rule,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"Counter")," ",gettext("Integer counter generator")," "],[gettext("Minimum"),gettext("Maximum"),gettext("Rule (1:Increment, 2:Decrement)")],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
maxim=int(maxim);
minim=int(minim);
if (maxim<minim) {
block_parameter_error(msprintf(gettext("Wrong values for \'Maximum\' and \'Minimum\' parameters: %d &lt; %d"),minim,maxim),msprintf(gettext("\'Minimum\' must be less than \'Maximum\'.")));
} else if ((rule!=1&&rule!=2)) {
block_parameter_error(msprintf(gettext("Wrong value for \'Rule\' parameter: %d"),rule),msprintf(gettext("Must be in the interval %s."),"[1,2]"));
} else {
graphics.exprs=exprs;
model.dstate=0;
model.ipar=[rule,maxim,minim];
x.graphics=graphics;
x.model=model;
break
}
}
}
Counter.prototype.define = function Counter() {
minim=0;
maxim=2;
rule=1;
model=scicos_model();
model.sim=list("counter",4);
model.evtin=1;
model.out=1;
model.out2=1;
model.dstate=0;
model.ipar=[rule,maxim,minim];
model.blocktype="c";
model.dep_ut=[None,None];
exprs=[string(minim),string(maxim),string(rule)];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
Counter.prototype.details = function Counter() {
}
}
/* autogenerated from "macros/Sources/FROMWS_c.sci" */
function FROMWS_c() {
FROMWS_c.prototype.get = function FROMWS_c() {
}
FROMWS_c.prototype.set = function FROMWS_c() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,varnam,Method,ZC,OutEnd,exprs]=scicos_getvalue("Set From_Workspace block parameters",["Variable name","Interpolation Method","Enable zero crossing(0:No, 1:Yes)?","Output at end(0:Zero, 1:Hold, 2:Repeat)"],list("str",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (!(Method==0||Method==1||Method==2||Method==3)) {
message("Interpolation method should be chosen in [0,1,2,3]");
ok=None;
}
if (!(ZC==0||ZC==1)) {
message("Zero crossing should be either 0 or 1");
ok=None;
}
if (!(OutEnd==0||OutEnd==1||OutEnd==2)) {
message("Output at end option should be either 0 or 1");
ok=None;
}
r=None;
ierr=execstr("r=validvar(varnam)","errcatch");
if (!r) {
message(["Invalid variable name.","Please choose another variable name."]);
ok=None;
}
if (ok) {
model.ipar=[length(varnam),_str2code(varnam),Method,ZC,OutEnd];
[model,graphics,ok]=set_io(model,graphics,list(),list([-1,-2],-1),1,1);
if (ok) {
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
FROMWS_c.prototype.define = function FROMWS_c() {
varnam="V";
Method=1;
ZC=1;
OutEnd=0;
model=scicos_model();
model.sim=list("fromws_c",4);
model.out=-1;
model.out2=-2;
model.outtyp=-1;
model.ipar=[length(varnam),_str2code(varnam),Method,ZC,OutEnd];
model.evtin=[1];
model.evtout=[1];
model.firing=[0];
model.blocktype="d";
model.dep_ut=[None,true];
gr_i=[];
exprs=[string(varnam),string(Method),string(ZC),string(OutEnd)];
x=standard_define([3.5,2],model,exprs,gr_i);
}
FROMWS_c.prototype.details = function FROMWS_c() {
}
}
/* autogenerated from "macros/Sources/SAWTOOTH_f.sci" */
function SAWTOOTH_f() {
SAWTOOTH_f.prototype.get = function SAWTOOTH_f() {
}
SAWTOOTH_f.prototype.set = function SAWTOOTH_f() {
x=arg1;
}
SAWTOOTH_f.prototype.define = function SAWTOOTH_f() {
model=scicos_model();
model.sim="sawtth";
model.out=1;
model.evtin=1;
model.dstate=0;
model.blocktype="c";
model.dep_ut=[None,true];
exprs=" ";
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
SAWTOOTH_f.prototype.details = function SAWTOOTH_f() {
}
}
/* autogenerated from "macros/Sources/RAND_f.sci" */
function RAND_f() {
RAND_f.prototype.get = function RAND_f() {
}
RAND_f.prototype.set = function RAND_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")==5) {
exprs=exprs.slice(1-1,3);
}
if (size(exprs,"*")==3) {
exprs=[exprs,string(model.dstate(1))];
}
while (true) {
[ok,flag,a,b,seed_c,exprs]=scicos_getvalue(["Set Random generator block parameters","flag = 0 : Uniform distribution A is min and A+B max","flag = 1 : Normal distribution A is mean and B deviation"," ","A and B must be vector with equal sizes","seed is the seed of random number generator (integer<2**31)"],["flag","A","B","seed"],list("vec",1,"vec",-1,"vec","size(%2,\'*\')","vec",1),exprs);
if (!ok) {
break
}
if (flag!=0&&flag!=1) {
message("flag must be equal to 1 or 0");
} else {
nout=size(a,"*");
graphics.exprs=exprs;
model.out=nout;
model.ipar=flag;
model.rpar=[a.slice(),b.slice()];
model.dstate=[seed_c,0*a.slice()];
x.graphics=graphics;
x.model=model;
break
}
}
}
RAND_f.prototype.define = function RAND_f() {
a=0;
b=1;
dt=0;
out=1;
flag=0;
model=scicos_model();
model.sim="rndblk";
model.out=out;
model.evtin=1;
model.dstate=[int(rand()*(10^7-1)),0*a.slice()];
model.rpar=[a.slice(),b.slice()];
model.ipar=flag;
model.blocktype="d";
model.dep_ut=[None,None];
exprs=[string(flag),sci2exp(a.slice()),sci2exp(b.slice()),string(model.dstate(1))];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
RAND_f.prototype.details = function RAND_f() {
}
}
/* autogenerated from "macros/Sources/READAU_f.sci" */
function READAU_f() {
READAU_f.prototype.get = function READAU_f() {
}
READAU_f.prototype.set = function READAU_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
out=model.out;
dstate=model.dstate;
ipar=model.ipar;
imask=9+ipar(1);
tmask=ipar(imask);
lunit=dstate(3);
fname=exprs(1);
while (true) {
[ok,fname1,N,swap,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"READAU_f")," ",gettext("(Read Audio File)")," ",gettext("Read is done on a binary \'.au\' file")],[gettext("Input File Name"),gettext("Buffer size"),gettext("Swap Mode (0:No, 1:Yes)")],list("str",1,"vec",1,"vec",1),exprs);
tmask1=[];
outmask=1;
frmt1="uc";
M=1;
offset=1;
if (!ok) {
break
}
fname1=stripblanks(fname1);
frmt1=stripblanks(frmt1);
if (alreadyran&&fname1!=fname) {
block_parameter_error(gettext("Simulation running !!! You cannot modify Input file name"),gettext("End current simulation first."));
} else if (fname1=="") {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter."),gettext("Input File Name")),gettext("You must provide a filename."));
} else if (N<1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Buffer size"),N),msprintf(gettext("Must be greater than %d."),1));
} else if (alreadyran&&(N!=ipar(6))) {
block_parameter_error(msprintf(gettext("You cannot modify \'%s\' when running."),gettext("Buffer Size")),gettext("End current simulation first."));
} else if (swap!=0&&swap!=1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Swap Mode"),swap),msprintf(gettext("Must be in the interval %s."),"[0, 1]"));
} else {
[model,graphics,ok]=check_io(model,graphics,[],1,1,[]);
frmt1=part(frmt1,1,3);
if (ok) {
ipar=[length(fname1),_str2code(frmt1),0,N,M,swap,offset,_str2code(fname1),tmask1,outmask.slice()];
if (prod(size(dstate))!=(N*M)+3) {
dstate=[-1,-1,lunit,zeros(N*M,1)];
}
model.dstate=dstate;
model.ipar=ipar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
READAU_f.prototype.define = function READAU_f() {
frmt="uc ";
fname="test.au";
lunit=0;
N=20;
M=1;
tmask=[];
swap=0;
offset=1;
outmask=1;
ievt=0;
nout=size(outmask,"*");
model=scicos_model();
model.sim=list("readau",2);
model.out=nout;
model.evtin=1;
model.dstate=[1,1,lunit,zeros(N*M,1)];
model.ipar=[length(fname),_str2code(frmt),ievt,N,M,swap,offset,_str2code(fname),tmask,outmask];
model.blocktype="d";
model.dep_ut=[None,None];
exprs=[fname,string(N),string(swap)];
gr_i=[];
x=standard_define([5,2],model,exprs,gr_i);
}
READAU_f.prototype.details = function READAU_f() {
}
}
/* autogenerated from "macros/Sources/CLKIN_f.sci" */
function CLKIN_f() {
CLKIN_f.prototype.get = function CLKIN_f() {
}
CLKIN_f.prototype.set = function CLKIN_f() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
exprs=exprs(1);
while (true) {
[ok,prt,exprs]=scicos_getvalue("Set Event Input block parameters","Port number",list("vec",1),exprs);
prt=int(prt);
if (!ok) {
break
}
if (prt<=0) {
message("Port number must be a positive integer");
} else {
model.ipar=prt;
model.evtout=1;
model.firing=-1;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CLKIN_f.prototype.define = function CLKIN_f() {
prt=1;
model=scicos_model();
model.sim="input";
model.evtout=1;
model.ipar=prt;
model.blocktype="d";
model.firing=-1;
model.dep_ut=[None,None];
exprs=string(prt);
x=standard_define([1,1],model,exprs," ");
}
CLKIN_f.prototype.details = function CLKIN_f() {
}
}
/* autogenerated from "macros/Sources/TIME_f.sci" */
function TIME_f() {
TIME_f.prototype.get = function TIME_f() {
}
TIME_f.prototype.set = function TIME_f() {
x=arg1;
}
TIME_f.prototype.define = function TIME_f() {
model=scicos_model();
model.sim="timblk";
model.out=1;
model.blocktype="c";
model.dep_ut=[None,true];
gr_i=[];
x=standard_define([2,2],model,[],gr_i);
}
TIME_f.prototype.details = function TIME_f() {
}
}
/* autogenerated from "macros/Sources/SampleCLK.sci" */
function SampleCLK() {
SampleCLK.prototype.get = function SampleCLK() {
}
SampleCLK.prototype.set = function SampleCLK() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
while (true) {
[ok,frequ,offset,exprs]=scicos_getvalue("Set block parameters",["Sample time","Offset"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (frequ<0) {
message("Frequency must be a positif number");
ok=None;
}
if (abs(offset)>frequ) {
message("The |Offset| must be less than the Frequency");
ok=None;
}
if (ok) {
if (or(model.rpar.slice()!=[frequ,offset])) {
needcompile=4;
y=needcompile;
}
model.rpar=[frequ,offset];
model.evtout=1;
model.firing=-1;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
needcompile=resume(needcompile)
}
SampleCLK.prototype.define = function SampleCLK() {
model=scicos_model();
model.sim="sampleclk";
model.evtout=1;
model.rpar=[1,0];
model.blocktype="d";
model.firing=-1;
model.dep_ut=[None,None];
exprs=[sci2exp(1),sci2exp(0)];
x=standard_define([2,2],model,exprs," ");
}
SampleCLK.prototype.details = function SampleCLK() {
}
}
/* autogenerated from "macros/Sources/READC_f.sci" */
function READC_f() {
READC_f.prototype.get = function READC_f() {
}
READC_f.prototype.set = function READC_f() {
x=arg1;
model=x.model;
graphics=arg1.graphics;
exprs=graphics.exprs;
out=model.out;
dstate=model.dstate;
ipar=model.ipar;
imask=9+ipar(1);
tmask=ipar(imask);
lunit=dstate(3);
fname=exprs(3);
frmt=exprs(4);
while (true) {
[ok,tmask1,outmask,fname1,frmt1,M,N,offset,swap,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"READC_f")," ",gettext("Read from C binary file")],[gettext("Time Record Selection"),gettext("Outputs Record Selection"),gettext("Input File Name"),gettext("Input Format"),gettext("Record Size"),gettext("Buffer Size"),gettext("Initial Record Index"),gettext("Swap Mode (0:No, 1:Yes)")],list("vec",-1,"vec",-1,"str",1,"str",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
fname1=pathconvert(stripblanks(fname1),None,true);
frmt1=stripblanks(frmt1);
fmts=["s","l","d","f","c","us","ul","uc","ull","uls","ubl","ubs","dl","fl","ll","sl","db","fb","lb","sb"];
nout=size(outmask,"*");
if (prod(size(tmask1))>1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter."),gettext("Time Record Selection")),gettext("Must be a scalar or an empty matrix."));
} else if (and(frmt1!=fmts)) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %s."),gettext("Input Format"),frmt1),gettext("Valid formats are: "+strcat(fmts,", ")));
} else if (alreadyran&&fname1!=fname) {
block_parameter_error(msprintf(gettext("You cannot modify \'%s\' when running"),gettext("Input File Name")),gettext("End current simulation first."));
} else if (N!=ipar(6)&&alreadyran) {
block_parameter_error(msprintf(gettext("You cannot modify \'%s\' when running."),gettext("Buffer Size")),gettext("End current simulation first"));
} else if (alreadyran&&size(tmask1)!=size(tmask)) {
block_parameter_error(msprintf(gettext("You cannot modify \'%s\' when running."),gettext("Time Record Selection")),gettext("End current simulation first."));
} else if (fname1=="") {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter."),gettext("Input File Name")),gettext("You must provide a file name."));
} else if (M<1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Record Size"),M),gettext("Strictly positive integer expected."));
} else if (tmask1!=[]&&(tmask1<1||tmask1>M)) {
block_parameter_error(msprintf(gettext("Wrong value for  \'%s\' parameter: %d."),gettext("Time Record Selection"),tmask1),msprintf(gettext("Must be in the interval %s."),gettext("[1, Record Size = ")+string(M)+"]"));
} else if (nout==0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Outputs Record Selection"),nout),gettext("Strictly positive integer expected."));
} else if (nout>M) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Outputs Record Selection"),nout),msprintf(gettext("Must be in the interval %s."),gettext("[1, Record Size = ")+string(M)+"]"));
} else if (max(outmask)>M||min(outmask)<1) {
block_parameter_error(msprintf(gettext("Wrong value for indexes in \'%s\' parameter: %s."),gettext("Outputs Record Selection"),strcat(string(outmask.slice())," ")),msprintf(gettext("Must be in the interval %s."),gettext("[1, Record Size = ")+string(M)+"]"));
} else if (N<1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Buffer Size"),N),gettext("Strictly positive integer expected."));
} else if (swap!=0&&swap!=1) {
block_parameter_error(msprintf(gettext("Wrong value for  \'%s\' parameter: %d."),gettext("Swap Mode"),swap),msprintf(gettext("Must be in the interval %s."),"[0, 1]"));
} else if (offset<1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Initial Record Index"),offset),gettext("Strictly positive integer expected."));
} else {
if (tmask1==[]) {
ievt=0;
tmask1=0;
outpt=[];
} else {
ievt=1;
outpt=1;
}
out=size(outmask,"*");
[model,graphics,ok]=check_io(model,graphics,[],out,1,outpt);
frmt1=part(frmt1,1,3);
if (ok) {
if (ievt==0) {
model.firing=-1;
} else {
model.firing=0;
}
ipar=[length(fname1),_str2code(frmt1),ievt,N,M,swap,offset,_str2code(fname1),tmask1,outmask.slice()];
if (prod(size(dstate))!=(N*M)+3) {
dstate=[-1,-1,lunit,zeros(N*M,1)];
}
model.dstate=dstate;
model.ipar=ipar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
READC_f.prototype.define = function READC_f() {
frmt="d  ";
fname="foo";
lunit=0;
N=20;
M=1;
rpar=[];
tmask=0;
swap=0;
offset=1;
outmask=1;
ievt=0;
nout=size(outmask,"*");
ipar=[length(fname),_str2code(frmt),ievt,N,M,swap,offset,_str2code(fname),tmask,outmask];
model=scicos_model();
model.sim=list("readc",2);
model.out=nout;
model.evtin=1;
model.evtout=[];
model.dstate=[1,1,lunit,zeros(N*M,1)];
model.ipar=[length(fname),_str2code(frmt),ievt,N,M,swap,offset,_str2code(fname),tmask,outmask];
model.blocktype="d";
model.firing=-1;
model.dep_ut=[None,None];
exprs=["[]",sci2exp(outmask),fname,frmt,string(M),string(N),string(offset),string(swap)];
gr_i=[];
x=standard_define([4,2],model,exprs,gr_i);
}
READC_f.prototype.details = function READC_f() {
}
}
/* autogenerated from "macros/Sources/CLOCK_f.sci" */
function CLOCK_f() {
CLOCK_f.prototype.get = function CLOCK_f() {
}
CLOCK_f.prototype.set = function CLOCK_f() {
for(i=1;i<=length(arg1.model.rpar.objs);i+=1) {
o=arg1.model.rpar.objs(i);
if (typeof(o)=="Block"&&o.gui=="EVTDLY_f") {
path=i;
break
}
}
newpar=list();
xx=arg1.model.rpar.objs(path);
exprs=xx.graphics.exprs;
model=xx.model;
t0_old=model.firing;
dt_old=model.rpar;
model_n=model;
while (true) {
[ok,dt,t0,exprs0]=scicos_getvalue("Set Clock  block parameters",["Period","Init time"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (dt<=0) {
message("period must be positive");
ok=None;
}
if (ok) {
xx.graphics.exprs=exprs0;
model.rpar=dt;
model.firing=t0;
xx.model=model;
arg1.model.rpar.objs[path-1]=xx;
break
}
}
if (!and([t0_old,dt_old]==[t0,dt])||!and(exprs0==exprs)) {
newpar[size(newpar)+1-1]=path;
}
if (t0_old!=t0) {
needcompile=2;
} else {
needcompile=0;
}
x=arg1;
y=needcompile;
typ=newpar;
}
CLOCK_f.prototype.define = function CLOCK_f() {
evtdly=EVTDLY_f("define");
evtdly.graphics.orig=[320,232];
evtdly.graphics.sz=[40,40];
evtdly.graphics.flip=true;
evtdly.graphics.exprs=["0.1","0.1"];
evtdly.graphics.pein=6;
evtdly.graphics.peout=3;
evtdly.model.rpar=0.1;
evtdly.model.firing=0.1;
output_port=CLKOUT_f("define");
output_port.graphics.orig=[399,162];
output_port.graphics.sz=[20,20];
output_port.graphics.flip=true;
output_port.graphics.exprs="1";
output_port.graphics.pein=5;
output_port.model.ipar=1;
split=CLKSPLIT_f("define");
split.graphics.orig=[380.71066,172];
split.graphics.pein=3;
split.graphics.peout=[5,6];
gr_i=[];
diagram=scicos_diagram();
diagram.objs[1-1]=output_port;
diagram.objs[2-1]=evtdly;
diagram.objs[3-1]=scicos_link(xx=[340,340,380.71],yy=[226.29,172,172],ct=[5,-1],from=[2,1],to=[4,1]);
diagram.objs[4-1]=split;
diagram.objs[5-1]=scicos_link(xx=[380.71,399],yy=[172,172],ct=[5,-1],from=[4,1],to=[1,1]);
diagram.objs[6-1]=scicos_link(xx=[380.71,380.71,340,340],yy=[172,302,302,277.71],ct=[5,-1],from=[4,2],to=[2,1]);
x=scicos_block();
x.gui="CLOCK_f";
x.graphics.sz=[2,2];
x.graphics.gr_i=gr_i;
x.graphics.peout=0;
x.model.sim="csuper";
x.model.evtout=1;
x.model.blocktype="h";
x.model.firing=None;
x.model.dep_ut=[None,None];
x.model.rpar=diagram;
}
CLOCK_f.prototype.details = function CLOCK_f() {
}
}
/* autogenerated from "macros/Sources/CONST.sci" */
function CONST() {
CONST.prototype.get = function CONST() {
}
CONST.prototype.set = function CONST() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,C,exprs]=scicos_getvalue(["Set Contant Block"],"Constant",list("vec",-1),exprs);
if (!ok) {
break
}
sz=size(C);
nout=size(C,"*");
if (nout==0) {
message("C must have at least one element");
} else if (and(sz>1)) {
message("C matrix is not supported, use CONST_m instead");
} else {
model.rpar=C.slice();
model.out=nout;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CONST.prototype.define = function CONST() {
C=1;
model=scicos_model();
model.sim=list("cstblk4",4);
model.in1=[];
model.out=1;
model.rpar=C;
model.blocktype="d";
model.dep_ut=[None,None];
exprs=strcat(sci2exp(C));
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CONST.prototype.details = function CONST() {
}
}
/* autogenerated from "macros/Sources/Modulo_Count.sci" */
function Modulo_Count() {
Modulo_Count.prototype.get = function Modulo_Count() {
}
Modulo_Count.prototype.set = function Modulo_Count() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,ini_c,base,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"Modulo_Count")," ",gettext("Modulo counter (0 to N counter)")," "],[gettext("Initial State (zero or positive number)"),gettext("Upper Limit (positive number)")],list("vec",1,"vec",1),exprs);
ini_c=int(ini_c);
base=int(base);
if (!ok) {
break
}
if (ini_c<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'Initial State\' parameter: %d."),ini_c),gettext("Null or positive integer expected."));
} else if (base<=0) {
block_parameter_error(msprintf(gettext("Wrong values for \'Upper Limit\' parameter: %d."),base),gettext("Strictly positive integer expected."));
} else {
graphics.exprs=exprs;
model.ipar=base;
model.dstate=ini_c;
x.graphics=graphics;
x.model=model;
break
}
}
}
Modulo_Count.prototype.define = function Modulo_Count() {
ini_c=0;
base=3;
model=scicos_model();
model.sim=list("modulo_count",4);
model.evtin=1;
model.out=1;
model.dstate=ini_c;
model.ipar=base;
model.blocktype="c";
model.dep_ut=[None,None];
exprs=[string(ini_c),string(base)];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
Modulo_Count.prototype.details = function Modulo_Count() {
}
}
/* autogenerated from "macros/Sources/CONST_m.sci" */
function CONST_m() {
CONST_m.prototype.get = function CONST_m() {
}
CONST_m.prototype.set = function CONST_m() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,C,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"CONST_m")," ",gettext("Constant value generator")," "],gettext("Constant Value"),list("vec",-1),exprs);
if (!ok) {
break
}
nout=size(C);
if (find(nout==0)!=[]) {
block_parameter_error(msprintf(gettext("Wrong size for \'%s\' parameter"),gettext("Constant Value")),gettext("Constant value must have at least one element."));
} else {
model.sim=list("cstblk4_m",4);
model.opar=list(C);
if ((type(C)==1)) {
if (isreal(C)) {
ot=1;
} else {
ot=2;
}
} else if ((typeof(C)=="int32")) {
ot=3;
} else if ((typeof(C)=="int16")) {
ot=4;
} else if ((typeof(C)=="int8")) {
ot=5;
} else if ((typeof(C)=="uint32")) {
ot=6;
} else if ((typeof(C)=="uint16")) {
ot=7;
} else if ((typeof(C)=="uint8")) {
ot=8;
} else {
block_parameter_error(msprintf(gettext("Wrong type for \'%s\' parameter"),gettext("Constant Value")),gettext("Value type must be a numeric type (double, complex, int, int8, ...)."));
ok=None;
}
if (ok) {
model.rpar=[];
[model,graphics,ok]=set_io(model,graphics,list(),list(nout,ot),[],[]);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
CONST_m.prototype.define = function CONST_m() {
C=[1];
model=scicos_model();
model.sim=list("cstblk4",4);
model.in1=[];
model.out=size(C,1);
model.in2=[];
model.out2=size(C,2);
model.rpar=C;
model.opar=list();
model.blocktype="d";
model.dep_ut=[None,None];
exprs=sci2exp(C);
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
CONST_m.prototype.details = function CONST_m() {
}
}
/* autogenerated from "macros/Sources/CLKINV_f.sci" */
function CLKINV_f() {
CLKINV_f.prototype.get = function CLKINV_f() {
}
CLKINV_f.prototype.set = function CLKINV_f() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
exprs=exprs(1);
while (true) {
[ok,prt,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"CLKINV_f")," ",gettext("Event input port")," "],"Port Number",list("vec",1),exprs);
prt=int(prt);
if (!ok) {
break
}
if (prt<=0) {
block_parameter_error(msprintf(gettext("Wrong values for \'Port Number\' parameter: %d."),prt),gettext("Strictly positive integer expected."));
} else {
model.ipar=prt;
model.evtout=1;
model.firing=-1;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CLKINV_f.prototype.define = function CLKINV_f() {
prt=1;
model=scicos_model();
model.sim="input";
model.evtout=1;
model.ipar=prt;
model.blocktype="d";
model.firing=-1;
model.dep_ut=[None,None];
exprs=string(prt);
gr_i=[];
x=standard_define([1,1],model,exprs,gr_i);
}
CLKINV_f.prototype.details = function CLKINV_f() {
}
}
/* autogenerated from "macros/Sources/FROMWSB.sci" */
function FROMWSB() {
FROMWSB.prototype.get = function FROMWSB() {
}
FROMWSB.prototype.set = function FROMWSB() {
for(i=1;i<=length(arg1.model.rpar.objs);i+=1) {
o=arg1.model.rpar.objs(i);
if (typeof(o)=="Block"&&o.gui=="FROMWS_c") {
ppath=list(i);
break
}
}
newpar=list();
y=0;
for(path in ppath) {
np=size(path,"*");
spath=list();
for(k=1;k<=np;k+=1) {
spath[$+1-1]="model";
spath[$+1-1]="rpar";
spath[$+1-1]="objs";
spath[$+1-1]=path(k);
}
xx=arg1(spath);
execstr("xxn="+xx.gui+"(\'set\',xx)");
if (!isequalbitwise(xxn,xx)) {
model=xx.model;
model_n=xxn.model;
if (!is_modelica_block(xx)) {
modified=or(model.sim!=model_n.sim)||!isequal(model.state,model_n.state)||!isequal(model.dstate,model_n.dstate)||!isequal(model.odstate,model_n.odstate)||!isequal(model.rpar,model_n.rpar)||!isequal(model.ipar,model_n.ipar)||!isequal(model.opar,model_n.opar)||!isequal(model.label,model_n.label);
if (or(model.in1!=model_n.in1)||or(model.out!=model_n.out)||or(model.in2!=model_n.in2)||or(model.out2!=model_n.out2)||or(model.outtyp!=model_n.outtyp)||or(model.intyp!=model_n.intyp)) {
needcompile=1;
}
if (or(model.firing!=model_n.firing)) {
needcompile=2;
}
if ((size(model.in1,"*")!=size(model_n.in1,"*"))||(size(model.out,"*")!=size(model_n.out,"*"))) {
needcompile=4;
}
if (model.sim=="input"||model.sim=="output") {
if (model.ipar!=model_n.ipar) {
needcompile=4;
}
}
if (or(model.blocktype!=model_n.blocktype)||or(model.dep_ut!=model_n.dep_ut)) {
needcompile=4;
}
if ((model.nzcross!=model_n.nzcross)||(model.nmode!=model_n.nmode)) {
needcompile=4;
}
if (prod(size(model_n.sim))>1) {
if (model_n.sim(2)>1000) {
if (model.sim(1)!=model_n.sim(1)) {
needcompile=4;
}
}
}
} else {
modified=or(model_n!=model);
eq=model.equations;
eqn=model_n.equations;
if (or(eq.model!=eqn.model)||or(eq.inputs!=eqn.inputs)||or(eq.outputs!=eqn.outputs)) {
needcompile=4;
}
}
arg1[spath-1]=xxn;
newpar[size(newpar)+1-1]=path;
y=max(y,needcompile);
}
}
x=arg1;
typ=newpar;
}
FROMWSB.prototype.define = function FROMWSB() {
scs_m_1=scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[-159.096,811.104,-121.216,617.984,1323,1008,331,284,630,480,1426,231,1.4],Title="FROMWSB",tol=[0.0001,0.000001,1.000e-10,100001,0,0],tf=100000,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
scs_m_1.objs[1-1]=scicos_block(gui="FROMWS_c",graphics=scicos_graphics(orig=[260.37067,261.584],sz=[70,40],flip=true,theta=0,exprs=["V","1","1","0"],pin=[],pout=4,pein=2,peout=2,gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim=list("fromws_c",4),in1=[],in2=[],intyp=1,out=-1,out2=-2,outtyp=-1,evtin=1,evtout=1,state=[],dstate=[],odstate=list(),rpar=[],ipar=[1,-31,1,1,0],opar=list(),blocktype="d",firing=0,dep_ut=[None,true],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m_1.objs[2-1]=scicos_link(xx=[295.37067,295.37067,233.23733,233.23733,295.37067,295.37067],yy=[255.86971,223.45067,223.45067,337.85067,337.85067,307.29829],id="drawlink",thick=[0,0],ct=[5,-1],from=[1,1,0],to=[1,1,1]);
scs_m_1.objs[3-1]=scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[358.9421,271.584],sz=[20,20],flip=true,theta=0,exprs="1",pin=4,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=-2,intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m_1.objs[4-1]=scicos_link(xx=[338.9421,358.9421],yy=[281.584,281.584],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[3,1,1]);
model=scicos_model(sim="csuper",in1=[],in2=[],intyp=1,out=-1,out2=-2,outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=scs_m_1,ipar=[],opar=list(),blocktype="h",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list());
gr_i=[];
x=standard_define([5,2],model,[],gr_i);
}
FROMWSB.prototype.details = function FROMWSB() {
}
}
/* autogenerated from "macros/Sources/GENSIN_f.sci" */
function GENSIN_f() {
GENSIN_f.prototype.get = function GENSIN_f() {
}
GENSIN_f.prototype.set = function GENSIN_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,M,F,P,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"GENSIN_f")," ",gettext("Sine wave generator")," "],[gettext("Magnitude"),gettext("Frequency (rad/s)"),gettext("Phase (rad)")],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (F<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'Frequency\' parameter: %e."),F),gettext("Strictly positive integer expected."));
ok=None;
}
if (ok) {
[model,graphics,ok]=check_io(model,graphics,[],1,[],[]);
model.rpar=[M,F,P];
model.out2=1;
model.outtyp=1;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
GENSIN_f.prototype.define = function GENSIN_f() {
rpar=[1,1,0];
model=scicos_model();
model.sim="gensin";
model.in1=[];
model.out=1;
model.out2=1;
model.outtyp=1;
model.rpar=[1,1,0];
model.blocktype="c";
model.dep_ut=[None,true];
exprs=[string(rpar(1)),string(rpar(2)),string(rpar(3))];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
GENSIN_f.prototype.details = function GENSIN_f() {
}
}
/* autogenerated from "macros/MatrixOp/MATMUL.sci" */
function MATMUL() {
MATMUL.prototype.get = function MATMUL() {
}
MATMUL.prototype.set = function MATMUL() {
x=arg1;
graphics=x.graphics;
label=graphics.exprs;
model=x.model;
if (model.ipar==[]) {
model.ipar=1;
}
if (size(label,"*")==1) {
label[2-1]=sci2exp(1);
}
if (size(label,"*")==2) {
label[3-1]=sci2exp(1);
}
while (true) {
[ok,dtype,rule,np,exprs]=scicos_getvalue(["Set MATMUL parameter","For the Multipication rule:","    1= Matrix by Matrix","    2= Matrix by Matrix element wise ","    3= Matrix by Scalar","In the third case the second input will be the scalar"],["Datatype(1=real double 2=Complex 3=int32 ...)","Multiplication rule","Do on Overflow(0=Nothing 1=Saturate 2=Error)"],list("vec",1,"vec",1,"vec",1),label);
if (!ok) {
break
}
rule=int(rule);
if ((dtype<1||dtype>8)) {
message("type is not supported");
ok=None;
}
if ((rule<1||rule>3)) {
message("Multiplication rule must be only 1,2 or 3");
ok=None;
}
if ((dtype==1||dtype==2)) {
np=0;
}
TABMIN=[0,0,-(2^31),-(2^15),-(2^7),0,0,0];
TABMAX=[0,0,(2^31)-1,(2^15)-1,(2^7)-1,(2^32)-1,(2^16)-1,(2^8)-1];
if (rule==2) {
if (np==0) {
model.sim=list("matmul2_m",4);
} else if (np==1) {
model.sim=list("matmul2_s",4);
} else {
model.sim=list("matmul2_e",4);
}
} else if (rule==3) {
if (np==0) {
model.sim=list("matbyscal",4);
} else if (np==1) {
model.sim=list("matbyscal_s",4);
} else {
model.sim=list("matbyscal_e",4);
}
} else {
if ((dtype==1)) {
model.sim=list("matmul_m",4);
} else if ((dtype==2)) {
model.sim=list("matzmul_m",4);
} else if (dtype==3) {
if (np==0) {
model.sim=list("matmul_i32n",4);
} else if (np==1) {
model.sim=list("matmul_i32s",4);
} else {
model.sim=list("matmul_i32e",4);
}
} else if (dtype==4) {
if (np==0) {
model.sim=list("matmul_i16n",4);
} else if (np==1) {
model.sim=list("matmul_i16s",4);
} else {
model.sim=list("matmul_i16e",4);
}
} else if (dtype==5) {
if (np==0) {
model.sim=list("matmul_i8n",4);
} else if (np==1) {
model.sim=list("matmul_i8s",4);
} else {
model.sim=list("matmul_i8e",4);
}
} else if (dtype==6) {
if (np==0) {
model.sim=list("matmul_ui32n",4);
} else if (np==1) {
model.sim=list("matmul_ui32s",4);
} else {
model.sim=list("matmul_ui32e",4);
}
} else if (dtype==7) {
if (np==0) {
model.sim=list("matmul_ui16n",4);
} else if (np==1) {
model.sim=list("matmul_ui16s",4);
} else {
model.sim=list("matmul_ui16e",4);
}
} else if (dtype==8) {
if (np==0) {
model.sim=list("matmul_ui8n",4);
} else if (np==1) {
model.sim=list("matmul_ui8s",4);
} else {
model.sim=list("matmul_ui8e",4);
}
}
}
kmin=TABMIN(dtype);
kmax=TABMAX(dtype);
it=dtype*ones(1,2);
ot=dtype;
if (rule==1) {
in1=[-1,-2,-2,-3];
out=[-1,-3];
} else if (rule==2) {
in1=[-1,-2,-1,-2];
out=[-1,-2];
} else {
in1=[-1,-2,1,1];
out=[-1,-2];
}
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
if (ok) {
label=exprs;
model.ipar=rule;
model.rpar=[kmin,kmax];
graphics.exprs=label;
x.graphics=graphics;
x.model=model;
arg1=x;
break
}
}
}
MATMUL.prototype.define = function MATMUL() {
model=scicos_model();
model.sim=list("matmul_m",4);
model.in1=[-1,-2];
model.in2=[-2,-3];
model.out=-1;
model.out2=-3;
model.dep_ut=[true,None];
model.ipar=1;
label=[sci2exp(model.ipar)];
gr_i=[];
x=standard_define([3,2],model,label,gr_i);
}
MATMUL.prototype.details = function MATMUL() {
}
}
/* autogenerated from "macros/MatrixOp/MATMAGPHI.sci" */
function MATMAGPHI() {
MATMAGPHI.prototype.get = function MATMAGPHI() {
}
MATMAGPHI.prototype.set = function MATMAGPHI() {
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
label=graphics.exprs;
if (size(label,"*")==14) {
label[9-1]=[];
}
while (true) {
[ok,decomptyp,lab]=scicos_getvalue("Set MATMAGPHI block parameters",["decomposition type (1=Complex2MAG&PHI 2=MAG&PHI2Complex)"],list("vec",1),label);
if (!ok) {
break
}
label=lab;
if ((decomptyp==1)) {
function_name="matz_abs";
in1=[-1,-2];
it=2;
out=[-1,-2,-1,-2];
ot=[1,1];
} else if ((decomptyp==2)) {
function_name="matz_absc";
in1=[-1,-2,-1,-2];
it=[1,1];
out=[-1,-2];
ot=2;
} else {
message("decomposition type is not supported");
ok=None;
}
funtyp=4;
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
if (ok) {
model.sim=list(function_name,funtyp);
arg1.model=model;
graphics.exprs=label;
arg1.graphics=graphics;
x=arg1;
break
}
}
}
MATMAGPHI.prototype.define = function MATMAGPHI() {
model=scicos_model();
function_name="matz_abs";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in1=-1;
model.in2=-2;
model.intyp=2;
model.out=[-1,-1];
model.out2=[-2,-2];
model.outtyp=[1,1];
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1)];
gr_i=[];
x=standard_define([3,2],model,label,gr_i);
}
MATMAGPHI.prototype.details = function MATMAGPHI() {
}
}
/* autogenerated from "macros/MatrixOp/SQRT.sci" */
function SQRT() {
SQRT.prototype.get = function SQRT() {
}
SQRT.prototype.set = function SQRT() {
x=arg1;
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
while (true) {
[ok,typ,exprs]=scicos_getvalue("Set SQRT Block",["Datatype(1=real double  2=Complex)"],list("vec",1),label);
if (!ok) {
break
}
if ((typ==1)) {
function_name="mat_sqrt";
} else if ((typ==2)) {
function_name="matz_sqrt";
} else {
message("type is not supported");
ok=None;
}
it=typ;
ot=typ;
in1=[model.in1,model.in2];
out=[model.out,model.out2];
funtyp=4;
if (ok) {
label=exprs;
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
model.sim=list(function_name,funtyp);
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
SQRT.prototype.define = function SQRT() {
model=scicos_model();
model.sim=list("mat_sqrt",4);
model.in1=-1;
model.in2=-2;
model.intyp=1;
model.outtyp=1;
model.out=-1;
model.out2=-2;
model.dep_ut=[true,None];
label=[sci2exp(1)];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
SQRT.prototype.details = function SQRT() {
}
}
/* autogenerated from "macros/MatrixOp/MATEXPM.sci" */
function MATEXPM() {
MATEXPM.prototype.get = function MATEXPM() {
}
MATEXPM.prototype.set = function MATEXPM() {
x=arg1;
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
if (size(label,"*")==14) {
label[9-1]=[];
}
while (true) {
[ok,typ,exprs]=scicos_getvalue("Set EXPM Block",["Datatype(1=real double  2=Complex)"],list("vec",1),label);
if (!ok) {
break
}
if ((typ==1)) {
function_name="mat_expm";
ot=1;
it=1;
} else if ((typ==2)) {
function_name="matz_expm";
ot=2;
it=2;
} else {
message("Datatype is not supported");
ok=None;
}
in1=[model.in1,model.in2];
out=[model.out,model.out2];
funtyp=4;
if (ok) {
label=exprs;
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
model.sim=list(function_name,funtyp);
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
MATEXPM.prototype.define = function MATEXPM() {
model=scicos_model();
function_name="mat_expm";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in1=-1;
model.in2=-1;
model.intyp=1;
model.out=-1;
model.out2=-1;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1)];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
MATEXPM.prototype.details = function MATEXPM() {
}
}
/* autogenerated from "macros/MatrixOp/MATPINV.sci" */
function MATPINV() {
MATPINV.prototype.get = function MATPINV() {
}
MATPINV.prototype.set = function MATPINV() {
x=arg1;
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
if (size(label,"*")==14) {
label[9-1]=[];
}
while (true) {
[ok,typ,exprs]=scicos_getvalue("Set MATPINV Block",["Datatype(1=real double  2=Complex)"],list("vec",1),label);
if (!ok) {
break
}
if ((typ==1)) {
function_name="mat_pinv";
ot=1;
it=1;
} else if ((typ==2)) {
function_name="matz_pinv";
ot=2;
it=2;
} else {
message("Datatype is not supported");
ok=None;
}
in1=[model.in1,model.in2];
out=[model.out,model.out2];
funtyp=4;
if (ok) {
label=exprs;
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
model.sim=list(function_name,funtyp);
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
MATPINV.prototype.define = function MATPINV() {
model=scicos_model();
function_name="mat_pinv";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in1=-1;
model.in2=-2;
model.intyp=1;
model.out=-2;
model.out2=-1;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1)];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
MATPINV.prototype.details = function MATPINV() {
}
}
/* autogenerated from "macros/MatrixOp/MATDIAG.sci" */
function MATDIAG() {
MATDIAG.prototype.get = function MATDIAG() {
}
MATDIAG.prototype.set = function MATDIAG() {
x=arg1;
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
if (size(label,"*")==14) {
label[9-1]=[];
}
while (true) {
[ok,typ,exprs]=scicos_getvalue("Set MATDIAG Block",["Datatype (1=real double  2=Complex)"],list("vec",1),label);
if (!ok) {
break
}
if ((typ==1)) {
function_name="mat_diag";
ot=1;
it=1;
} else if ((typ==2)) {
function_name="matz_diag";
ot=2;
it=2;
} else {
message("Datatype is not supported");
ok=None;
}
in1=[model.in1,model.in2];
out=[model.out,model.out2];
funtyp=4;
if (ok) {
label=exprs;
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
model.sim=list(function_name,funtyp);
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
MATDIAG.prototype.define = function MATDIAG() {
model=scicos_model();
function_name="mat_diag";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in1=-1;
model.in2=1;
model.intyp=1;
model.out=-1;
model.out2=-1;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1)];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
MATDIAG.prototype.details = function MATDIAG() {
}
}
/* autogenerated from "macros/MatrixOp/MATZCONJ.sci" */
function MATZCONJ() {
MATZCONJ.prototype.get = function MATZCONJ() {
}
MATZCONJ.prototype.set = function MATZCONJ() {
x=arg1;
}
MATZCONJ.prototype.define = function MATZCONJ() {
model=scicos_model();
function_name="matz_conj";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in1=-1;
model.in2=-2;
model.intyp=2;
model.out=-1;
model.out2=-2;
model.outtyp=2;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
MATZCONJ.prototype.details = function MATZCONJ() {
}
}
/* autogenerated from "macros/MatrixOp/MATINV.sci" */
function MATINV() {
MATINV.prototype.get = function MATINV() {
}
MATINV.prototype.set = function MATINV() {
x=arg1;
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
if (size(label,"*")==14) {
label[9-1]=[];
}
while (true) {
[ok,typ,exprs]=scicos_getvalue("Set MATINV Block",["Datatype(1=real double  2=Complex)"],list("vec",1),label);
if (!ok) {
break
}
if ((typ==1)) {
function_name="mat_inv";
ot=1;
it=1;
} else if ((typ==2)) {
function_name="matz_inv";
ot=2;
it=2;
} else {
message("Datatype is not supported");
ok=None;
}
in1=[model.in1,model.in2];
out=[model.out,model.out2];
funtyp=4;
if (ok) {
label=exprs;
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
model.sim=list(function_name,funtyp);
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
MATINV.prototype.define = function MATINV() {
model=scicos_model();
function_name="mat_inv";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in1=-1;
model.in2=-1;
model.intyp=1;
model.out=-1;
model.out2=-1;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1)];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
MATINV.prototype.details = function MATINV() {
}
}
/* autogenerated from "macros/MatrixOp/MATLU.sci" */
function MATLU() {
MATLU.prototype.get = function MATLU() {
}
MATLU.prototype.set = function MATLU() {
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
label=graphics.exprs;
if (size(label,"*")==14) {
label[9-1]=[];
}
while (true) {
[ok,typ,lab]=scicos_getvalue("Set MATLU block parameters",["Datatype(1=real double  2=Complex)"],list("vec",1),label);
if (!ok) {
break
}
if ((typ==1)) {
function_name="mat_lu";
ot=[1,1];
it=1;
} else if ((typ==2)) {
function_name="matz_lu";
ot=[2,2];
it=2;
} else {
message("Datatype is not supported");
ok=None;
}
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list([model.in1,model.in2],it),list([model.out,model.out2],ot),[],[]);
}
if (ok) {
funtyp=4;
model.sim=list(function_name,funtyp);
graphics.exprs=lab;
x.graphics=graphics;
x.model=model;
break
}
}
}
MATLU.prototype.define = function MATLU() {
model=scicos_model();
function_name="mat_lu";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in1=-1;
model.in2=-1;
model.intyp=1;
model.out=[-1,-1];
model.out2=[-1,-1];
model.outtyp=[1,1];
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=sci2exp(1);
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
MATLU.prototype.details = function MATLU() {
}
}
/* autogenerated from "macros/MatrixOp/MATSUM.sci" */
function MATSUM() {
MATSUM.prototype.get = function MATSUM() {
}
MATSUM.prototype.set = function MATSUM() {
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
label=graphics.exprs;
if (size(label,"*")==14) {
label[9-1]=[];
}
while (true) {
[ok,typ,decomptyp,lab]=scicos_getvalue("Set MATSUM block parameters",["Datatype(1=real double  2=Complex)","Sum along (0=all 1=lines  2=Columns)"],list("vec",1,"vec",1),label);
if (!ok) {
break
}
label=lab;
if ((typ==1)) {
if ((decomptyp==0)) {
function_name="mat_sum";
out=[1,1];
} else if ((decomptyp==2)) {
function_name="mat_suml";
out=[-1,1];
} else if ((decomptyp==1)) {
function_name="mat_sumc";
out=[1,-2];
} else {
message("decomposition type is not supported");
ok=None;
}
it=1;
ot=1;
} else if ((typ==2)) {
if ((decomptyp==0)) {
function_name="matz_sum";
out=[1,1];
} else if ((decomptyp==2)) {
function_name="matz_suml";
out=[-1,1];
} else if ((decomptyp==1)) {
function_name="matz_sumc";
out=[1,-2];
} else {
message("decomposition type is not supported");
ok=None;
}
it=2;
ot=2;
} else {
message("Datatype is not supported");
ok=None;
}
in1=[model.in1,model.in2];
funtyp=4;
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
if (ok) {
model.sim=list(function_name,funtyp);
arg1.model=model;
graphics.exprs=label;
arg1.graphics=graphics;
x=arg1;
break
}
}
}
MATSUM.prototype.define = function MATSUM() {
model=scicos_model();
function_name="mat_sum";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in1=-1;
model.in2=-2;
model.intyp=1;
model.out=1;
model.out2=1;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1),sci2exp(0)];
gr_i=[];
x=standard_define([3,2],model,label,gr_i);
}
MATSUM.prototype.details = function MATSUM() {
}
}
/* autogenerated from "macros/MatrixOp/MATBKSL.sci" */
function MATBKSL() {
MATBKSL.prototype.get = function MATBKSL() {
}
MATBKSL.prototype.set = function MATBKSL() {
x=arg1;
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
if (size(label,"*")==14) {
label[9-1]=[];
}
while (true) {
[ok,typ,exprs]=scicos_getvalue("Set MATBKSL Block",["Datatype (1=real double  2=Complex)"],list("vec",1),label);
if (!ok) {
break
}
if ((typ==1)) {
function_name="mat_bksl";
ot=1;
it=[1,1];
} else if ((typ==2)) {
function_name="matz_bksl";
ot=2;
it=[2,2];
} else {
message("Datatype is not supported");
ok=None;
}
in1=[model.in1,model.in2];
out=[model.out,model.out2];
funtyp=4;
if (ok) {
label=exprs;
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
model.sim=list(function_name,funtyp);
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
MATBKSL.prototype.define = function MATBKSL() {
model=scicos_model();
function_name="mat_bksl";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in1=[-1,-1];
model.in2=[-2,-3];
model.intyp=[1,1];
model.out=-2;
model.out2=-3;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1)];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
MATBKSL.prototype.details = function MATBKSL() {
}
}
/* autogenerated from "macros/MatrixOp/MATRESH.sci" */
function MATRESH() {
MATRESH.prototype.get = function MATRESH() {
}
MATRESH.prototype.set = function MATRESH() {
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
label=graphics.exprs;
if (size(label,"*")==14) {
label[9-1]=[];
}
while (true) {
[ok,typ,l1,out,lab]=scicos_getvalue("Set MATRESH block parameters",["Datatype(1=real double  2=Complex)","input size","output size desired"],list("vec",-1,"vec",-1,"vec",-1),label);
if (!ok) {
break
}
nout=size(out);
nin=size(l1);
if (nout==0) {
message("output must have at least one element");
ok=None;
}
if (nin==0) {
message("input must have at least one element");
ok=None;
}
if (ok) {
if (((out(1)>(l1(1)*l1(2))))) {
message("the first dimension of the output is too big");
ok=None;
}
if (((out(2)>(l1(1)*l1(2))))) {
message("the second dimension of the output is too big");
ok=None;
}
if ((((out(2)*out(1))>(l1(1)*l1(2))))) {
message("the dimensions of the output are too big");
ok=None;
}
}
if ((typ==1)) {
function_name="mat_reshape";
ot=1;
it=1;
} else if ((typ==2)) {
function_name="matz_reshape";
ot=2;
it=2;
} else {
message("Datatype is not supported");
ok=None;
}
if (ok) {
label=lab;
[model,graphics,ok]=set_io(model,graphics,list(l1,it),list(out,ot),[],[]);
}
if (ok) {
funtyp=4;
model.sim=list(function_name,funtyp);
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
needcompile=resume(needcompile)
}
MATRESH.prototype.define = function MATRESH() {
model=scicos_model();
function_name="mat_reshape";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in1=-1;
model.in2=-2;
model.intyp=1;
model.out=-1;
model.out2=-2;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1),sci2exp([1,1]),sci2exp([1,1])];
gr_i=[];
x=standard_define([3,2],model,label,gr_i);
}
MATRESH.prototype.details = function MATRESH() {
}
}
/* autogenerated from "macros/MatrixOp/MATTRAN.sci" */
function MATTRAN() {
MATTRAN.prototype.get = function MATTRAN() {
}
MATTRAN.prototype.set = function MATTRAN() {
x=arg1;
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
if (size(label,"*")==1) {
label[2-1]=sci2exp(1);
}
while (true) {
[ok,typ,rule,exprs]=scicos_getvalue("Set MATTRAN Block",["Datatype(1=real double 2=Complex)","rule (1=.\' 2=\')"],list("vec",1,"vec",1),label);
if (!ok) {
break
}
if ((typ==1)) {
function_name="mattran_m";
ot=1;
it=1;
} else if ((typ==2)) {
if (rule==1) {
function_name="matztran_m";
} else {
function_name="mathermit_m";
}
ot=2;
it=2;
} else {
message("Datatype is not supported");
ok=None;
}
in1=[model.in1,model.in2];
out=[model.out,model.out2];
funtyp=4;
if (ok) {
label=exprs;
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
model.sim=list(function_name,funtyp);
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
MATTRAN.prototype.define = function MATTRAN() {
model=scicos_model();
model.sim=list("mattran_m",4);
model.in1=-1;
model.in2=-2;
model.out=-2;
model.out2=-1;
model.dep_ut=[true,None];
label=[sci2exp(1)];
gr_i=[];
x=standard_define([3,2],model,label,gr_i);
}
MATTRAN.prototype.details = function MATTRAN() {
}
}
/* autogenerated from "macros/MatrixOp/RICC.sci" */
function RICC() {
RICC.prototype.get = function RICC() {
}
RICC.prototype.set = function RICC() {
x=arg1;
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
if (size(label,"*")==14) {
label[9-1]=[];
}
while (true) {
[ok,tpe,mod,exprs]=scicos_getvalue("Set RICC Block",["Type (1=Cont  2=Disc)","Model(1=Schr  2=sign(cont) inv(disc))"],list("vec",1,"vec",1),label);
if (!ok) {
break
}
in1=[model.in1,model.in2];
out=[model.out,model.out2];
it=[1,1,1];
ot=1;
label=exprs;
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
if (ok) {
model.ipar=[tpe,mod];
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
RICC.prototype.define = function RICC() {
model=scicos_model();
function_name="ricc_m";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in1=[-1,-1,-1];
model.in2=[-1,-1,-1];
model.intyp=[1,1,1];
model.out=-1;
model.out2=-1;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[1,1];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1),sci2exp(1)];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
RICC.prototype.details = function RICC() {
}
}
/* autogenerated from "macros/MatrixOp/MATZREIM.sci" */
function MATZREIM() {
MATZREIM.prototype.get = function MATZREIM() {
}
MATZREIM.prototype.set = function MATZREIM() {
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
label=graphics.exprs;
if (size(label,"*")==14) {
label[9-1]=[];
}
while (true) {
[ok,decomptyp,lab]=scicos_getvalue("Set MATZREIM block parameters",["decomposition type (1=Complex2Real&Imag 2=Real&Imag2Complex)"],list("vec",1),label);
if (!ok) {
break
}
label=lab;
if ((decomptyp==1)) {
function_name="matz_reim";
in1=[-1,-2];
it=2;
out=[-1,-2,-1,-2];
ot=[1,1];
} else if ((decomptyp==2)) {
function_name="matz_reimc";
in1=[-1,-2,-1,-2];
it=[1,1];
out=[-1,-2];
ot=2;
} else {
message("decomposition type is not supported");
ok=None;
}
funtyp=4;
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
if (ok) {
model.sim=list(function_name,funtyp);
arg1.model=model;
graphics.exprs=label;
arg1.graphics=graphics;
x=arg1;
break
}
}
}
MATZREIM.prototype.define = function MATZREIM() {
model=scicos_model();
function_name="matz_reim";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in1=-1;
model.in2=-2;
model.intyp=2;
model.out=[-1,-1];
model.out2=[-2,-2];
model.outtyp=[1,1];
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=sci2exp(1);
gr_i=[];
x=standard_define([3,2],model,label,gr_i);
}
MATZREIM.prototype.details = function MATZREIM() {
}
}
/* autogenerated from "macros/MatrixOp/MATSING.sci" */
function MATSING() {
MATSING.prototype.get = function MATSING() {
}
MATSING.prototype.set = function MATSING() {
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
label=graphics.exprs;
if (size(label,"*")==14) {
label[9-1]=[];
}
while (true) {
[ok,typ,decomptyp,lab]=scicos_getvalue("Set MATSVD block parameters",["Datatype(1=real double  2=Complex)","decomposition type (1=singular values  2=sing values+matrix U & V)"],list("vec",1,"vec",1),label);
if (!ok) {
break
}
label=lab;
if ((typ==1)) {
if ((decomptyp==1)) {
function_name="mat_sing";
in1=[-1,-2];
out=[-1,1];
ot=1;
} else if ((decomptyp==2)) {
function_name="mat_svd";
in1=[-1,-2];
out=[-1,-1,-1,-2,-2,-2];
ot=[1,1,1];
} else {
message("decomposition type is not supported");
ok=None;
}
it=1;
} else if ((typ==2)) {
if ((decomptyp==1)) {
function_name="matz_sing";
in1=[-1,-2];
out=[-1,1];
ot=1;
} else if ((decomptyp==2)) {
function_name="matz_svd";
in1=[-1,-2];
out=[-1,-1,-1,-2,-2,-2];
ot=[2,1,2];
} else {
message("decomposition type is not supported");
ok=None;
}
it=2;
} else {
message("Datatype is not supported");
ok=None;
}
funtyp=4;
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
if (ok) {
model.sim=list(function_name,funtyp);
arg1.model=model;
graphics.exprs=label;
arg1.graphics=graphics;
x=arg1;
break
}
}
}
MATSING.prototype.define = function MATSING() {
model=scicos_model();
function_name="mat_sing";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in1=-1;
model.in2=-2;
model.intyp=1;
model.out=-1;
model.out2=1;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1),sci2exp(1)];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
MATSING.prototype.details = function MATSING() {
}
}
/* autogenerated from "macros/MatrixOp/MATDET.sci" */
function MATDET() {
MATDET.prototype.get = function MATDET() {
}
MATDET.prototype.set = function MATDET() {
x=arg1;
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
if (size(label,"*")==14) {
label[9-1]=[];
}
while (true) {
[ok,typ,exprs]=scicos_getvalue("Set MATDET Block",["Datatype(1=real double  2=Complex)"],list("vec",1),label);
if (!ok) {
break
}
if ((typ==1)) {
function_name="mat_det";
ot=1;
it=1;
} else if ((typ==2)) {
function_name="matz_det";
ot=2;
it=2;
} else {
message("Datatype is not supported");
ok=None;
}
in1=[model.in1,model.in2];
out=[model.out,model.out2];
funtyp=4;
if (ok) {
label=exprs;
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
model.sim=list(function_name,funtyp);
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
MATDET.prototype.define = function MATDET() {
model=scicos_model();
function_name="mat_det";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in1=-1;
model.in2=-1;
model.intyp=1;
model.out=1;
model.out2=1;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1)];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
MATDET.prototype.details = function MATDET() {
}
}
/* autogenerated from "macros/MatrixOp/SUBMAT.sci" */
function SUBMAT() {
SUBMAT.prototype.get = function SUBMAT() {
}
SUBMAT.prototype.set = function SUBMAT() {
x=arg1;
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
if (size(label,"*")==5) {
label[6-1]=sci2exp([1,1]);
}
while (true) {
[ok,typ,a,b,c,d,inp,exprs]=scicos_getvalue("Set SUBMAT Block",["Datatype (1=real double  2=Complex)","Starting Row Index","Ending Row Index","Starting Column Index","Ending Column Index","Input Dimensions"],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",2),label);
if (!ok) {
break
}
if ((typ==1)) {
function_name="submat";
ot=1;
it=1;
} else if ((typ==2)) {
function_name="submatz";
ot=2;
it=2;
} else {
message("Datatype is not supported");
ok=None;
}
if ((a<=0)||(b<=0)||(c<=0)||(d<=0)) {
message("invalid index");
ok=None;
}
if (b<a) {
message("ending row must be greater than starting row");
ok=None;
}
if (d<c) {
message("ending column must be greater than starting column");
ok=None;
}
if (b>inp(1)) {
message("index of ending row is out of range");
ok=None;
}
if (d>inp(2)) {
message("index of ending column is out of range");
ok=None;
}
model.ipar=[a,b,c,d];
in1=[inp(1),inp(2)];
out=[(b-a)+1,(d-c)+1];
funtyp=4;
label=exprs;
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
model.sim=list(function_name,funtyp);
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
SUBMAT.prototype.define = function SUBMAT() {
model=scicos_model();
function_name="submat";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in1=-1;
model.in2=-2;
model.intyp=1;
model.out=-1;
model.out2=-2;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[1,1,1,1];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1),sci2exp(1),sci2exp(1),sci2exp(1),sci2exp(1)];
gr_i=[];
x=standard_define([2.5,2],model,label,gr_i);
}
SUBMAT.prototype.details = function SUBMAT() {
}
}
/* autogenerated from "macros/MatrixOp/ROOTCOEF.sci" */
function ROOTCOEF() {
ROOTCOEF.prototype.get = function ROOTCOEF() {
}
ROOTCOEF.prototype.set = function ROOTCOEF() {
x=arg1;
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
if (size(label,"*")==14) {
label[9-1]=[];
}
while (true) {
[ok,typ,inp,exprs]=scicos_getvalue("Set ROOTCOEF Block",["Datatype(1=real double  2=Complex)","input row size"],list("vec",1,"vec",1),label);
if (!ok) {
break
}
if ((typ==1)) {
function_name="root_coef";
ot=1;
it=1;
} else if ((typ==2)) {
function_name="rootz_coef";
ot=2;
it=2;
} else {
message("Datatype is not supported");
ok=None;
}
in1=[inp,model.in2];
out=[inp+1,model.out2];
funtyp=4;
if (ok) {
label=exprs;
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
model.sim=list(function_name,funtyp);
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
ROOTCOEF.prototype.define = function ROOTCOEF() {
model=scicos_model();
function_name="root_coef";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in1=-1;
model.in2=1;
model.intyp=1;
model.out=-2;
model.out2=1;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1),sci2exp(1)];
gr_i=[];
x=standard_define([3,2],model,label,gr_i);
}
ROOTCOEF.prototype.details = function ROOTCOEF() {
}
}
/* autogenerated from "macros/MatrixOp/EXTRACT.sci" */
function EXTRACT() {
EXTRACT.prototype.get = function EXTRACT() {
}
EXTRACT.prototype.set = function EXTRACT() {
x=arg1;
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
if (size(label,"*")==14) {
label[9-1]=[];
}
while (true) {
[ok,typ,a,b,exprs]=scicos_getvalue("Set EXTRACT Block",["Datatype (1=real double  2=Complex)","Lines to extract","Columns to extract"],list("vec",1,"mat",[1,-1],"mat",[1,-1]),label);
a=a.slice();
b=b.slice();
if (!ok) {
break
}
if ((typ==1)) {
function_name="extract";
ot=1;
it=1;
} else if ((typ==2)) {
function_name="extractz";
ot=2;
it=2;
} else {
message("Datatype is not supported");
ok=None;
}
ma=size(a,1);
mb=size(b,1);
if ((ma==0||mb==0)) {
message("empty field");
ok=None;
}
for(i=1;i<=ma;i+=1) {
if ((a(i)<=0)) {
message("invalid index");
ok=None;
}
}
for(j=1;j<=mb;j+=1) {
if ((b(j)<=0)) {
message("invalid index");
ok=None;
}
}
model.ipar=[a,b,ma,mb];
in1=[model.in1,model.in2];
out=[ma,mb];
funtyp=4;
if (ok) {
label=exprs;
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
model.sim=list(function_name,funtyp);
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
EXTRACT.prototype.define = function EXTRACT() {
model=scicos_model();
function_name="extract";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in1=-1;
model.in2=-2;
model.intyp=1;
model.out=1;
model.out2=1;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[1,1,1,1];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1),sci2exp([1]),sci2exp([1])];
gr_i=[];
x=standard_define([3,2],model,label,gr_i);
}
EXTRACT.prototype.details = function EXTRACT() {
}
}
/* autogenerated from "macros/MatrixOp/MATEIG.sci" */
function MATEIG() {
MATEIG.prototype.get = function MATEIG() {
}
MATEIG.prototype.set = function MATEIG() {
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
label=graphics.exprs;
if (size(label,"*")==14) {
label[9-1]=[];
}
while (true) {
[ok,typ,decomptyp,lab]=scicos_getvalue("Set MATEIG block parameters",["Datatype(1=real double  2=Complex)","decomposition type (1=eig values  2=eig values+eig vectors"],list("vec",1,"vec",1),label);
if (!ok) {
break
}
label=lab;
if ((typ==1)) {
if ((decomptyp==1)) {
function_name="mat_vps";
out=[-1,1];
ot=2;
} else if ((decomptyp==2)) {
function_name="mat_vpv";
out=[-1,-1,-1,-1];
ot=[2,2];
} else {
message("decomposition type is not supported");
ok=None;
}
it=1;
} else if ((typ==2)) {
if ((decomptyp==1)) {
function_name="matz_vps";
out=[-1,1];
ot=2;
} else if ((decomptyp==2)) {
function_name="matz_vpv";
out=[-1,-1,-1,-1];
ot=[2,2];
} else {
message("decomposition type is not supported");
ok=None;
}
it=2;
} else {
message("Datatype is not supported");
ok=None;
}
in1=[-1,-1];
funtyp=4;
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
if (ok) {
model.sim=list(function_name,funtyp);
arg1.model=model;
graphics.exprs=label;
arg1.graphics=graphics;
x=arg1;
break
}
}
}
MATEIG.prototype.define = function MATEIG() {
model=scicos_model();
function_name="mat_vps";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in1=-1;
model.in2=-1;
model.intyp=1;
model.out=-1;
model.out2=1;
model.outtyp=2;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1),sci2exp(1)];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
MATEIG.prototype.details = function MATEIG() {
}
}
/* autogenerated from "macros/MatrixOp/CUMSUM.sci" */
function CUMSUM() {
CUMSUM.prototype.get = function CUMSUM() {
}
CUMSUM.prototype.set = function CUMSUM() {
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
label=graphics.exprs;
if (size(label,"*")==14) {
label[9-1]=[];
}
while (true) {
[ok,typ,decomptyp,lab]=scicos_getvalue("Set CUMSUM block parameters",["Datatype(1=real double  2=Complex)","Sum along (0=the first non singleton dimension  1=Rows  2=Columns)"],list("vec",1,"vec",1),label);
if (!ok) {
break
}
label=lab;
if ((typ==1)) {
if ((decomptyp==0)) {
function_name="cumsum_m";
out=[-1,-2];
} else if ((decomptyp==1)) {
function_name="cumsum_r";
out=[-1,1];
} else if ((decomptyp==2)) {
function_name="cumsum_c";
out=[1,-2];
} else {
message("decomposition type is not supported");
ok=None;
}
it=1;
ot=1;
} else if ((typ==2)) {
if ((decomptyp==0)) {
function_name="cumsumz_m";
} else if ((decomptyp==1)) {
function_name="cumsumz_r";
} else if ((decomptyp==2)) {
function_name="cumsumz_c";
} else {
message("decomposition type is not supported");
ok=None;
}
it=2;
ot=2;
} else {
message("Datatype is not supported");
ok=None;
}
in1=[model.in1,model.in2];
out=[model.out,model.out2];
funtyp=4;
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
if (ok) {
model.sim=list(function_name,funtyp);
arg1.model=model;
graphics.exprs=label;
arg1.graphics=graphics;
x=arg1;
break
}
}
}
CUMSUM.prototype.define = function CUMSUM() {
model=scicos_model();
function_name="cumsum_m";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in1=-1;
model.in2=-2;
model.intyp=1;
model.out=-1;
model.out2=-2;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1),sci2exp(0)];
gr_i=[];
x=standard_define([3,2],model,label,gr_i);
}
CUMSUM.prototype.details = function CUMSUM() {
}
}
/* autogenerated from "macros/MatrixOp/MATDIV.sci" */
function MATDIV() {
MATDIV.prototype.get = function MATDIV() {
}
MATDIV.prototype.set = function MATDIV() {
x=arg1;
graphics=arg1.graphics;
label=graphics.exprs;
model=arg1.model;
if (size(label,"*")==14) {
label[9-1]=[];
}
while (true) {
[ok,typ,exprs]=scicos_getvalue("Set MATDIV Block",["Datatype(1=real double  2=Complex)"],list("vec",1),label);
if (!ok) {
break
}
if ((typ==1)) {
function_name="mat_div";
ot=1;
it=[1,1];
} else if ((typ==2)) {
function_name="matz_div";
ot=2;
it=[2,2];
} else {
message("Datatype is not supported");
ok=None;
}
in1=[model.in1,model.in2];
out=[model.out,model.out2];
funtyp=4;
if (ok) {
label=exprs;
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
model.sim=list(function_name,funtyp);
graphics.exprs=label;
arg1.graphics=graphics;
arg1.model=model;
x=arg1;
break
}
}
}
MATDIV.prototype.define = function MATDIV() {
model=scicos_model();
function_name="mat_div";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in1=[-1,-2];
model.in2=[-3,-3];
model.intyp=[1,1];
model.out=-1;
model.out2=-2;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1)];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
MATDIV.prototype.details = function MATDIV() {
}
}
/* autogenerated from "macros/MatrixOp/EXTTRI.sci" */
function EXTTRI() {
EXTTRI.prototype.get = function EXTTRI() {
}
EXTTRI.prototype.set = function EXTTRI() {
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
label=graphics.exprs;
if (size(label,"*")==14) {
label[9-1]=[];
}
while (true) {
[ok,typ,decomptyp,lab]=scicos_getvalue("Set EXTTRI block parameters",["Datatype(1=real double  2=Complex)","extraction type (1=lower  2=upper  3=diagonal)"],list("vec",1,"vec",1),label);
if (!ok) {
break
}
label=lab;
if ((typ==1)) {
if ((decomptyp==1)) {
function_name="exttril";
} else if ((decomptyp==2)) {
function_name="exttriu";
} else if ((decomptyp==3)) {
function_name="extdiag";
} else {
message("decomposition type is not supported");
ok=None;
}
it=1;
ot=1;
} else if ((typ==2)) {
if ((decomptyp==1)) {
function_name="exttrilz";
} else if ((decomptyp==2)) {
function_name="exttriuz";
} else if ((decomptyp==3)) {
function_name="extdiagz";
} else {
message("decomposition type is not supported");
ok=None;
}
it=2;
ot=2;
} else {
message("Datatype is not supported");
ok=None;
}
in1=[model.in1,model.in2];
out=[model.out,model.out2];
funtyp=4;
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
if (ok) {
model.sim=list(function_name,funtyp);
arg1.model=model;
graphics.exprs=label;
arg1.graphics=graphics;
x=arg1;
break
}
}
}
EXTTRI.prototype.define = function EXTTRI() {
model=scicos_model();
function_name="extrilz";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in1=-1;
model.in2=-2;
model.intyp=1;
model.out=-1;
model.out2=-2;
model.outtyp=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[sci2exp(1),sci2exp(1)];
gr_i=[];
x=standard_define([3,2],model,label,gr_i);
}
EXTTRI.prototype.details = function EXTTRI() {
}
}
/* autogenerated from "macros/Threshold/NEGTOPOS_f.sci" */
function NEGTOPOS_f() {
NEGTOPOS_f.prototype.get = function NEGTOPOS_f() {
}
NEGTOPOS_f.prototype.set = function NEGTOPOS_f() {
x=arg1;
x.model.firing=-1;
}
NEGTOPOS_f.prototype.define = function NEGTOPOS_f() {
model=scicos_model();
model.sim=list("zcross",1);
model.nzcross=1;
model.in1=1;
model.evtout=1;
model.rpar=[-1,-1,0,-1];
model.blocktype="z";
model.firing=-1;
model.dep_ut=[true,None];
gr_i=[];
x=standard_define([2,2],model,[],gr_i);
}
NEGTOPOS_f.prototype.details = function NEGTOPOS_f() {
}
}
/* autogenerated from "macros/Threshold/ZCROSS_f.sci" */
function ZCROSS_f() {
ZCROSS_f.prototype.get = function ZCROSS_f() {
}
ZCROSS_f.prototype.set = function ZCROSS_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,in1,exprs]=scicos_getvalue(["Set Zero-Crossing parameters","All surfaces must cross together"],"Input size",list("vec",1),exprs);
if (!ok) {
break
}
in1=int(in1);
if (in1<=0) {
message("Block must have at least one input");
} else {
kk=0;
for(jj=1;jj<=in1;jj+=1) {
kk=kk+2^(in1+jj-1);
}
model.rpar=[-ones(kk,1),zeros(2^(2*in1)-kk,1)];
graphics.exprs=exprs;
model.in1=in1;
model.nzcross=in1;
model.firing=-1;
x.graphics=graphics;
x.model=model;
break
}
}
}
ZCROSS_f.prototype.define = function ZCROSS_f() {
rpar=[-1,-1,0,0];
in1=1;
model=scicos_model();
model.sim=list("zcross",1);
model.in1=in1;
model.nzcross=in1;
model.evtout=1;
model.rpar=[-1,-1,0,0];
model.blocktype="z";
model.firing=-1;
model.dep_ut=[true,None];
exprs=strcat(sci2exp(in1));
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
ZCROSS_f.prototype.details = function ZCROSS_f() {
}
}
/* autogenerated from "macros/Threshold/POSTONEG_f.sci" */
function POSTONEG_f() {
POSTONEG_f.prototype.get = function POSTONEG_f() {
}
POSTONEG_f.prototype.set = function POSTONEG_f() {
x=arg1;
x.model.firing=[-1];
}
POSTONEG_f.prototype.define = function POSTONEG_f() {
rpar=[-1,-1,-1,0];
model=scicos_model();
model.sim=list("zcross",1);
model.nzcross=1;
model.in1=1;
model.evtout=1;
model.rpar=[-1,-1,-1,0];
model.blocktype="z";
model.dep_ut=[true,None];
model.firing=[-1];
gr_i=[];
x=standard_define([2,2],model,[],gr_i);
}
POSTONEG_f.prototype.details = function POSTONEG_f() {
}
}
/* autogenerated from "macros/Electrical/PotentialSensor.sci" */
function PotentialSensor() {
PotentialSensor.prototype.get = function PotentialSensor() {
}
PotentialSensor.prototype.set = function PotentialSensor() {
x=arg1;
}
PotentialSensor.prototype.define = function PotentialSensor() {
model=scicos_model();
model.in1=[1];
model.out=[1];
model.rpar=[];
model.sim="PotentialSensor";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="PotentialSensor";
mo.inputs="p";
mo.outputs=["v"];
model.equations=mo;
gr_i=[];
x=standard_define([2,2],model,"",list(gr_i,0));
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["E"];
}
PotentialSensor.prototype.details = function PotentialSensor() {
}
}
/* autogenerated from "macros/Electrical/SineVoltage.sci" */
function SineVoltage() {
SineVoltage.prototype.get = function SineVoltage() {
}
SineVoltage.prototype.set = function SineVoltage() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,V,ph,frq,offset,start,exprs]=scicos_getvalue("Set voltage source parameter",["Amplitude (Volt)","phase (rad)","Frequency (Hz)","Voltageoffset (V)","Timeoffset (s)"],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
model.rpar=[V,ph,frq,offset,start];
model.equations.parameters[2-1]=list(V,ph,frq,offset,start);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
SineVoltage.prototype.define = function SineVoltage() {
model=scicos_model();
model.in1=[1];
model.out=[1];
V=1;
ph=0;
frq=1;
offset=0;
start=0;
model.rpar=[V,ph,frq,offset,start];
model.sim="SineVoltage";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="SineVoltage";
mo.inputs="p";
mo.outputs="n";
mo.parameters=list(["V","phase","freqHz","offset","startTime"],list(V,ph,frq,offset,start));
model.equations=mo;
exprs=[string(V),string(ph),string(frq),string(offset),string(start)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I"];
}
SineVoltage.prototype.details = function SineVoltage() {
}
}
/* autogenerated from "macros/Electrical/CCS.sci" */
function CCS() {
CCS.prototype.get = function CCS() {
}
CCS.prototype.set = function CCS() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
x=arg1;
}
CCS.prototype.define = function CCS() {
ModelName="CCS";
PrametersValue=[];
ParametersName=[];
model=scicos_model();
Typein=[];
Typeout=[];
MI=[];
MO=[];
P=[2,50,1,0,70,98,2,0,70,2,-2,0];
PortName=["Iin","p","n"];
for(i=1;i<=size(P,"r");i+=1) {
if (P(i,3)==1) {
Typein=[Typein,"E"];
MI=[MI,PortName(i)];
}
if (P(i,3)==2) {
Typein=[Typein,"I"];
MI=[MI,PortName(i)];
}
if (P(i,3)==-1) {
Typeout=[Typeout,"E"];
MO=[MO,PortName(i)];
}
if (P(i,3)==-2) {
Typeout=[Typeout,"I"];
MO=[MO,PortName(i)];
}
}
model=scicos_model();
mo=modelica();
model.sim=ModelName;
mo.inputs=MI;
mo.outputs=MO;
model.rpar=PrametersValue;
mo.parameters=list(ParametersName,PrametersValue,zeros(ParametersName));
exprs=[];
gr_i=[];
model.blocktype="c";
model.dep_ut=[None,true];
mo.model=ModelName;
model.equations=mo;
model.in1=ones(size(MI,"*"),1);
model.out=ones(size(MO,"*"),1);
x=standard_define([2.1,3],model,exprs,list(gr_i,0));
x.graphics.in_implicit=Typein;
x.graphics.out_implicit=Typeout;
}
CCS.prototype.details = function CCS() {
}
}
/* autogenerated from "macros/Electrical/PMOS.sci" */
function PMOS() {
PMOS.prototype.get = function PMOS() {
}
PMOS.prototype.set = function PMOS() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,W,L,Beta,Vt,K2,K5,dW,dL,RDS,exprs]=scicos_getvalue("Set PMOS Transistor parameters",["Width [m]","Length [m]","Transconductance parameter [A/(V*V)]","Zero bias threshold voltage [V]","Bulk threshold parameter","Reduction of pinch-off region","Narrowing of channel [m]","Shortening of channel [m]","Drain-Source-Resistance [Ohm]"],list("vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
model.equations.parameters[2-1]=list(W,L,Beta,Vt,K2,K5,dW,dL,RDS);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
PMOS.prototype.define = function PMOS() {
model=scicos_model();
W=50.0e-6;
L=6.0e-6;
Beta=0.0105e-3;
Vt=-1;
K2=0.41;
K5=0.839;
dW=-2.5e-6;
dL=-2.1e-6;
RDS=1.e+7;
model.sim="PMOS";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="PMOS";
mo.outputs=["D","B","S"];
mo.inputs="G";
mo.parameters=list(["W","L","Beta","Vt","K2","K5","dW","dL","RDS"],[W,L,Beta,Vt,K2,K5,dW,dL,RDS]);
model.equations=mo;
model.in1=ones(size(mo.inputs,"*"),1);
model.out=ones(size(mo.outputs,"*"),1);
exprs=[string(W),string(L),string(Beta),string(Vt),string(K2),string(K5),string(dW),string(dL),string(RDS)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I","I","I"];
}
PMOS.prototype.details = function PMOS() {
}
}
/* autogenerated from "macros/Electrical/Inductor.sci" */
function Inductor() {
Inductor.prototype.get = function Inductor() {
}
Inductor.prototype.set = function Inductor() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,L,exprs]=scicos_getvalue("Set Inductor block parameter","L (H)",list("vec",1),exprs);
if (!ok) {
break
}
model.rpar=L;
model.equations.parameters[2-1]=list(L);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
Inductor.prototype.define = function Inductor() {
model=scicos_model();
model.in1=[1];
model.out=[1];
L=1.e-5;
model.rpar=L;
model.sim="Inductor";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="Inductor";
mo.inputs="p";
mo.outputs="n";
mo.parameters=list("L",list(L));
model.equations=mo;
exprs=string(L);
gr_i=[];
x=standard_define([2,0.9],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I"];
}
Inductor.prototype.details = function Inductor() {
}
}
/* autogenerated from "macros/Electrical/Diode.sci" */
function Diode() {
Diode.prototype.get = function Diode() {
}
Diode.prototype.set = function Diode() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,Ids,Vt,Maxexp,R,exprs]=scicos_getvalue("Set Diode block parameter",["Saturation cuurent (A)","Voltage equivalent to temperature (Volt)","Max exponent for linear continuation","R (ohm)"],list("vec",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
model.rpar=[Ids,Vt,Maxexp,R];
model.equations.parameters=list(["Ids","Vt","Maxexp","R"],list(Ids,Vt,Maxexp,R));
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
Diode.prototype.define = function Diode() {
Ids=1.e-6;
Vt=0.04;
Maxexp=15;
R=1.e8;
model=scicos_model();
model.rpar=[Ids,Vt,Maxexp,R];
model.in1=1;
model.out=1;
model.sim="Diode";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="Diode";
mo.inputs="p";
mo.outputs="n";
mo.parameters=list(["Ids","Vt","Maxexp","R"],list(Ids,Vt,Maxexp,R));
model.equations=mo;
exprs=string([Ids,Vt,Maxexp,R]);
gr_i=[];
x=standard_define([2,1],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I"];
}
Diode.prototype.details = function Diode() {
}
}
/* autogenerated from "macros/Electrical/IdealTransformer.sci" */
function IdealTransformer() {
IdealTransformer.prototype.get = function IdealTransformer() {
}
IdealTransformer.prototype.set = function IdealTransformer() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
x=arg1;
exprs=x.graphics.exprs;
while (true) {
[ok,N,exprs]=scicos_getvalue(["Set Transformer block parameters:","","N:"+" Turn ratio (N1/N2)"],["N"],list("vec",1),exprs);
if (!ok) {
break
}
x.model.equations.parameters[2-1]=list(N);
x.graphics.exprs=exprs;
break
}
}
IdealTransformer.prototype.define = function IdealTransformer() {
ModelName="IdealTransformer";
PrametersValue=[1];
ParametersName=["N"];
model=scicos_model();
Typein=[];
Typeout=[];
MI=[];
MO=[];
P=[2.5,90,2,0,2.5,10,2,0,97.5,90,-2,0,97.5,10,-2,0];
PortName=["p1","n1","p2","n2"];
for(i=1;i<=size(P,"r");i+=1) {
if (P(i,3)==1) {
Typein=[Typein,"E"];
MI=[MI,PortName(i)];
}
if (P(i,3)==2) {
Typein=[Typein,"I"];
MI=[MI,PortName(i)];
}
if (P(i,3)==-1) {
Typeout=[Typeout,"E"];
MO=[MO,PortName(i)];
}
if (P(i,3)==-2) {
Typeout=[Typeout,"I"];
MO=[MO,PortName(i)];
}
}
model=scicos_model();
mo=modelica();
model.sim=ModelName;
mo.inputs=MI;
mo.outputs=MO;
model.rpar=PrametersValue;
mo.parameters=list(ParametersName,PrametersValue,zeros(ParametersName));
exprs=["1"];
gr_i=[];
model.blocktype="c";
model.dep_ut=[None,true];
mo.model=ModelName;
model.equations=mo;
model.in1=ones(size(MI,"*"),1);
model.out=ones(size(MO,"*"),1);
x=standard_define([2,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=Typein;
x.graphics.out_implicit=Typeout;
}
IdealTransformer.prototype.details = function IdealTransformer() {
}
}
/* autogenerated from "macros/Electrical/Ground.sci" */
function Ground() {
Ground.prototype.get = function Ground() {
}
Ground.prototype.set = function Ground() {
x=arg1;
}
Ground.prototype.define = function Ground() {
model=scicos_model();
model.in1=[1];
model.out=[];
model.sim="Ground";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="Ground";
mo.inputs="p";
model.equations=mo;
exprs="";
gr_i=[];
x=standard_define([1,1],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I"];
}
Ground.prototype.details = function Ground() {
}
}
/* autogenerated from "macros/Electrical/CVS.sci" */
function CVS() {
CVS.prototype.get = function CVS() {
}
CVS.prototype.set = function CVS() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
x=arg1;
}
CVS.prototype.define = function CVS() {
ModelName="CVS";
PrametersValue=[];
ParametersName=[];
model=scicos_model();
Typein=[];
Typeout=[];
MI=[];
MO=[];
P=[2,50,1,0,70,98,2,0,70,2,-2,0];
PortName=["vin","p","n"];
for(i=1;i<=size(P,"r");i+=1) {
if (P(i,3)==1) {
Typein=[Typein,"E"];
MI=[MI,PortName(i)];
}
if (P(i,3)==2) {
Typein=[Typein,"I"];
MI=[MI,PortName(i)];
}
if (P(i,3)==-1) {
Typeout=[Typeout,"E"];
MO=[MO,PortName(i)];
}
if (P(i,3)==-2) {
Typeout=[Typeout,"I"];
MO=[MO,PortName(i)];
}
}
model=scicos_model();
mo=modelica();
model.sim=ModelName;
mo.inputs=MI;
mo.outputs=MO;
model.rpar=PrametersValue;
mo.parameters=list(ParametersName,PrametersValue,zeros(ParametersName));
exprs=[];
gr_i=[];
model.blocktype="c";
model.dep_ut=[None,true];
mo.model=ModelName;
model.equations=mo;
model.in1=ones(size(MI,"*"),1);
model.out=ones(size(MO,"*"),1);
x=standard_define([2.1,3],model,exprs,list(gr_i,0));
x.graphics.in_implicit=Typein;
x.graphics.out_implicit=Typeout;
}
CVS.prototype.details = function CVS() {
}
}
/* autogenerated from "macros/Electrical/Resistor.sci" */
function Resistor() {
Resistor.prototype.get = function Resistor() {
}
Resistor.prototype.set = function Resistor() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,R,exprs]=scicos_getvalue("Set Resistor block parameter","R (ohm)",list("vec",1),exprs);
if (!ok) {
break
}
model.rpar=R;
model.equations.parameters[2-1]=list(R);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
Resistor.prototype.define = function Resistor() {
model=scicos_model();
R=0.01;
model.rpar=R;
model.sim="resistor";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="Resistor";
mo.inputs="p";
mo.outputs="n";
mo.parameters=list("R",list(R));
model.equations=mo;
model.in1=ones(size(mo.inputs,"*"),1);
model.out=ones(size(mo.outputs,"*"),1);
exprs=string(R);
gr_i=[];
x=standard_define([2,1],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I"];
}
Resistor.prototype.details = function Resistor() {
}
}
/* autogenerated from "macros/Electrical/PNP.sci" */
function PNP() {
PNP.prototype.get = function PNP() {
}
PNP.prototype.set = function PNP() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
x=arg1;
exprs=x.graphics.exprs;
while (true) {
[ok,Bf,Br,Is,Vak,Tauf,Taur,Ccs,Cje,Cjc,Phie,Me,Phic,Mc,Gbc,Gbe,Vt,EMinMax,exprs]=scicos_getvalue(["Set PNP block parameters:",""],["Bf  : Forward beta","Br  : Reverse beta","Is  : Transport saturation current","Vak : Early voltage (inverse), 1/Volt","Tauf: Ideal forward transit time","Taur: Ideal reverse transit time","Ccs : Collector-substrat(ground) cap.","Cje : Base-emitter zero bias depletion cap.","Cjc : Base-coll. zero bias depletion cap.","Phie: Base-emitter diffusion voltage","Me  : Base-emitter gradation exponent","Phic: Base-collector diffusion voltage","Mc  : Base-collector gradation exponent","Gbc : Base-collector conductance","Gbe : Base-emitter conductance","Vt  : Voltage equivalent of temperature","EMinMax: if x > EMinMax, the exp(x) function is linearized"],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
x.model.equations.parameters[2-1]=list(Bf,Br,Is,Vak,Tauf,Taur,Ccs,Cje,Cjc,Phie,Me,Phic,Mc,Gbc,Gbe,Vt,EMinMax);
x.graphics.exprs=exprs;
break
}
}
PNP.prototype.define = function PNP() {
ModelName="PNP";
PrametersValue=[50,0.1,0,0.02,1.200e-10,5.000e-09,1.000e-12,4.000e-13,5.000e-13,0.8,0.4,0.8,0.333,1.000e-15,1.000e-15,0.02585,40];
ParametersName=["Bf","Br","Is","Vak","Tauf","Taur","Ccs","Cje","Cjc","Phie","Me","Phic","Mc","Gbc","Gbe","Vt","EMinMax"];
model=scicos_model();
Typein=[];
Typeout=[];
MI=[];
MO=[];
P=[100,90,-2,0,0,50,2,0,100,10,-2,0];
PortName=["C","B","E"];
for(i=1;i<=size(P,"r");i+=1) {
if (P(i,3)==1) {
Typein=[Typein,"E"];
MI=[MI,PortName(i)];
}
if (P(i,3)==2) {
Typein=[Typein,"I"];
MI=[MI,PortName(i)];
}
if (P(i,3)==-1) {
Typeout=[Typeout,"E"];
MO=[MO,PortName(i)];
}
if (P(i,3)==-2) {
Typeout=[Typeout,"I"];
MO=[MO,PortName(i)];
}
}
model=scicos_model();
mo=modelica();
model.sim=ModelName;
mo.inputs=MI;
mo.outputs=MO;
model.rpar=PrametersValue;
mo.parameters=list(ParametersName,PrametersValue,zeros(ParametersName));
exprs=["50","0.1","1.e-16","0.02","0.12e-9","5e-9","1e-12","0.4e-12","0.5e-12","0.8","0.4","0.8","0.333","1e-15","1e-15","0.02585","40"];
gr_i=[];
model.blocktype="c";
model.dep_ut=[None,true];
mo.model=ModelName;
model.equations=mo;
model.in1=ones(size(MI,"*"),1);
model.out=ones(size(MO,"*"),1);
x=standard_define([2,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=Typein;
x.graphics.out_implicit=Typeout;
}
PNP.prototype.details = function PNP() {
}
}
/* autogenerated from "macros/Electrical/NPN.sci" */
function NPN() {
NPN.prototype.get = function NPN() {
}
NPN.prototype.set = function NPN() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
x=arg1;
exprs=x.graphics.exprs;
while (true) {
[ok,Bf,Br,Is,Vak,Tauf,Taur,Ccs,Cje,Cjc,Phie,Me,Phic,Mc,Gbc,Gbe,Vt,EMinMax,exprs]=scicos_getvalue(["Set NPN block parameters:",""],["Bf  : Forward beta","Br  : Reverse beta","Is  : Transport saturation current","Vak : Early voltage (inverse), 1/Volt","Tauf: Ideal forward transit time","Taur: Ideal reverse transit time","Ccs : Collector-substrat(ground) cap.","Cje : Base-emitter zero bias depletion cap.","Cjc : Base-coll. zero bias depletion cap.","Phie: Base-emitter diffusion voltage","Me  : Base-emitter gradation exponent","Phic: Base-collector diffusion voltage","Mc  : Base-collector gradation exponent","Gbc : Base-collector conductance","Gbe : Base-emitter conductance","Vt  : Voltage equivalent of temperature","EMinmax: if x > EMinMax, the exp(x) is linearized"],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
x.model.equations.parameters[2-1]=list(Bf,Br,Is,Vak,Tauf,Taur,Ccs,Cje,Cjc,Phie,Me,Phic,Mc,Gbc,Gbe,Vt,EMinMax);
x.graphics.exprs=exprs;
break
}
}
NPN.prototype.define = function NPN() {
ModelName="NPN";
PrametersValue=[50,0.1,0,0.02,1.200e-10,5.000e-09,1.000e-12,4.000e-13,5.000e-13,0.8,0.4,0.8,0.333,1.000e-15,1.000e-15,0.02585,40];
ParametersName=["Bf","Br","Is","Vak","Tauf","Taur","Ccs","Cje","Cjc","Phie","Me","Phic","Mc","Gbc","Gbe","Vt","EMinMax"];
model=scicos_model();
Typein=[];
Typeout=[];
MI=[];
MO=[];
P=[100,90,-2,0,0,50,2,0,100,10,-2,0];
PortName=["C","B","E"];
for(i=1;i<=size(P,"r");i+=1) {
if (P(i,3)==1) {
Typein=[Typein,"E"];
MI=[MI,PortName(i)];
}
if (P(i,3)==2) {
Typein=[Typein,"I"];
MI=[MI,PortName(i)];
}
if (P(i,3)==-1) {
Typeout=[Typeout,"E"];
MO=[MO,PortName(i)];
}
if (P(i,3)==-2) {
Typeout=[Typeout,"I"];
MO=[MO,PortName(i)];
}
}
model=scicos_model();
mo=modelica();
model.sim=ModelName;
mo.inputs=MI;
mo.outputs=MO;
model.rpar=PrametersValue;
mo.parameters=list(ParametersName,PrametersValue,zeros(ParametersName));
exprs=["50","0.1","1.e-16","0.02","0.12e-9","5e-9","1e-12","0.4e-12","0.5e-12","0.8","0.4","0.8","0.333","1e-15","1e-15","0.02585","40"];
gr_i=[];
model.blocktype="c";
model.dep_ut=[None,true];
mo.model=ModelName;
model.equations=mo;
model.in1=ones(size(MI,"*"),1);
model.out=ones(size(MO,"*"),1);
x=standard_define([2,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=Typein;
x.graphics.out_implicit=Typeout;
}
NPN.prototype.details = function NPN() {
}
}
/* autogenerated from "macros/Electrical/CurrentSensor.sci" */
function CurrentSensor() {
CurrentSensor.prototype.get = function CurrentSensor() {
}
CurrentSensor.prototype.set = function CurrentSensor() {
x=arg1;
}
CurrentSensor.prototype.define = function CurrentSensor() {
model=scicos_model();
model.in1=1;
model.out=[1,1];
model.sim="CurrentSensor";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="CurrentSensor";
mo.inputs="p";
mo.outputs=["n","i"];
model.equations=mo;
exprs=[];
gr_i=[];
x=standard_define([2,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I","E"];
}
CurrentSensor.prototype.details = function CurrentSensor() {
}
}
/* autogenerated from "macros/Electrical/ConstantVoltage.sci" */
function ConstantVoltage() {
ConstantVoltage.prototype.get = function ConstantVoltage() {
}
ConstantVoltage.prototype.set = function ConstantVoltage() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,V,exprs]=scicos_getvalue("Set ConstantVoltage block parameter","V (volt)",list("vec",1),exprs);
if (!ok) {
break
}
model.rpar=V;
model.equations.parameters[2-1]=list(V);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
ConstantVoltage.prototype.define = function ConstantVoltage() {
V=0.01;
model=scicos_model();
model.rpar=V;
model.in1=1;
model.out=1;
model.sim="ConstantVoltage";
model.blocktype="c";
model.dep_ut=[None,None];
mo=modelica();
mo.model="ConstantVoltage";
mo.inputs="p";
mo.outputs="n";
mo.parameters=list("V",list(V));
model.equations=mo;
exprs=string(V);
gr_i=[];
x=standard_define([1.5,1.1],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I"];
}
ConstantVoltage.prototype.details = function ConstantVoltage() {
}
}
/* autogenerated from "macros/Electrical/VVsourceAC.sci" */
function VVsourceAC() {
VVsourceAC.prototype.get = function VVsourceAC() {
}
VVsourceAC.prototype.set = function VVsourceAC() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,FR,exprs]=scicos_getvalue("Set voltage source parameter",["Frequency (Hz)"],list("vec",-1),exprs);
if (!ok) {
break
}
model.rpar=[FR];
model.equations.parameters[2-1]=list(FR);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
VVsourceAC.prototype.define = function VVsourceAC() {
model=scicos_model();
model.in1=[1,1];
model.out=[1];
VA=220;
FR=50;
model.rpar=[FR];
model.sim="VVsourceAC";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="VVsourceAC";
mo.inputs=["p","VA"];
mo.outputs="n";
mo.parameters=list(["f"],list(FR));
model.equations=mo;
exprs=[string(FR)];
gr_i=[];
x=standard_define([2,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I","E"];
x.graphics.out_implicit=["I"];
}
VVsourceAC.prototype.details = function VVsourceAC() {
}
}
/* autogenerated from "macros/Electrical/VoltageSensor.sci" */
function VoltageSensor() {
VoltageSensor.prototype.get = function VoltageSensor() {
}
VoltageSensor.prototype.set = function VoltageSensor() {
x=arg1;
}
VoltageSensor.prototype.define = function VoltageSensor() {
model=scicos_model();
model.in1=1;
model.out=[1,1];
model.sim="VoltageSensor";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="VoltageSensor";
mo.inputs="p";
mo.outputs=["n","v"];
model.equations=mo;
exprs=[];
gr_i=[];
x=standard_define([2,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I","E"];
}
VoltageSensor.prototype.details = function VoltageSensor() {
}
}
/* autogenerated from "macros/Electrical/VariableResistor.sci" */
function VariableResistor() {
VariableResistor.prototype.get = function VariableResistor() {
}
VariableResistor.prototype.set = function VariableResistor() {
x=arg1;
}
VariableResistor.prototype.define = function VariableResistor() {
model=scicos_model();
model.sim="VariableResistor";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="VariableResistor";
mo.inputs=["p","R"];
mo.outputs="n";
model.equations=mo;
model.in1=ones(size(mo.inputs,"*"),1);
model.out=ones(size(mo.outputs,"*"),1);
exprs=[];
gr_i=[];
x=standard_define([2,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I","E"];
x.graphics.out_implicit=["I"];
}
VariableResistor.prototype.details = function VariableResistor() {
}
}
/* autogenerated from "macros/Electrical/Switch.sci" */
function Switch() {
Switch.prototype.get = function Switch() {
}
Switch.prototype.set = function Switch() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,Ron,Roff,exprs]=scicos_getvalue("Set non-ideal electrical switch parameters",["Resistance in On state (Ohm)","Resistance in Off state (Ohm)"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
model.equations.parameters[2-1]=list(Ron,Roff);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
Switch.prototype.define = function Switch() {
model=scicos_model();
Ron=0.01;
Roff=1e5;
S=["Ron","Roff"];
Z=eval(S);
model.sim="Switch";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model=model.sim;
mo.inputs=["p","inp"];
mo.outputs="n";
mo.parameters=list(S,Z);
model.equations=mo;
model.in1=ones(size(mo.inputs,"*"),1);
model.out=ones(size(mo.outputs,"*"),1);
model.rpar=Z;
exprs=string(Z);
gr_i=[];
x=standard_define([2,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I","E"];
x.graphics.out_implicit=["I"];
}
Switch.prototype.details = function Switch() {
}
}
/* autogenerated from "macros/Electrical/MOTOR.sci" */
function MOTOR() {
MOTOR.prototype.get = function MOTOR() {
}
MOTOR.prototype.set = function MOTOR() {
x=arg1;
}
MOTOR.prototype.define = function MOTOR() {
model=scicos_model();
model.out=[1,1];
model.in1=[1];
model.sim="motor";
model.blocktype="c";
model.dep_ut=[true,None];
gr_i=[];
exprs="";
x=standard_define([2,2],model,exprs,gr_i);
x.graphics.out_implicit=["I","I"];
x.graphics.in_implicit=["I"];
}
MOTOR.prototype.details = function MOTOR() {
}
}
/* autogenerated from "macros/Electrical/NMOS.sci" */
function NMOS() {
NMOS.prototype.get = function NMOS() {
}
NMOS.prototype.set = function NMOS() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,W,L,Beta,Vt,K2,K5,dW,dL,RDS,exprs]=scicos_getvalue("Set NMOS Transistor block parameters",["Width [m]","Length [m]","Transconductance parameter [A/(V*V)]","Zero bias threshold voltage [V]","Bulk threshold parameter","Reduction of pinch-off region","Narrowing of channel [m]","Shortening of channel [m]","Drain-Source-Resistance [Ohm]"],list("vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
model.equations.parameters[2-1]=list(W,L,Beta,Vt,K2,K5,dW,dL,RDS);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
NMOS.prototype.define = function NMOS() {
model=scicos_model();
W=20.e-6;
L=6.e-6;
Beta=0.041e-3;
Vt=0.8;
K2=1.144;
K5=0.7311;
dW=-2.5e-6;
dL=-1.5e-6;
RDS=1.e+7;
model.sim="NMOS";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="NMOS";
mo.outputs=["D","B","S"];
mo.inputs="G";
mo.parameters=list(["W","L","Beta","Vt","K2","K5","dW","dL","RDS"],[W,L,Beta,Vt,K2,K5,dW,dL,RDS]);
model.equations=mo;
model.in1=ones(size(mo.inputs,"*"),1);
model.out=ones(size(mo.outputs,"*"),1);
exprs=[string(W),string(L),string(Beta),string(Vt),string(K2),string(K5),string(dW),string(dL),string(RDS)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I","I","I"];
}
NMOS.prototype.details = function NMOS() {
}
}
/* autogenerated from "macros/Electrical/VsourceAC.sci" */
function VsourceAC() {
VsourceAC.prototype.get = function VsourceAC() {
}
VsourceAC.prototype.set = function VsourceAC() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,VA,FR,exprs]=scicos_getvalue("Set voltage source parameter",["Amplitude (Volt)","Frequency (Hz)"],list("vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
model.rpar=[VA,FR];
model.equations.parameters[2-1]=list(VA,FR);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
VsourceAC.prototype.define = function VsourceAC() {
model=scicos_model();
model.in1=[1];
model.out=[1];
VA=220;
FR=50;
model.rpar=[VA,FR];
model.sim="VsourceAC";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="VsourceAC";
mo.inputs="p";
mo.outputs="n";
mo.parameters=list(["VA","f"],list(VA,FR));
model.equations=mo;
exprs=[string(VA),string(FR)];
gr_i=[];
x=standard_define([2,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I"];
}
VsourceAC.prototype.details = function VsourceAC() {
}
}
/* autogenerated from "macros/Electrical/OpAmp.sci" */
function OpAmp() {
OpAmp.prototype.get = function OpAmp() {
}
OpAmp.prototype.set = function OpAmp() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (None) {
[ok,OLGain,SatH,SatL,exprs]=scicos_getvalue("Set the Operational Amplifier parameters",["Open Loop Gain","Positive saturation voltage","Negative saturation voltage"],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
model.equations.parameters[2-1]=list(OLGain,SatH,SatL);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
OpAmp.prototype.define = function OpAmp() {
S=[];
Z=[];
model=scicos_model();
model.sim="OpAmp";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model=model.sim;
mo.inputs=["in_p","in_n"];
mo.outputs=["out"];
mo.parameters=list(S,Z);
model.equations=mo;
model.in1=ones(size(mo.inputs,"*"),1);
model.out=ones(size(mo.outputs,"*"),1);
model.rpar=Z;
exprs=string(Z);
gr_i=[];
x=standard_define([3,5],model,exprs,gr_i);
x.graphics.in_implicit=["I","I"];
x.graphics.out_implicit=["I"];
}
OpAmp.prototype.details = function OpAmp() {
}
}
/* autogenerated from "macros/Electrical/Capacitor.sci" */
function Capacitor() {
Capacitor.prototype.get = function Capacitor() {
}
Capacitor.prototype.set = function Capacitor() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,C,v,exprs]=scicos_getvalue("Set Capacitor block parameter",["C (F)","Initial Voltage"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
model.rpar=C;
model.equations.parameters[2-1]=list(C,v);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
Capacitor.prototype.define = function Capacitor() {
model=scicos_model();
C=0.01;
v=0;
model.rpar=[C,v];
model.sim="Capacitor";
model.blocktype="c";
model.dep_ut=[true,None];
mo=modelica();
mo.model="Capacitor";
mo.inputs="p";
mo.outputs="n";
mo.parameters=list(["C","v"],list(C,v),[0,1]);
model.equations=mo;
model.in1=ones(size(mo.inputs,"*"),1);
model.out=ones(size(mo.outputs,"*"),1);
exprs=string([C,v]);
gr_i=[];
x=standard_define([2,1.1],model,exprs,list(gr_i,0));
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I"];
}
Capacitor.prototype.details = function Capacitor() {
}
}
/* autogenerated from "macros/Electrical/Gyrator.sci" */
function Gyrator() {
Gyrator.prototype.get = function Gyrator() {
}
Gyrator.prototype.set = function Gyrator() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
x=arg1;
exprs=x.graphics.exprs;
while (true) {
[ok,G1,G2,exprs]=scicos_getvalue(["Set Gyrator block parameters:","","G1: Gyration conductance","G2: Gyration conductance"],["G1","G2"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
x.model.equations.parameters[2-1]=list(G1,G2);
x.graphics.exprs=exprs;
break
}
}
Gyrator.prototype.define = function Gyrator() {
ModelName="Gyrator";
PrametersValue=[1,1];
ParametersName=["G1","G2"];
model=scicos_model();
Typein=[];
Typeout=[];
MI=[];
MO=[];
P=[2.5,90,2,0,2.5,10,2,0,97.5,90,-2,0,97.5,10,-2,0];
PortName=["p1","n1","p2","n2"];
for(i=1;i<=size(P,"r");i+=1) {
if (P(i,3)==1) {
Typein=[Typein,"E"];
MI=[MI,PortName(i)];
}
if (P(i,3)==2) {
Typein=[Typein,"I"];
MI=[MI,PortName(i)];
}
if (P(i,3)==-1) {
Typeout=[Typeout,"E"];
MO=[MO,PortName(i)];
}
if (P(i,3)==-2) {
Typeout=[Typeout,"I"];
MO=[MO,PortName(i)];
}
}
model=scicos_model();
mo=modelica();
model.sim=ModelName;
mo.inputs=MI;
mo.outputs=MO;
model.rpar=PrametersValue;
mo.parameters=list(ParametersName,PrametersValue,zeros(ParametersName));
exprs=["1","1"];
gr_i=[];
model.blocktype="c";
model.dep_ut=[None,true];
mo.model=ModelName;
model.equations=mo;
model.in1=ones(size(MI,"*"),1);
model.out=ones(size(MO,"*"),1);
x=standard_define([2,2],model,exprs,list(gr_i,0));
x.graphics.in_implicit=Typein;
x.graphics.out_implicit=Typeout;
}
Gyrator.prototype.details = function Gyrator() {
}
}
/* autogenerated from "macros/Misc/DEADBAND.sci" */
function DEADBAND() {
DEADBAND.prototype.get = function DEADBAND() {
}
DEADBAND.prototype.set = function DEADBAND() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,maxp,minp,zeroc,exprs]=scicos_getvalue("Set Deadband parameters",["End of dead band","Start of dead band","zero crossing (0:no, 1:yes)"],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (maxp<=minp) {
message("Upper limit must be > Lower limit");
} else {
rpar=[maxp,minp];
model.rpar=rpar;
if (zeroc!=0) {
model.nzcross=2;
model.nmode=1;
} else {
model.nzcross=0;
model.nmode=0;
}
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
DEADBAND.prototype.define = function DEADBAND() {
minp=-.5;
maxp=.5;
rpar=[maxp,minp];
model=scicos_model();
model.sim=list("deadband",4);
model.in1=1;
model.nzcross=2;
model.nmode=1;
model.out=1;
model.rpar=rpar;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string(maxp),string(minp),string(model.nmode)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
DEADBAND.prototype.details = function DEADBAND() {
}
}
/* autogenerated from "macros/Misc/SUPER_f.sci" */
function SUPER_f() {
SUPER_f.prototype.get = function SUPER_f() {
}
SUPER_f.prototype.set = function SUPER_f() {
xcos(arg1.model.rpar);
}
SUPER_f.prototype.define = function SUPER_f() {
scs=scicos_diagram();
scs.props.title="Super Block";
in1=IN_f("define");
in1.graphics.orig=[40,40];
in1.graphics.sz=[20,20];
out=OUT_f("define");
out.graphics.orig=[240,40];
out.graphics.sz=[20,20];
scs.objs[1-1]=in1;
scs.objs[2-1]=out;
model=scicos_model();
model.sim="super";
model.in1=1;
model.out=1;
model.rpar=scs;
model.blocktype="h";
model.dep_ut=[None,None];
gr_i=[];
x=standard_define([2,2],model,[],gr_i);
}
SUPER_f.prototype.details = function SUPER_f() {
}
}
/* autogenerated from "macros/Misc/fortran_block.sci" */
function fortran_block() {
fortran_block.prototype.get = function fortran_block() {
}
fortran_block.prototype.set = function fortran_block() {
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
label=graphics.exprs;
while (true) {
[ok,i,o,rpar,funam,lab]=scicos_getvalue("Set fortran_block parameters",["input ports sizes","output port sizes","System parameters vector","function name"],list("vec",-1,"vec",-1,"vec",-1,"str",-1),label(1));
if (!ok) {
break
}
if (funam==" ") {
break
}
label[1-1]=lab;
rpar=rpar.slice();
i=int(i.slice());
ni=size(i,1);
o=int(o.slice());
no=size(o,1);
tt=label[2-1];
if (model.sim(1)!=funam||size(model.in1,"*")!=size(i,"*")||size(model.out,"*")!=size(o,"*")) {
tt=[];
}
[ok,tt]=FORTR(funam,tt,i,o);
if (!ok) {
break
}
[model,graphics,ok]=check_io(model,graphics,i,o,[],[]);
if (ok) {
model.sim[1-1]=funam;
model.rpar=rpar;
label[2-1]=tt;
x.model=model;
graphics.exprs=label;
x.graphics=graphics;
break
}
}
}
fortran_block.prototype.define = function fortran_block() {
model=scicos_model();
model.sim=list(" ",1001);
model.in1=1;
model.out=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=0;
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
funam="forty";
label=list([sci2exp(model.in1),sci2exp(model.out),strcat(sci2exp(model.rpar)),funam],list([]));
gr_i=[];
x=standard_define([4,2],model,label,gr_i);
}
fortran_block.prototype.details = function fortran_block() {
}
}
/* autogenerated from "macros/Misc/DIFF_f.sci" */
function DIFF_f() {
DIFF_f.prototype.get = function DIFF_f() {
}
DIFF_f.prototype.set = function DIFF_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,x0,xd0,exprs]=scicos_getvalue("Set continuous linear system parameters",["Initial state","Initial Derivative"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
graphics.exprs=exprs;
model.state=[x0.slice(),xd0.slice()];
x.graphics=graphics;
x.model=model;
break
}
x.model.firing=[];
}
DIFF_f.prototype.define = function DIFF_f() {
x0=[0,0];
model=scicos_model();
model.sim=list("diffblk",10001);
model.in1=1;
model.out=1;
model.state=x0;
model.blocktype="c";
model.dep_ut=[None,true];
exprs=[strcat(sci2exp(x0(1))),strcat(sci2exp(x0(2)))];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
DIFF_f.prototype.details = function DIFF_f() {
}
}
/* autogenerated from "macros/Misc/BOUNCE.sci" */
function BOUNCE() {
BOUNCE.prototype.get = function BOUNCE() {
}
BOUNCE.prototype.set = function BOUNCE() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")<9) {
exprs[8-1]="9.81";
exprs[9-1]="0";
}
while (true) {
[ok,rpar1,rpar2,walls,xt,xd,y,yd,g,C,exprs]=scicos_getvalue(["Set Bounce Block"],["Mass","Radius","[xmin,xmax,ymin,ymax]","xpos","xdpos","ypos","ydpos","g (gravity)","C (aerodynamic coeff"],list("vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
xt=xt.slice();
y=y.slice();
xd=xd.slice();
yd=yd.slice();
rpar1=rpar1.slice();
rpar2=rpar2.slice();
n=size(xt,"*");
walls=walls.slice();
if (walls(1)>walls(2)) {
walls=walls([2,1]);
}
if (walls(3)>walls(3)) {
walls=walls([3,4]);
}
if (n!=size(y,"*")||n!=size(rpar1,"*")||n!=size(rpar2,"*")||n!=size(xd,"*")||n!=size(yd,"*")) {
message("All vectors must have equal size");
ok=None;
} else if (!(min([rpar1,rpar2])>0)) {
message("Mass and radius must be >0");
ok=None;
}
if (!ok) {
break
}
[model,graphics,ok]=check_io(model,graphics,[],[n,n],[],[]);
if (ok) {
k=1;
ipar=[];
for(i=1;i<=n;i+=1) {
for(j=i+1;j<=n;j+=1) {
ipar[k-1]=i;
k=k+1;
ipar[k-1]=j;
k=k+1;
}
}
model.rpar=[rpar1,rpar2,walls,g,C];
model.ipar=ipar;
state=[xt,xd,y,yd];
state=transpose(state);
model.state=state.slice();
model.nzcross=n*(n-1)/2+4*n;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
BOUNCE.prototype.define = function BOUNCE() {
n=2;
k=1;
ipar=[];
for(i=1;i<=n;i+=1) {
for(j=i+1;j<=n;j+=1) {
ipar[k-1]=i;
k=k+1;
ipar[k-1]=j;
k=k+1;
}
}
walls=[0,5,0,5];
x=[2,2.5];
xd=[0,0];
y=[3,5];
yd=[0,0];
g=9.81;
C=0;
rpar1=ones(n,1);
rpar2=rpar1;
state=[x,xd,y,yd];
state=transpose(state);
model=scicos_model();
model.sim=list("bounce_ball",4);
model.in1=[];
model.out=[n,n];
model.state=state.slice();
model.rpar=[rpar1,rpar2,walls,g,C];
model.ipar=ipar;
model.nzcross=n*(n-1)/2+4*n;
model.blocktype="c";
model.dep_ut=[None,true];
exprs=[strcat(sci2exp(rpar1)),strcat(sci2exp(rpar2)),strcat(sci2exp(walls)),strcat(sci2exp(x)),strcat(sci2exp(xd)),strcat(sci2exp(y)),strcat(sci2exp(yd))];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
BOUNCE.prototype.details = function BOUNCE() {
}
}
/* autogenerated from "macros/Misc/scifunc_block_m.sci" */
function scifunc_block_m() {
scifunc_block_m.prototype.get = function scifunc_block_m() {
}
scifunc_block_m.prototype.set = function scifunc_block_m() {
needcompile=0;
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
exprs=graphics.exprs;
while (true) {
[ok,i,o,ci,co,xx,z,rpar,auto0,deptime,lab]=scicos_getvalue(["Set scifunc_block parameters","only regular blocks supported"],["input ports sizes","output port sizes","input event ports sizes","output events ports sizes","initial continuous state","initial discrete state","System parameters vector","initial firing vector (<0 for no firing)","is block always active (0:no, 1:yes)"],list("mat",[-1,2],"mat",[-2,2],"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",1),exprs(1));
if (!ok) {
break
}
exprs[1-1]=lab;
xx=xx.slice();
z=z.slice();
rpar=rpar.slice();
it=ones(1,size(i,1));
ot=ones(1,size(o,1));
nrp=prod(size(rpar));
ni=size(i,1);
no=size(o,1);
ci=int(ci.slice());
nci=size(ci,1);
co=int(co.slice());
nco=size(co,1);
[ok,tt,dep_ut]=genfunc2(exprs[2-1],i,o,nci,nco,size(xx,1),size(z,1),nrp,"c");
dep_ut[2-1]=(1==deptime);
if (!ok) {
break
}
[model,graphics,ok]=set_io(model,graphics,list(i,it),list(o,ot),ci,co);
if (ok) {
auto=auto0;
model.state=xx;
model.dstate=z;
model.rpar=rpar;
if (model.ipar!=0) {
model.opar=model.ipar;
model.ipar=0;
}
if (or(model.opar!=tt)) {
needcompile=4;
}
model.opar=tt;
model.firing=auto;
model.dep_ut=dep_ut;
x.model=model;
exprs[2-1]=tt;
graphics.exprs=exprs;
x.graphics=graphics;
break
}
}
needcompile=resume(needcompile)
}
scifunc_block_m.prototype.define = function scifunc_block_m() {
in1=1;
out=1;
clkin=[];
clkout=[];
x0=[];
z0=[];
typ="c";
auto=[];
rpar=[];
it=1;
model=scicos_model();
model.sim=list("scifunc",3);
model.in1=in1;
model.in2=in1;
model.intyp=it;
model.out=out;
model.out2=out;
model.outtyp=it;
model.evtin=clkin;
model.evtout=clkout;
model.state=x0;
model.dstate=z0;
model.rpar=rpar;
model.ipar=0;
model.opar=list();
model.blocktype=typ;
model.firing=auto;
model.dep_ut=[true,None];
exprs=list([sci2exp([in1,in1]),sci2exp([out,out]),sci2exp(clkin),sci2exp(clkout),strcat(sci2exp(x0)),strcat(sci2exp(z0)),strcat(sci2exp(rpar)),sci2exp(auto),sci2exp(0)],list("y1=sin(u1)"," "," ","y1=sin(u1)"," "," "," "));
gr_i=[];
x=standard_define([4,2],model,exprs,gr_i);
}
scifunc_block_m.prototype.details = function scifunc_block_m() {
}
}
/* autogenerated from "macros/Misc/c_block.sci" */
function c_block() {
c_block.prototype.get = function c_block() {
}
c_block.prototype.set = function c_block() {
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
label=graphics.exprs;
while (true) {
[ok,i,o,rpar,funam,lab]=scicos_getvalue("Set C_block parameters",["input ports sizes","output port sizes","System parameters vector","function name"],list("vec",-1,"vec",-1,"vec",-1,"str",-1),label(1));
if (!ok) {
break
}
if (funam==" ") {
break
}
label[1-1]=lab;
rpar=rpar.slice();
i=int(i.slice());
ni=size(i,1);
o=int(o.slice());
no=size(o,1);
tt=label[2-1];
if (model.sim(1)!=funam||size(model.in1,"*")!=size(i,"*")||size(model.out,"*")!=size(o,"*")) {
tt=[];
}
[ok,tt]=CFORTR(funam,tt,i,o);
if (!ok) {
break
}
[model,graphics,ok]=check_io(model,graphics,i,o,[],[]);
if (ok) {
model.sim[1-1]=funam;
model.rpar=rpar;
label[2-1]=tt;
x.model=model;
graphics.exprs=label;
x.graphics=graphics;
break
}
}
}
c_block.prototype.define = function c_block() {
in1=1;
out=1;
clkin=[];
clkout=[];
x0=[];
z0=[];
typ="c";
auto=[];
rpar=[];
funam="toto";
model=scicos_model();
model.sim=list(" ",2001);
model.in1=in1;
model.out=out;
model.evtin=clkin;
model.evtout=clkout;
model.state=x0;
model.dstate=z0;
model.rpar=rpar;
model.ipar=0;
model.blocktype=typ;
model.firing=auto;
model.dep_ut=[true,None];
label=list([sci2exp(in1),sci2exp(out),strcat(sci2exp(rpar)),funam],list([]));
gr_i=[];
x=standard_define([3,2],model,label,gr_i);
}
c_block.prototype.details = function c_block() {
}
}
/* autogenerated from "macros/Misc/CONSTRAINT2_c.sci" */
function CONSTRAINT2_c() {
CONSTRAINT2_c.prototype.get = function CONSTRAINT2_c() {
}
CONSTRAINT2_c.prototype.set = function CONSTRAINT2_c() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
ask_again=None;
[ok,x0,xd0,id,exprs]=scicos_getvalue("Set Constraint block parameters",["Initial guess values of states x","Initial guess values of derivative x\'","Id(i)=1: if x\'(i) is present in the feedback, else Id(i)=0"],list("vec",-1,"vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
x0=x0.slice();
N=size(x0,"*");
xd0=xd0.slice();
Nxd=size(xd0,"*");
id=id.slice();
Nid=size(id,"*");
if ((N!=Nxd)||(N!=Nid)) {
message("incompatible sizes, states, their derivatives, and ID should be the same size ");
ask_again=true;
}
if ((N<=0&&!ask_again)) {
x_message("number of states (constraints) must be > 0 ");
ask_again=true;
}
if ((!ask_again)) {
for(i=1;i<=N;i+=1) {
if (!((id(i)==0)||(id(i)==1))) {
ask_again=true;
x_message(["Id(i) must be either","0 when x\'(i) is not present in the feedback","1: when x\'(i) is present in the feedback"]);
break
}
if ((id(i)==0)) {
id[i-1]=-1;
}
}
}
if (!ask_again) {
graphics.exprs=exprs;
model.state=[x0,xd0];
model.out=[N,N];
model.in1=N;
model.ipar=id;
x.graphics=graphics;
x.model=model;
break
}
}
}
CONSTRAINT2_c.prototype.define = function CONSTRAINT2_c() {
x0=[0];
xd0=[0];
id=[0];
model=scicos_model();
model.sim=list("constraint_c",10004);
model.in1=1;
model.out=[1,1];
model.state=[x0,xd0];
model.ipar=id;
model.blocktype="c";
model.dep_ut=[None,true];
exprs=list(strcat(sci2exp(x0)),strcat(sci2exp(xd0)),strcat(sci2exp(id)));
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
CONSTRAINT2_c.prototype.details = function CONSTRAINT2_c() {
}
}
/* autogenerated from "macros/Misc/generic_block.sci" */
function generic_block() {
generic_block.prototype.get = function generic_block() {
}
generic_block.prototype.set = function generic_block() {
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
label=graphics.exprs;
if (size(label,"*")==14) {
label[9-1]=[];
}
while (true) {
[ok,function_name,funtyp,i,o,ci,co,xx,z,rpar,ipar,auto0,depu,dept,lab]=scicos_getvalue("Set GENERIC block parameters",["simulation function","function type (0,1,2,..)","input ports sizes","output port sizes","input event ports sizes","output events ports sizes","initial continuous state","initial discrete state","Real parameters vector","Integer parameters vector","initial firing vector (<0 for no firing)","direct feedthrough (y or n)","time dependence (y or n)"],list("str",1,"vec",1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec","sum(%6)","str",1,"str",1),label);
if (!ok) {
break
}
label=lab;
function_name=stripblanks(function_name);
xx=xx.slice();
z=z.slice();
rpar=rpar.slice();
ipar=int(ipar.slice());
i=int(i.slice());
o=int(o.slice());
ci=int(ci.slice());
co=int(co.slice());
funtyp=int(funtyp);
if (funtyp<0) {
message("function type cannot be negative");
ok=None;
}
if ([ci,co]!=[]) {
if (max([ci,co])>1) {
message("vector event links not supported");
ok=None;
}
}
depu=stripblanks(depu);
if (part(depu,1)=="y") {
depu=true;
} else {
depu=None;
}
dept=stripblanks(dept);
if (part(dept,1)=="y") {
dept=true;
} else {
dept=None;
}
dep_ut=[depu,dept];
if (ok) {
[model,graphics,ok]=check_io(model,graphics,i,o,ci,co);
}
if (ok) {
if (funtyp==3) {
needcompile=4;
}
model.sim=list(function_name,funtyp);
model.state=xx;
model.dstate=z;
model.rpar=rpar;
model.ipar=ipar;
model.firing=auto0;
model.dep_ut=dep_ut;
arg1.model=model;
graphics.exprs=label;
arg1.graphics=graphics;
x=arg1;
break
}
}
needcompile=resume(needcompile)
}
generic_block.prototype.define = function generic_block() {
model=scicos_model();
function_name="sinblk";
funtyp=1;
model.sim=list(function_name,funtyp);
model.in1=1;
model.out=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[function_name,sci2exp(funtyp),sci2exp(model.in1),sci2exp(model.out),sci2exp(model.evtin),sci2exp(model.evtout),sci2exp(model.state),sci2exp(model.dstate),sci2exp(model.rpar),sci2exp(model.ipar),sci2exp(model.firing),"y","n"];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
generic_block.prototype.details = function generic_block() {
}
}
/* autogenerated from "macros/Misc/RATELIMITER.sci" */
function RATELIMITER() {
RATELIMITER.prototype.get = function RATELIMITER() {
}
RATELIMITER.prototype.set = function RATELIMITER() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,maxp,minp,exprs]=scicos_getvalue("Set rate limiter parameters",["max slope","min slope"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (maxp<=minp||maxp<=0||minp>=0) {
message("We must have max_slope> 0 > min_slope.");
} else {
rpar=[maxp,minp];
model.rpar=rpar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
RATELIMITER.prototype.define = function RATELIMITER() {
minp=-1;
maxp=1;
rpar=[maxp,minp];
model=scicos_model();
model.sim=list("ratelimiter",4);
model.in1=1;
model.out=1;
model.rpar=rpar;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string(maxp),string(minp)];
gr_i=[];
x=standard_define([3.5,2],model,exprs,gr_i);
}
RATELIMITER.prototype.details = function RATELIMITER() {
}
}
/* autogenerated from "macros/Misc/DEBUG.sci" */
function DEBUG() {
DEBUG.prototype.get = function DEBUG() {
}
DEBUG.prototype.set = function DEBUG() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
textmp=exprs(2);
ok=true;
while (1==1) {
[txt]=dialog(["Enter scilab instructions for debugging."," Inputs are block and flag, output is block"],textmp);
if (txt!=[]) {
tt=["block=debug_scicos(block,flag)"];
if (execstr("deff(tt,txt)","errcatch")==0) {
warnMode=warning("query");
warning("off");
save(TMPDIR+"/debug_scicos",debug_scicos);
warning(warnMode);
exprs[2-1]=txt;
if ((scicos_debug()!=2&&scicos_debug()!=3)) {
scicos_debug(2);
}
break
} else {
message(["Error in the instructions",lasterror()]);
}
} else {
ok=None;
break
}
}
if (ok) {
graphics.exprs=exprs;
x.graphics=graphics;
}
}
DEBUG.prototype.define = function DEBUG() {
model=scicos_model();
model.sim=list("%debug_scicos",99);
model.blocktype="d";
exprs=list("","xcos_debug_gui(flag,block);");
gr_i=[];
x=standard_define([8,2],model,exprs,gr_i);
}
DEBUG.prototype.details = function DEBUG() {
}
}
/* autogenerated from "macros/Misc/RELATIONALOP.sci" */
function RELATIONALOP() {
RELATIONALOP.prototype.get = function RELATIONALOP() {
}
RELATIONALOP.prototype.set = function RELATIONALOP() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,1)==2) {
exprs=[exprs,sci2exp(1)];
}
while (true) {
[ok,rule,zcr,Datatype,exprs]=scicos_getvalue("Set parameters",["Operator: == (0), ~= (1), < (2), <= (3), > (4), >= (5)","Use zero crossing (no: 0), (yes: 1)","Datatype (1=double 3=int32 ...)"],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
rule=int(rule);
if (zcr!=0) {
zcr=1;
}
if ((rule<0)||(rule>5)) {
message("Incorrect operator "+string(rule)+" ; must be 0 to 5.");
ok=None;
}
if ((Datatype==1)) {
model.sim=list("relational_op",4);
} else if ((Datatype==3||Datatype==9)) {
model.sim=list("relational_op_i32",4);
} else if ((Datatype==4)) {
model.sim=list("relational_op_i16",4);
} else if ((Datatype==5)) {
model.sim=list("relational_op_i8",4);
} else if ((Datatype==6)) {
model.sim=list("relational_op_ui32",4);
} else if ((Datatype==7)) {
model.sim=list("relational_op_ui16",4);
} else if ((Datatype==8)) {
model.sim=list("relational_op_ui8",4);
} else {
message("Datatype is not supported");
ok=None;
}
if (ok) {
it=Datatype*ones(1,2);
ot=Datatype;
in1=[-1,-2,-1,-2];
out=[-1,-2];
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
if (ok) {
if (rule==0) {
label="==";
} else if (rule==1) {
label="~=";
} else if (rule==2) {
label="&#60;";
} else if (rule==3) {
label="&#8804;";
} else if (rule==4) {
label="&#62;";
} else if (rule==5) {
label="&#8805;";
}
graphics.exprs=exprs;
graphics.style=["fontSize=13;fontStyle=1;displayedLabel="+label];
model.ipar=[rule];
model.nzcross=zcr;
model.nmode=zcr;
x.graphics=graphics;
x.model=model;
break
}
}
}
RELATIONALOP.prototype.define = function RELATIONALOP() {
ipar=[2];
label="&lt";
model=scicos_model();
model.sim=list("relationalop",4);
model.in1=[1,1];
model.out=1;
model.ipar=ipar;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string(ipar),string(0)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
x.graphics.style=["fontSize=13;fontStyle=1;displayedLabel="+label];
}
RELATIONALOP.prototype.details = function RELATIONALOP() {
}
}
/* autogenerated from "macros/Misc/CONSTRAINT_c.sci" */
function CONSTRAINT_c() {
CONSTRAINT_c.prototype.get = function CONSTRAINT_c() {
}
CONSTRAINT_c.prototype.set = function CONSTRAINT_c() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,x0,exprs]=scicos_getvalue("Set solver block parameters","Initial guess values",list("vec",-1),exprs);
if (!ok) {
break
}
x0=x0.slice();
N=size(x0,"*");
if (N<=0) {
message("number of states (constraints) must be > 0 ");
} else {
[model,graphics,ok]=check_io(model,graphics,N,N,[],[]);
if (ok) {
graphics.exprs=exprs;
model.state=[x0,zeros(N,1)];
model.out=N;
model.in1=N;
model.ipar=-1*ones(N,1);
x.graphics=graphics;
x.model=model;
break
}
}
}
}
CONSTRAINT_c.prototype.define = function CONSTRAINT_c() {
x0=[0,0];
model=scicos_model();
model.sim=list("constraint_c",10004);
model.in1=1;
model.out=1;
model.ipar=0;
model.state=x0;
model.blocktype="c";
model.dep_ut=[None,true];
exprs="0";
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
CONSTRAINT_c.prototype.details = function CONSTRAINT_c() {
}
}
/* autogenerated from "macros/Misc/IMPSPLIT_f.sci" */
function IMPSPLIT_f() {
IMPSPLIT_f.prototype.get = function IMPSPLIT_f() {
}
IMPSPLIT_f.prototype.set = function IMPSPLIT_f() {
x=arg1;
}
IMPSPLIT_f.prototype.define = function IMPSPLIT_f() {
model=scicos_model();
model.sim="limpsplit";
mo=modelica();
mo.model="limpsplit";
mo.inputs="n";
mo.outputs=["n","n"];
model.equations=mo;
model.in1=ones(size(mo.inputs,"*"),1);
model.out=ones(size(mo.outputs,"*"),1);
x=standard_define([1,1]/3,model,[],[]);
x.graphics.in_implicit=["I"];
x.graphics.out_implicit=["I","I"];
}
IMPSPLIT_f.prototype.details = function IMPSPLIT_f() {
}
}
/* autogenerated from "macros/Misc/generic_block2.sci" */
function generic_block2() {
generic_block2.prototype.get = function generic_block2() {
}
generic_block2.prototype.set = function generic_block2() {
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
label=graphics.exprs;
if (size(label,"*")==14) {
label[9-1]=[];
}
while (true) {
[ok,function_name,funtyp,i,o,ci,co,xx,z,rpar,ipar,nmode,nzcr,auto0,depu,dept,lab]=scicos_getvalue("Set GENERIC block parameters",["simulation function","function type (0,1,2,..)","input ports sizes","output port sizes","input event ports sizes","output events ports sizes","initial continuous state","initial discrete state","Real parameters vector","Integer parameters vector","number of modes","number of zero_crossings","initial firing vector (<0 for no firing)","direct feedthrough (y or n)","time dependence (y or n)"],list("str",1,"vec",1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",1,"vec",1,"vec","sum(%6)","str",1,"str",1),label);
if (!ok) {
break
}
label=lab;
function_name=stripblanks(function_name);
xx=xx.slice();
z=z.slice();
rpar=rpar.slice();
ipar=int(ipar.slice());
i=int(i.slice());
o=int(o.slice());
ci=int(ci.slice());
co=int(co.slice());
funtyp=int(funtyp);
if (funtyp<0) {
message("function type cannot be negative");
ok=None;
}
if ([ci,co]!=[]) {
if (max([ci,co])>1) {
message("vector event links not supported");
ok=None;
}
}
depu=stripblanks(depu);
if (part(depu,1)=="y") {
depu=true;
} else {
depu=None;
}
dept=stripblanks(dept);
if (part(dept,1)=="y") {
dept=true;
} else {
dept=None;
}
dep_ut=[depu,dept];
if (ok) {
[model,graphics,ok]=check_io(model,graphics,i,o,ci,co);
}
if (ok) {
if (funtyp==3) {
needcompile=4;
}
model.sim=list(function_name,funtyp);
model.state=xx;
model.dstate=z;
model.rpar=rpar;
model.ipar=ipar;
model.firing=auto0;
model.nzcross=nzcr;
model.nmode=nmode;
model.dep_ut=dep_ut;
arg1.model=model;
graphics.exprs=label;
arg1.graphics=graphics;
x=arg1;
break
}
}
needcompile=resume(needcompile)
}
generic_block2.prototype.define = function generic_block2() {
model=scicos_model();
function_name="sinblk";
funtyp=1;
model.sim=list(function_name,funtyp);
model.in1=1;
model.out=1;
model.evtin=[];
model.evtout=[];
model.state=[];
model.dstate=[];
model.rpar=[];
model.ipar=[];
model.blocktype="c";
model.firing=[];
model.dep_ut=[true,None];
label=[function_name,sci2exp(funtyp),sci2exp(model.in1),sci2exp(model.out),sci2exp(model.evtin),sci2exp(model.evtout),sci2exp(model.state),sci2exp(model.dstate),sci2exp(model.rpar),sci2exp(model.ipar),sci2exp(model.nmode),sci2exp(model.nzcross),sci2exp(model.firing),"y","n"];
gr_i=[];
x=standard_define([2,2],model,label,gr_i);
}
generic_block2.prototype.details = function generic_block2() {
}
}
/* autogenerated from "macros/Misc/generic_block3.sci" */
function generic_block3() {
generic_block3.prototype.get = function generic_block3() {
}
generic_block3.prototype.set = function generic_block3() {
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
label=graphics.exprs;
if (size(label,"*")==14) {
label[9-1]=[];
}
while (true) {
[ok,function_name,funtyp,in1,it,out,ot,ci,co,xx,z,oz,rpar,ipar,opar,nmode,nzcr,auto0,depu,dept,lab]=scicos_getvalue("Set GENERIC block parameters",["Simulation function","Function type (0,1,2,..)","Input ports sizes","Input ports type","Output port sizes","Output ports type","Input event ports sizes","Output events ports sizes","Initial continuous state","Initial discrete state","Initial object state","Real parameters vector","Integer parameters vector","Object parameters list","Number of modes","Number of zero crossings","Initial firing vector (<0 for no firing)","Direct feedthrough (y or n)","Time dependence (y or n)"],list("str",1,"vec",1,"mat",[-1,2],"vec",-1,"mat",[-1,2],"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"lis",-1,"vec",-1,"vec",-1,"lis",-1,"vec",1,"vec",1,"vec","sum(%8)","str",1,"str",1),label);
if (!ok) {
break
}
label=lab;
function_name=stripblanks(function_name);
xx=xx.slice();
z=z.slice();
rpar=rpar.slice();
ipar=int(ipar.slice());
ci=int(ci.slice());
co=int(co.slice());
funtyp=funtyp;
if (funtyp<0) {
message("function type cannot be negative");
ok=None;
}
if ([ci,co]!=[]) {
if (max([ci,co])>1) {
message("vector event links not supported");
ok=None;
}
}
if (type(opar)!=15) {
message("object parameter must be a list");
ok=None;
}
if (type(oz)!=15) {
message("discrete object state must be a list");
ok=None;
}
depu=stripblanks(depu);
if (part(depu,1)=="y") {
depu=true;
} else {
depu=None;
}
dept=stripblanks(dept);
if (part(dept,1)=="y") {
dept=true;
} else {
dept=None;
}
dep_ut=[depu,dept];
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),ci,co);
}
if (ok) {
if (funtyp==3) {
needcompile=4;
}
model.sim=list(function_name,funtyp);
model.state=xx;
model.dstate=z;
model.odstate=oz;
model.rpar=rpar;
model.ipar=ipar;
model.opar=opar;
model.firing=auto0;
model.nzcross=nzcr;
model.nmode=nmode;
model.dep_ut=dep_ut;
arg1.model=model;
graphics.exprs=label;
arg1.graphics=graphics;
x=arg1;
break
}
}
needcompile=resume(needcompile)
}
generic_block3.prototype.define = function generic_block3() {
model=scicos_model();
function_name="sinblk";
funtyp=4;
model.sim=list(function_name,funtyp);
model.in1=1;
model.in2=1;
model.intyp=1;
model.out=1;
model.out2=1;
model.outtyp=1;
model.dep_ut=[true,None];
label=[function_name,sci2exp(funtyp),sci2exp([model.in1,model.in2]),sci2exp(model.intyp),sci2exp([model.out,model.out2]),sci2exp(model.outtyp),sci2exp(model.evtin),sci2exp(model.evtout),sci2exp(model.state),sci2exp(model.dstate),sci2exp(model.odstate),sci2exp(model.rpar),sci2exp(model.ipar),sci2exp(model.opar),sci2exp(model.nmode),sci2exp(model.nzcross),sci2exp(model.firing),"y","n"];
gr_i=[];
x=standard_define([4,2],model,label,gr_i);
}
generic_block3.prototype.details = function generic_block3() {
}
}
/* autogenerated from "macros/Misc/DEBUG_SCICOS.sci" */
function DEBUG_SCICOS() {
DEBUG_SCICOS.prototype.get = function DEBUG_SCICOS() {
}
DEBUG_SCICOS.prototype.set = function DEBUG_SCICOS() {
arg1.gui="DEBUG";
[x,y,typ]=DEBUG("set",arg1);
}
DEBUG_SCICOS.prototype.define = function DEBUG_SCICOS() {
x=DEBUG("define");
}
DEBUG_SCICOS.prototype.details = function DEBUG_SCICOS() {
}
}
/* autogenerated from "macros/Misc/EDGETRIGGER.sci" */
function EDGETRIGGER() {
EDGETRIGGER.prototype.get = function EDGETRIGGER() {
}
EDGETRIGGER.prototype.set = function EDGETRIGGER() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,edge,exprs]=scicos_getvalue("Set edge trigger block parameters",["rising (1), falling (-1), both (0)"],list("vec",1),exprs);
if (!ok) {
break
}
model.ipar=sign(edge);
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
EDGETRIGGER.prototype.define = function EDGETRIGGER() {
edge=1;
model=scicos_model();
model.sim=list("edgetrig",4);
model.in1=1;
model.out=1;
model.dstate=0;
model.nzcross=1;
model.ipar=sign(edge);
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string(edge)];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
EDGETRIGGER.prototype.details = function EDGETRIGGER() {
}
}
/* autogenerated from "macros/Misc/TEXT_f.sci" */
function TEXT_f() {
TEXT_f.prototype.get = function TEXT_f() {
}
TEXT_f.prototype.set = function TEXT_f() {
x=arg1;
graphics=arg1.graphics;
orig=graphics.orig;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")==1) {
exprs=[exprs,"3","1"];
}
while (true) {
[ok,txt,font,siz,exprs]=scicos_getvalue("Set Text block parameters",["Text","Font number","Font size"],list("str",-1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (font<=0||font>6) {
message("Font number must be greater than 0 and less than 7");
ok=None;
}
if (siz<0) {
message("Font size must be positive");
ok=None;
}
if (ok) {
graphics.exprs=exprs;
gh_winpal=gca();
default_font_style=gh_winpal.font_style;
default_font_size=gh_winpal.font_size;
default_font_color=gh_winpal.font_color;
gh_winpal.font_style=font;
gh_winpal.font_size=siz;
r=xstringl(0,0,exprs(1),evstr(exprs(2)),evstr(exprs(3)));
gh_winpal.font_style=default_font_style;
gh_winpal.font_size=default_font_size;
gh_winpal.font_color=default_font_color;
sz=r.slice(3-1,4);
graphics.sz=sz;
x.graphics=graphics;
ipar=[font,siz];
model.rpar=txt;
model.ipar=ipar;
x.model=model;
break
}
}
}
TEXT_f.prototype.define = function TEXT_f() {
font=2;
siz=1;
model=scicos_model();
model.sim="text";
model.rpar="Text";
model.ipar=[font,siz];
exprs=["Text",string(font),string(siz)];
graphics=scicos_graphics();
graphics.orig=[0,0];
graphics.sz=[2,1];
graphics.exprs=exprs;
x=mlist(["Text","graphics","model","void","gui"],graphics,model," ","TEXT_f");
}
TEXT_f.prototype.details = function TEXT_f() {
}
}
/* autogenerated from "macros/Misc/CBLOCK4.sci" */
function CBLOCK4() {
CBLOCK4.prototype.get = function CBLOCK4() {
}
CBLOCK4.prototype.set = function CBLOCK4() {
x=arg1;
model=arg1.model;
graphics=arg1.graphics;
label=graphics.exprs;
while (true) {
[ok,function_name,impli,in1,it,out,ot,ci,co,xx,z,oz,rpar,ipar,opar,nmode,nzcr,auto0,depu,dept,lab]=scicos_getvalue("Set C-Block4 block parameters",["Simulation function","Is block implicit? (y,n)","Input ports sizes","Input ports type","Output port sizes","Output ports type","Input event ports sizes","Output events ports sizes","Initial continuous state","Initial discrete state","Initial object state","Real parameters vector","Integer parameters vector","Object parameters list","Number of modes","Number of zero crossings","Initial firing vector (<0 for no firing)","Direct feedthrough (y or n)","Time dependence (y or n)"],list("str",1,"str",1,"mat",[-1,2],"vec",-1,"mat",[-1,2],"vec",-1,"vec",-1,"vec",-1,"vec",-1,"vec",-1,"lis",-1,"vec",-1,"vec",-1,"lis",-1,"vec",1,"vec",1,"vec","sum(%8)","str",1,"str",1),label(1));
if (!ok) {
break
}
label[1-1]=lab;
funam=stripblanks(function_name);
xx=xx.slice();
z=z.slice();
rpar=rpar.slice();
ipar=int(ipar.slice());
nx=size(xx,1);
nz=size(z,1);
ci=int(ci.slice());
nevin=size(ci,1);
co=int(co.slice());
nevout=size(co,1);
if (part(impli,1)=="y") {
funtyp=12004;
} else {
funtyp=2004;
}
if ([ci,co]!=[]) {
if (max([ci,co])>1) {
message("vector event links not supported");
ok=None;
}
}
if (ok) {
depu=stripblanks(depu);
if (part(depu,1)=="y") {
depu=true;
} else {
depu=None;
}
dept=stripblanks(dept);
if (part(dept,1)=="y") {
dept=true;
} else {
dept=None;
}
dep_ut=[depu,dept];
if (funam==" ") {
break
}
if (model.sim(1)!=funam||sign(size(model.state,"*"))!=sign(nx)||sign(size(model.dstate,"*"))!=sign(nz)||model.nzcross!=nzcr||sign(size(model.evtout,"*"))!=sign(nevout)) {
tt=[];
}
tt=label[2-1];
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),ci,co);
}
if (ok) {
while (true) {
[ok,tt,cancel]=CC4(funam,tt);
if (!ok) {
if (cancel) {
break
}
} else {
model.sim=list(funam,funtyp);
model.state=xx;
model.dstate=z;
model.odstate=oz;
model.rpar=rpar;
model.ipar=ipar;
model.opar=opar;
model.firing=auto0;
model.nzcross=nzcr;
model.nmode=nmode;
model.dep_ut=dep_ut;
label[2-1]=tt;
x.model=model;
graphics.exprs=label;
x.graphics=graphics;
break
}
}
if (ok||cancel) {
break
}
}
}
}
CBLOCK4.prototype.define = function CBLOCK4() {
funam="toto";
model=scicos_model();
model.sim=list(" ",2004);
model.in1=1;
model.in2=1;
model.intyp=1;
model.out=1;
model.out2=1;
model.outtyp=1;
model.dep_ut=[true,None];
label=list([funam,"n",sci2exp([model.in1,model.in2]),sci2exp(model.intyp),sci2exp([model.out,model.out2]),sci2exp(model.outtyp),sci2exp(model.evtin),sci2exp(model.evtout),sci2exp(model.state),sci2exp(model.dstate),sci2exp(model.odstate),sci2exp(model.rpar),sci2exp(model.ipar),sci2exp(model.opar),sci2exp(model.nmode),sci2exp(model.nzcross),sci2exp(model.firing),"y","n"],[]);
gr_i=[];
x=standard_define([4,2],model,label,gr_i);
}
CBLOCK4.prototype.details = function CBLOCK4() {
}
}
/* autogenerated from "macros/Misc/BOUNCEXY.sci" */
function BOUNCEXY() {
BOUNCEXY.prototype.get = function BOUNCEXY() {
}
BOUNCEXY.prototype.set = function BOUNCEXY() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
dstate=model.dstate;
while (true) {
[ok,clrs,siz,win,imode,xmin,xmax,ymin,ymax,exprs]=scicos_getvalue("Set Scope parameters",["colors","radii","window number (-1 for automatic)","animation mode (0,1)","Xmin","Xmax","Ymin","Ymax"],list("vec",-1,"vec",-1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
mess=[];
if (size(clrs,"*")!=size(siz,"*")) {
mess=[mess,"colors and radii must have equal size (number of balls)"," "];
ok=None;
}
if (win<-1) {
mess=[mess,"Window number cannot be inferior than -1"," "];
ok=None;
}
if (ymin>=ymax) {
mess=[mess,"Ymax must be greater than Ymin"," "];
ok=None;
}
if (xmin>=xmax) {
mess=[mess,"Xmax must be greater than Xmin"," "];
ok=None;
}
if (!ok) {
message(mess);
} else {
rpar=[xmin,xmax,ymin,ymax];
ipar=[win,imode,clrs.slice()];
z=[];
for(i=1;i<=size(clrs,"*");i+=1) {
z[6*(i-1)+1-1]=0;
z[6*(i-1)+2-1]=0;
z[6*(i-1)+3-1]=2*siz(i);
z[6*(i-1)+4-1]=2*siz(i);
z[6*(i-1)+5-1]=0.000;
z[6*(i-1)+6-1]=64.0*360.000;
}
model.dstate=z;
model.rpar=rpar;
model.ipar=ipar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
BOUNCEXY.prototype.define = function BOUNCEXY() {
win=-1;
imode=1;
clrs=[1,2];
siz=[1,1];
xmin=-5;
xmax=5;
ymin=0;
ymax=15;
model=scicos_model();
model.sim=list("bouncexy",4);
model.in1=[-1,-1];
model.in2=[1,1];
model.intyp=[1,1];
model.evtin=1;
z=[];
for(i=1;i<=size(clrs,"*");i+=1) {
z[6*(i-1)+1-1]=0;
z[6*(i-1)+2-1]=0;
z[6*(i-1)+3-1]=2*siz(i);
z[6*(i-1)+4-1]=2*siz(i);
z[6*(i-1)+5-1]=0.000;
z[6*(i-1)+6-1]=64.0*360.000;
}
model.dstate=z;
model.rpar=[xmin,xmax,ymin,ymax];
model.ipar=[win,imode,clrs.slice()];
model.blocktype="d";
model.firing=[];
model.dep_ut=[None,None];
exprs=[strcat(sci2exp(clrs)),strcat(sci2exp(siz)),strcat(sci2exp(win)),strcat(sci2exp(1)),strcat(sci2exp(xmin)),strcat(sci2exp(xmax)),strcat(sci2exp(ymin)),strcat(sci2exp(ymax))];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
BOUNCEXY.prototype.details = function BOUNCEXY() {
}
}
/* autogenerated from "macros/Misc/BACKLASH.sci" */
function BACKLASH() {
BACKLASH.prototype.get = function BACKLASH() {
}
BACKLASH.prototype.set = function BACKLASH() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
rpar=model.rpar;
while (true) {
[ok,ini,gap,zcr,exprs]=scicos_getvalue("Set backlash parameters",["initial output","gap","use zero-crossing (0:no, 1:yes)"],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (ok) {
graphics.exprs=exprs;
rpar[1-1]=ini;
rpar[2-1]=gap;
if (zcr!=0) {
model.nzcross=2;
} else {
model.nzcross=0;
}
model.rpar=rpar;
x.graphics=graphics;
x.model=model;
break
}
}
}
BACKLASH.prototype.define = function BACKLASH() {
exprs=["0","1","1"];
model=scicos_model();
model.sim=list("backlash",4);
model.in1=1;
model.out=1;
model.rpar=[0,1];
model.nzcross=2;
model.blocktype="c";
model.dep_ut=[true,None];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
BACKLASH.prototype.details = function BACKLASH() {
}
}
/* autogenerated from "macros/Misc/BPLATFORM.sci" */
function BPLATFORM() {
BPLATFORM.prototype.get = function BPLATFORM() {
}
BPLATFORM.prototype.set = function BPLATFORM() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
dstate=model.dstate;
while (true) {
[ok,plen,csiz,phi,xmin,xmax,ymin,ymax,exprs]=scicos_getvalue("Set Scope parameters",["pendulum length","cart size (square side)","slope","Xmin","Xmax","Ymin","Ymax"],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
mess=[];
if (plen<=0||csiz<=0) {
mess=[mess,"Pendulum length and cart size must be positive."," "];
ok=None;
}
if (ymin>=ymax) {
mess=[mess,"Ymax must be greater than Ymin"," "];
ok=None;
}
if (xmin>=xmax) {
mess=[mess,"Xmax must be greater than Xmin"," "];
ok=None;
}
if (!ok) {
message(mess);
} else {
rpar=[plen,csiz,phi,xmin,xmax,ymin,ymax];
model.rpar=rpar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
BPLATFORM.prototype.define = function BPLATFORM() {
plen=2;
csiz=2;
phi=0;
xmin=-5;
xmax=5;
ymin=0;
ymax=15;
model=scicos_model();
model.sim=list("bplatform2",5);
model.in1=[1,1];
model.evtin=1;
model.dstate=0;
model.rpar=[plen,csiz,phi,xmin,xmax,ymin,ymax];
model.blocktype="d";
model.dep_ut=[None,None];
exprs=string(model.rpar);
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
BPLATFORM.prototype.details = function BPLATFORM() {
}
}
/* autogenerated from "macros/Misc/func_block.sci" */
function func_block() {
func_block.prototype.get = function func_block() {
}
func_block.prototype.set = function func_block() {
model=arg1.model;
graphics=arg1.graphics;
exprs=graphics.exprs;
x=arg1;
model=x.model;
[ok,mac,exprs]=genfunc(exprs);
if (ok) {
model.sim=mac;
graphics.exprs=exprs;
x.model=model;
x.graphics=graphics;
}
}
func_block.prototype.define = function func_block() {
model=scicos_model();
model.sim=" ";
model.in1=1;
model.out=1;
model.blocktype="c";
model.dep_ut=[true,None];
exprs="v=sin(u);y=u*v";
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
func_block.prototype.details = function func_block() {
}
}
/* autogenerated from "macros/Misc/SPLIT_f.sci" */
function SPLIT_f() {
SPLIT_f.prototype.get = function SPLIT_f() {
}
SPLIT_f.prototype.set = function SPLIT_f() {
x=arg1;
}
SPLIT_f.prototype.define = function SPLIT_f() {
model=scicos_model();
model.sim="lsplit";
model.in1=-1;
model.out=[-1,-1,-1];
model.blocktype="c";
model.dep_ut=[true,None];
x=standard_define([1,1]/3,model,[],[]);
}
SPLIT_f.prototype.details = function SPLIT_f() {
}
}
/* autogenerated from "macros/Misc/PENDULUM_ANIM.sci" */
function PENDULUM_ANIM() {
PENDULUM_ANIM.prototype.get = function PENDULUM_ANIM() {
}
PENDULUM_ANIM.prototype.set = function PENDULUM_ANIM() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
dstate=model.dstate;
while (true) {
[ok,plen,csiz,phi,xmin,xmax,ymin,ymax,exprs]=scicos_getvalue("Set Scope parameters",["pendulum length","cart size (square side)","slope","Xmin","Xmax","Ymin","Ymax"],list("vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
mess=[];
if (plen<=0||csiz<=0) {
mess=[mess,"Pendulum length and cart size must be positive."," "];
ok=None;
}
if (ymin>=ymax) {
mess=[mess,"Ymax must be greater than Ymin"," "];
ok=None;
}
if (xmin>=xmax) {
mess=[mess,"Xmax must be greater than Xmin"," "];
ok=None;
}
if (!ok) {
message(mess);
} else {
rpar=[plen,csiz,phi,xmin,xmax,ymin,ymax];
model.rpar=rpar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
PENDULUM_ANIM.prototype.define = function PENDULUM_ANIM() {
plen=2;
csiz=2;
phi=0;
xmin=-5;
xmax=5;
ymin=-5;
ymax=5;
model=scicos_model();
model.sim=list("anim_pen",5);
model.in1=[1,1];
model.evtin=1;
model.dstate=0;
model.rpar=[plen,csiz,phi,xmin,xmax,ymin,ymax];
model.blocktype="d";
model.dep_ut=[None,None];
exprs=string(model.rpar);
gr_i=[];
x=standard_define([3,3],model,exprs,gr_i);
}
PENDULUM_ANIM.prototype.details = function PENDULUM_ANIM() {
}
}
/* autogenerated from "macros/Misc/MEMORY_f.sci" */
function MEMORY_f() {
MEMORY_f.prototype.get = function MEMORY_f() {
}
MEMORY_f.prototype.set = function MEMORY_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,a,inh,exprs]=scicos_getvalue("Set memory block parameters",["initial condition","Inherit (1: no, 0: yes)"],list("vec",-1,"vec",1),exprs);
if (!ok) {
break
}
if (inh==0) {
inh=[];
} else {
inh=1;
}
[model,graphics,ok]=check_io(model,graphics,-1,-1,inh,[]);
out=size(a,"*");
if (out==0) {
ok=None;
messagebox("Initial condition empty","modal","error");
}
in1=out;
if (ok) {
graphics.exprs=exprs;
model.rpar=a;
model.in1=in1;
model.out=out;
x.graphics=graphics;
x.model=model;
break
}
}
}
MEMORY_f.prototype.define = function MEMORY_f() {
z=0;
in1=1;
exprs=[string(z),string(1)];
model=scicos_model();
model.sim="memo";
model.in1=in1;
model.out=in1;
model.evtin=1;
model.dstate=0;
model.rpar=z;
model.blocktype="m";
model.dep_ut=[None,None];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
MEMORY_f.prototype.details = function MEMORY_f() {
}
}
/* autogenerated from "macros/Misc/ENDBLK.sci" */
function ENDBLK() {
ENDBLK.prototype.get = function ENDBLK() {
}
ENDBLK.prototype.set = function ENDBLK() {
for(i=1;i<=length(arg1.model.rpar.objs);i+=1) {
o=arg1.model.rpar.objs(i);
if (typeof(o)=="Block"&&o.gui=="END_c") {
ppath=list(i);
break
}
}
newpar=list();
y=0;
for(path in ppath) {
np=size(path,"*");
spath=list();
for(k=1;k<=np;k+=1) {
spath[$+1-1]="model";
spath[$+1-1]="rpar";
spath[$+1-1]="objs";
spath[$+1-1]=path(k);
}
xx=arg1(spath);
execstr("xxn="+xx.gui+"(\'set\',xx)");
if (!isequalbitwise(xxn,xx)) {
model=xx.model;
model_n=xxn.model;
if (!is_modelica_block(xx)) {
modified=or(model.sim!=model_n.sim)||!isequal(model.state,model_n.state)||!isequal(model.dstate,model_n.dstate)||!isequal(model.odstate,model_n.odstate)||!isequal(model.rpar,model_n.rpar)||!isequal(model.ipar,model_n.ipar)||!isequal(model.opar,model_n.opar)||!isequal(model.label,model_n.label);
if (or(model.in1!=model_n.in1)||or(model.out!=model_n.out)||or(model.in2!=model_n.in2)||or(model.out2!=model_n.out2)||or(model.outtyp!=model_n.outtyp)||or(model.intyp!=model_n.intyp)) {
needcompile=1;
}
if (or(model.firing!=model_n.firing)) {
needcompile=2;
}
if ((size(model.in1,"*")!=size(model_n.in1,"*"))||(size(model.out,"*")!=size(model_n.out,"*"))||(size(model.evtin,"*")!=size(model_n.evtin,"*"))) {
needcompile=4;
}
if (model.sim=="input"||model.sim=="output") {
if (model.ipar!=model_n.ipar) {
needcompile=4;
}
}
if (or(model.blocktype!=model_n.blocktype)||or(model.dep_ut!=model_n.dep_ut)) {
needcompile=4;
}
if ((model.nzcross!=model_n.nzcross)||(model.nmode!=model_n.nmode)) {
needcompile=4;
}
if (prod(size(model_n.sim))>1) {
if (model_n.sim(2)>1000) {
if (model.sim(1)!=model_n.sim(1)) {
needcompile=4;
}
}
}
} else {
modified=or(model_n!=model);
eq=model.equations;
eqn=model_n.equations;
if (or(eq.model!=eqn.model)||or(eq.inputs!=eqn.inputs)||or(eq.outputs!=eqn.outputs)) {
needcompile=4;
}
}
arg1[spath-1]=xxn;
newpar[size(newpar)+1-1]=path;
y=max(y,needcompile);
}
}
x=arg1;
typ=newpar;
}
ENDBLK.prototype.define = function ENDBLK() {
scs_m_1=scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[-159.096,811.104,-121.216,617.984,1323,1008,331,284,630,480,0,7,1.4],Title="ENDBLK",tol=[0.0001,0.000001,1.000e-10,100001,0,0],tf=100000,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
scs_m_1.objs[1-1]=scicos_block(gui="END_c",graphics=scicos_graphics(orig=[272.104,249.11733],sz=[40,40],flip=true,theta=0,exprs="1.000E+08",pin=[],pout=[],pein=2,peout=2,gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim=list("scicosexit",4),in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=1,state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="d",firing=1.000e+08,dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m_1.objs[2-1]=scicos_link(xx=[292.104,292.104,261.83733,261.83733,292.104,292.104],yy=[243.40305,234.45067,234.45067,305.584,305.584,294.83162],id="drawlink",thick=[0,0],ct=[5,-1],from=[1,1,0],to=[1,1,1]);
model=scicos_model(sim="csuper",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=scs_m_1,ipar=[],opar=list(),blocktype="h",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list());
gr_i=[];
x=standard_define([2,2],model,[],gr_i);
}
ENDBLK.prototype.details = function ENDBLK() {
}
}
/* autogenerated from "macros/IntegerOp/INTMUL.sci" */
function INTMUL() {
INTMUL.prototype.get = function INTMUL() {
}
INTMUL.prototype.set = function INTMUL() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
while (true) {
[ok,Datatype,np,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"INTMUL")," ",gettext("Integer matrix multiplication")," "],[msprintf(gettext("Data Type %s"),"(3:int32, 4:int16, 5:int8, ...)"),gettext("Do on Overflow (0:Nothing, 1:Saturate, 2:Error)")],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
it=Datatype*ones(1,2);
ot=Datatype;
if ((np!=0&&np!=1&&np!=2)) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Do on Overflow"),np),msprintf(gettext("Must be in the interval %s."),"[0, 2]"));
ok=None;
} else if (Datatype==3) {
if (np==0) {
model.sim=list("matmul_i32n",4);
} else if (np==1) {
model.sim=list("matmul_i32s",4);
} else {
model.sim=list("matmul_i32e",4);
}
} else if (Datatype==4) {
if (np==0) {
model.sim=list("matmul_i16n",4);
} else if (np==1) {
model.sim=list("matmul_i16s",4);
} else {
model.sim=list("matmul_i16e",4);
}
} else if (Datatype==5) {
if (np==0) {
model.sim=list("matmul_i8n",4);
} else if (np==1) {
model.sim=list("matmul_i8s",4);
} else {
model.sim=list("matmul_i8e",4);
}
} else if (Datatype==6) {
if (np==0) {
model.sim=list("matmul_ui32n",4);
} else if (np==1) {
model.sim=list("matmul_ui32s",4);
} else {
model.sim=list("matmul_ui32e",4);
}
} else if (Datatype==7) {
if (np==0) {
model.sim=list("matmul_ui16n",4);
} else if (np==1) {
model.sim=list("matmul_ui16s",4);
} else {
model.sim=list("matmul_ui16e",4);
}
} else if (Datatype==8) {
if (np==0) {
model.sim=list("matmul_ui8n",4);
} else if (np==1) {
model.sim=list("matmul_ui8s",4);
} else {
model.sim=list("matmul_ui8e",4);
}
} else {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Data Type"),ot),msprintf(gettext("Must be in the interval %s."),"[3, 8]"));
ok=None;
}
in1=[model.in1,model.in2];
out=[model.out,model.out2];
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
if (ok) {
model.ipar=np;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
INTMUL.prototype.define = function INTMUL() {
sgn=0;
model=scicos_model();
model.sim=list("matmul_i32",4);
model.in1=[-1,-2];
model.out=-1;
model.in2=[-2,-3];
model.out2=-3;
model.intyp=[3,3];
model.outtyp=3;
model.rpar=[];
model.ipar=sgn;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[sci2exp(3),sci2exp(0)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
INTMUL.prototype.details = function INTMUL() {
}
}
/* autogenerated from "macros/IntegerOp/CONVERT.sci" */
function CONVERT() {
CONVERT.prototype.get = function CONVERT() {
}
CONVERT.prototype.set = function CONVERT() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
while (true) {
[ok,it,ot,np,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"CONVERT")," ",gettext("Type conversion")," "],[gettext("Input Type (1:double, 3:int32, 4:int16, 5:int8, ...)"),gettext("Output Type (1:double, 3:int32, 4:int16, 5:int8, ...)"),gettext("Do on Overflow (0:Nothing, 1:Saturate, 2:Error)")],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (it==2) {
it=1;
}
if (ot==2) {
ot=1;
}
if ((np!=0&&np!=1&&np!=2)) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Do on Overflow"),np),msprintf(gettext("Must be in the interval %s."),"[0, 2]"));
ok=None;
} else if ((it>8||it<1)) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Input Type"),it),msprintf(gettext("Must be in the interval %s."),"[1, 8]"));
ok=None;
} else if ((ot>8||ot<1)) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Output Type"),ot),msprintf(gettext("Must be in the interval %s."),"[1, 8]"));
ok=None;
}
model.sim=list("convert",4);
if ((it==ot)) {
model.ipar=1;
} else {
if ((np==0)) {
if ((it==1)) {
if ((ot==3)) {
model.ipar=2;
} else if ((ot==4)) {
model.ipar=3;
} else if ((ot==5)) {
model.ipar=4;
} else if ((ot==6)) {
model.ipar=5;
} else if ((ot==7)) {
model.ipar=6;
} else if ((ot==8)) {
model.ipar=7;
}
} else if ((it==3)) {
if ((ot==1)) {
model.ipar=8;
} else if ((ot==4)) {
model.ipar=9;
} else if ((ot==5)) {
model.ipar=10;
} else if ((ot==6)) {
model.ipar=1;
} else if ((ot==7)) {
model.ipar=11;
} else if ((ot==8)) {
model.ipar=12;
}
} else if ((it==4)) {
if ((ot==1)) {
model.ipar=13;
} else if ((ot==3)) {
model.ipar=14;
} else if ((ot==5)) {
model.ipar=15;
} else if ((ot==6)) {
model.ipar=16;
} else if ((ot==7)) {
model.ipar=1;
} else if ((ot==8)) {
model.ipar=17;
}
} else if ((it==5)) {
if ((ot==1)) {
model.ipar=18;
} else if ((ot==3)) {
model.ipar=19;
} else if ((ot==4)) {
model.ipar=20;
} else if ((ot==6)) {
model.ipar=21;
} else if ((ot==7)) {
model.ipar=22;
} else if ((ot==8)) {
model.ipar=1;
}
} else if ((it==6)) {
if ((ot==1)) {
model.ipar=23;
} else if ((ot==3)) {
model.ipar=1;
} else if ((ot==4)) {
model.ipar=24;
} else if ((ot==5)) {
model.ipar=25;
} else if ((ot==7)) {
model.ipar=26;
} else if ((ot==8)) {
model.ipar=27;
}
} else if ((it==7)) {
if ((ot==1)) {
model.ipar=28;
} else if ((ot==3)) {
model.ipar=29;
} else if ((ot==4)) {
model.ipar=1;
} else if ((ot==5)) {
model.ipar=30;
} else if ((ot==6)) {
model.ipar=31;
} else if ((ot==8)) {
model.ipar=32;
}
} else if ((it==8)) {
if ((ot==1)) {
model.ipar=33;
} else if ((ot==3)) {
model.ipar=34;
} else if ((ot==4)) {
model.ipar=35;
} else if ((ot==5)) {
model.ipar=1;
} else if ((ot==6)) {
model.ipar=36;
} else if ((ot==7)) {
model.ipar=37;
}
}
} else if ((np==1)) {
if ((it==1)) {
if ((ot==3)) {
model.ipar=38;
} else if ((ot==4)) {
model.ipar=39;
} else if ((ot==5)) {
model.ipar=40;
} else if ((ot==6)) {
model.ipar=41;
} else if ((ot==7)) {
model.ipar=42;
} else if ((ot==8)) {
model.ipar=43;
}
} else if ((it==3)) {
if ((ot==1)) {
model.ipar=8;
} else if ((ot==4)) {
model.ipar=44;
} else if ((ot==5)) {
model.ipar=45;
} else if ((ot==6)) {
model.ipar=46;
} else if ((ot==7)) {
model.ipar=47;
} else if ((ot==8)) {
model.ipar=48;
}
} else if ((it==4)) {
if ((ot==1)) {
model.ipar=13;
} else if ((ot==3)) {
model.ipar=14;
} else if ((ot==5)) {
model.ipar=49;
} else if ((ot==6)) {
model.ipar=50;
} else if ((ot==7)) {
model.ipar=51;
} else if ((ot==8)) {
model.ipar=52;
}
} else if ((it==5)) {
if ((ot==1)) {
model.ipar=18;
} else if ((ot==3)) {
model.ipar=19;
} else if ((ot==4)) {
model.ipar=20;
} else if ((ot==6)) {
model.ipar=53;
} else if ((ot==7)) {
model.ipar=54;
} else if ((ot==8)) {
model.ipar=55;
}
} else if ((it==6)) {
if ((ot==1)) {
model.ipar=23;
} else if ((ot==3)) {
model.ipar=56;
} else if ((ot==4)) {
model.ipar=57;
} else if ((ot==5)) {
model.ipar=58;
} else if ((ot==7)) {
model.ipar=59;
} else if ((ot==8)) {
model.ipar=60;
}
} else if ((it==7)) {
if ((ot==1)) {
model.ipar=28;
} else if ((ot==3)) {
model.ipar=29;
} else if ((ot==4)) {
model.ipar=61;
} else if ((ot==5)) {
model.ipar=62;
} else if ((ot==6)) {
model.ipar=31;
} else if ((ot==8)) {
model.ipar=63;
}
} else if ((it==8)) {
if ((ot==1)) {
model.ipar=33;
} else if ((ot==3)) {
model.ipar=34;
} else if ((ot==4)) {
model.ipar=35;
} else if ((ot==5)) {
model.ipar=64;
} else if ((ot==6)) {
model.ipar=36;
} else if ((ot==7)) {
model.ipar=37;
}
}
} else if ((np==2)) {
if ((it==1)) {
if ((ot==3)) {
model.ipar=65;
} else if ((ot==4)) {
model.ipar=66;
} else if ((ot==5)) {
model.ipar=67;
} else if ((ot==6)) {
model.ipar=68;
} else if ((ot==7)) {
model.ipar=69;
} else if ((ot==8)) {
model.ipar=70;
}
} else if ((it==3)) {
if ((ot==1)) {
model.ipar=8;
} else if ((ot==4)) {
model.ipar=71;
} else if ((ot==5)) {
model.ipar=72;
} else if ((ot==6)) {
model.ipar=73;
} else if ((ot==7)) {
model.ipar=74;
} else if ((ot==8)) {
model.ipar=75;
}
} else if ((it==4)) {
if ((ot==1)) {
model.ipar=13;
} else if ((ot==3)) {
model.ipar=14;
} else if ((ot==5)) {
model.ipar=76;
} else if ((ot==6)) {
model.ipar=77;
} else if ((ot==7)) {
model.ipar=78;
} else if ((ot==8)) {
model.ipar=79;
}
} else if ((it==5)) {
if ((ot==1)) {
model.ipar=18;
} else if ((ot==3)) {
model.ipar=19;
} else if ((ot==4)) {
model.ipar=20;
} else if ((ot==6)) {
model.ipar=80;
} else if ((ot==7)) {
model.ipar=81;
} else if ((ot==8)) {
model.ipar=82;
}
} else if ((it==6)) {
if ((ot==1)) {
model.ipar=23;
} else if ((ot==3)) {
model.ipar=83;
} else if ((ot==4)) {
model.ipar=84;
} else if ((ot==5)) {
model.ipar=85;
} else if ((ot==7)) {
model.ipar=86;
} else if ((ot==8)) {
model.ipar=87;
}
} else if ((it==7)) {
if ((ot==1)) {
model.ipar=28;
} else if ((ot==3)) {
model.ipar=29;
} else if ((ot==4)) {
model.ipar=88;
} else if ((ot==5)) {
model.ipar=89;
} else if ((ot==6)) {
model.ipar=31;
} else if ((ot==8)) {
model.ipar=90;
}
} else if ((it==8)) {
if ((ot==1)) {
model.ipar=33;
} else if ((ot==3)) {
model.ipar=34;
} else if ((ot==4)) {
model.ipar=35;
} else if ((ot==5)) {
model.ipar=91;
} else if ((ot==6)) {
model.ipar=36;
} else if ((ot==7)) {
model.ipar=37;
}
}
}
}
in1=[model.in1,model.in2];
out=[model.out,model.out2];
if (ok) {
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
if (ok) {
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
CONVERT.prototype.define = function CONVERT() {
sgn=2;
model=scicos_model();
model.sim=list("convert",4);
model.in1=-1;
model.out=-1;
model.in2=-2;
model.out2=-2;
model.intyp=1;
model.outtyp=3;
model.rpar=[];
model.ipar=sgn;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[sci2exp(1),sci2exp(3),sci2exp(0)];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
CONVERT.prototype.details = function CONVERT() {
}
}
/* autogenerated from "macros/IntegerOp/SRFLIPFLOP.sci" */
function SRFLIPFLOP() {
SRFLIPFLOP.prototype.get = function SRFLIPFLOP() {
}
SRFLIPFLOP.prototype.set = function SRFLIPFLOP() {
for(i=1;i<=length(arg1.model.rpar.objs);i+=1) {
o=arg1.model.rpar.objs(i);
if (typeof(o)=="Block"&&o.gui=="DOLLAR_m") {
path=i;
break
}
}
newpar=list();
xx=arg1.model.rpar.objs(path);
exprs=xx.graphics.exprs(1);
model=xx.model;
init_old=model.odstate(1);
while (true) {
[ok,init,exprs0]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"SRFLIPFLOP")," ",gettext("SR flip-flop")," ",gettext("The \'Initial Value\' must be 0 or 1 of type int8"),gettext("&nbsp;- Negative values are considered as int8(0)"),gettext("&nbsp;- Positive values are considered as int8(1)")," "],gettext("Initial Value"),list("vec",1),exprs);
if (!ok) {
break
}
if (init<=0) {
init=int8(0);
} else if (init>0) {
init=int8(1);
}
if (ok) {
xx.graphics.exprs[1-1]=exprs0;
model.odstate[1-1]=init;
xx.model=model;
arg1.model.rpar.objs[path-1]=xx;
break
}
}
needcompile=0;
if (init_old!=init) {
newpar[size(newpar)+1-1]=path;
needcompile=2;
}
x=arg1;
y=needcompile;
typ=newpar;
}
SRFLIPFLOP.prototype.define = function SRFLIPFLOP() {
scs_m=scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["SRFLIPFLOP"],tol=[0.0001,0.000001,1.000e-10,100001,0,0,0],tf=60,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
scs_m.objs[1-1]=scicos_block(gui="LOGIC",graphics=scicos_graphics(orig=[298.504,201.45067],sz=[40,40],flip=true,theta=0,exprs=["[0 1;1 0;1 0;1 0;0 1;0 1;0 0;0 0]","1"],pin=[4,10,12],pout=[3,8],pein=[],peout=[],gr_i=[],id="",in_implicit=["E","E","E"],out_implicit=["E","E"]),model=scicos_model(sim=list("logic",4),in1=[1,1,1],in2=[1,1,1],intyp=[5,5,5],out=[1,1],out2=[1,1],outtyp=[5,5],evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(int8([0,1,1,0,1,0,1,0,0,1,0,1,0,0,0,0])),blocktype="c",firing=None,dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[2-1]=scicos_block(gui="DOLLAR_m",graphics=scicos_graphics(orig=[299.23733,254.25067],sz=[40,40],flip=None,theta=0,exprs=["int8(0)","1"],pin=6,pout=4,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("dollar4_m",4),in1=1,in2=1,intyp=5,out=1,out2=1,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(int8(0)),rpar=[],ipar=[],opar=list(),blocktype="d",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[3-1]=scicos_link(xx=[347.07543,363.03733,363.03733],yy=[228.11733,228.11733,248.584],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[5,1,1]);
scs_m.objs[4-1]=scicos_link(xx=[290.6659,272.104,272.104,289.93257],yy=[274.25067,274.25067,231.45067,231.45067],id="drawlink",thick=[0,0],ct=[1,1],from=[2,1,0],to=[1,1,1]);
scs_m.objs[5-1]=scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[363.03733,248.584],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=3,pout=[6,14],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=["E","E","E"]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[-1,-1,-1],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[6-1]=scicos_link(xx=[363.03733,363.03733,344.95162],yy=[248.584,274.25067,274.25067],id="drawlink",thick=[0,0],ct=[1,1],from=[5,1,0],to=[2,1,1]);
scs_m.objs[7-1]=scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[367.07543,204.784],sz=[20,20],flip=true,theta=0,exprs="2",pin=8,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[8-1]=scicos_link(xx=[347.07543,367.07543],yy=[214.784,214.784],id="drawlink",thick=[0,0],ct=[1,1],from=[1,2,0],to=[7,1,1]);
scs_m.objs[9-1]=scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[249.93257,211.45067],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=10,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[10-1]=scicos_link(xx=[269.93257,289.93257],yy=[221.45067,221.45067],id="drawlink",thick=[0,0],ct=[1,1],from=[9,1,0],to=[1,2,1]);
scs_m.objs[11-1]=scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[249.93257,201.45067],sz=[20,20],flip=true,theta=0,exprs="2",pin=[],pout=12,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[12-1]=scicos_link(xx=[269.93257,289.93257],yy=[211.45067,211.45067],id="drawlink",thick=[0,0],ct=[1,1],from=[11,1,0],to=[1,3,1]);
scs_m.objs[13-1]=scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[383.03733,238.584],sz=[20,20],flip=true,theta=0,exprs="1",pin=14,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[14-1]=scicos_link(xx=[363.03733,383.03733],yy=[248.584,248.584],id="drawlink",thick=[0,0],ct=[1,1],from=[5,2,0],to=[13,1,1]);
model=scicos_model();
model.sim="csuper";
model.in1=[1,1];
model.in2=[1,1];
model.out=[1,1];
model.out2=[1,1];
model.intyp=[5,5];
model.outtyp=[5,5];
model.blocktype="h";
model.firing=None;
model.dep_ut=[true,None];
model.rpar=scs_m;
gr_i=[];
x=standard_define([2,3],model,[],gr_i);
}
SRFLIPFLOP.prototype.details = function SRFLIPFLOP() {
}
}
/* autogenerated from "macros/IntegerOp/BITSET.sci" */
function BITSET() {
BITSET.prototype.get = function BITSET() {
}
BITSET.prototype.set = function BITSET() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,Datatype,bit,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"BITSET")," ",gettext("Set a bit")," "],[msprintf(gettext("Data Type %s"),"(3:int32, 4:int16, 5:int8, ...)"),gettext("Index of Bit (0 is least significant)")],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
in1=[model.in1,model.in2];
if (floor(bit)!=bit) {
block_parameter_error(msprintf(gettext("Wrong type for \'%s\' parameter: %5.1f."),gettext("Index of Bit"),bit),gettext("Must be integer."));
ok=None;
}
if ((Datatype==3)||(Datatype==6)) {
if (bit>31||bit<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Index of Bit"),bit),msprintf(gettext("Must be in the interval %s."),"[0, 31]"));
ok=None;
}
bit=uint32(bit);
n=2^bit;
n=uint32(n);
model.sim=list("bit_set_32",4);
} else if ((Datatype==4)||(Datatype==7)) {
if (bit>15||bit<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Index of Bit"),bit),msprintf(gettext("Must be in the interval %s."),"[0, 15]"));
ok=None;
}
bit=uint16(bit);
n=2^bit;
n=uint16(n);
model.sim=list("bit_set_16",4);
} else if ((Datatype==5)||(Datatype==8)) {
if (bit>7||bit<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Index of Bit"),bit),msprintf(gettext("Must be in the interval %s."),"[0, 7]"));
ok=None;
}
bit=uint8(bit);
n=2^bit;
n=uint8(n);
model.sim=list("bit_set_8",4);
} else {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Data Type"),Datatype),msprintf(gettext("Must be in the interval %s."),"[3, 8]"));
ok=None;
}
if (ok) {
it=Datatype;
ot=Datatype;
out=[1,1];
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
if (ok) {
graphics.exprs=exprs;
model.opar=list(n);
x.graphics=graphics;
x.model=model;
break
}
}
}
BITSET.prototype.define = function BITSET() {
model=scicos_model();
model.sim=list("bit_set_32",4);
model.in1=1;
model.in2=1;
model.out=1;
model.out2=1;
model.intyp=3;
model.outtyp=3;
model.opar=list(uint32(0));
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[sci2exp(3),sci2exp(0)];
gr_i=[];
x=standard_define([4,2],model,exprs,gr_i);
}
BITSET.prototype.details = function BITSET() {
}
}
/* autogenerated from "macros/IntegerOp/JKFLIPFLOP.sci" */
function JKFLIPFLOP() {
JKFLIPFLOP.prototype.get = function JKFLIPFLOP() {
}
JKFLIPFLOP.prototype.set = function JKFLIPFLOP() {
for(i=1;i<=length(arg1.model.rpar.objs);i+=1) {
o=arg1.model.rpar.objs(i);
if (typeof(o)=="Block"&&o.gui=="DOLLAR_m") {
path=i;
break
}
}
newpar=list();
xx=arg1.model.rpar.objs(path);
exprs=xx.graphics.exprs(1);
model=xx.model;
init_old=model.odstate(1);
while (true) {
[ok,init,exprs0]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"JKFLIPFLOP")," ",gettext("JK flip-flop")," ",gettext("The \'Initial Value\' must be 0 or 1 of type int8"),gettext("&nbsp;- Negative values are considered as int8(0)"),gettext("&nbsp;- Positive values are considered as int8(1)")," "],gettext("Initial Value"),list("vec",1),exprs);
if (!ok) {
break
}
if (init<=0) {
init=int8(0);
} else if (init>0) {
init=int8(1);
}
if (ok) {
xx.graphics.exprs[1-1]=exprs0;
model.odstate[1-1]=init;
xx.model=model;
arg1.model.rpar.objs[path-1]=xx;
break
}
}
needcompile=0;
if (init_old!=init) {
newpar[size(newpar)+1-1]=1;
needcompile=2;
}
x=arg1;
y=needcompile;
typ=newpar;
}
JKFLIPFLOP.prototype.define = function JKFLIPFLOP() {
scs_m=scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["JKFLIPFLOP"],tol=[0.0001,0.000001,1.000e-10,100001,0,0,0],tf=60,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
scs_m.objs[1-1]=scicos_block(gui="DOLLAR_m",graphics=scicos_graphics(orig=[299.96961,261.584],sz=[40,40],flip=None,theta=0,exprs=["int8(0)","1"],pin=7,pout=5,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("dollar4_m",4),in1=1,in2=1,intyp=5,out=1,out2=1,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(int8(0)),rpar=[],ipar=[],opar=list(),blocktype="d",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m_1=scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["EDGE_TRIGGER","./"],tol=[0.0001,0.000001,1.000e-10,100001,0,0,0],tf=30,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
scs_m_1.objs[1-1]=scicos_block(gui="EDGETRIGGER",graphics=scicos_graphics(orig=[288.58631,257.1131],sz=[60,40],flip=true,theta=0,exprs="-1",pin=5,pout=3,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("edgetrig",4),in1=1,in2=[],intyp=1,out=1,out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=0,odstate=list(),rpar=[],ipar=-1,opar=list(),blocktype="c",firing=[],dep_ut=[true,None],label="",nzcross=1,nmode=0,equations=list()),doc=list());
scs_m_1.objs[2-1]=scicos_block(gui="IFTHEL_f",graphics=scicos_graphics(orig=[388.28869,247.1131],sz=[60,60],flip=true,theta=0,exprs=["0","0"],pin=3,pout=[],pein=[],peout=[7,0],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim=list("ifthel",-1),in1=1,in2=[],intyp=1,out=[],out2=1,outtyp=[],evtin=[],evtout=[1,1],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="l",firing=[-1,-1],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m_1.objs[3-1]=scicos_link(xx=[357.15774,362.99107,379.71726],yy=[277.1131,277.1131,277.1131],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[2,1,1]);
scs_m_1.objs[4-1]=scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[240.01488,267.1131],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=5,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m_1.objs[5-1]=scicos_link(xx=[260.01488,280.01488],yy=[277.1131,277.1131],id="drawlink",thick=[0,0],ct=[1,1],from=[4,1,0],to=[1,1,1]);
scs_m_1.objs[6-1]=scicos_block(gui="CLKOUTV_f",graphics=scicos_graphics(orig=[398.28869,181.39881],sz=[20,30],flip=true,theta=0,exprs="1",pin=[],pout=[],pein=7,peout=[],gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="output",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="d",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m_1.objs[7-1]=scicos_link(xx=[408.28869,408.28869],yy=[241.39881,211.39881],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,1,0],to=[6,1,1]);
scs_m.objs[2-1]=scicos_block(gui="EDGE_TRIGGER",graphics=scicos_graphics(orig=[292.52452,323.54888],sz=[60,40],flip=true,theta=0,exprs=[],pin=14,pout=[],pein=[],peout=8,gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="csuper",in1=-1,in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=1,state=[],dstate=[],odstate=list(),rpar=scs_m_1,ipar=[],opar=list(),blocktype="h",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[3-1]=scicos_block(gui="LOGIC",graphics=scicos_graphics(orig=[302.79613,202.52782],sz=[40,40],flip=true,theta=0,exprs=["[0;1;1;1;0;0;1;0]","0"],pin=[5,16,18],pout=4,pein=8,peout=[],gr_i=[],id="",in_implicit=["E","E","E"],out_implicit="E"),model=scicos_model(sim=list("logic",4),in1=[1,1,1],in2=[1,1,1],intyp=[5,5,5],out=1,out2=1,outtyp=5,evtin=1,evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(int8([0,1,1,1,0,0,1,0])),blocktype="c",firing=None,dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[4-1]=scicos_link(xx=[351.36756,368.82793,368.82793],yy=[222.52782,222.52782,223.06473],id="drawlink",thick=[0,0],ct=[1,1],from=[3,1,0],to=[10,1,1]);
scs_m.objs[5-1]=scicos_link(xx=[291.39818,274.18235,274.18235,294.2247],yy=[281.584,281.584,232.52782,232.52782],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[3,1,1]);
scs_m.objs[6-1]=scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[368.82793,243.45067],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=11,pout=[7,20],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=["E","E","E"]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[-1,-1,-1],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[7-1]=scicos_link(xx=[368.82793,368.82793,345.68389],yy=[243.45067,281.584,281.584],id="drawlink",thick=[0,0],ct=[1,1],from=[6,1,0],to=[1,1,1]);
scs_m.objs[8-1]=scicos_link(xx=[322.52452,374.69743,374.69743,322.79613],yy=[317.8346,317.8346,248.24211,248.24211],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,1,0],to=[3,1,1]);
scs_m.objs[9-1]=scicos_block(gui="LOGICAL_OP",graphics=scicos_graphics(orig=[377.63217,159.25363],sz=[60,40],flip=true,theta=0,exprs=["1","5","5","0"],pin=12,pout=22,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("logicalop_i8",4),in1=-1,in2=-2,intyp=5,out=-1,out2=-2,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[5,0],opar=list(),blocktype="c",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[10-1]=scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[368.82793,223.06473],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=4,pout=[11,12],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=["E","E","E"]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[-1,-1,-1],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[11-1]=scicos_link(xx=[368.82793,368.82793],yy=[223.06473,243.45067],id="drawlink",thick=[0,0],ct=[1,1],from=[10,1,0],to=[6,1,1]);
scs_m.objs[12-1]=scicos_link(xx=[368.82793,368.82793,369.06074],yy=[223.06473,177.7867,179.25363],id="drawlink",thick=[0,0],ct=[1,1],from=[10,2,0],to=[9,1,1]);
scs_m.objs[13-1]=scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[243.95309,333.54888],sz=[20,20],flip=true,theta=0,exprs="2",pin=[],pout=14,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[14-1]=scicos_link(xx=[263.95309,283.95309],yy=[343.54888,343.54888],id="drawlink",thick=[0,0],ct=[1,1],from=[13,1,0],to=[2,1,1]);
scs_m.objs[15-1]=scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[254.2247,212.52782],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=16,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[16-1]=scicos_link(xx=[274.2247,294.2247],yy=[222.52782,222.52782],id="drawlink",thick=[0,0],ct=[1,1],from=[15,1,0],to=[3,2,1]);
scs_m.objs[17-1]=scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[254.2247,202.52782],sz=[20,20],flip=true,theta=0,exprs="3",pin=[],pout=18,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=3,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[18-1]=scicos_link(xx=[274.2247,294.2247],yy=[212.52782,212.52782],id="drawlink",thick=[0,0],ct=[1,1],from=[17,1,0],to=[3,3,1]);
scs_m.objs[19-1]=scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[388.82793,233.45067],sz=[20,20],flip=true,theta=0,exprs="1",pin=20,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[20-1]=scicos_link(xx=[368.82793,388.82793],yy=[243.45067,243.45067],id="drawlink",thick=[0,0],ct=[1,1],from=[6,2,0],to=[19,1,1]);
scs_m.objs[21-1]=scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[466.2036,169.25363],sz=[20,20],flip=true,theta=0,exprs="2",pin=22,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[22-1]=scicos_link(xx=[446.2036,466.2036],yy=[179.25363,179.25363],id="drawlink",thick=[0,0],ct=[1,1],from=[9,1,0],to=[21,1,1]);
model=scicos_model();
model.sim="csuper";
model.in1=[1,1,1];
model.in2=[1,1,1];
model.out=[1,1];
model.out2=[1,1];
model.intyp=[5,1,5];
model.outtyp=[5,5];
model.blocktype="h";
model.firing=None;
model.dep_ut=[true,None];
model.rpar=scs_m;
gr_i=[];
x=standard_define([2,3],model,[],gr_i);
}
JKFLIPFLOP.prototype.details = function JKFLIPFLOP() {
}
}
/* autogenerated from "macros/IntegerOp/DLATCH.sci" */
function DLATCH() {
DLATCH.prototype.get = function DLATCH() {
}
DLATCH.prototype.set = function DLATCH() {
x=arg1;
}
DLATCH.prototype.define = function DLATCH() {
scs_m=scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["DLATCH"],tol=[0.0001,0.000001,1.000e-10,100001,0,0],tf=100000,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
scs_m.objs[1-1]=scicos_block(gui="CONST_m",graphics=scicos_graphics(orig=[109.62561,263.44465],sz=[20,20],flip=true,theta=0,exprs="int8(0)",pin=[],pout=7,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim=list("cstblk4_m",4),in1=[],in2=[],intyp=1,out=1,out2=1,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(int8(0)),blocktype="d",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[2-1]=scicos_block(gui="IFTHEL_f",graphics=scicos_graphics(orig=[233.37693,320.30536],sz=[60,60],flip=true,theta=0,exprs=["0","1"],pin=13,pout=[],pein=[],peout=[6,0],gr_i=list(["txt=[\'If in>0\';\' \';\' then    else\'];","xstringb(orig(1),orig(2),txt,sz(1),sz(2),\'fill\');"],8),id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim=list("ifthel",-1),in1=1,in2=1,intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[1,1],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="l",firing=[-1,-1],dep_ut=[true,None],label="",nzcross=1,nmode=1,equations=list()),doc=list());
scs_m.objs[3-1]=scicos_block(gui="LOGICAL_OP",graphics=scicos_graphics(orig=[152.88902,260.24498],sz=[60,40],flip=true,theta=0,exprs=["2","1","5","0"],pin=[15,7],pout=5,pein=[],peout=[],gr_i=list("xstringb(orig(1),orig(2),[\'Logical Op \';OPER],sz(1),sz(2),\'fill\');",8),id="",in_implicit=["E","E"],out_implicit="E"),model=scicos_model(sim=list("logicalop_i8",4),in1=[-1,-1],in2=[-2,-2],intyp=[5,5],out=-1,out2=-2,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[1,0],opar=list(),blocktype="c",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[4-1]=scicos_block(gui="SAMPHOLD_m",graphics=scicos_graphics(orig=[233.72156,260.24498],sz=[40,40],flip=true,theta=0,exprs="5",pin=5,pout=9,pein=6,peout=[],gr_i=list("xstringb(orig(1),orig(2),\'S/H\',sz(1),sz(2),\'fill\')",8),id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("samphold4_m",4),in1=-1,in2=-2,intyp=5,out=-1,out2=-2,outtyp=5,evtin=1,evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="d",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[5-1]=scicos_link(xx=[221.46044,225.15013],yy=[280.24498,280.24498],id="drawlink",thick=[0,0],ct=[1,1],from=[3,1,0],to=[4,1,1]);
scs_m.objs[6-1]=scicos_link(xx=[253.37693,253.72156],yy=[314.59108,305.95927],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,1,0],to=[4,1,1]);
scs_m.objs[7-1]=scicos_link(xx=[138.19704,144.31759],yy=[273.44465,273.57832],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[3,2,1]);
scs_m.objs[8-1]=scicos_block(gui="LOGICAL_OP",graphics=scicos_graphics(orig=[317.46698,309.46812],sz=[60,40],flip=true,theta=0,exprs=["1","5","5","0"],pin=11,pout=17,pein=[],peout=[],gr_i=list("xstringb(orig(1),orig(2),[\'Logical Op \';OPER],sz(1),sz(2),\'fill\');",8),id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("logicalop_i8",4),in1=-1,in2=-2,intyp=5,out=-1,out2=-2,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[5,0],opar=list(),blocktype="c",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[9-1]=scicos_link(xx=[282.29299,305.09603,305.09603],yy=[280.24498,280.52797,280.83282],id="drawlink",thick=[0,0],ct=[1,1],from=[4,1,0],to=[10,1,1]);
scs_m.objs[10-1]=scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[305.09603,280.83282],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=9,pout=[11,19],pein=[],peout=[],gr_i=list([],8),id="",in_implicit="E",out_implicit=["E","E","E"]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[-1,-1,-1],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[11-1]=scicos_link(xx=[305.09603,305.09603,308.89555],yy=[280.83282,329.46812,329.46812],id="drawlink",thick=[0,0],ct=[1,1],from=[10,1,0],to=[8,1,1]);
scs_m.objs[12-1]=scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[184.8055,340.30536],sz=[20,20],flip=true,theta=0,exprs="2",pin=[],pout=13,pein=[],peout=[],gr_i=list(" ",8),id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[13-1]=scicos_link(xx=[204.8055,224.8055],yy=[350.30536,350.30536],id="drawlink",thick=[0,0],ct=[1,1],from=[12,1,0],to=[2,1,1]);
scs_m.objs[14-1]=scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[104.31759,276.91165],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=15,pein=[],peout=[],gr_i=list(" ",8),id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[15-1]=scicos_link(xx=[124.31759,144.31759],yy=[286.91165,286.91165],id="drawlink",thick=[0,0],ct=[1,1],from=[14,1,0],to=[3,1,1]);
scs_m.objs[16-1]=scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[406.03841,319.46812],sz=[20,20],flip=true,theta=0,exprs="2",pin=17,pout=[],pein=[],peout=[],gr_i=list(" ",8),id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[17-1]=scicos_link(xx=[386.03841,406.03841],yy=[329.46812,329.46812],id="drawlink",thick=[0,0],ct=[1,1],from=[8,1,0],to=[16,1,1]);
scs_m.objs[18-1]=scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[325.09603,270.83282],sz=[20,20],flip=true,theta=0,exprs="1",pin=19,pout=[],pein=[],peout=[],gr_i=list(" ",8),id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[19-1]=scicos_link(xx=[305.09603,325.09603],yy=[280.83282,280.83282],id="drawlink",thick=[0,0],ct=[1,1],from=[10,2,0],to=[18,1,1]);
model=scicos_model();
model.sim="csuper";
model.in1=[1,1];
model.in2=[1,1];
model.out=[1,1];
model.out2=[1,1];
model.intyp=[5,-1];
model.outtyp=[5,5];
model.blocktype="h";
model.firing=None;
model.dep_ut=[true,None];
model.rpar=scs_m;
gr_i=[];
x=standard_define([2,3],model,[],gr_i);
}
DLATCH.prototype.details = function DLATCH() {
}
}
/* autogenerated from "macros/IntegerOp/BITCLEAR.sci" */
function BITCLEAR() {
BITCLEAR.prototype.get = function BITCLEAR() {
}
BITCLEAR.prototype.set = function BITCLEAR() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,Datatype,bit,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"BITCLEAR")," ",gettext("Clear a bit")," "],[msprintf(gettext("Data Type %s"),"(3:int32, 4:int16, 5:int8, ...)"),gettext("Index of Bit (0 is least significant)")],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
in1=[model.in1,model.in2];
if (floor(bit)!=bit) {
block_parameter_error(msprintf(gettext("Wrong type for \'%s\' parameter: %5.1f."),gettext("Index of Bit"),bit),gettext("Must be integer."));
ok=None;
} else if ((Datatype==3)||(Datatype==6)) {
if (bit>31||bit<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Index of Bit"),bit),msprintf(gettext("Must be in the interval %s."),"[0, 31]"));
ok=None;
} else {
bit=uint32(bit);
n=(2^32-1)-2^bit;
n=uint32(n);
model.sim=list("bit_clear_32",4);
}
} else if ((Datatype==4)||(Datatype==7)) {
if (bit>15||bit<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Index of Bit"),bit),msprintf(gettext("Must be in the interval %s."),"[0, 15]"));
ok=None;
} else {
bit=uint16(bit);
n=(2^16-1)-2^bit;
n=uint16(n);
model.sim=list("bit_clear_16",4);
}
} else if ((Datatype==5)||(Datatype==8)) {
if (bit>7||bit<0) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Index of Bit"),bit),msprintf(gettext("Must be in the interval %s."),"[0, 7]"));
ok=None;
} else {
bit=uint8(bit);
n=(2^8-1)-2^bit;
n=uint8(n);
model.sim=list("bit_clear_8",4);
}
} else {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Data Type"),Datatype),msprintf(gettext("Must be in the interval %s."),"[3, 8]"));
ok=None;
}
if (ok) {
it=Datatype;
ot=Datatype;
out=[1,1];
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),[],[]);
}
if (ok) {
graphics.exprs=exprs;
model.opar=list(n);
x.graphics=graphics;
x.model=model;
break
}
}
}
BITCLEAR.prototype.define = function BITCLEAR() {
model=scicos_model();
model.sim=list("bit_clear_32",4);
model.in1=1;
model.in2=1;
model.out=1;
model.out2=1;
model.intyp=3;
model.outtyp=3;
model.opar=list(int32(0));
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[sci2exp(3),sci2exp(0)];
gr_i=[];
x=standard_define([4,2],model,exprs,gr_i);
}
BITCLEAR.prototype.details = function BITCLEAR() {
}
}
/* autogenerated from "macros/IntegerOp/DFLIPFLOP.sci" */
function DFLIPFLOP() {
DFLIPFLOP.prototype.get = function DFLIPFLOP() {
}
DFLIPFLOP.prototype.set = function DFLIPFLOP() {
x=arg1;
}
DFLIPFLOP.prototype.define = function DFLIPFLOP() {
scs_m=scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["DFLIPFLOP"],tol=[0.0001,0.000001,1.000e-10,100001,0,0],tf=100000,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
scs_m.objs[1-1]=scicos_block(gui="CONST_m",graphics=scicos_graphics(orig=[109.62561,263.44465],sz=[20,20],flip=true,theta=0,exprs="int8(0)",pin=[],pout=6,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim=list("cstblk4_m",4),in1=[],in2=[],intyp=1,out=1,out2=1,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(int8(0)),blocktype="d",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[2-1]=scicos_block(gui="IFTHEL_f",graphics=scicos_graphics(orig=[239.98293,378.2166],sz=[60,60],flip=true,theta=0,exprs=["1","1"],pin=29,pout=[],pein=22,peout=[16,44],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim=list("ifthel",-1),in1=1,in2=1,intyp=-1,out=[],out2=[],outtyp=1,evtin=1,evtout=[1,1],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="l",firing=[-1,-1],dep_ut=[true,None],label="",nzcross=1,nmode=1,equations=list()),doc=list());
scs_m.objs[3-1]=scicos_block(gui="LOGICAL_OP",graphics=scicos_graphics(orig=[152.88902,260.24498],sz=[60,40],flip=true,theta=0,exprs=["2","1","5","0"],pin=[11,39],pout=5,pein=[],peout=[],gr_i=[],id="",in_implicit=["E","E"],out_implicit="E"),model=scicos_model(sim=list("logicalop_i8",4),in1=[-1,-1],in2=[-2,-2],intyp=[5,5],out=-1,out2=-2,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[1,0],opar=list(),blocktype="c",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[4-1]=scicos_block(gui="SAMPHOLD_m",graphics=scicos_graphics(orig=[233.72156,260.24498],sz=[40,40],flip=true,theta=0,exprs="5",pin=5,pout=33,pein=42,peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("samphold4_m",4),in1=-1,in2=-2,intyp=5,out=-1,out2=-2,outtyp=5,evtin=1,evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="d",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[5-1]=scicos_link(xx=[221.46044,225.15013],yy=[280.24498,280.24498],id="drawlink",thick=[0,0],ct=[1,1],from=[3,1,0],to=[4,1,1]);
scs_m.objs[6-1]=scicos_link(xx=[138.19704,140.34523],yy=[273.44465,273.49157],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[38,1,1]);
scs_m.objs[7-1]=scicos_block(gui="LOGICAL_OP",graphics=scicos_graphics(orig=[373.24106,309.46812],sz=[60,40],flip=true,theta=0,exprs=["1","5","5","0"],pin=36,pout=13,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("logicalop_i8",4),in1=-1,in2=-2,intyp=5,out=-1,out2=-2,outtyp=5,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[5,0],opar=list(),blocktype="c",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[8-1]=scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[199.48466,398.2166],sz=[20,20],flip=true,theta=0,exprs="3",pin=[],pout=9,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=3,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[9-1]=scicos_link(xx=[219.48466,222.54128],yy=[408.2166,408.2166],id="drawlink",thick=[0,0],ct=[1,1],from=[8,1,0],to=[28,1,1]);
scs_m.objs[10-1]=scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[104.31759,276.91165],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=11,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[11-1]=scicos_link(xx=[124.31759,144.31759],yy=[286.91165,286.91165],id="drawlink",thick=[0,0],ct=[1,1],from=[10,1,0],to=[3,1,1]);
scs_m.objs[12-1]=scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[457.40928,320.20131],sz=[20,20],flip=true,theta=0,exprs="2",pin=13,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[13-1]=scicos_link(xx=[441.81249,457.40928],yy=[329.46812,330.20131],id="drawlink",thick=[0,0],ct=[1,1],from=[7,1,0],to=[12,1,1]);
scs_m.objs[14-1]=scicos_block(gui="OUT_f",graphics=scicos_graphics(orig=[376.4669,270.83282],sz=[20,20],flip=true,theta=0,exprs="1",pin=37,pout=[],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="output",in1=-1,in2=[],intyp=-1,out=[],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m_1=scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title="Untitled",tol=[0.0001,0.000001,1.000e-10,100001,0,0],tf=100000,context=[],void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
scs_m_1.objs[1-1]=scicos_block(gui="ANDLOG_f",graphics=scicos_graphics(orig=[194,133],sz=[60,60],flip=true,theta=0,exprs=[],pin=[],pout=9,pein=[4,11],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="andlog",in1=[],in2=[],intyp=1,out=1,out2=[],outtyp=1,evtin=[1,1],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="d",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m_1.objs[2-1]=scicos_block(gui="CLKIN_f",graphics=scicos_graphics(orig=[149,287],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=[],pein=[],peout=4,gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=1,state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="d",firing=-1,dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m_1.objs[3-1]=scicos_block(gui="CLKOUT_f",graphics=scicos_graphics(orig=[450,83],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=[],pein=8,peout=[],gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="output",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="d",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m_1.objs[4-1]=scicos_link(xx=[169,214,214],yy=[297,297,198.71],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,1],to=[1,1]);
scs_m_1.objs[5-1]=scicos_block(gui="CLKIN_f",graphics=scicos_graphics(orig=[141,330],sz=[20,20],flip=true,theta=0,exprs="2",pin=[],pout=[],pein=[],peout=6,gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=1,state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="d",firing=-1,dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m_1.objs[6-1]=scicos_link(xx=[161,234,234],yy=[340,340,275.78],id="drawlink",thick=[0,0],ct=[5,-1],from=[5,1],to=[10,1]);
scs_m_1.objs[7-1]=scicos_block(gui="IFTHEL_f",graphics=scicos_graphics(orig=[331,137],sz=[60,60],flip=true,theta=0,exprs=["1","1"],pin=9,pout=[],pein=12,peout=[8,0],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim=list("ifthel",-1),in1=1,in2=1,intyp=-1,out=[],out2=[],outtyp=1,evtin=1,evtout=[1,1],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="l",firing=[-1,-1],dep_ut=[true,None],label="",nzcross=1,nmode=1,equations=list()),doc=list());
scs_m_1.objs[8-1]=scicos_link(xx=[351,351,450],yy=[131.29,93,93],id="drawlink",thick=[0,0],ct=[5,-1],from=[7,1],to=[3,1]);
scs_m_1.objs[9-1]=scicos_link(xx=[262.57,322.43],yy=[163,167],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1],to=[7,1]);
scs_m_1.objs[10-1]=scicos_block(gui="CLKSPLIT_f",graphics=scicos_graphics(orig=[234,275.78348],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=[],pout=[],pein=6,peout=[11,12],gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="split",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=[1,1],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="d",firing=[None,None,None],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m_1.objs[11-1]=scicos_link(xx=[234,234],yy=[275.78,198.71],id="drawlink",thick=[0,0],ct=[5,-1],from=[10,1],to=[1,2]);
scs_m_1.objs[12-1]=scicos_link(xx=[234,361,361],yy=[275.78,275.78,202.71],id="drawlink",thick=[0,0],ct=[5,-1],from=[10,2],to=[7,1]);
scs_m.objs[15-1]=scicos_block(gui="ANDBLK",graphics=scicos_graphics(orig=[233.73039,318.74407],sz=[40,40],flip=true,theta=0,exprs=[],pin=[],pout=[],pein=[19,16],peout=17,gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="csuper",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[1,1],evtout=1,state=[],dstate=[],odstate=list(),rpar=scs_m_1,ipar=[],opar=list(),blocktype="h",firing=None,dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[16-1]=scicos_link(xx=[259.98293,260.39705],yy=[372.50232,364.45835],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,1,0],to=[15,2,1]);
scs_m.objs[17-1]=scicos_link(xx=[253.73039,253.72572],yy=[313.02978,309.29537],id="drawlink",thick=[0,0],ct=[5,-1],from=[15,1,0],to=[41,1,1]);
scs_m_1=scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["EDGE_TRIGGER","./"],tol=[0.0001,0.000001,1.000e-10,100001,0,0,0],tf=30,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
scs_m_1.objs[1-1]=scicos_block(gui="EDGETRIGGER",graphics=scicos_graphics(orig=[288.58631,257.1131],sz=[60,40],flip=true,theta=0,exprs="1",pin=5,pout=3,pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit="E"),model=scicos_model(sim=list("edgetrig",4),in1=1,in2=[],intyp=1,out=1,out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=0,odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[true,None],label="",nzcross=1,nmode=0,equations=list()),doc=list());
scs_m_1.objs[2-1]=scicos_block(gui="IFTHEL_f",graphics=scicos_graphics(orig=[388.28869,247.1131],sz=[60,60],flip=true,theta=0,exprs=["0","0"],pin=3,pout=[],pein=[],peout=[7,0],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim=list("ifthel",-1),in1=1,in2=[],intyp=1,out=[],out2=1,outtyp=[],evtin=[],evtout=[1,1],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="l",firing=[-1,-1],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m_1.objs[3-1]=scicos_link(xx=[357.15774,362.99107,379.71726],yy=[277.1131,277.1131,277.1131],id="drawlink",thick=[0,0],ct=[1,1],from=[1,1,0],to=[2,1,1]);
scs_m_1.objs[4-1]=scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[240.01488,267.1131],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=5,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=-1,out=-1,out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m_1.objs[5-1]=scicos_link(xx=[260.01488,280.01488],yy=[277.1131,277.1131],id="drawlink",thick=[0,0],ct=[1,1],from=[4,1,0],to=[1,1,1]);
scs_m_1.objs[6-1]=scicos_block(gui="CLKOUTV_f",graphics=scicos_graphics(orig=[398.28869,181.39881],sz=[20,30],flip=true,theta=0,exprs="1",pin=[],pout=[],pein=7,peout=[],gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="output",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="d",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m_1.objs[7-1]=scicos_link(xx=[408.28869,408.28869],yy=[241.39881,211.39881],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,1,0],to=[6,1,1]);
scs_m.objs[18-1]=scicos_block(gui="EDGE_TRIGGER",graphics=scicos_graphics(orig=[133.90637,385.342],sz=[60,40],flip=true,theta=0,exprs=[],pin=26,pout=[],pein=[],peout=19,gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="csuper",in1=-1,in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=1,state=[],dstate=[],odstate=list(),rpar=scs_m_1,ipar=[],opar=list(),blocktype="h",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[19-1]=scicos_link(xx=[163.90637,163.90637,247.06372],yy=[379.62771,364.45835,364.45835],id="drawlink",thick=[0,0],ct=[5,-1],from=[18,1,0],to=[15,1,1]);
scs_m.objs[20-1]=scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[79.594811,395.47647],sz=[20,20],flip=true,theta=0,exprs="2",pin=[],pout=23,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=1,out=-1,out2=[],outtyp=-1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=2,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m_1=scicos_diagram(version="scicos4.2",props=scicos_params(wpar=[600,450,0,0,600,450],Title=["Extract_Activation","./"],tol=[0.0001,0.000001,1.000e-10,100001,0,0,0],tf=30,context=" ",void1=[],options=tlist(["scsopt","3D","Background","Link","ID","Cmap"],list(true,33),[8,1],[1,5],list([5,1],[4,1]),[0.8,0.8,0.8]),void2=[],void3=[],doc=list()));
scs_m_1.objs[1-1]=scicos_block(gui="IFTHEL_f",graphics=scicos_graphics(orig=[150.65045,143.82208],sz=[60,60],flip=true,theta=0,exprs=["0","0"],pin=6,pout=[],pein=[],peout=[3,4],gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim=list("ifthel",-1),in1=1,in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=[1,1],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="l",firing=[-1,-1],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m_1.objs[2-1]=scicos_block(gui="CLKSOMV_f",graphics=scicos_graphics(orig=[169.82143,96.146231],sz=[16.666667,16.666667],flip=true,theta=0,exprs=[],pin=[],pout=[],pein=[3,4,0],peout=8,gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="sum",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[1,1,1],evtout=1,state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="d",firing=-1,dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m_1.objs[3-1]=scicos_link(xx=[170.65045,170.65045,150.04302,150.04302,169.82143],yy=[138.10779,128.235,128.235,104.47956,104.47956],id="drawlink",thick=[0,0],ct=[5,-1],from=[1,1,0],to=[2,1,1]);
scs_m_1.objs[4-1]=scicos_link(xx=[190.65045,190.65045,178.15476],yy=[138.10779,111.55729,112.8129],id="drawlink",thick=[0,0],ct=[5,-1],from=[1,2,0],to=[2,2,1]);
scs_m_1.objs[5-1]=scicos_block(gui="IN_f",graphics=scicos_graphics(orig=[102.07902,163.82208],sz=[20,20],flip=true,theta=0,exprs="1",pin=[],pout=6,pein=[],peout=[],gr_i=[],id="",in_implicit=[],out_implicit="E"),model=scicos_model(sim="input",in1=[],in2=[],intyp=-1,out=-1,out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="c",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m_1.objs[6-1]=scicos_link(xx=[122.07902,142.07902],yy=[173.82208,173.82208],id="drawlink",thick=[0,0],ct=[1,1],from=[5,1,0],to=[1,1,1]);
scs_m_1.objs[7-1]=scicos_block(gui="CLKOUTV_f",graphics=scicos_graphics(orig=[168.15476,38.527183],sz=[20,30],flip=true,theta=0,exprs="1",pin=[],pout=[],pein=8,peout=[],gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="output",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=1,opar=list(),blocktype="d",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m_1.objs[8-1]=scicos_link(xx=[178.15476,178.15476],yy=[98.527183,68.527183],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,1,0],to=[7,1,1]);
scs_m.objs[21-1]=scicos_block(gui="Extract_Activation",graphics=scicos_graphics(orig=[239.82193,456.57677],sz=[60,40],flip=true,theta=0,exprs=[],pin=31,pout=[],pein=[],peout=22,gr_i=[],id="",in_implicit="E",out_implicit=[]),model=scicos_model(sim="csuper",in1=-1,in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=[],evtout=1,state=[],dstate=[],odstate=list(),rpar=scs_m_1,ipar=[],opar=list(),blocktype="h",firing=[],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[22-1]=scicos_link(xx=[269.82193,269.98293],yy=[450.86248,443.93089],id="drawlink",thick=[0,0],ct=[5,-1],from=[21,1,0],to=[2,1,1]);
scs_m.objs[23-1]=scicos_link(xx=[99.594811,110.25582],yy=[405.47647,405.42077],id="drawlink",thick=[0,0],ct=[1,1],from=[20,1,0],to=[25,1,1]);
scs_m.objs[24-1]=scicos_block(gui="SUM_f",graphics=scicos_graphics(orig=[200.5252,469.13173],sz=[16.666667,16.666667],flip=true,theta=0,exprs=[],pin=[27,0,30],pout=31,pein=[],peout=[],gr_i=[],id="",in_implicit=["E","E","E"],out_implicit="E"),model=scicos_model(sim=list("plusblk",2),in1=[-1,-1,-1],in2=[],intyp=1,out=-1,out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[25-1]=scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[110.25582,405.42077],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=23,pout=[26,27],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=["E","E","E"]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[-1,-1,-1],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[26-1]=scicos_link(xx=[110.25582,114.33667,125.33494],yy=[405.42077,405.39945,405.342],id="drawlink",thick=[0,0],ct=[1,1],from=[25,1,0],to=[18,1,1]);
scs_m.objs[27-1]=scicos_link(xx=[110.25582,110.25582,208.85853],yy=[405.42077,469.13173,469.13173],id="drawlink",thick=[0,0],ct=[1,1],from=[25,2,0],to=[24,1,1]);
scs_m.objs[28-1]=scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[222.54128,408.2166],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=9,pout=[29,30],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=["E","E","E"]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[-1,-1,-1],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[29-1]=scicos_link(xx=[222.54128,231.4115],yy=[408.2166,408.2166],id="drawlink",thick=[0,0],ct=[1,1],from=[28,1,0],to=[2,1,1]);
scs_m.objs[30-1]=scicos_link(xx=[222.54128,222.54128,208.85853,208.85853],yy=[408.2166,453.0015,453.0015,485.7984],id="drawlink",thick=[0,0],ct=[1,1],from=[28,2,0],to=[24,3,1]);
scs_m.objs[31-1]=scicos_link(xx=[219.57282,231.2505],yy=[477.46506,476.57677],id="drawlink",thick=[0,0],ct=[1,1],from=[24,1,0],to=[21,1,1]);
scs_m.objs[32-1]=scicos_block(gui="SELECT_m",graphics=scicos_graphics(orig=[298.86371,253.57321],sz=[40,40],flip=true,theta=0,exprs=["5","2","1"],pin=[33,40],pout=34,pein=[43,44],peout=[],gr_i=[],id="",in_implicit=["E","E"],out_implicit="E"),model=scicos_model(sim=list("selector_m",4),in1=[-1,-1],in2=[-2,-2],intyp=[5,5],out=-1,out2=-2,outtyp=5,evtin=[1,1],evtout=[],state=[],dstate=1,odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[33-1]=scicos_link(xx=[282.29299,290.29229],yy=[280.24498,280.23987],id="drawlink",thick=[0,0],ct=[1,1],from=[4,1,0],to=[32,1,1]);
scs_m.objs[34-1]=scicos_link(xx=[347.43514,357.57328,357.57328],yy=[273.57321,273.57321,280.83282],id="drawlink",thick=[0,0],ct=[1,1],from=[32,1,0],to=[35,1,1]);
scs_m.objs[35-1]=scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[357.57328,280.83282],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=34,pout=[36,37],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=["E","E","E"]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[-1,-1,-1],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[36-1]=scicos_link(xx=[357.57328,357.57328,364.66964],yy=[280.83282,329.46812,329.46812],id="drawlink",thick=[0,0],ct=[1,1],from=[35,1,0],to=[7,1,1]);
scs_m.objs[37-1]=scicos_link(xx=[357.57328,376.4669],yy=[280.83282,280.83282],id="drawlink",thick=[0,0],ct=[1,1],from=[35,2,0],to=[14,1,1]);
scs_m.objs[38-1]=scicos_block(gui="SPLIT_f",graphics=scicos_graphics(orig=[140.34523,273.49157],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=6,pout=[39,40],pein=[],peout=[],gr_i=[],id="",in_implicit="E",out_implicit=["E","E","E"]),model=scicos_model(sim="lsplit",in1=-1,in2=[],intyp=1,out=[-1,-1,-1],out2=[],outtyp=1,evtin=[],evtout=[],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="c",firing=[],dep_ut=[true,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[39-1]=scicos_link(xx=[140.34523,144.31759],yy=[273.49157,273.57832],id="drawlink",thick=[0,0],ct=[1,1],from=[38,1,0],to=[3,2,1]);
scs_m.objs[40-1]=scicos_link(xx=[140.34523,140.34523,290.29229,290.29229],yy=[273.49157,247.70767,247.70767,266.90654],id="drawlink",thick=[0,0],ct=[1,1],from=[38,2,0],to=[32,2,1]);
scs_m.objs[41-1]=scicos_block(gui="CLKSPLIT_f",graphics=scicos_graphics(orig=[253.72572,309.29537],sz=[0.3333333,0.3333333],flip=true,theta=0,exprs=[],pin=[],pout=[],pein=17,peout=[42,43],gr_i=[],id="",in_implicit=[],out_implicit=[]),model=scicos_model(sim="split",in1=[],in2=[],intyp=1,out=[],out2=[],outtyp=1,evtin=1,evtout=[1,1],state=[],dstate=[],odstate=list(),rpar=[],ipar=[],opar=list(),blocktype="d",firing=[None,None,None],dep_ut=[None,None],label="",nzcross=0,nmode=0,equations=list()),doc=list());
scs_m.objs[42-1]=scicos_link(xx=[253.72572,253.72156],yy=[309.29537,305.95927],id="drawlink",thick=[0,0],ct=[5,-1],from=[41,1,0],to=[4,1,1]);
scs_m.objs[43-1]=scicos_link(xx=[253.72572,312.19705,312.19705],yy=[309.29537,309.29537,299.28749],id="drawlink",thick=[0,0],ct=[5,-1],from=[41,2,0],to=[32,1,1]);
scs_m.objs[44-1]=scicos_link(xx=[279.98293,279.98293,325.53038,325.53038],yy=[372.50232,315.89455,315.89455,299.28749],id="drawlink",thick=[0,0],ct=[5,-1],from=[2,2,0],to=[32,2,1]);
model=scicos_model();
model.sim="csuper";
model.in1=[1,1,1];
model.in2=[1,1,1];
model.out=[1,1];
model.out2=[1,1];
model.intyp=[5,1,1];
model.outtyp=[5,5];
model.blocktype="h";
model.firing=None;
model.dep_ut=[true,None];
model.rpar=scs_m;
gr_i=[];
x=standard_define([2,3],model,[],gr_i);
}
DFLIPFLOP.prototype.details = function DFLIPFLOP() {
}
}
/* autogenerated from "macros/IntegerOp/LOGIC.sci" */
function LOGIC() {
LOGIC.prototype.get = function LOGIC() {
}
LOGIC.prototype.set = function LOGIC() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,mat,herit,exprs]=scicos_getvalue([msprintf(gettext("Set %s block parameters"),"LOGIC")," ",gettext("Combinatorial logic")," ",gettext("&nbsp; Rows of the matrix are the output values"),gettext("&nbsp; Number of rows must be a power of two."),gettext("&nbsp; Number of columns gives the number of outputs.")," "],[gettext("Truth Table (matrix of outputs)"),gettext("Accepts Inherited Events (0:No, 1:Yes)")],list("mat",[-1,-2],"vec",1),exprs);
if (!ok) {
break
}
nout=size(mat,2);
nin=(log(size(mat,1))/log(2));
u1=floor(nin);
if ((u1!=nin)) {
block_parameter_error(msprintf(gettext("Wrong size for \'%s\' parameter: %d."),gettext("Truth Table"),size(mat,1)),gettext("Number of rows must be a power of two."));
ok=None;
} else if ((find(mat.slice()!=0&&mat.slice()!=1)!=[])) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter."),gettext("Truth Table")),msprintf(gettext("Elements must be in the interval %s."),"[0, 1]"));
ok=None;
} else if (herit<0||herit>1) {
block_parameter_error(msprintf(gettext("Wrong value for \'%s\' parameter: %d."),gettext("Accepts Inherited Events"),herit),msprintf(gettext("Must be in the interval %s."),"[0, 1]"));
ok=None;
}
if (ok) {
in1=[ones(nin,1),ones(nin,1)];
out=[ones(nout,1),ones(nout,1)];
it=5*ones(1,nin);
ot=5*ones(1,nout);
[model,graphics,ok]=set_io(model,graphics,list(in1,it),list(out,ot),ones(1-herit,1),[]);
}
if (ok) {
graphics.exprs=exprs;
mat=int8(mat);
model.opar=list(mat);
x.graphics=graphics;
x.model=model;
break
}
}
}
LOGIC.prototype.define = function LOGIC() {
mat=[0,0,0,1];
model=scicos_model();
model.sim=list("logic",4);
model.in1=[1,1];
model.in2=[1,1];
model.out=1;
model.out2=1;
model.evtin=1;
model.intyp=[5,5];
model.outtyp=5;
model.opar=list(int8(mat));
model.blocktype="c";
model.firing=None;
model.dep_ut=[true,None];
exprs=[sci2exp(mat),sci2exp(0)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
LOGIC.prototype.details = function LOGIC() {
}
}
/* autogenerated from "macros/NonLinear/INTRP2BLK_f.sci" */
function INTRP2BLK_f() {
INTRP2BLK_f.prototype.get = function INTRP2BLK_f() {
}
INTRP2BLK_f.prototype.set = function INTRP2BLK_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,a,b,c,exprs]=scicos_getvalue("Set Interpolation block parameters",["X coord.","Y coord.","Z values"],list("vec",-1,"vec",-1,"mat",[-1,-1]),exprs);
if (!ok) {
break
}
if (size(a,"*")!=size(c,"c")||size(b,"*")!=size(c,"r")) {
message("incompatible dimension");
} else if (min(a.slice(2-1,$)-a.slice(1-1,$-1))<=0||min(b.slice(2-1,$)-b.slice(1-1,$-1))<=0) {
message("X and Y must be strictly increasing");
} else {
if (ok) {
graphics.exprs=exprs;
model.rpar=[a.slice(),b.slice(),c.slice()];
model.ipar=[size(a,"*"),size(b,"*")];
x.graphics=graphics;
x.model=model;
break
}
}
}
}
INTRP2BLK_f.prototype.define = function INTRP2BLK_f() {
a=[0,1];
b=[0,1];
c=[0,1,1,2];
model=scicos_model();
model.sim=list("intrp2",1);
model.in1=[1,1];
model.out=1;
model.rpar=[a,b,c.slice()];
model.ipar=[2,2];
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[strcat(sci2exp(a)),strcat(sci2exp(b)),strcat(sci2exp(c,0))];
gr_i=[];
x=standard_define([3,2],model,exprs,gr_i);
}
INTRP2BLK_f.prototype.details = function INTRP2BLK_f() {
}
}
/* autogenerated from "macros/NonLinear/PRODUCT.sci" */
function PRODUCT() {
PRODUCT.prototype.get = function PRODUCT() {
}
PRODUCT.prototype.set = function PRODUCT() {
x=arg1;
graphics=arg1.graphics;
model=arg1.model;
exprs=graphics.exprs;
while (true) {
[ok,sgn,exprs]=scicos_getvalue(["         Set multiplication block parameters","(multiplication is set with + 1, division with -1)",""],"Number of inputs or sign vector",list("vec",-1),exprs);
if (!ok) {
break
}
sgn=sgn.slice();
if (size(sgn,1)==1) {
if (sgn<1) {
message("Number of inputs must be > 0");
ok=None;
} else if (sgn==1) {
in1=-1;
sgn=[];
nout=1;
} else {
in1=-ones(sgn,1);
sgn=ones(sgn,1);
nout=-1;
}
} else {
if (!and(abs(sgn)==1)) {
message("Signs can only be +1 or -1");
ok=None;
} else {
in1=-ones(size(sgn,1),1);
nout=-1;
}
}
if (ok) {
[model,graphics,ok]=check_io(model,graphics,in1,nout,[],[]);
}
if (ok) {
model.ipar=sgn;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
PRODUCT.prototype.define = function PRODUCT() {
sgn=[1,-1];
model=scicos_model();
model.sim=list("product",4);
model.in1=[-1,-1];
model.out=-1;
model.ipar=sgn;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=sci2exp(sgn);
gr_i=[];
x=standard_define([2,3],model,exprs,gr_i);
}
PRODUCT.prototype.details = function PRODUCT() {
}
}
/* autogenerated from "macros/NonLinear/COSBLK_f.sci" */
function COSBLK_f() {
COSBLK_f.prototype.get = function COSBLK_f() {
}
COSBLK_f.prototype.set = function COSBLK_f() {
x=arg1;
}
COSBLK_f.prototype.define = function COSBLK_f() {
in1=1;
model=scicos_model();
model.sim="cosblk";
model.in1=-1;
model.out=-1;
model.blocktype="c";
model.dep_ut=[true,None];
gr_i=[];
x=standard_define([2,2],model,[],gr_i);
}
COSBLK_f.prototype.details = function COSBLK_f() {
}
}
/* autogenerated from "macros/NonLinear/SIGNUM.sci" */
function SIGNUM() {
SIGNUM.prototype.get = function SIGNUM() {
}
SIGNUM.prototype.set = function SIGNUM() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,zcr,exprs]=scicos_getvalue("Set block parameters",["use zero_crossing (1: yes) (0:no)"],list("vec",1),exprs);
if (!ok) {
break
}
graphics.exprs=exprs;
if (ok) {
if (zcr!=0) {
model.nmode=-1;
model.nzcross=-1;
} else {
model.nmode=0;
model.nzcross=0;
}
x.graphics=graphics;
x.model=model;
break
}
}
}
SIGNUM.prototype.define = function SIGNUM() {
nu=-1;
model=scicos_model();
model.sim=list("signum",4);
model.in1=nu;
model.out=nu;
model.nzcross=nu;
model.nmode=nu;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string([1])];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
SIGNUM.prototype.details = function SIGNUM() {
}
}
/* autogenerated from "macros/NonLinear/SINBLK_f.sci" */
function SINBLK_f() {
SINBLK_f.prototype.get = function SINBLK_f() {
}
SINBLK_f.prototype.set = function SINBLK_f() {
x=arg1;
}
SINBLK_f.prototype.define = function SINBLK_f() {
model=scicos_model();
model.sim="sinblk";
model.in1=-1;
model.out=-1;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=" ";
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
SINBLK_f.prototype.details = function SINBLK_f() {
}
}
/* autogenerated from "macros/NonLinear/SAT_f.sci" */
function SAT_f() {
SAT_f.prototype.get = function SAT_f() {
}
SAT_f.prototype.set = function SAT_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,minp,maxp,pente,exprs]=scicos_getvalue("Set Saturation parameters",["Min","Max","Slope"],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (maxp<=0) {
message("Max must be strictly positive");
} else if (pente<=0) {
message("Slope must be strictly positive");
} else {
rpar=[minp/pente,maxp/pente,pente];
model.rpar=rpar;
model.firing=[];
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
SAT_f.prototype.define = function SAT_f() {
minp=-1;
maxp=1;
slope=1;
rpar=[minp,maxp,slope];
model=scicos_model();
model.sim=list("lusat",1);
model.in1=1;
model.nzcross=2;
model.out=1;
model.rpar=[minp,maxp,slope];
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string(minp),string(maxp),string(slope)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
SAT_f.prototype.details = function SAT_f() {
}
}
/* autogenerated from "macros/NonLinear/LOOKUP_f.sci" */
function LOOKUP_f() {
LOOKUP_f.prototype.get = function LOOKUP_f() {
}
LOOKUP_f.prototype.set = function LOOKUP_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
rpar=model.rpar;
n=size(rpar,"*")/2;
xx=rpar.slice(1-1,n);
yy=rpar.slice(n+1-1,2*n);
while (true) {
[ln,fun]=where()
if (!or(fun=="do_eval")) {
[xx,yy,ok,gc]=edit_curv(xx,yy,"axy");
} else {
ok=true;
}
if (!ok) {
break
}
n=size(xx,"*");
if (or(xx.slice(2-1,n)-xx.slice(1-1,n-1)<=0)) {
message("You have not defined a function");
ok=None;
}
if (ok) {
model.rpar=[xx.slice(),yy.slice()];
x.graphics=graphics;
x.model=model;
break
}
}
}
LOOKUP_f.prototype.define = function LOOKUP_f() {
model=scicos_model();
model.sim="lookup";
model.in1=1;
model.out=1;
model.rpar=[-2,-1,1,2,-1,1,-1,1];
model.blocktype="c";
model.dep_ut=[true,None];
gr_i=[];
x=standard_define([2,2],model,[],gr_i);
}
LOOKUP_f.prototype.details = function LOOKUP_f() {
}
}
/* autogenerated from "macros/NonLinear/INTRPLBLK_f.sci" */
function INTRPLBLK_f() {
INTRPLBLK_f.prototype.get = function INTRPLBLK_f() {
}
INTRPLBLK_f.prototype.set = function INTRPLBLK_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,a,b,exprs]=scicos_getvalue("Set Interpolation block parameters",["X coord.","Y coord."],list("vec",-1,"vec",-1),exprs);
if (!ok) {
break
}
if (size(a,"*")!=size(b,"*")) {
message("X and Y must have the same size");
} else if (min(a.slice(2-1,$)-a.slice(1-1,$-1))<=0) {
message("X must be strictly increasing");
} else {
if (ok) {
graphics.exprs=exprs;
model.rpar=[a.slice(),b.slice()];
x.graphics=graphics;
x.model=model;
break
}
}
}
}
INTRPLBLK_f.prototype.define = function INTRPLBLK_f() {
a=[0,1];
b=[0,1];
model=scicos_model();
model.sim="intrpl";
model.in1=1;
model.out=1;
model.rpar=[a,b];
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[strcat(sci2exp(a)),strcat(sci2exp(b))];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
INTRPLBLK_f.prototype.details = function INTRPLBLK_f() {
}
}
/* autogenerated from "macros/NonLinear/PROD_f.sci" */
function PROD_f() {
PROD_f.prototype.get = function PROD_f() {
}
PROD_f.prototype.set = function PROD_f() {
x=arg1;
}
PROD_f.prototype.define = function PROD_f() {
model=scicos_model();
model.sim=list("prod",2);
model.in1=[-1,-1];
model.out=-1;
model.blocktype="c";
model.dep_ut=[true,None];
x=standard_define([1,1],model,[],[]);
}
PROD_f.prototype.details = function PROD_f() {
}
}
/* autogenerated from "macros/NonLinear/DLRADAPT_f.sci" */
function DLRADAPT_f() {
DLRADAPT_f.prototype.get = function DLRADAPT_f() {
}
DLRADAPT_f.prototype.set = function DLRADAPT_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,p,rn,rd,g,last_u,last_y,exprs]=scicos_getvalue("Set block parameters",["Vector of p mesh points","Numerator roots (one line for each mesh)","Denominator roots (one line for each mesh)","Vector of gain at mesh points","past inputs (Num degree values)","past outputs (Den degree values)"],list("vec",-1,"mat",[-1,-1],"mat",["size(%1,\'*\')","-1"],"vec","size(%1,\'*\')","vec","size(%2,2)","vec","size(%3,2)"),exprs);
if (!ok) {
break
}
m=size(rn,2);
[npt,n]=size(rd);
if (m>=n) {
message("Transfer must be strictly proper");
} else if (size(rn,1)!=0&&size(rn,1)!=size(p,"*")) {
message("Numerator roots matrix row size\'s is incorrect");
} else {
rpar=[p.slice(),real(rn.slice()),imag(rn.slice()),real(rd.slice()),imag(rd.slice()),g.slice()];
ipar=[m,n,npt];
model.dstate=[last_u.slice(),last_y.slice()];
model.rpar=rpar;
model.ipar=ipar;
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
DLRADAPT_f.prototype.define = function DLRADAPT_f() {
p=[0,1];
rn=[];
rd=[math.complex(0.2,0.8),math.complex(0.2,-0.8),math.complex(0.3,0.7),math.complex(0.3,-0.7)];
g=[1,1];
last_u=[];
last_y=[0,0];
model=scicos_model();
model.sim="dlradp";
model.in1=[1,1];
model.out=1;
model.evtin=1;
model.dstate=[last_u,last_y];
model.rpar=[p.slice(),real(rn.slice()),imag(rn.slice()),real(rd.slice()),imag(rd.slice()),g.slice()];
model.ipar=[0,2,2];
model.blocktype="d";
model.firing=[];
model.dep_ut=[true,None];
exprs=[sci2exp(p),sci2exp(rn),sci2exp(rd,0),sci2exp(g),sci2exp(last_u),sci2exp(last_y)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
DLRADAPT_f.prototype.details = function DLRADAPT_f() {
}
}
/* autogenerated from "macros/NonLinear/QUANT_f.sci" */
function QUANT_f() {
QUANT_f.prototype.get = function QUANT_f() {
}
QUANT_f.prototype.set = function QUANT_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,pas,meth,exprs]=scicos_getvalue("Set parameters",["Step","Quantization Type (1-4)"],list("vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (meth<1||meth>4) {
message("Quantization Type must be from 1 to 4");
} else {
rpar=pas;
model.rpar=rpar;
model.ipar=meth;
switch (meth) {
case 1:
model.sim="qzrnd";
case 2:
model.sim="qztrn";
case 3:
model.sim="qzflr";
case 4:
model.sim="qzcel";
}
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
QUANT_f.prototype.define = function QUANT_f() {
pas=0.1;
meth=1;
model=scicos_model();
model.sim="qzrnd";
model.in1=-1;
model.out=-1;
model.rpar=pas;
model.ipar=meth;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string(pas),string(meth)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
QUANT_f.prototype.details = function QUANT_f() {
}
}
/* autogenerated from "macros/NonLinear/LOGBLK_f.sci" */
function LOGBLK_f() {
LOGBLK_f.prototype.get = function LOGBLK_f() {
}
LOGBLK_f.prototype.set = function LOGBLK_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")==2) {
exprs=exprs(2);
}
while (true) {
[ok,a,exprs]=scicos_getvalue("Set log block parameters","Basis (>1)",list("vec",1),exprs);
if (!ok) {
break
}
if (a<=1) {
message("Basis must be larger than 1");
} else {
if (ok) {
graphics.exprs=exprs;
model.rpar=a;
x.graphics=graphics;
x.model=model;
break
}
}
}
}
LOGBLK_f.prototype.define = function LOGBLK_f() {
in1=1;
a=math.E;
model=scicos_model();
model.sim="logblk";
model.in1=-1;
model.out=-1;
model.rpar=a;
model.blocktype="c";
model.dep_ut=[true,None];
exprs="%e";
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
LOGBLK_f.prototype.details = function LOGBLK_f() {
}
}
/* autogenerated from "macros/NonLinear/MAX_f.sci" */
function MAX_f() {
MAX_f.prototype.get = function MAX_f() {
}
MAX_f.prototype.set = function MAX_f() {
x=arg1;
}
MAX_f.prototype.define = function MAX_f() {
in1=-1;
model=scicos_model();
model.sim="maxblk";
model.in1=in1;
model.out=1;
model.dstate=[0,0];
model.blocktype="c";
model.dep_ut=[true,None];
exprs=" ";
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
MAX_f.prototype.details = function MAX_f() {
}
}
/* autogenerated from "macros/NonLinear/INVBLK.sci" */
function INVBLK() {
INVBLK.prototype.get = function INVBLK() {
}
INVBLK.prototype.set = function INVBLK() {
x=arg1;
}
INVBLK.prototype.define = function INVBLK() {
in1=-1;
model=scicos_model();
model.sim=list("invblk4",4);
model.in1=in1;
model.out=in1;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=" ";
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
INVBLK.prototype.details = function INVBLK() {
}
}
/* autogenerated from "macros/NonLinear/EXPBLK_m.sci" */
function EXPBLK_m() {
EXPBLK_m.prototype.get = function EXPBLK_m() {
}
EXPBLK_m.prototype.set = function EXPBLK_m() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")==2) {
exprs=exprs(2);
}
while (true) {
[ok,a,exprs]=scicos_getvalue("Set a^u  block parameters","a (>0)",list("vec",1),exprs);
if (!ok) {
break
}
if (or(a<=0)) {
message("a^u : a must be positive");
} else {
graphics.exprs=exprs;
model.rpar=a;
x.graphics=graphics;
x.model=model;
break
}
}
}
EXPBLK_m.prototype.define = function EXPBLK_m() {
in1=1;
a=math.E;
model=scicos_model();
model.sim=list("expblk_m",4);
model.in1=-1;
model.in2=-2;
model.out=-1;
model.out2=-2;
model.intyp=1;
model.outtyp=1;
model.rpar=a;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=["%e"];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
EXPBLK_m.prototype.details = function EXPBLK_m() {
}
}
/* autogenerated from "macros/NonLinear/ABS_VALUE.sci" */
function ABS_VALUE() {
ABS_VALUE.prototype.get = function ABS_VALUE() {
}
ABS_VALUE.prototype.set = function ABS_VALUE() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,zcr,exprs]=scicos_getvalue("Set block parameters",["use zero_crossing (1: yes) (0:no)"],list("vec",1),exprs);
if (!ok) {
break
}
graphics.exprs=exprs;
if (ok) {
if (zcr!=0) {
model.nmode=-1;
model.nzcross=-1;
} else {
model.nmode=0;
model.nzcross=0;
}
x.graphics=graphics;
x.model=model;
break
}
}
}
ABS_VALUE.prototype.define = function ABS_VALUE() {
nu=-1;
model=scicos_model();
model.sim=list("absolute_value",4);
model.in1=nu;
model.out=nu;
model.nzcross=nu;
model.nmode=nu;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string([1])];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
ABS_VALUE.prototype.details = function ABS_VALUE() {
}
}
/* autogenerated from "macros/NonLinear/MIN_f.sci" */
function MIN_f() {
MIN_f.prototype.get = function MIN_f() {
}
MIN_f.prototype.set = function MIN_f() {
x=arg1;
}
MIN_f.prototype.define = function MIN_f() {
in1=-1;
model=scicos_model();
model.sim="minblk";
model.in1=in1;
model.out=1;
model.dstate=[0,0];
model.blocktype="c";
model.dep_ut=[true,None];
exprs=sci2exp(in1);
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
MIN_f.prototype.details = function MIN_f() {
}
}
/* autogenerated from "macros/NonLinear/SATURATION.sci" */
function SATURATION() {
SATURATION.prototype.get = function SATURATION() {
}
SATURATION.prototype.set = function SATURATION() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
while (true) {
[ok,maxp,minp,zeroc,exprs]=scicos_getvalue("Set Saturation parameters",["Upper limit","Lower limit","zero crossing (0:no, 1:yes)"],list("vec",1,"vec",1,"vec",1),exprs);
if (!ok) {
break
}
if (maxp<=minp) {
message("Upper limit must be > Lower limit");
} else {
rpar=[maxp,minp];
model.rpar=rpar;
if (zeroc!=0) {
model.nzcross=2;
model.nmode=1;
} else {
model.nzcross=0;
model.nmode=0;
}
graphics.exprs=exprs;
x.graphics=graphics;
x.model=model;
break
}
}
}
SATURATION.prototype.define = function SATURATION() {
minp=-1;
maxp=1;
rpar=[maxp,minp];
model=scicos_model();
model.sim=list("satur",4);
model.in1=1;
model.nzcross=2;
model.nmode=1;
model.out=1;
model.rpar=rpar;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=[string(maxp),string(minp),string(model.nmode)];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
SATURATION.prototype.details = function SATURATION() {
}
}
/* autogenerated from "macros/NonLinear/TANBLK_f.sci" */
function TANBLK_f() {
TANBLK_f.prototype.get = function TANBLK_f() {
}
TANBLK_f.prototype.set = function TANBLK_f() {
x=arg1;
x.model.firing=[];
}
TANBLK_f.prototype.define = function TANBLK_f() {
in1=-1;
model=scicos_model();
model.sim="tanblk";
model.in1=in1;
model.out=in1;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=sci2exp(in1);
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
TANBLK_f.prototype.details = function TANBLK_f() {
}
}
/* autogenerated from "macros/NonLinear/FSV_f.sci" */
function FSV_f() {
FSV_f.prototype.get = function FSV_f() {
}
FSV_f.prototype.set = function FSV_f() {
x=arg1;
}
FSV_f.prototype.define = function FSV_f() {
in1=1;
model=scicos_model();
model.sim=list("fsv",1);
model.in1=in1;
model.out=in1;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=" ";
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
FSV_f.prototype.details = function FSV_f() {
}
}
/* autogenerated from "macros/NonLinear/EXPBLK_f.sci" */
function EXPBLK_f() {
EXPBLK_f.prototype.get = function EXPBLK_f() {
}
EXPBLK_f.prototype.set = function EXPBLK_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")==2) {
exprs=exprs(2);
}
while (true) {
[ok,a,exprs]=scicos_getvalue("Set a^u  block parameters","a (>0)",list("vec",1),exprs);
if (!ok) {
break
}
if (or(a<=0)) {
message("a^u : a must be positive");
} else {
graphics.exprs=exprs;
model.rpar=a;
x.graphics=graphics;
x.model=model;
break
}
}
}
EXPBLK_f.prototype.define = function EXPBLK_f() {
in1=1;
a=math.E;
model=scicos_model();
model.sim="expblk";
model.in1=-1;
model.out=-1;
model.rpar=a;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=["%e"];
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
EXPBLK_f.prototype.details = function EXPBLK_f() {
}
}
/* autogenerated from "macros/NonLinear/ABSBLK_f.sci" */
function ABSBLK_f() {
ABSBLK_f.prototype.get = function ABSBLK_f() {
}
ABSBLK_f.prototype.set = function ABSBLK_f() {
x=arg1;
}
ABSBLK_f.prototype.define = function ABSBLK_f() {
model=scicos_model();
model.sim=list("absblk",1);
model.in1=-1;
model.out=-1;
model.blocktype="c";
model.dep_ut=[true,None];
gr_i=[];
x=standard_define([2,2],model,[],gr_i);
}
ABSBLK_f.prototype.details = function ABSBLK_f() {
}
}
/* autogenerated from "macros/NonLinear/POWBLK_f.sci" */
function POWBLK_f() {
POWBLK_f.prototype.get = function POWBLK_f() {
}
POWBLK_f.prototype.set = function POWBLK_f() {
x=arg1;
graphics=arg1.graphics;
exprs=graphics.exprs;
model=arg1.model;
if (size(exprs,"*")==2) {
exprs=exprs(2);
}
while (true) {
[ok,a,exprs]=scicos_getvalue("Set u^a block parameters","to the power of",list("vec",1),exprs);
if (!ok) {
break
}
graphics.exprs=exprs;
if (a==int(a)) {
model.ipar=a;
model.rpar=[];
} else {
model.rpar=a;
model.ipar=[];
}
model.firing=[];
x.graphics=graphics;
x.model=model;
break
}
}
POWBLK_f.prototype.define = function POWBLK_f() {
in1=1;
a=1.5;
model=scicos_model();
model.sim="powblk";
model.in1=-1;
model.out=-1;
model.rpar=a;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=string(a);
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
POWBLK_f.prototype.details = function POWBLK_f() {
}
}
/* autogenerated from "macros/NonLinear/INVBLK_f.sci" */
function INVBLK_f() {
INVBLK_f.prototype.get = function INVBLK_f() {
}
INVBLK_f.prototype.set = function INVBLK_f() {
x=arg1;
}
INVBLK_f.prototype.define = function INVBLK_f() {
in1=-1;
model=scicos_model();
model.sim="invblk";
model.in1=in1;
model.out=in1;
model.blocktype="c";
model.dep_ut=[true,None];
exprs=" ";
gr_i=[];
x=standard_define([2,2],model,exprs,gr_i);
}
INVBLK_f.prototype.details = function INVBLK_f() {
}
}

/* made from 232/274 files */
